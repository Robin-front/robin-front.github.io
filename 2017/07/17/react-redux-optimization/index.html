<!doctype html><html class="theme-next pisces" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="ezF4b6TIq3nrF8BJmQrK_v9BmJnUQfVVPB4xBYo7AD8"><meta name="baidu-site-verification" content="T2V9h2EnoE"><link href="https://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="https://cdn.staticfile.org/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css"><meta name="keywords" content="react,redux,"><link rel="alternate" href="/atom.xml" title="三寸稚笔" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="white"><link rel="apple-touch-icon" href="/touch-icon.png?v=5.1.0"><meta name="apple-mobile-web-app-capable" content="yes"><link rel="apple-touch-startup-image" sizes="750x1294" href="/launch.png?v=5.1.0"><meta name="description" content="Redux 并不慢，只是你使用姿势不对 —— 一份优化指南如何优化使用了 Redux 的 react 应用程序并不是显而易见的。但实际上相当简单。这是一个简短的指南，以及一些例子。当优化使用 Redux 的 react 应用程序时，我经常听到有人说 Redux 缓慢。在99％的情况下，性能不佳的原因（适用于任何其他框架）与不必要的渲染相关联，因为 DOM 更新是昂贵的！在本文中，您将学习如何在使用"><meta name="keywords" content="react,redux"><meta property="og:type" content="article"><meta property="og:title" content="Redux 并不慢，只是你使用姿势不对 —— 一份优化指南"><meta property="og:url" content="http://robin-front.github.io/2017/07/17/react-redux-optimization/index.html"><meta property="og:site_name" content="三寸稚笔"><meta property="og:description" content="Redux 并不慢，只是你使用姿势不对 —— 一份优化指南如何优化使用了 Redux 的 react 应用程序并不是显而易见的。但实际上相当简单。这是一个简短的指南，以及一些例子。当优化使用 Redux 的 react 应用程序时，我经常听到有人说 Redux 缓慢。在99％的情况下，性能不佳的原因（适用于任何其他框架）与不必要的渲染相关联，因为 DOM 更新是昂贵的！在本文中，您将学习如何在使用"><meta property="og:updated_time" content="2017-07-17T09:12:02.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Redux 并不慢，只是你使用姿势不对 —— 一份优化指南"><meta name="twitter:description" content="Redux 并不慢，只是你使用姿势不对 —— 一份优化指南如何优化使用了 Redux 的 react 应用程序并不是显而易见的。但实际上相当简单。这是一个简短的指南，以及一些例子。当优化使用 Redux 的 react 应用程序时，我经常听到有人说 Redux 缓慢。在99％的情况下，性能不佳的原因（适用于任何其他框架）与不必要的渲染相关联，因为 DOM 更新是昂贵的！在本文中，您将学习如何在使用"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",sidebar:{position:"left",display:"always",offset:12,offset_float:0,b2t:!1,scrollpercent:!0},fancybox:!0,motion:!1,duoshuo:{userId:"undefined",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://robin-front.github.io/2017/07/17/react-redux-optimization/"><title>Redux 并不慢，只是你使用姿势不对 —— 一份优化指南 | 三寸稚笔</title><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-8386186071288063",enable_page_level_ads:!0})</script></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src="https://www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-74634898-1","auto"),ga("send","pageview")</script><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?51f2c21567935649debac704a10c43f1";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">三寸稚笔</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description"></h1></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-book"><a href="/RxJS-doc-chinese/" rel="section"><i class="menu-item-icon fa fa-fw fa-book"></i><br>RXJS中文文档</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-travel"><a href="/categories/travel/" rel="section"><i class="menu-item-icon fa fa-fw fa-plane"></i><br>旅行</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i><br>站点地图</a></li><li class="menu-item menu-item-commonweal"><a href="/404.html" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i><br>公益404</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://robin-front.github.io/2017/07/17/react-redux-optimization/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="robin"><meta itemprop="description" content=""><meta itemprop="image" content="https://avatars2.githubusercontent.com/u/6723674?v=3&s=460"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="三寸稚笔"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">Redux 并不慢，只是你使用姿势不对 —— 一份优化指南</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-17T17:12:02+08:00">2017-07-17 </time><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="更新于" itemprop="dateModified" datetime="2017-07-17T17:12:02+08:00">2017-07-17 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span> </a></span></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2017/07/17/react-redux-optimization/#comments" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/17/react-redux-optimization/" itemprop="commentCount"></span></a></span><div class="post-wordcount"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计</span> <span title="字数统计">2,219 </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长</span> <span title="阅读时长">8 min</span></div></div></header><div class="post-body" itemprop="articleBody"><div align="center"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-8386186071288063" data-ad-slot="5007169637" data-ad-format="auto"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><h1 id="Redux-并不慢，只是你使用姿势不对-——-一份优化指南"><a href="#Redux-并不慢，只是你使用姿势不对-——-一份优化指南" class="headerlink" title="Redux 并不慢，只是你使用姿势不对 —— 一份优化指南"></a>Redux 并不慢，只是你使用姿势不对 —— 一份优化指南</h1><p><em>如何优化使用了 Redux 的 react 应用程序并不是显而易见的。但实际上相当简单。这是一个简短的指南，以及一些例子。</em></p><p>当优化使用 Redux 的 react 应用程序时，我经常听到有人说 Redux 缓慢。在99％的情况下，性能不佳的原因（适用于任何其他框架）与不必要的渲染相关联，因为 DOM 更新是昂贵的！在本文中，您将学习如何在使用 Redux 绑定 react 时避免不必要的 <code>render</code>。</p><p>通常，我们使用<a href="https://github.com/reactjs/react-redux" target="_blank" rel="external">官方 react 绑定的 Redux</a> 的 <a href="https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options" target="_blank" rel="external">connect</a> 高阶组件， 当您的 Redux <code>store</code> 更新时，react 组件就会更新。这是一个将组件包装在另一个组件中的函数，该组件订阅了 Redux <code>store</code> 中的更改，并渲染 <code>store</code>，这就是它的子节点更新的原因。<a id="more"></a></p><h2 id="快速入坑-react-redux，官方-react-绑定-Redux"><a href="#快速入坑-react-redux，官方-react-绑定-Redux" class="headerlink" title="快速入坑 react-redux，官方 react 绑定 Redux"></a>快速入坑 react-redux，官方 react 绑定 Redux</h2><p>该 <code>connect</code> 高阶组件实际上是已经过优化。要了解如何最好地使用它，最好了解先它是如何工作的！</p><p>Redux 以及 react-redux 实际上是相当小的库，所以源代码并不费解。我鼓励大家阅读源代码，或至少其中的一些。如果你想进一步，编写自己的实现，它将让你深入了解为什么库的设计方式是这样的。</p><p>不用多说，我们来看看 react 绑定的工作原理。正如我们公认的那样，react 绑定的核心部分就是 <code>connect</code> 高阶组件，这是它的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"></span></span></div><div class="line">  mapStateToProps,</div><div class="line">  mapDispatchToProps,</div><div class="line">  mergeProps,</div><div class="line">  &#123;</div><div class="line">    pure = true,</div><div class="line">    areStatesEqual = strictEqual,</div><div class="line">    areOwnPropsEqual = shallowEqual,</div><div class="line">    areStatePropsEqual = shallowEqual,</div><div class="line">    areMergedPropsEqual = shallowEqual,</div><div class="line">    ...extraOptions</div><div class="line">  &#125; = &#123;&#125;</div><div class="line">) &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>作为附注 - 唯一的强制性参数是 <code>mapStateToProps</code>，在大多数情况下，您只需要前两个参数。但是，我在这里使用完整的写法来说明 <code>react bindings</code> 是如何工作的。</p><p>传递给 <code>connect</code> 函数的所有参数都用于生成一个对象，该对象作为 <code>props</code> 传递到封装的组件上。<code>mapStateToProps</code> 用于将状态从 Redux store 映射到一个对象，<code>mapDispatchToProps</code> 用于生成包含函数的对象 - 通常这些函数是 <code>actions</code> 创建者。最后，<code>mergeProps</code> 有三个参数 <code>stateProps</code>，<code>dispatchProps</code> 和 <code>ownProps</code>。第一个是 <code>mapStateToProps</code> 的结果，第二个参数是 <code>mapDispatchToProps</code> 的结果，第三个参数是从组件本身继承的 <code>props</code> 对象。默认情况下，<code>mergeProps</code> 将这些参数简单地组合到一个对象中，但是如果您传递一个函数作为 <code>mergeProps</code> 参数，<code>connect</code> 则将使用该函数生成封装组件的 <code>props</code>。</p><p><code>connect</code> 函数的第四个参数是一个 <code>options</code> 对象。这包含5个选项：<code>pure</code> 可以是 <code>true</code> 或 <code>false</code>，以及确定是否重新渲染组件的4个函数（应该返回一个布尔值）。<code>pure</code> 默认设置为<code>true</code>。如果设置为<code>false</code>，则<code>connect</code> 将跳过任何优化，并且<code>options</code>对象中的4个函数将不生效。我个人不能想到一个用例，但是如果您希望关闭优化，则将其设置为<code>false</code>。</p><p>我们的 <code>mergeProps</code> 函数产生的对象与最后一个 <code>props</code> 对象进行比较。如果我们的 <code>connect</code> 认为 <code>props</code> 对象已经改变了，那么这个组件就会重新渲染。要了解库如何决定是否有变更，我们可以查看该 <code>shallowEqual</code> 功能。如果函数返回 <code>true</code>，组件将不会重新渲染，如果返回 <code>false</code>，它将重新渲染。<code>shallowEqual</code> 执行此比较。下面你会看到 <code>shallowEqual</code> 方法的一部分，它告诉你所有你需要知道的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keysA.length; i++) &#123;</div><div class="line">  <span class="keyword">if</span> (!hasOwn.call(objB, keysA[i]) ||</div><div class="line">      !is(objA[keysA[i]], objB[keysA[i]])) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>总而言之，这是上面的代码：</p><p>它在 object a 中的 key 上循环，并检查 object B 是否拥有相同的属性。然后它检查 object A中的属性（具有相同名称）是否等于对象B的属性。如果只有一个比较返回false，那么对象将被视为不相等，并且会发生重新渲染。</p><p>这导致我们一个黄金法则：</p><h2 id="只给您的组件它需要呈现的数据"><a href="#只给您的组件它需要呈现的数据" class="headerlink" title="只给您的组件它需要呈现的数据"></a>只给您的组件它需要呈现的数据</h2><p>这说得很含糊，所以让我们用一些实际的例子来阐述。</p><h3 id="拆分连接的组件"><a href="#拆分连接的组件" class="headerlink" title="拆分连接的组件"></a>拆分连接的组件</h3><p>我看到人们这样做 订阅容器组件一系列状态，并通过 <code>props</code> 传递所有东西。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> BigComponent = <span class="function">(<span class="params">&#123; a, b, c, d &#125;</span>) =&gt;</span> (</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;CompA a=&#123;a&#125; /&gt;</div><div class="line">    &lt;CompB b=&#123;b&#125; /&gt;</div><div class="line">    &lt;CompC c=&#123;c&#125; /&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">);</div><div class="line"></div><div class="line">const ConnectedBigComponent = connect(</div><div class="line">  (&#123; a, b, c &#125;) =&gt; (&#123; a, b, c &#125;)</div><div class="line">);</div></pre></td></tr></table></figure><p>现在，每次要么a，b或c变化，BigComponent包括CompA，CompB并且CompC将重新呈现。</p><p>相反，拆分您的组件，不要害怕更多地使用 connect：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ConnectedA = connect(CompA, (&#123; a &#125;) =&gt; (&#123; a &#125;));</div><div class="line"><span class="keyword">const</span> ConnectedB = connect(CompB, (&#123; b &#125;) =&gt; (&#123; b &#125;));</div><div class="line"><span class="keyword">const</span> ConnectedC = connect(CompC, (&#123; c &#125;) =&gt; (&#123; c &#125;));</div><div class="line"></div><div class="line"><span class="keyword">const</span> BigComponent = <span class="function"><span class="params">()</span> =&gt;</span> (</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;ConnectedA a=&#123;a&#125; /&gt;</div><div class="line">    &lt;ConnectedB b=&#123;b&#125; /&gt;</div><div class="line">    &lt;ConnectedC c=&#123;c&#125; /&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">);</div></pre></td></tr></table></figure><p>通过此次更新，<code>CompA</code> 将只有当<code>a</code>已经改变才会重新渲染，<code>CompB</code>当<code>b</code>改变等。考虑这样一个场景，每一个值<code>a</code>，<code>b</code>并<code>c</code>分别经常更新。对于每次更新，我们现在重新渲染一个，而不是所有组件。这几乎没有什么明显的三个组件，但如果你有更多！</p><h3 id="改变你的状态，使其尽可能的最小"><a href="#改变你的状态，使其尽可能的最小" class="headerlink" title="改变你的状态，使其尽可能的最小"></a>改变你的状态，使其尽可能的最小</h3><p>这是一个假设（稍微设计过）的例子：</p><p>你有一个大的项目列表，我们假设有300或更多。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;List&gt;</div><div class="line">  &#123;<span class="keyword">this</span>.props.items.map(<span class="function">(<span class="params">&#123; content, itemId &#125;</span>) =&gt;</span> (</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ListItem</span></span></span></div><div class="line">      <span class="attr">onClick</span>=<span class="string">&#123;selectItem&#125;</span></div><div class="line">      <span class="attr">content</span>=<span class="string">&#123;content&#125;</span></div><div class="line">      <span class="attr">itemId</span>=<span class="string">&#123;itemId&#125;</span></div><div class="line">      <span class="attr">key</span>=<span class="string">&#123;itemId&#125;</span></div><div class="line">    /&gt;</div><div class="line">  ))&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">List</span>&gt;</span></div></pre></td></tr></table></figure><p>当我们点击一​​个列表项时，一个动作被触发，更新一个存储值 - <code>selectedItem</code>。每个列表项连接到 Redux 并获取<code>selectedItem</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ListItem = connect(</div><div class="line">  <span class="function">(<span class="params">&#123; selectedItem &#125;</span>) =&gt;</span> (&#123; selectedItem &#125;)</div><div class="line">)(SimpleListItem);</div></pre></td></tr></table></figure><p>我们正在做正确的事情，我们仅将组件连接到所需的状态。但是，当<code>selectedItem</code>更新时，所有<code>ListItem</code>组件都将重新渲染，因为我们返回的对象<code>selectedItem</code>已经更改。在此之前 <code>{ selectedItem: 123 }</code>，现在是 <code>{ selectedItem: 120 }</code>。</p><p>请记住，我们正在使用该 <code>selectedItem</code> 值来检查当前项目是否被选中。所以我们的组件真正需要知道的是它是否被选择 - 实质上是一个<code>Boolean</code>。<code>Boolean</code> 是伟大的，因为只有两个可能的值，<code>true</code> 或者 <code>false</code>。所以如果我们返回一个布尔值，而不是 <code>selectedItem</code> ，仅 <code>Boolean</code> 更改的两个项目将会重新渲染，这就是我们需要的。<code>mapStateToProps</code> 实际上 <code>props</code> 它是组件的第二个参数，我们可以用它来检查这是否实际上是选定的项目。以下是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ListItem = connect(</div><div class="line">  <span class="function">(<span class="params">&#123; selectedItem &#125;, &#123; itemId &#125;</span>) =&gt;</span> (&#123; <span class="attr">isSelected</span>: selectedItem === itemId &#125;)</div><div class="line">)(SimpleListItem);</div></pre></td></tr></table></figure><p>现在，只要我们的 <code>selectedItem</code> 值发生变化，只有两个组件重新呈现 - <code>ListItem</code> 现在已经被选择了，而且原来那个已经被取消选择了。</p><h3 id="保持数据扁平化"><a href="#保持数据扁平化" class="headerlink" title="保持数据扁平化"></a>保持数据扁平化</h3><p>在 <a href="http://redux.js.org/docs/recipes/reducers/NormalizingStateShape.html" target="_blank" rel="external">Redux文档提到</a> 这是一种最佳实践。保持您的store 扁平化是有益的一些原因。但是对于本文的主旨，嵌套会造成问题，因为为了让我们的应用程序尽可能的快，我们希望我们的更新尽可能的细微。假设我们有一个这样的嵌套形状：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">articles</span>: [&#123;</div><div class="line">    <span class="attr">comments</span>: [&#123;</div><div class="line">      <span class="attr">users</span>: [&#123;</div><div class="line">      &#125;]</div><div class="line">    &#125;]</div><div class="line">  &#125;],</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>为了优化我们的 <code>Article</code>，<code>Comment</code> 和 <code>User</code> 组件，我们现在需要所有的人订阅 <code>articles</code>，然后深深伸入这种结构只返回他们所需要的状态。相反地​​，如此设计你的形状更有意义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">articles</span>: [&#123;</div><div class="line">    ...</div><div class="line">  &#125;],</div><div class="line">  <span class="attr">comments</span>: [&#123;</div><div class="line">    <span class="attr">articleId</span>: ..,</div><div class="line">    <span class="attr">userId</span>: ...,</div><div class="line">    ...</div><div class="line">  &#125;],</div><div class="line">  <span class="attr">users</span>: [&#123;</div><div class="line">    ...</div><div class="line">  &#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后使用映射函数选择注释和用户信息。关于这一点的更多信息可以在 <a href="http://redux.js.org/docs/recipes/reducers/NormalizingStateShape.html" target="_blank" rel="external">Redux文档中阅读关于规范化状态的信息</a>。</p><h2 id="彩蛋：用于选择-Redux-state-的库"><a href="#彩蛋：用于选择-Redux-state-的库" class="headerlink" title="彩蛋：用于选择 Redux state 的库"></a>彩蛋：用于选择 Redux state 的库</h2><p>这是完全可选的，取决于您。通常所有以上的建议都足够深入地让你写出快速的 react 和 Redux 应用程序。但是有两个优秀的库使得选择状态更容易一些：</p><p><a href="https://github.com/reactjs/reselect" target="_blank" rel="external">Reselect</a> 是 <code>selectors</code> 为您的 Redux 应用程序编写的引人注目的工具。从重新选择文档：</p><ul><li>选择器可以计算派生数据，允许 Redux 存储尽可能小的状态。</li><li>选择器效率高。除非其中一个参数发生变化，否则不会重新计算选择器。</li><li>选择器是可组合的。它们可以用作其他选择器的输入。</li></ul><p>对于具有复杂接口，复杂状态 和/或 频繁更新的应用程序，重新选择可以帮助您轻松使您的应用程序更快！</p><p><a href="http://ramdajs.com/" target="_blank" rel="external">Ramda</a> 是一个功能强大的库，具有更高阶的函数。换句话说 - 用函数创建函数。由于我们的映射函数只是这个函数，所以我们可以很方便地使用 <code>Ramda</code> 创建我们的选择器。<code>Ramda</code> 可以有选择器的所有功能并做的更多。查看 <a href="https://github.com/ramda/ramda/wiki/Cookbook" target="_blank" rel="external">Ramda 食谱</a>的一些例子，您可以使用 Ramda 做什么。</p></div><div></div><div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong> robin</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="http://robin-front.github.io/2017/07/17/react-redux-optimization/" title="Redux 并不慢，只是你使用姿势不对 —— 一份优化指南">http://robin-front.github.io/2017/07/17/react-redux-optimization/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/react/" rel="tag"># react</a> <a href="/tags/redux/" rel="tag"># redux</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/07/17/react-at-light-speed/" rel="next" title="优化 react 让它快如闪电——你是电，你是光，你是唯一的神话"><i class="fa fa-chevron-left"></i> 优化 react 让它快如闪电——你是电，你是光，你是唯一的神话</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/07/18/make-react-fast-again-tools-and-techniques-for-speeding-up-your-react-app/" rel="prev" title="高性能 react：3种加快应用程序的新工具">高性能 react：3种加快应用程序的新工具 <i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-8386186071288063" data-ad-slot="9018566839" data-ad-format="auto"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><div class="comments" id="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="https://avatars2.githubusercontent.com/u/6723674?v=3&s=460" alt="robin"><p class="site-author-name" itemprop="name">robin</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">70</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">7</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">68</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/robin-front" target="_blank" title="github"><i class="fa fa-fw fa-github"></i> github </a></span><span class="links-of-author-item"><a href="https://twitter.com/lb_robin" target="_blank" title="twitter"><i class="fa fa-fw fa-twitter"></i> twitter </a></span><span class="links-of-author-item"><a href="https://stackoverflow.com/users/6053135/robin" target="_blank" title="stackoverflow"><i class="fa fa-fw fa-stack-overflow"></i> stackoverflow</a></span></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Redux-并不慢，只是你使用姿势不对-——-一份优化指南"><span class="nav-number">1.</span> <span class="nav-text">Redux 并不慢，只是你使用姿势不对 —— 一份优化指南</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#快速入坑-react-redux，官方-react-绑定-Redux"><span class="nav-number">1.1.</span> <span class="nav-text">快速入坑 react-redux，官方 react 绑定 Redux</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#只给您的组件它需要呈现的数据"><span class="nav-number">1.2.</span> <span class="nav-text">只给您的组件它需要呈现的数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#拆分连接的组件"><span class="nav-number">1.2.1.</span> <span class="nav-text">拆分连接的组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#改变你的状态，使其尽可能的最小"><span class="nav-number">1.2.2.</span> <span class="nav-text">改变你的状态，使其尽可能的最小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#保持数据扁平化"><span class="nav-number">1.2.3.</span> <span class="nav-text">保持数据扁平化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#彩蛋：用于选择-Redux-state-的库"><span class="nav-number">1.3.</span> <span class="nav-text">彩蛋：用于选择 Redux state 的库</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div align="center"></div><div class="copyright">&copy; 2014 - <span itemprop="copyrightYear">2017</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">robin</span></div><div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info">主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div><div id="left-side"></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="https://cdn.bootcss.com/jquery/2.1.3/jquery.min.js"></script><script type="text/javascript" src="https://cdn.staticfile.org/fastclick/1.0.6/fastclick.min.js"></script><script type="text/javascript" src="https://cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script><script type="text/javascript" src="https://cdn.staticfile.org/velocity/1.2.1/velocity.min.js"></script><script type="text/javascript" src="https://cdn.bootcss.com/velocity/1.2.1/velocity.ui.min.js"></script><script type="text/javascript" src="https://cdn.staticfile.org/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script><script type="text/javascript">$(function(){setTimeout(function(){var a=function(a){return'<ins class="adsbygoogle"style="display:block"data-ad-client="ca-pub-8386186071288063"data-ad-slot="'+a+'"data-ad-format="auto"></ins>'},t=$("#posts .post-body").children(),o=$("#more");o.parent().is(".post-body")||(o=o.parent()),o.after(function(a){return'<ins class="adsbygoogle"style="display:block; text-align:center;"data-ad-format="fluid"data-ad-layout="in-article"data-ad-client="ca-pub-8386186071288063"data-ad-slot="'+a+'"></ins>'}(9111344837)),(adsbygoogle=window.adsbygoogle||[]).push({}),t.length>20&&(t.eq(t.length/2>>0).after(a(6018277638)),(adsbygoogle=window.adsbygoogle||[]).push({})),t.length>30&&(t.eq(-5).after(a(7495010830)),(adsbygoogle=window.adsbygoogle||[]).push({}))},0)})</script><script id="dsq-count-scr" src="https://robin-front-github-io.disqus.com/count.js" async></script><script type="text/javascript">var disqus_config=function(){this.page.url="http://robin-front.github.io/2017/07/17/react-redux-optimization/",this.page.identifier="2017/07/17/react-redux-optimization/",this.page.title="Redux 并不慢，只是你使用姿势不对 —— 一份优化指南"},d=document,s=d.createElement("script");s.src="https://robin-front-github-io.disqus.com/embed.js",s.setAttribute("data-timestamp",""+ +new Date),(d.head||d.body).appendChild(s)</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script></body></html>