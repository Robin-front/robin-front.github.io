<!DOCTYPE html><html class="theme-next muse use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="ezF4b6TIq3nrF8BJmQrK_v9BmJnUQfVVPB4xBYo7AD8"><meta name="baidu-site-verification" content="T2V9h2EnoE"><link href="https://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css"><link href="https://unpkg.com/gitalk/dist/gitalk.css" rel="stylesheet" type="text/css"><link href="https://cdn.staticfile.org/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css"><meta name="keywords" content="tutorial,web development,programming,asynchronous,events loop,promise,async await,"><link rel="alternate" href="/atom.xml" title="三寸稚笔" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2"><meta name="apple-mobile-web-app-status-bar-style" content="white"><link rel="apple-touch-icon" href="/touch-icon.png?v=5.1.2"><meta name="description" content="javascript 事件循环是如何工作的以及使用async／await提升异步编程的5种方式这次我们将通过回顾在单线程环境中编程的缺点来扩展先前的第一篇文章，以及如何克服它来建立一个令人惊叹的 javascript UIs。像以往一样，在文章的最后，我会分享使用 async/await 写简洁代码的 5 个小贴士。"><meta name="keywords" content="tutorial,web development,programming,asynchronous,events loop,promise,async await"><meta property="og:type" content="article"><meta property="og:title" content="javascript 事件循环是如何工作的以及使用async／await提升异步编程的5种方式"><meta property="og:url" content="http://robin-front.github.io/2017/11/06/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-async-and-await/index.html"><meta property="og:site_name" content="三寸稚笔"><meta property="og:description" content="javascript 事件循环是如何工作的以及使用async／await提升异步编程的5种方式这次我们将通过回顾在单线程环境中编程的缺点来扩展先前的第一篇文章，以及如何克服它来建立一个令人惊叹的 javascript UIs。像以往一样，在文章的最后，我会分享使用 async/await 写简洁代码的 5 个小贴士。"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http://robin-front.github.io/js/lazyload-plugin/loading.svg"><meta property="og:image" content="http://robin-front.github.io/js/lazyload-plugin/loading.svg"><meta property="og:image" content="http://robin-front.github.io/js/lazyload-plugin/loading.svg"><meta property="og:image" content="http://robin-front.github.io/js/lazyload-plugin/loading.svg"><meta property="og:image" content="http://robin-front.github.io/js/lazyload-plugin/loading.svg"><meta property="og:image" content="http://robin-front.github.io/js/lazyload-plugin/loading.svg"><meta property="og:image" content="http://robin-front.github.io/js/lazyload-plugin/loading.svg"><meta property="og:image" content="http://robin-front.github.io/js/lazyload-plugin/loading.svg"><meta property="og:image" content="http://robin-front.github.io/js/lazyload-plugin/loading.svg"><meta property="og:image" content="http://robin-front.github.io/js/lazyload-plugin/loading.svg"><meta property="og:image" content="http://robin-front.github.io/js/lazyload-plugin/loading.svg"><meta property="og:image" content="http://robin-front.github.io/js/lazyload-plugin/loading.svg"><meta property="og:image" content="http://robin-front.github.io/js/lazyload-plugin/loading.svg"><meta property="og:image" content="http://robin-front.github.io/js/lazyload-plugin/loading.svg"><meta property="og:image" content="http://robin-front.github.io/js/lazyload-plugin/loading.svg"><meta property="og:image" content="http://robin-front.github.io/js/lazyload-plugin/loading.svg"><meta property="og:image" content="http://robin-front.github.io/js/lazyload-plugin/loading.svg"><meta property="og:image" content="http://robin-front.github.io/js/lazyload-plugin/loading.svg"><meta property="og:image" content="http://robin-front.github.io/js/lazyload-plugin/loading.svg"><meta property="og:image" content="http://robin-front.github.io/js/lazyload-plugin/loading.svg"><meta property="og:image" content="http://robin-front.github.io/js/lazyload-plugin/loading.svg"><meta property="og:image" content="http://robin-front.github.io/js/lazyload-plugin/loading.svg"><meta property="og:updated_time" content="2017-11-06T02:40:21.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="javascript 事件循环是如何工作的以及使用async／await提升异步编程的5种方式"><meta name="twitter:description" content="javascript 事件循环是如何工作的以及使用async／await提升异步编程的5种方式这次我们将通过回顾在单线程环境中编程的缺点来扩展先前的第一篇文章，以及如何克服它来建立一个令人惊叹的 javascript UIs。像以往一样，在文章的最后，我会分享使用 async/await 写简洁代码的 5 个小贴士。"><meta name="twitter:image" content="http://robin-front.github.io/js/lazyload-plugin/loading.svg"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.2",sidebar:{position:"left",display:"post",offset:12,offset_float:12,b2t:!1,scrollpercent:!0,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://robin-front.github.io/2017/11/06/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-async-and-await/"><title>javascript 事件循环是如何工作的以及使用async／await提升异步编程的5种方式 | 三寸稚笔</title><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-8386186071288063",enable_page_level_ads:!0})</script><script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src="https://www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-74634898-1","auto"),ga("send","pageview")</script><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?51f2c21567935649debac704a10c43f1";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">三寸稚笔</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description"></h1></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-travel"><a href="/tags/travel/" rel="section"><i class="menu-item-icon fa fa-fw fa-plane"></i><br>旅行</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i><br>公益404</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-rss"></i><br>站点地图</a></li><li class="menu-item menu-item-subscribe"><a href="http://eepurl.com/c-SI5f" rel="section"><i class="menu-item-icon fa fa-fw fa-envelope"></i><br>订阅</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://robin-front.github.io/2017/11/06/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-async-and-await/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="robin"><meta itemprop="description" content=""><meta itemprop="image" content="https://avatars2.githubusercontent.com/u/6723674?v=3&s=460"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="三寸稚笔"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">javascript 事件循环是如何工作的以及使用async／await提升异步编程的5种方式</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-06T10:40:21+08:00">2017-11-06 </time><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于&#58;</span> <time title="更新于" itemprop="dateModified" datetime="2017-11-06T10:40:21+08:00">2017-11-06 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span> </a></span></span><span class="post-meta-divider">|</span> <span class="page-pv"><i class="fa fa-file-o"></i> <span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">5,254 </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">19</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="javascript-事件循环是如何工作的以及使用async／await提升异步编程的5种方式"><a href="#javascript-事件循环是如何工作的以及使用async／await提升异步编程的5种方式" class="headerlink" title="javascript 事件循环是如何工作的以及使用async／await提升异步编程的5种方式"></a>javascript 事件循环是如何工作的以及使用async／await提升异步编程的5种方式</h1><p>这次我们将通过回顾在单线程环境中编程的缺点来扩展先前的第一篇文章，以及如何克服它来建立一个令人惊叹的 javascript UIs。像以往一样，在文章的最后，我会分享使用 async/await 写简洁代码的 5 个小贴士。<a id="more"></a></p><h2 id="为什么单线程是一个限制？"><a href="#为什么单线程是一个限制？" class="headerlink" title="为什么单线程是一个限制？"></a>为什么单线程是一个限制？</h2><p>在我们推出的<a href="https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf" target="_blank" rel="noopener">第一篇文章</a>, 我们仔细思考了这个问题，<em>当我们调用了一个非常耗时的函数时发生了什么</em>。</p><p>想象一下，例如浏览器中运行着一个复杂的图像变换算法。</p><p>当调用栈执行函数时，浏览器不能做任何其他事——它被阻塞了。这意味着浏览器不能渲染，不能执行其他代码，暂时卡住了。那问题也来了————你的UI界面也不再顺畅和高效。</p><p>你的应用被卡住了。</p><p>它很丑陋，完全毁了你的用户体验：</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*MCt4ZC0dMVhJsgo1u6lpYw.jpeg" data-original="https://cdn-images-1.medium.com/max/800/1*MCt4ZC0dMVhJsgo1u6lpYw.jpeg"></p><h2 id="javascript-程序的组成部分"><a href="#javascript-程序的组成部分" class="headerlink" title="javascript 程序的组成部分"></a>javascript 程序的组成部分</h2><p>你可能会把你的 javascript 应用写在单个 <code>.js</code> 文件里，但你的程序肯定包含着好几块，只有其只一块正在执行，其他的会稍后执行。最常见的块就是函数。</p><p>问题是，大多数新开发者似乎都觉得，这个 <em>稍后执行</em> 并不是严格地在 <em>当前执行</em> 之后立即执行。换句话说，任务当前不能立即完成，通过定义，将会异步完成。意味着不会出现上面所说的阻塞行为，就像你所期望或希望发生的那样。</p><p>让我们看看下面的例子：</p><script src="https://gist.github.com/zlatkov/7a8b43e4fb8059bc810aa6aa4941148e.js"></script><p>你可能已经意识到，标准的 <code>Ajax</code> 事件不会同步完成。意味着当执行代码 <code>ajax(...)</code> 的时候，并不会立即返回值并赋值给变量 <code>response</code>。</p><p>一个简单的方法就是使用一个叫 回调函数（callback）的函数去等待异步函数返回的结果。</p><script src="https://gist.github.com/zlatkov/cbd87df9ff2922512609a36d4155274a.js"></script><p>提醒一下：你实际可以发起一个 <strong>同步</strong> 的 <code>Ajax</code> 请求。但永远不要这样做。如果你发送一个同步 Ajax 请求, 你 javascript 应用的 UI 就会被阻塞————用户将不能点击，输入数据，导航或滚动。这会阻碍用户交互，非常糟糕的体验。</p><p>就像下面这样，但请永远不要这样做，不要毁了网页：</p><script src="https://gist.github.com/zlatkov/1b834ae5eb037f46347d71d4c497d43c.js"></script><p>我们只是用 Ajax 请求做一个例子，你可以异步执行任意一段代码。</p><p>可以通过 <code>setTimeout(callback, milliseconds)</code> 函数来做到。<code>setTimeout</code> 函数建立一个延后发生的事件。就像这样：</p><script src="https://gist.github.com/zlatkov/688a0b41ae10e45bd202d02bb12df264.js"></script><p>将会输出</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">first</span></div><div class="line"><span class="keyword">third</span></div><div class="line"><span class="keyword">second</span></div></pre></td></tr></table></figure><h2 id="剖析事件循环"><a href="#剖析事件循环" class="headerlink" title="剖析事件循环"></a>剖析事件循环</h2><p>我们会从一个奇怪的要求开始————尽管允许异步编码（就像刚刚讨论的<code>setTimeout</code>），直到 ES6， javascript从未有过真正直接的异步的概念。javascript 引擎在执行单一代码块的时刻不会再做任何事情。</p><p>关于javascript 引擎（google专用的V8引擎）的更多细节，请查看我们<a href="https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e" target="_blank" rel="noopener">之前的文章</a>.</p><p>那么，谁让 javascript 引擎执行程序块呢？现实中，javascript 引擎并不是孤立运行的————它运行在一个 <em>宿主</em> 环境中，对于大多数开发者来说，典型的是网页浏览器或者 Node.js。事实上，javascript 被嵌入到各种设备中，从机器人到小灯泡。每个设备代表 javascript 引擎的不同的宿主环境类型。</p><p>在所有环境中，不变的是拥有共同的称为 <strong>事件循环</strong> 的内置机制，控制处理多个程序块的执行时机。</p><p>这意味着 JS 引擎只是在执行环境中按需调用任意代码。它（执行JS代码的）是一个事件调度的环境。</p><p>那，举个例子，当你的 JS 程序发起一个 Ajax 请求去从服务器中获取一些数据，你在一个函数里设置了“响应”的代码（称为“回调函数”），JS 引擎告诉宿主环境：“嘿，我现在会暂停执行，但当网络请求完成时，并返回一些数据，请回来调用这个函数。”</p><p>浏览器会监听网络响应，并在拿到数据时返回给你，它会通过插入到 <em>事件循环</em> 中来调度回调函数。</p><p>让我们看看下面的图表：</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*FA9NGxNB6-v1oI2qGEtlRQ.png" data-original="https://cdn-images-1.medium.com/max/800/1*FA9NGxNB6-v1oI2qGEtlRQ.png"></p><p>你可以在<a href="https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf" target="_blank" rel="noopener">以前的文章</a>阅读到更多关于堆内存和调用栈的讨论。</p><p>这些 web APIs 是什么？本质上来讲，它们是无法访问的线程，你只能利用它。它们只是浏览器的并发访问的一部分。如果你是 Node.js 开发者，它们是 C++ APIs。</p><p>那么，<em>事件循环</em> 到底是什么呢？</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*KGBiAxjeD9JT2j6KDo0zUg.png" data-original="https://cdn-images-1.medium.com/max/800/1*KGBiAxjeD9JT2j6KDo0zUg.png"></p><p>事件循环有一个简单的工作————监视调用栈和回调队列。如果调用栈清空了，它会获取队列里的第一个事件放入调用栈，高效地运行。</p><p>在事件循环中，像这样的一个迭代被称为 <strong>tick</strong>。每个事件都只是一个回调函数。</p><script src="https://gist.github.com/zlatkov/6d2e3006addd24cd73e5b576312a1c98.js"></script><p>让我们一起“执行”这段代码，然后看看发生了什么：</p><p>1、状态是清空的。浏览器控制台是清空的，调用栈也是空的。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*9fbOuFXJHwhqa6ToCc_v2A.png" data-original="https://cdn-images-1.medium.com/max/800/1*9fbOuFXJHwhqa6ToCc_v2A.png"></p><p>2、<code>console.log(&#39;Hi&#39;)</code>被添加进调用栈。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*dvrghQCVQIZOfNC27Jrtlw.png" data-original="https://cdn-images-1.medium.com/max/800/1*dvrghQCVQIZOfNC27Jrtlw.png"></p><p>3、<code>console.log(&#39;Hi&#39;)</code>被执行。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*yn9Y4PXNP8XTz6mtCAzDZQ.png" data-original="https://cdn-images-1.medium.com/max/800/1*yn9Y4PXNP8XTz6mtCAzDZQ.png"></p><p>4、 <code>console.log(&#39;Hi&#39;)</code> 被移出调用栈。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*iBedryNbqtixYTKviPC1tA.png" data-original="https://cdn-images-1.medium.com/max/800/1*iBedryNbqtixYTKviPC1tA.png"></p><p>5、<code>setTimeout(function cb1() { ... })</code>被添加进调用栈。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*HIn-BxIP38X6mF_65snMKg.png" data-original="https://cdn-images-1.medium.com/max/800/1*HIn-BxIP38X6mF_65snMKg.png"></p><p>6、 <code>setTimeout(function cb1() { ... })</code>被执行。浏览器通过 web api 创建了一个定时器。它将为你处理倒计时。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*vd3X2O_qRfqaEpW4AfZM4w.png" data-original="https://cdn-images-1.medium.com/max/800/1*vd3X2O_qRfqaEpW4AfZM4w.png"></p><p>7、<code>setTimeout(function cb1() { ... })</code>被执行完毕并移出调用栈。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*_nYLhoZPKD_HPhpJtQeErA.png" data-original="https://cdn-images-1.medium.com/max/800/1*_nYLhoZPKD_HPhpJtQeErA.png"></p><p>8、<code>console.log(&#39;Bye&#39;)</code>被添加进调用栈。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*1NAeDnEv6DWFewX_C-L8mg.png" data-original="https://cdn-images-1.medium.com/max/800/1*1NAeDnEv6DWFewX_C-L8mg.png"></p><p>9、<code>console.log(&#39;Bye&#39;)</code>被执行。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*UwtM7DmK1BmlBOUUYEopGQ.png" data-original="https://cdn-images-1.medium.com/max/800/1*UwtM7DmK1BmlBOUUYEopGQ.png"></p><p>10、<code>console.log(&#39;Bye&#39;)</code>被移出调用栈。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*-vHNuJsJVXvqq5dLHPt7cQ.png" data-original="https://cdn-images-1.medium.com/max/800/1*-vHNuJsJVXvqq5dLHPt7cQ.png"></p><p>11、在 <em>至少</em> 5000毫秒之后，定时器完成，并将 <code>cb1</code> 回调推入回调队列。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*eOj6NVwGI2N78onh6CuCbA.png" data-original="https://cdn-images-1.medium.com/max/800/1*eOj6NVwGI2N78onh6CuCbA.png"></p><p>12、事件循环从回调队列里取出 <code>cb1</code> 并推入调用栈。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*jQMQ9BEKPycs2wFC233aNg.png" data-original="https://cdn-images-1.medium.com/max/800/1*jQMQ9BEKPycs2wFC233aNg.png"></p><p>13、<code>cb1</code> 被执行，并添加 <code>console.log(&#39;cb1&#39;)</code> 到调用栈。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*hpyVeL1zsaeHaqS7mU4Qfw.png" data-original="https://cdn-images-1.medium.com/max/800/1*hpyVeL1zsaeHaqS7mU4Qfw.png"></p><p>14、<code>console.log(&#39;cb1&#39;)</code> 被执行。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*lvOtCg75ObmUTOxIS6anEQ.png" data-original="https://cdn-images-1.medium.com/max/800/1*lvOtCg75ObmUTOxIS6anEQ.png"></p><p>15、<code>console.log(&#39;cb1&#39;)</code> 被移出调用栈。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*Jyyot22aRkKMF3LN1bgE-w.png" data-original="https://cdn-images-1.medium.com/max/800/1*Jyyot22aRkKMF3LN1bgE-w.png"></p><p>16、<code>cb1</code> 被移出调用栈。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*t2Btfb_tBbBxTvyVgKX0Qg.png" data-original="https://cdn-images-1.medium.com/max/800/1*t2Btfb_tBbBxTvyVgKX0Qg.png"></p><p>快速回顾一下：</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*TozSrkk92l8ho6d8JxqF_w.gif" data-original="https://cdn-images-1.medium.com/max/800/1*TozSrkk92l8ho6d8JxqF_w.gif"></p><p>有趣的是 ES6 指定了 事件循环如何工作，意味着技术上来讲，事件循环是在 JS 引擎的职责范围内的，它将不再扮演宿主环境的角色。这一变化的一个主要原因是 ES6 Promise 的介绍说：因为后者需要直接访问和细粒度地控制事件队列循环的调度操作。（稍后我们会更详细地讨论它们）</p><h2 id="setTimeout-…-如何工作"><a href="#setTimeout-…-如何工作" class="headerlink" title="setTimeout(…) 如何工作"></a>setTimeout(…) 如何工作</h2><p>值得注意地的， <code>setTimeout(…)</code> 并不会自动将回调函数添加进事件循环队列。它只是设定一个定时器。当定时器到期时，运行环境将回调事件推入事件循环。所以未来 <code>tick</code> 会取出回调并执行它。看一眼这个代码：</p><script src="https://gist.github.com/zlatkov/9345a7c43b2407ddd1c52a6173a97dd9.js"></script><p>它并不意味着 <code>myCallback</code> 将会在1000毫秒的时候立即执行，而是在1000毫秒后，<code>myCallback</code> 被添加进事件循环队列。但是，队列里可能已经有其他事件被更早地添加进来————你的回调必须等待。</p><p>有相当多的文章和教程在开始使用异步js时建议使用 <code>setTimeout(callback, 0)</code>。现在你知道事件循环是怎么回事以及 setTimeout 如何工作：调用第二个参数为 0 的 setTimeout 只是推迟执行回调函数直至调用栈清空。</p><p>看一下下面的代码：</p><script src="https://gist.github.com/zlatkov/b12986d07676bc17fe51398847ebc917.js"></script><p>尽管定时器设置为 0ms, 但浏览器控制台的结果是：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">Hi</span></div><div class="line"><span class="keyword">Bye</span></div><div class="line"><span class="symbol">callback</span></div></pre></td></tr></table></figure><h2 id="ES6-里的-Jobs-是什么？"><a href="#ES6-里的-Jobs-是什么？" class="headerlink" title="ES6 里的 Jobs 是什么？"></a>ES6 里的 Jobs 是什么？</h2><p>在 ES6 介绍中，出现了一个新概念 “Jobs Queue”。它是事件循环之上的一层。当你处理 Promise 异步操作的时候，你几乎经常碰到它（我们也会谈谈它）。</p><p>我们先来谈谈这个概念，以便稍后讨论异步 Promise 表现的时候，你能理解那些行为是如何被调度和处理的。</p><p>想像一下，Job Queue 是一个附属于事件队列中每一个 tick 结尾的队列。某些异步行为可能会发生在事件循环的某一刻，却不会引起一个全新的事件添加到事件循环队列中。但会添加一个项目（也叫Job）到当前 tick 的 Job Queue。</p><p>这意味着你可以添加一个功能，让它稍后执行。并且你可以放心，它刚好会在其他事件之前，在那之后执行。</p><p>一个 Job 也能引起其他的 Job 添加到相同的队列后面。理论上，Job “循环”也是有可能产生的（一个不断添加其他 Jobs的Job之类）。这样需要资源的程序就必须移动到事件循环的下一个 tick。概念上看，这就类似于需要长时候运行或死循环（就像 <code>while (true) ..</code>）。</p><p>Job 就像 <code>setTimeout(callback, 0)</code> 的 <code>hack</code>，但通过引入一个更加明确的概念来实现：稍后执行，但尽可能快。</p><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>正如你所知道的，回调函数是迄今为止 javascript 程序中最常见的表达和管理异步的方式。的确，回调是 javascript 语言中最基本的异步模式。无数的JS程序，甚至是即使是非常复杂的一个，也不会少了最基础的回调异步模式。</p><p>除了回调，其他的不会没有缺点。许多开发者尝试寻找更好的异步模式。但是，如果不能很好地理解引擎下的工作原理，就不可能有效地使用任何抽象概念。</p><p>在接下来的章节，我们将探索这些抽象概念，深入地展示为什么更复杂的异步模式（这将在随后的帖子中讨论）是必须的，甚至是推荐的。</p><h2 id="嵌套回调"><a href="#嵌套回调" class="headerlink" title="嵌套回调"></a>嵌套回调</h2><p>看下面的代码：</p><script src="https://gist.github.com/zlatkov/cf5d201413729777fa6b8d5af1f8eaa4.js"></script><p>我们有三个函数嵌套在一起，每一个就代表异步系列的一步。</p><p>这种代码经常被称为“回调地狱（callback hell）”。但“回调地狱”实际上与嵌套、缩进没什么关系。这是一个更深入的问题。</p><p>首先，我们等待“点击”事件，然后等待定时器被触发，然后等待 Ajax 请求响应数据，在这一点，它可能会再次重复。</p><p>粗略地看，这段代码似乎自然而然地将异步映射为连续的步骤：</p><script src="https://gist.github.com/zlatkov/c279bb1865ad3a8ff8c890d842b105c1.js"></script><p>然后我们有：</p><script src="https://gist.github.com/zlatkov/8c9c5601ba6b35adf652b7a6797d1a14.js"></script><p>再然后有：</p><script src="https://gist.github.com/zlatkov/250ccf280b4f191f87bca3a0b8337a41.js"></script><p>最后我们有：</p><script src="https://gist.github.com/zlatkov/6dc48448f85e010542ac9ba86482f38d.js"></script><p>这样用连续的方式表达异步看起来更自然，不是吗？这种方式一定行得通，对吧？</p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>看一下这个代码：</p><script src="https://gist.github.com/zlatkov/bf8888880822b83e4a9c1bfc4b21c6a9.js"></script><p>这非常简单：将 <code>x</code> 和 <code>y</code> 的值相加然后输出在控制台。但是，如果 <code>x</code> 和 <code>y</code> 的值在用于表达式之前丢失了，或还不确定怎么办呢？让我们想象一下，我们有两个函数 <code>loadx</code> 和 <code>loady</code> 分别从服务端加载 <code>x</code> 和 <code>y</code> 的值。然后，有一个函数 <code>sum</code> 会在 <code>x</code> 和 <code>y</code> 都获取到值的时候相加。</p><p>代码看起来可能是这样的（非常丑陋，不是吗）：</p><script src="https://gist.github.com/zlatkov/1ffa6e00a2750217f1a168fe36deda08.js"></script><p>这里有一些非常值得注意的事情——在上面的代码段中，我们假设 <code>x</code> 和 <code>y</code> 都是未来值，并且我们表达了一个操作函数 <code>sum</code> 并不关心 <code>x</code>或<code>y</code>或两者是否都可用。</p><p>当然，这种基于回调的方式不尽人意。这只是首先的一小步，为了更好地理解为什么不需要关心 <em>未来值</em> 何时可用这方面。</p><h2 id="Promise-Value"><a href="#Promise-Value" class="headerlink" title="Promise Value"></a>Promise Value</h2><p>让我们粗略地看一下，如何使用 Promise 来表达 <code>x + y</code>:</p><script src="https://gist.github.com/zlatkov/e7098be769383bac5336c54d952beb53.js"></script><p>这个代码段中有两层 Promise.</p><p><code>fetchX()</code> 和 <code>fetchY()</code> 被直接调用，并且他们的返回值被传递到 <code>sum(...)</code> 。潜在的值可能在现在或稍后准备好，但每个 Promise 规定了它们的表现是相同的。我们以独立的方式分析 <code>x</code> 和 <code>y</code>的值。它们是未来的值，有一段期限。</p><p>第二层是<code>sum(...)</code> 创建的 Promise(来源于 <code>Promise.all([ ... ])</code>)。我们等待着调用 <code>then(...)</code> .当 <code>sum(...)</code> 操作符完成时，我们相加的未来的值已经准备好，并且可以输出。我们为了等待 <code>x</code> 和<code>y</code> 值，在 <code>sum(...)</code>中隐藏了逻辑。</p><p><strong>注意：</strong> 在<code>sum(…)</code>之中，调用 <code>Promise.all([ … ])</code> 创建一个 Promise （等待 <code>promiseX</code> 和 <code>promiseY</code> 完成）。调用链 <code>.then(...)</code> 创建另一个 Promise，立即返回 <code>values[0] + values[1]</code> （相加的结果）。<code>sum(...)</code> 后面调用的 <code>then(...)</code> 实际上是第二个Promise 返回的，而不是第一个 <code>Promise.all([ ... ])</code> 返回的。同样，我们没有链接第二个 <code>then(...)</code>, 它也同样已经创建了另一个 Promise。这一 Promise 链的内容将在本章结尾详细解释。</p><p>使用 Promise, <code>then(...)</code> 实际上可以传入两个函数，第一个对应完成状态，第二个是对应失败状态。</p><script src="https://gist.github.com/zlatkov/33582dc127209706688796092e268772.js"></script><p>如果在获取 <code>x</code> 或 <code>y</code> 的时候发生错误，或者在相加的时候出错，<code>sum(...)</code> 会返回失败，并且传入 <code>then(...)</code> 的第二个错误处理函数会收到 Promise 返回的值。</p><p>因为 Promise 封装了依赖时间的状态——等待底层值的完成或失败——从外部看，Promise 本身是依赖时间的，因此 Promise 可以以可预测的方式组合起来，而不用考虑时间和结果。</p><p>此外，一旦 Promise 解决了，它将永入停留在那个状态——它这时变成一个 <em>不可变的</em> 值——并且根据需要可以观察多次。</p><p>链式调用 Promise 真的非常有用：</p><script src="https://gist.github.com/zlatkov/f94c8e16cbbb8b8940744b348c70de14.js"></script><p>调用 <code>delay(2000)</code> 创建一个 Promise 将会在 2000ms 后达到条件，然后从第一个 <code>then(...)</code> 成功回调返回，这会造成第二个 <code>then(...)</code> 会等待 2000ms 的 Promise.</p><p><strong>注意：</strong> 因为 Promise 从外部看来如果被解决了是无法再改变的，现在把值传到任何一部分都是安全的，它不能被恶意或意外地修改。尤其是关系到多个 Promise 遵守协议。一方不可能影响另一方遵守协议的能力。不变性听起来关系到学术性的话题。但它实际上是 Promise 设计的最基本也是最重要的部分，不应该随便错过。</p><h2 id="用还是不用-Promise"><a href="#用还是不用-Promise" class="headerlink" title="用还是不用 Promise"></a>用还是不用 Promise</h2><p>关于 Promise 有一个很重要的细节就是要知道某个值是否是 Promise。换句话说，某个值表现得像 Promise 吗？</p><p>我们知道，Promise 通过 <code>new Promise(…)</code> 语法构造，然后你认为 <code>p instanceof Promise</code> 足以检查它是否是一个 Promise。但，并不完全是。</p><p>主要是因为你可以有通过其他的浏览窗口接收一个 Promise 值（比如：iframe），它有它所属的 Promise， 不同于当前窗口的，并且检测是否是 Promise 实例会返回失败。</p><p>此外，一个类库或框架可能会选择自己使用的 Promise 实现版本，而不是使用 ES6 原生实现的 Promise。通过类库使用 Promise 可能在不支持 Promise 的浏览器上工作得很好。</p><h2 id="被吞掉的异常"><a href="#被吞掉的异常" class="headerlink" title="被吞掉的异常"></a>被吞掉的异常</h2><p>如果任何时候创建一个 Promise ，或正在监听它决策的时候，发生了意外错误，比如 <code>TypeError</code> 或者 <code>ReferenceError</code>, 异常将会被捕获，并且这个 Promise 将会被强制变成失败状态。</p><p>举个例子：</p><script src="https://gist.github.com/zlatkov/ba13f1f0a37b0156417bc389785d37ea.js"></script><p>但如果一个 Promise 还没有变成成功状态，却在观察期间发生了异常会怎样呢（在 <code>then(...)</code> 注册了回调）？尽管这个异常可以捕获，但它的处理方式可能让你有点吃惊。让我们挖得更深一点。</p><script src="https://gist.github.com/zlatkov/2ab398f4d3eeccb80556de844de2cd92.js"></script><p>这看起来发生在 <code>foo.bar()</code> 的异常确实被吞掉了。虽然事实并没有。有一些更深的东西发生了错误，但是，我们并没有监听到。<code>p.then(…)</code> 返回另一个 Promise，而且这个 Promise 会因为 <code>TypeError</code> 变成失败状态。</p><h2 id="处理未捕获的异常"><a href="#处理未捕获的异常" class="headerlink" title="处理未捕获的异常"></a>处理未捕获的异常</h2><p>还有其他一些许多人认为 <em>更好</em> 的解决办法。</p><p>一个普遍的建议就是 Promise 应该添加一个 <code>done(…)</code>，意味着 Promise 链式调用已“完成”。<code>done(…)</code> 不会再创建并返回一个 Promise，所以传递回调函数到 <code>done(..)</code> 显然不能与不存在的 Promise 连接上报异常。</p><p>你可能期望发现任何未捕获的错误的情况：任何 <code>done(..)</code> 中的异常都会抛出全局的未捕获的错误（基本都会出现在控制台）：</p><script src="https://gist.github.com/zlatkov/ae156463adf288ca0ac9da9e8964fa18.js"></script><h2 id="ES8-有什么变化？Async-await"><a href="#ES8-有什么变化？Async-await" class="headerlink" title="ES8 有什么变化？Async/await"></a>ES8 有什么变化？Async/await</h2><p>javascript ES8 推出了 <code>async/await</code> 让 Promise 的工作更容易更简单。我们简要地看看 <code>async/await</code> 提供了什么并利用它们写一些异步代码。</p><p>那么，让我们来看看 <code>async/await</code> 是如何工作的。</p><p>你可以使用 <code>async</code> 声明定义一个异步函数。这样的函数返回一个<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction" target="_blank" rel="noopener">异步函数对象</a>。<code>AsyncFunction</code> 对象代表异步函数执行代码，并包含在那个宿主函数中。</p><p>当异步函数被调用时，它返回一个 <code>Promise</code>。当异步函数返回一个值时，那就不是一个 <code>Promise</code>。<code>Promise</code> 会被自动创建，并且会通过返回值来完成状态。当 <code>async</code> 抛出异常，<code>Promise</code> 将抛出值并变成失败状态。</p><p>一个 <code>async</code> 函数可以包含一个 <code>await</code> 表达式，它会暂停执行函数内的代码并等待 Promise 返回结果，然后继续执行异步函数并返回结果。</p><p>你可以认为 <code>Promise</code> 与 Java中的<code>Future</code>或者 <code>C#</code> 的任务。</p><blockquote><p>使用 <code>async/await</code> 的目的是为了简化使用 Promise 的行为。</p></blockquote><p>看下面的代码：</p><script src="https://gist.github.com/zlatkov/8f74044b900d1ea4d365ca3992b50ea3.js"></script><p>同样的，异步函数内抛出异常相当于普通函数抛出一个被拒绝的 Promise：</p><script src="https://gist.github.com/zlatkov/159929de0c27b2ddfc9c8e100ce51b43.js"></script><p><code>await</code> 语句只有用在 <code>async</code> 函数内，并允许你在 Promise 进行同步等待。如果我们要在 <code>async</code> 函数外使用 Promise, 我们仍要使用 <code>then</code> 来执行回调：</p><script src="https://gist.github.com/zlatkov/448a79cab54330c062a13a84ebb06cf7.js"></script><p>你也可以使用“异步函数表达式”来定义异步函数。一个异步函数表达式和一个异步函数声明很类似，几乎有相同的语法。他们之前主要的不同就是函数名。异步函数表达式可以省略函数名，创建一个匿名函数。异步函数表达式可以被当成 IIFE（自执行函数）来使用，一经定义就执行。</p><p>看下这个：</p><script src="https://gist.github.com/zlatkov/0873db2fd9f5883a2e1bae414e43a5cc.js"></script><p>更重要的地，<code>async/await</code> 在主流浏览器中的支持情况：</p><p><img src="/js/lazyload-plugin/loading.svg" alt="If this compatibility is not what you are after, there are also several JS transpilers like Babel and TypeScript." data-original="https://cdn-images-1.medium.com/max/800/0*z-A-JIe5OWFtgyd2."></p><p>最后，最重要的是不要盲目地选择“最新”的写法去实现异步函数。本质是要理解异步 javascript 的内部原理。了解它为什么如此关键，并深入理解你的选择的内部原理。每种方法都有优缺点，就像编程中的其他部分一样。</p><h1 id="编写高可维护性，健壮的代码的5个提示"><a href="#编写高可维护性，健壮的代码的5个提示" class="headerlink" title="编写高可维护性，健壮的代码的5个提示"></a>编写高可维护性，健壮的代码的5个提示</h1><h2 id="1、-简洁的代码"><a href="#1、-简洁的代码" class="headerlink" title="1、 简洁的代码"></a>1、 简洁的代码</h2><p>使用 async/await 允许你写很少的代码。每次你使用 async/await 跳过一些不必须要步骤：写 <code>.then</code> 时，创建一个匿名函数去处理回应，给返回值命名。例如：</p><script src="https://gist.github.com/zlatkov/b66f922b26bb6d5fd701c7ba40ac81d7.js"></script><p>与：</p><script src="https://gist.github.com/zlatkov/f506c8de2c73ba1c4c9ec78c5871816c.js"></script><h2 id="2、错误处理"><a href="#2、错误处理" class="headerlink" title="2、错误处理"></a>2、错误处理</h2><p>Async/await 让处理同步和异步错误使用相同的方法——广为人知的 <code>try/catch</code>。</p><script src="https://gist.github.com/zlatkov/c5fc0706d2d37ce3bb9db75e8a991807.js"></script><p>与：</p><script src="https://gist.github.com/zlatkov/1f858a186da7d19fab77893e34e46adc.js"></script><h2 id="3、条件语句"><a href="#3、条件语句" class="headerlink" title="3、条件语句"></a>3、条件语句</h2><p>使用 <code>async/await</code> 写条件句更简单：</p><script src="https://gist.github.com/zlatkov/30e8c04023639ed289a5d107b6989269.js"></script><p>与：</p><script src="https://gist.github.com/zlatkov/3dea9285325304af9a73aceb3beb6742.js"></script><h2 id="4、堆栈帧"><a href="#4、堆栈帧" class="headerlink" title="4、堆栈帧"></a>4、堆栈帧</h2><p>与 <code>async/await</code> 不同，Promise 抛出的错误栈并没有包含错误发生在哪里。</p><script src="https://gist.github.com/zlatkov/8e728cc4d6ad1e302454e957fcce0580.js"></script><p>与：</p><script src="https://gist.github.com/zlatkov/7282966e52cab3eee85794d5e8df6928.js"></script><h2 id="5、调试"><a href="#5、调试" class="headerlink" title="5、调试"></a>5、调试</h2><p>如果你使用过 Promise, 你一定知道调试它们是一个噩梦。例如，如果你在一个 <code>.then</code> 打了个断点，并且使用调试快捷键操作，像“stop-over”，调试器并不会移动到下一个 <code>.then</code> ，因为它只是同步代码的“一步”。使用 <code>async/await</code> 你可以精确地定位到每一步 <code>await</code>，就好像他们是正常的同步函数一样。</p><p>书写异步函数不仅对应用程序很重要，对类库也同样如此。</p><p>举个例子： <a href="https://www.sessionstack.com/?utm_source=medium&amp;utm_medium=blog&amp;utm_content=Post-4-eventloop-outro" target="_blank" rel="noopener">Sessionstak</a> 类记录了网页上发生的所有事情。所有 DOM 操作，用户交互，javascript 异常，堆栈跟踪，失败的网络请求，以及调试信息。</p><p>这一切都发生在生产环境下却不影响用户体验。我们必须高度优化我们的代码，让它们尽可能地异步，这样就可以增加事件循环处理事件的数量。</p><p>也不止是类库，当你在 SessionStack 重播用户的会话时，我们必须在发生问题时，将用户浏览器的状态重现出来，我们必须重建整个状态，允许你在时间轴上向后或向前跳跃。为了让这成为可能，我们大量使用了异步javascript提供的机会。</p><p>这里有一个<a href="https://www.sessionstack.com/?utm_source=medium&amp;utm_medium=blog&amp;utm_content=Post-4-eventloop-GetStarted" target="_blank" rel="noopener">免费的计划</a>让你来体验一下。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/0*xSEaWHGqqlcF8g5H." data-original="https://cdn-images-1.medium.com/max/800/0*xSEaWHGqqlcF8g5H."></p><p>参考：</p><ul><li><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch2.md" target="_blank" rel="noopener">https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch2.md</a></li><li><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch3.md" target="_blank" rel="noopener">https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch3.md</a></li><li><a href="http://nikgrozev.com/2017/10/01/async-await/" target="_blank" rel="noopener">http://nikgrozev.com/2017/10/01/async-await/</a></li></ul><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong> robin</li><li class="post-copyright-link"><strong>本文翻译自：</strong> <a href="https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5" title="javascript 事件循环是如何工作的以及使用async／await提升异步编程的5种方式">https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5</a></li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="http://robin-front.github.io/2017/11/06/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-async-and-await/" title="javascript 事件循环是如何工作的以及使用async／await提升异步编程的5种方式">http://robin-front.github.io/2017/11/06/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-async-and-await/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/tutorial/" rel="tag"># tutorial</a> <a href="/tags/web-development/" rel="tag"># web development</a> <a href="/tags/programming/" rel="tag"># programming</a> <a href="/tags/asynchronous/" rel="tag"># asynchronous</a> <a href="/tags/events-loop/" rel="tag"># events loop</a> <a href="/tags/promise/" rel="tag"># promise</a> <a href="/tags/async-await/" rel="tag"># async await</a></div><h3>相关文章</h3><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/10/25/you-might-not-need-redux/" rel="next" title="你可能并不需要 redux"><i class="fa fa-chevron-left"></i> 你可能并不需要 redux</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/11/09/react-component-patterns/" rel="prev" title="react 组件设计模式">react 组件设计模式 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div id="gitalk-container"></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="https://avatars2.githubusercontent.com/u/6723674?v=3&s=460" alt="robin"><p class="site-author-name" itemprop="name">robin</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">87</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">8</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">101</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/robin-front" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:lb.robin1991@gmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://twitter.com/lb_robin" target="_blank" title="Twitter"><i class="fa fa-fw fa-twitter"></i>Twitter</a></span></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#javascript-事件循环是如何工作的以及使用async／await提升异步编程的5种方式"><span class="nav-number">1.</span> <span class="nav-text">javascript 事件循环是如何工作的以及使用async／await提升异步编程的5种方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么单线程是一个限制？"><span class="nav-number">1.1.</span> <span class="nav-text">为什么单线程是一个限制？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#javascript-程序的组成部分"><span class="nav-number">1.2.</span> <span class="nav-text">javascript 程序的组成部分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剖析事件循环"><span class="nav-number">1.3.</span> <span class="nav-text">剖析事件循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#setTimeout-…-如何工作"><span class="nav-number">1.4.</span> <span class="nav-text">setTimeout(…) 如何工作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ES6-里的-Jobs-是什么？"><span class="nav-number">1.5.</span> <span class="nav-text">ES6 里的 Jobs 是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回调函数"><span class="nav-number">1.6.</span> <span class="nav-text">回调函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#嵌套回调"><span class="nav-number">1.7.</span> <span class="nav-text">嵌套回调</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Promise"><span class="nav-number">1.8.</span> <span class="nav-text">Promise</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Promise-Value"><span class="nav-number">1.9.</span> <span class="nav-text">Promise Value</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用还是不用-Promise"><span class="nav-number">1.10.</span> <span class="nav-text">用还是不用 Promise</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#被吞掉的异常"><span class="nav-number">1.11.</span> <span class="nav-text">被吞掉的异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#处理未捕获的异常"><span class="nav-number">1.12.</span> <span class="nav-text">处理未捕获的异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ES8-有什么变化？Async-await"><span class="nav-number">1.13.</span> <span class="nav-text">ES8 有什么变化？Async/await</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#编写高可维护性，健壮的代码的5个提示"><span class="nav-number">2.</span> <span class="nav-text">编写高可维护性，健壮的代码的5个提示</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、-简洁的代码"><span class="nav-number">2.1.</span> <span class="nav-text">1、 简洁的代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、错误处理"><span class="nav-number">2.2.</span> <span class="nav-text">2、错误处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、条件语句"><span class="nav-number">2.3.</span> <span class="nav-text">3、条件语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、堆栈帧"><span class="nav-number">2.4.</span> <span class="nav-text">4、堆栈帧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、调试"><span class="nav-number">2.5.</span> <span class="nav-text">5、调试</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2014 &mdash; <span itemprop="copyrightYear">2017</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">robin</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">Site words total count&#58;</span> <span title="Site words total count">104.0k</span></div><div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div><span class="post-meta-divider">|</span><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.2</div><div class="busuanzi-count"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><i class="fa fa-user"></i> <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> </span><span class="site-pv"><i class="fa fa-eye"></i> <span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="https://cdn.bootcss.com/jquery/2.1.3/jquery.min.js"></script><script type="text/javascript" src="https://cdn.staticfile.org/fastclick/1.0.6/fastclick.min.js"></script><script type="text/javascript" src="https://cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script><script type="text/javascript" src="https://cdn.staticfile.org/velocity/1.2.1/velocity.min.js"></script><script type="text/javascript" src="https://cdn.bootcss.com/velocity/1.2.1/velocity.ui.min.js"></script><script type="text/javascript" src="https://cdn.staticfile.org/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script type="text/javascript" src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script><script type="text/javascript">var gitalk=new Gitalk({clientID:"470b9e9d99d37489877f",clientSecret:"c319e368fd485f89601b4c2c0cee649bd9cf97cd",repo:"robin-front.github.io",owner:"Robin-front",admin:["Robin-front"],distractionFreeMode:!0});gitalk.render("gitalk-container")</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script></body></html>