<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>三寸稚笔</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://robin-front.github.io/"/>
  <updated>2017-04-06T03:21:26.000Z</updated>
  <id>http://robin-front.github.io/</id>
  
  <author>
    <name>robin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Coverage针对js和css的代码覆盖检测-Chrome_devtools的新功能</title>
    <link href="http://robin-front.github.io/2017/04/06/Coverage%E9%92%88%E5%AF%B9js%E5%92%8Ccss%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E6%A3%80%E6%B5%8B-Chrome-devtools%E7%9A%84%E6%96%B0%E5%8A%9F%E8%83%BD/"/>
    <id>http://robin-front.github.io/2017/04/06/Coverage针对js和css的代码覆盖检测-Chrome-devtools的新功能/</id>
    <published>2017-04-06T03:21:26.000Z</published>
    <updated>2017-04-06T03:21:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>也许你之前用过一些像 <code>css usage</code>、<code>css used</code> 这样的浏览器插件去检测代码覆盖率。但现在，Chrome的实验版本<a href="https://www.google.com/chrome/browser/canary.html" target="_blank" rel="external">Canary</a>终于实现了代码覆盖率检测，这意味着它将很快普及到正式版本。这是一个令人兴奋的功能，在使用JavaScript和CSS时非常有用，所以我会做一个快速的演示，并探索它如何使用。</p>
<a id="more"></a>
<h2 id="它做了些什么事情"><a href="#它做了些什么事情" class="headerlink" title="它做了些什么事情"></a>它做了些什么事情</h2><p>代码覆盖可以在您运行您的Web应用程序的时候，遍历每个JS / CSS文件，看看哪些代码行运行，哪些代码没有运行。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*gD8lX40PSemDOZgvT695Mg.png" alt="coverage"></p>
<p>在这里，我做了一个简单的静态网页，Chrome生成了页面上存在的CSS和JS文件的问题汇总。右侧的栏显示每个文件的相对大小，红色表示未使用的代码，绿色显示运行的代码。</p>
<p>记录代码覆盖范围与devtools时间轴类似，您点击开始记录，然后在您的站点进行正常的交互。完成后，Chrome会进行一些计算并生成读数。在这里，我很好奇网站上有多少未使用的CSS，所以我导航到各个子页面，以确保我触及到每个css。果然，这里有很多改进的空间，因为我的网站上的css的97％没有使用！</p>
<p><img src="https://cdn-images-1.medium.com/max/1200/1*1SUTeKlhRee3MyKdxkUGtQ.png" alt="coverage"></p>
<p>Chrome还可让您深入研究单个文件的代码范围。在这里，左边的红色/绿色条显示哪一行执行了，哪一行没有。请注意，当检查最小化的文件时，可以按文件左下角的按钮来“<code>prettify</code>”代码。</p>
<h2 id="这有什么用"><a href="#这有什么用" class="headerlink" title="这有什么用"></a>这有什么用</h2><p>在一个复杂的或长期的项目上工作时，很容易积累冗余代码。如果你使用 <code>webpack</code> 或另一个JS构建系统，可以防止大多数无用的JS代码。但是对于CSS来说，这样做可能会有点棘手。有了这个覆盖工具，在Chrome是一个伟大的方式来快速了解多少冗余的代码在运行，哪些文件需要优化。</p>
<h2 id="如何才能使用它"><a href="#如何才能使用它" class="headerlink" title="如何才能使用它"></a>如何才能使用它</h2><p>下载Chrome的实验版本<a href="https://www.google.com/chrome/browser/canary.html" target="_blank" rel="external">Canary</a>或等待此功能更新到正式版本。</p>
<p><a href="https://blog.logrocket.com/using-the-chrome-devtools-new-code-coverage-feature-ca96c3dddcaf" target="_blank" rel="external">译文参考</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;也许你之前用过一些像 &lt;code&gt;css usage&lt;/code&gt;、&lt;code&gt;css used&lt;/code&gt; 这样的浏览器插件去检测代码覆盖率。但现在，Chrome的实验版本&lt;a href=&quot;https://www.google.com/chrome/browser/canary.html&quot;&gt;Canary&lt;/a&gt;终于实现了代码覆盖率检测，这意味着它将很快普及到正式版本。这是一个令人兴奋的功能，在使用JavaScript和CSS时非常有用，所以我会做一个快速的演示，并探索它如何使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Chrome_devtools" scheme="http://robin-front.github.io/categories/Chrome-devtools/"/>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/Chrome-devtools/javascript/"/>
    
    
      <category term="coverage" scheme="http://robin-front.github.io/tags/coverage/"/>
    
      <category term="Chrome_devtools" scheme="http://robin-front.github.io/tags/Chrome-devtools/"/>
    
  </entry>
  
  <entry>
    <title>学习RxJS需要知道的奇淫技巧</title>
    <link href="http://robin-front.github.io/2017/04/05/%E5%AD%A6%E4%B9%A0RxJS%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7/"/>
    <id>http://robin-front.github.io/2017/04/05/学习RxJS需要知道的奇淫技巧/</id>
    <published>2017-04-05T09:06:03.000Z</published>
    <updated>2017-04-05T09:06:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-Rx-的奇淫技巧"><a href="#使用-Rx-的奇淫技巧" class="headerlink" title="使用 Rx 的奇淫技巧"></a>使用 Rx 的奇淫技巧</h1><h3 id="尝试画珠宝图"><a href="#尝试画珠宝图" class="headerlink" title="尝试画珠宝图"></a>尝试画珠宝图</h3><p>为你想创建的流画一个珠宝图。 通过画珠宝图，你将会很清楚你应该使用哪些操作符。</p>
<p>珠宝图就是每个珠宝表示当前的一个事件或状态。珠宝图需要包含输入和输出流。</p>
<p><img src="https://raw.githubusercontent.com/Reactive-Extensions/RxJS/master/doc/designguidelines/images/throttleWithTimeout.png" alt="throttleWithSelector"></p>
<a id="more"></a>
<p>通过画珠宝图，我们可以看到，我们在异步调用事件回调之前，需要延迟检测用户的输入。在这个例图里展示的是<code>throttle</code>操作符的延迟。从一个流创建另一个流，我们会使用 <code>flatMap</code> 或 <code>selectMany</code> 操作符。然后就有了下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dictionarySuggest = userInput.throttle(<span class="number">250</span>).flatMap(<span class="function"><span class="params">input</span> =&gt;</span> serverCall(input));</div></pre></td></tr></table></figure>
<h4 id="何时忽略这条指南"><a href="#何时忽略这条指南" class="headerlink" title="何时忽略这条指南"></a>何时忽略这条指南</h4><p>如果你感觉你已经可以很熟练地编写出你想要的流，你可以省去画珠宝图这一步。不管怎样，就算是 Rx 团队的成员在写代码的时候也仍然会先画一画珠宝图。</p>
<h3 id="调用-subscribe-时传递多个参数"><a href="#调用-subscribe-时传递多个参数" class="headerlink" title="调用 subscribe 时传递多个参数"></a>调用 <code>subscribe</code> 时传递多个参数</h3><p>为了方便， Rx 提供一个<code>subscribe</code>方法来加载观察者的回调函数。</p>
<p>观察者只需要实现这三个方法（<code>onNext</code>, <code>onError</code> &amp; <code>onCompleted</code>）。 <code>subscribe</code>方法的扩展允许开发人员使用这些方法的默认选项。</p>
<p>比如： 当调用<code>subscribe</code>方法时只有一个<code>onNext</code>参数，<code>onError</code>将捕获来自事件流的异常。<code>onCompleted</code>在这里什么也不会做。</p>
<p>大部分情况下，处理异常是很重要的（不管是对于恢复还是中断应用程序）。</p>
<p>知道事件流是否完成也经常是很重要的。举个例子，告诉用户他的操作是否完成了。</p>
<p>所以，最好提供完整的三个参数给 <code>subscribe</code> 操作符。</p>
<p>RxJS还提供了三种方便的方法，其仅订阅所期望的序列的一部分。其他的处理程序会默认为原来的行为。有三个这样的功能：</p>
<ul>
<li><code>subscribeOnNext</code>: 只对应 <code>onNext</code> 消息</li>
<li><code>subscribeOnError</code>: 只对应 <code>onError</code> 消息</li>
<li><code>subscribeOnCompleted</code>: 只对应 <code>onCompleted</code> 消息.</li>
</ul>
<h4 id="何时忽略这条指南-1"><a href="#何时忽略这条指南-1" class="headerlink" title="何时忽略这条指南"></a>何时忽略这条指南</h4><ul>
<li>当流确定不会有完成状态，比如 <code>keyup</code>事件。</li>
<li>当流确定不会抛出异常，比如一个事件，一个完全确定的流。</li>
<li>当默认行为是符合预期的时候。</li>
</ul>
<h3 id="考虑通过特定的调度程序并发引入操作符"><a href="#考虑通过特定的调度程序并发引入操作符" class="headerlink" title="考虑通过特定的调度程序并发引入操作符"></a>考虑通过特定的调度程序并发引入操作符</h3><p>相比使用<code>observeon</code>操作符来改变可观察序列产生消息的执行上下文，更好的做法是在正确的地方开始创建并发。 通过正确的调度器将会减少 <code>ObserveOn</code>操作符的使用。</p>
<h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Rx.Observable.range(<span class="number">0</span>, <span class="number">90000</span>, Rx.Scheduler.requestAnimationFrame).subscribe(draw);</div></pre></td></tr></table></figure>
<p>在这个例子中，来自<code>range</code>操作符的回调将会通过<code>window.requestAnimationFrame</code>传递。在这个例子中， <code>range</code>操作符的回调将被调用。默认情况下，当递归调用立即执行时，<code>range</code>过载将会代替 <code>onNext</code>在<code>Rx.Scheduler.currentThread</code>上的调用。 通过提供<code>Rx.Scheduler.requestAnimationFrame</code>调度程序， 所有来自observable的消息都将会在 <code>window.requestAnimationFrame</code>回调中产生。</p>
<h4 id="何时忽略这条指南-2"><a href="#何时忽略这条指南-2" class="headerlink" title="何时忽略这条指南"></a>何时忽略这条指南</h4><p>当结合来自不同执行上下文的几个事件时，使用指南4.4将所有消息尽可能晚地放在特定的执行上下文。</p>
<h3 id="尽可能少且尽可能迟地调用observeOn-操作符"><a href="#尽可能少且尽可能迟地调用observeOn-操作符" class="headerlink" title="尽可能少且尽可能迟地调用observeOn 操作符"></a>尽可能少且尽可能迟地调用<code>observeOn</code> 操作符</h3><p>通过使用 <code>observeOn</code> 操作符， 一个预定的功能是通过原始的消息流来获取信息。这可能会改变时序信息以及对系统施加额外的压力。在查询中延迟使用这个操作符可以改善这两个问题。</p>
<h4 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = xs.throttle(<span class="number">1000</span>)</div><div class="line">  .flatMap(<span class="function"><span class="params">x</span> =&gt;</span> ys.takeUntil(zs).sample(<span class="number">250</span>).map(<span class="function"><span class="params">y</span> =&gt;</span> x + y))</div><div class="line">  .merge(ws)</div><div class="line">  .filter(<span class="function"><span class="params">x</span> =&gt;</span> x &lt; <span class="number">10</span>)</div><div class="line">  .observeOn(Rx.Scheduler.requestAnimationFrame);</div></pre></td></tr></table></figure>
<p>这个例子合并了多个 运行在不同上下文的 observable 。这个查询筛选掉了大部分信息。将<code>observeOn</code>操作符放在查询中的前面会对筛选出来的消息做额外的工作。最后才调用 <code>observeOn</code> 将会最大限度地提高性能。</p>
<h4 id="何时忽略这条指南-3"><a href="#何时忽略这条指南-3" class="headerlink" title="何时忽略这条指南"></a>何时忽略这条指南</h4><p>如果你使用的 observable 并没有指定不同的上下文环境。这种情况下可以不必使用 <code>observeOn</code> 操作符。</p>
<h3 id="关注内存限制"><a href="#关注内存限制" class="headerlink" title="关注内存限制"></a>关注内存限制</h3><p>RxJS 有很多操作符和类可以在内存中创建 observable, 比如：<code>replay</code> 操作符。当这些内存存储着 observable 时，这些缓存的大小将取决于 observable 的操作。如果缓存过大，将会造成内存溢出。有许多缓冲操作符提供策略来限制缓冲区，不管是从时间方面还是大小。提供这个限制将解决内存压力问题。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = xs.replay(<span class="literal">null</span>, <span class="number">10000</span>, <span class="number">1000</span> * <span class="number">60</span> <span class="comment">/* 1 hr */</span>).refCount();</div></pre></td></tr></table></figure>
<p>这个例子中，<code>replay</code> 操作符创建了一个 buffer. 我们有限制这个 buffer 最多包含 10,000 条信息以及最多保留这些信息1小时。</p>
<h4 id="何时忽略这条指南-4"><a href="#何时忽略这条指南-4" class="headerlink" title="何时忽略这条指南"></a>何时忽略这条指南</h4><p>当 observable 创建了大量的信息只填充了一小块 buffer， 或者当 buffer本身有大小限制。</p>
<h3 id="使用-do-tap-操作符的副作用很明显"><a href="#使用-do-tap-操作符的副作用很明显" class="headerlink" title="使用 do/tap 操作符的副作用很明显"></a>使用 <code>do</code>/<code>tap</code> 操作符的副作用很明显</h3><p>有很多 Rx 操作符使用函数作为参数，这可以在这些参数中传递任何有效的用户代码。这些代码可以改变全局状态（比如改变全局变量，读写硬盘等等）。</p>
<p>Rx 是通过每个操作符组合起来运行的（除了共享操作符，例如“publish”）。这将使副作用发生在每个订阅。</p>
<p>如果这种表现是期望的行为，最好弄清楚在 <code>do</code>/<code>tap</code> 操作符中有副作用的这部分代码。这些方法会过载，只能调用指定的方法，比如 <code>doOnNext</code>/<code>tapOnNext</code>，<code>doOnError</code>/<code>tapOnError</code>,<code>doOnCompleted</code>/<code>tapOnCompleted</code></p>
<h4 id="例-1"><a href="#例-1" class="headerlink" title="例"></a>例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = xs.filter(<span class="function"><span class="params">x</span> =&gt;</span> x.failed).tap(<span class="function"><span class="params">x</span> =&gt;</span> log(x));</div></pre></td></tr></table></figure>
<p>这个例子中，过滤失败的消息。将它们分发到订阅observable的代码之前记录该消息。此记录有一个副作用（比如：将消息放置在计算机的事件日志中）并明确地通过调用<code>do</code>/<code>tap</code>操作符。</p>
<h3 id="假设消息可以传达，直到退订完成"><a href="#假设消息可以传达，直到退订完成" class="headerlink" title="假设消息可以传达，直到退订完成"></a>假设消息可以传达，直到退订完成</h3><p>由于RxJS 使用推模式，消息可以通过不同的上下文环境发送。 当退订的时候，消息可能还在路上。当退订还没有完成的时候，这些消息仍然可以被传达。当控制权被返回时，消息将不能再传达。退订过程可以是在一个不同的上下文环境中进行。</p>
<h4 id="何时忽略这条指南-5"><a href="#何时忽略这条指南-5" class="headerlink" title="何时忽略这条指南"></a>何时忽略这条指南</h4><p>一旦 <code>onCompleted</code> 或 <code>onError</code> 方法被调用，RxJS语法可以保证订阅已结束。</p>
<h3 id="使用-publish-操作符分享副作用"><a href="#使用-publish-操作符分享副作用" class="headerlink" title="使用 publish 操作符分享副作用"></a>使用 <code>publish</code> 操作符分享副作用</h3><p>因为许多 observable是冷门的<a href="http://channel9.msdn.com/Blogs/J.Van.Gogh/Rx-API-in-depth-Hot-and-Cold-observables" target="_blank" rel="external">(see cold vs. hot on Channel 9)</a>, 每个订阅都有单独的副作用。 某些情况下，这些副作用只发生一次。<code>publish</code> 操作符通过向多个用户广播单个订阅来提供共享订阅的机制。</p>
<p>有几个过载<code>publish</code>运算符。最方便的过载是那些提供了一个函数封装 observable 共享的副作用的参数。</p>
<h4 id="例-2"><a href="#例-2" class="headerlink" title="例"></a>例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xs = Rx.Observable.create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Side effect'</span>);</div><div class="line">  observer.onNext(<span class="string">'hi!'</span>);</div><div class="line">  observer.onCompleted();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">xs.publish(<span class="function"><span class="params">sharedXs</span> =&gt;</span> &#123;</div><div class="line">  sharedXs.subscribe(<span class="built_in">console</span>.log);</div><div class="line">  sharedXs.subscribe(<span class="built_in">console</span>.log);</div><div class="line">  <span class="keyword">return</span> sharedXs;</div><div class="line">&#125;).subscribe();</div></pre></td></tr></table></figure>
<p>这个例子中，<code>xs</code> 是一个有副作用的（写入console） observable。正常情况下，每个单独的订阅都会触发这些副作用。 <code>publish</code> 操作符使用<code>xs</code>单独给所有订阅者 <code>sharedXs</code> 变量去订阅。</p>
<h4 id="何时忽略这条指南-6"><a href="#何时忽略这条指南-6" class="headerlink" title="何时忽略这条指南"></a>何时忽略这条指南</h4><p>只有当 <code>publish</code> 操作符需要共享副作用时才使用这条指南。在大多数情况下，您可以创建单独的订阅，没有任何问题：不管是订阅没有副作用的或是副作用可以执行多次没有任何问题的。</p>
<p><a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/designguidelines#4-using-rx" target="_blank" rel="external">参考</a><br><a href="https://robin-front.gitbooks.io/rxjs-doc-chinese/content/content/guidelines/using.html" target="_blank" rel="external">同步翻译至RxJS中文文档</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用-Rx-的奇淫技巧&quot;&gt;&lt;a href=&quot;#使用-Rx-的奇淫技巧&quot; class=&quot;headerlink&quot; title=&quot;使用 Rx 的奇淫技巧&quot;&gt;&lt;/a&gt;使用 Rx 的奇淫技巧&lt;/h1&gt;&lt;h3 id=&quot;尝试画珠宝图&quot;&gt;&lt;a href=&quot;#尝试画珠宝图&quot; class=&quot;headerlink&quot; title=&quot;尝试画珠宝图&quot;&gt;&lt;/a&gt;尝试画珠宝图&lt;/h3&gt;&lt;p&gt;为你想创建的流画一个珠宝图。 通过画珠宝图，你将会很清楚你应该使用哪些操作符。&lt;/p&gt;
&lt;p&gt;珠宝图就是每个珠宝表示当前的一个事件或状态。珠宝图需要包含输入和输出流。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Reactive-Extensions/RxJS/master/doc/designguidelines/images/throttleWithTimeout.png&quot; alt=&quot;throttleWithSelector&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="RxJS" scheme="http://robin-front.github.io/categories/RxJS/"/>
    
    
      <category term="RxJS" scheme="http://robin-front.github.io/tags/RxJS/"/>
    
  </entry>
  
  <entry>
    <title>为什么选择 RxJS?</title>
    <link href="http://robin-front.github.io/2017/04/04/why-rxjs/"/>
    <id>http://robin-front.github.io/2017/04/04/why-rxjs/</id>
    <published>2017-04-04T09:48:15.000Z</published>
    <updated>2017-04-04T09:48:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Why-RxJS"><a href="#Why-RxJS" class="headerlink" title="Why RxJS?"></a>Why RxJS?</h2><p>你可能会问，为什么选择 RxJS?  为什么不是 Promises? Promises 可以很好地解决异步操作，像使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" target="_blank" rel="external">XMLHttpRequest</a> 去查询服务器, 它预期会返回值并且最终完成请求。  <code>The Reactive Extensions</code> 统一了 <code>JavaScript</code> 中的 <code>Promises</code>, <code>callbacks</code> 以及事件数据，比如 DOM输入, <code>Web Workers</code>, <code>Web Sockets</code>. 一旦我们统一了这些概念，就可以进行各种各样的组合.</p>
<a id="more"></a>
<p>为了让您了解丰富的组合，我们可以创建一个自动完成功能，它从文本输入中接收用户输入，然后查询服务，确保不会对每个键盘输入的进行泛滥地调用，而是以一种更自然的方式调用。</p>
<p>首先，我们将引用JavaScript文件，包括jQuery，尽管RxJS没有依赖于jQuery …<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://code.jquery.com/jquery.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"rx.lite.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>接下来，我们将从输入框获取用户输入，使用<a href="content/observable/observable_methods/fromevent.html"><code>Rx.Observable.fromEvent</code></a> 方法监听 <code>keyup</code> 事件.  如果 <a href="http://jquery.com" target="_blank" rel="external">jQuery</a>, <a href="http://zeptojs.com/" target="_blank" rel="external">Zepto</a>, <a href="https://angularjs.org/" target="_blank" rel="external">AngularJS</a> and <a href="http://emberjs.com/" target="_blank" rel="external">Ember.js</a> 可用，将会使用它们来绑定事件, 否则将使用原生事件绑定. 这跟您的框架思考事件的一致方式，因此没有任何惊喜。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $input = $(<span class="string">'#input'</span>),</div><div class="line">    $results = $(<span class="string">'#results'</span>);</div><div class="line"></div><div class="line"><span class="comment">/* 只从 keyup 事件获得输入值 */</span></div><div class="line"><span class="keyword">var</span> keyups = Rx.Observable.fromEvent($input, <span class="string">'keyup'</span>)</div><div class="line">    .map(<span class="function"><span class="params">e</span> =&gt;</span> e.target.value)</div><div class="line">    .filter(<span class="function"><span class="params">text</span> =&gt;</span> text.length &gt; <span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="comment">/* 函数节流输出设置为 500ms */</span></div><div class="line"><span class="keyword">var</span> throttled = keyups.throttle(<span class="number">500</span> <span class="comment">/* ms */</span>);</div><div class="line"></div><div class="line"><span class="comment">/* 现在判断值是否有改变，只获取不同的值 */</span></div><div class="line"><span class="keyword">var</span> distinct = throttled.distinctUntilChanged();</div></pre></td></tr></table></figure></p>
<p>现在，让我们来查询维基百科！在RxJS中，我们可以立即通过<code>Rx.Observable.fromPromise</code>方法绑定到任何<a href="https://github.com/promises-aplus/promises-spec" target="_blank" rel="external">Promises A+</a>的实现上，或者直接返回它，并将其封装。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">searchWikipedia</span> (<span class="params">term</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> $.ajax(&#123;</div><div class="line">        <span class="attr">url</span>: <span class="string">'http://en.wikipedia.org/w/api.php'</span>,</div><div class="line">        <span class="attr">dataType</span>: <span class="string">'jsonp'</span>,</div><div class="line">        <span class="attr">data</span>: &#123;</div><div class="line">            <span class="attr">action</span>: <span class="string">'opensearch'</span>,</div><div class="line">            <span class="attr">format</span>: <span class="string">'json'</span>,</div><div class="line">            <span class="attr">search</span>: term</div><div class="line">        &#125;</div><div class="line">    &#125;).promise();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一旦创建，现在我们可以将不同的节流输入绑定在一起，然后查询服务。在这种情况下，我们将调用<code>flatMapLatest</code>获取该值，并确保我们不会有任何混乱的调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> suggestions = distinct.flatMapLatest(searchWikipedia);</div></pre></td></tr></table></figure>
<p>最后，我们将在可观察对象上调用<code>subscribe</code>方法开始拉数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">suggestions.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">var</span> res = data[<span class="number">1</span>];</div><div class="line"></div><div class="line">    <span class="comment">/* Do something 像数据绑定 */</span></div><div class="line">    $results.empty();</div><div class="line"></div><div class="line">    $.each(res, (_, value) =&gt; $(<span class="string">'&lt;li&gt;'</span> + value + <span class="string">'&lt;/li&gt;'</span>).appendTo($results));</div><div class="line">&#125;, error =&gt; &#123;</div><div class="line">    <span class="comment">/* handle any errors */</span></div><div class="line">    $results.empty();</div><div class="line"></div><div class="line">    $(<span class="string">'&lt;li&gt;Error: '</span> + error + <span class="string">'&lt;/li&gt;'</span>).appendTo($results);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><a href="https://github.com/Reactive-Extensions/RxJS#why-rxjs" target="_blank" rel="external">翻译参考</a><br><a href="https://robin-front.gitbooks.io/rxjs-doc-chinese/content/why_rxjs.html" target="_blank" rel="external">同步发布RxJS中文文档</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Why-RxJS&quot;&gt;&lt;a href=&quot;#Why-RxJS&quot; class=&quot;headerlink&quot; title=&quot;Why RxJS?&quot;&gt;&lt;/a&gt;Why RxJS?&lt;/h2&gt;&lt;p&gt;你可能会问，为什么选择 RxJS?  为什么不是 Promises? Promises 可以很好地解决异步操作，像使用 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;XMLHttpRequest&lt;/a&gt; 去查询服务器, 它预期会返回值并且最终完成请求。  &lt;code&gt;The Reactive Extensions&lt;/code&gt; 统一了 &lt;code&gt;JavaScript&lt;/code&gt; 中的 &lt;code&gt;Promises&lt;/code&gt;, &lt;code&gt;callbacks&lt;/code&gt; 以及事件数据，比如 DOM输入, &lt;code&gt;Web Workers&lt;/code&gt;, &lt;code&gt;Web Sockets&lt;/code&gt;. 一旦我们统一了这些概念，就可以进行各种各样的组合.&lt;/p&gt;
    
    </summary>
    
      <category term="RxJS" scheme="http://robin-front.github.io/categories/RxJS/"/>
    
    
      <category term="RxJS" scheme="http://robin-front.github.io/tags/RxJS/"/>
    
  </entry>
  
  <entry>
    <title>Lerp的应用-利用简单线性插值来平滑动画效果</title>
    <link href="http://robin-front.github.io/2017/03/20/Lerp%E7%9A%84%E5%BA%94%E7%94%A8-%E5%88%A9%E7%94%A8%E7%AE%80%E5%8D%95%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC%E6%9D%A5%E5%B9%B3%E6%BB%91%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C/"/>
    <id>http://robin-front.github.io/2017/03/20/Lerp的应用-利用简单线性插值来平滑动画效果/</id>
    <published>2017-03-20T03:04:39.000Z</published>
    <updated>2017-03-20T03:04:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇的 <a href="http://robin-front.github.io/2017/03/19/RxJS%E7%9A%84%E5%8A%A8%E7%94%BB%E7%AE%80%E4%BB%8B/">RxJS的动画简介</a> 里提到一个动画平滑的小技巧, 这里展示几个例子，它真的很简单却很有用。</p>
<p><code>Lerp</code>是两点之间的线性插值的别称。这是一个实现起来相当简单的效果，但可以真正改善你的动画的外观，如果你将一个对象从点A移动到点B.<br><a id="more"></a></p>
<h1 id="它是如何工作的？"><a href="#它是如何工作的？" class="headerlink" title="它是如何工作的？"></a>它是如何工作的？</h1><p>如果您有一个对象的当前位置和目标的位置，您可以线性内插这些点之间的距离的百分比，并在每个动画帧上更新该位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">lerp</span>(<span class="params">position, targetPosition</span>) </span>&#123;</div><div class="line"><span class="comment">// 计算当前位置与目标位置差值的 20%</span></div><div class="line">  position.x += (targetPosition.x - position.x)*<span class="number">0.2</span>;</div><div class="line">  position.y += (targetPosition.y - position.y)*<span class="number">0.2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过这样做，对象移动的量随着位置和目标之间的距离减小而变小。这意味着对象将越来越接近它的目标，速度将减慢，这创造一个很好的缓和效果。</p>
<h1 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h1><p>这里有一个球跟随用户的鼠标或触摸运动的例子。如果我们使球移动到鼠标移动的地方，球的移动可以非常快但看起来有点脱节。如果我们快速移动鼠标，我们也可以看到单独的“球影”。</p>
<iframe width="100%" height="300" src="//codepen.io/anon/embed/avXmyV?slug-hash=avXmyV&default-tab=result&height=300&theme-id=1970&user=anon"></iframe>

<p>这里是同样的演示，除了这次我们使用lerp。不是将球立即向右移动到鼠标位置，我们每次将它移动10％的距离。</p>
<iframe width="100%" height="300" src="//codepen.io/anon/embed/yYZapV?slug-hash=yYZapV&default-tab=result&height=300&theme-id=1970&user=anon"></iframe>

<p>注意球的运动很平滑，整体更令人愉快的效果。</p>
<p>这里是使用lerp的另一个例子。这次我们有一个滚动指示器，当您向下滚动“页面”时更新。</p>
<iframe width="100%" height="300" src="//codepen.io/anon/embed/rOPMvz?slug-hash=rOPMvz&default-tab=result&height=300&theme-id=1970&user=anon"></iframe>

<iframe width="100%" height="300" src="//codepen.io/anon/embed/epxdxe?slug-hash=epxdxe&default-tab=result&height=300&theme-id=1970&user=anon"></iframe>

<p>所以，lerp“把戏”是一个伟大的工具，我们的网络动画套路，以对抗线性或锯齿状的运动。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇的 &lt;a href=&quot;http://robin-front.github.io/2017/03/19/RxJS%E7%9A%84%E5%8A%A8%E7%94%BB%E7%AE%80%E4%BB%8B/&quot;&gt;RxJS的动画简介&lt;/a&gt; 里提到一个动画平滑的小技巧, 这里展示几个例子，它真的很简单却很有用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Lerp&lt;/code&gt;是两点之间的线性插值的别称。这是一个实现起来相当简单的效果，但可以真正改善你的动画的外观，如果你将一个对象从点A移动到点B.&lt;br&gt;
    
    </summary>
    
      <category term="animate" scheme="http://robin-front.github.io/categories/animate/"/>
    
    
      <category term="animate" scheme="http://robin-front.github.io/tags/animate/"/>
    
  </entry>
  
  <entry>
    <title>RxJS的动画简介</title>
    <link href="http://robin-front.github.io/2017/03/19/RxJS%E7%9A%84%E5%8A%A8%E7%94%BB%E7%AE%80%E4%BB%8B/"/>
    <id>http://robin-front.github.io/2017/03/19/RxJS的动画简介/</id>
    <published>2017-03-19T06:40:21.000Z</published>
    <updated>2017-03-19T06:40:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文译自 <a href="https://css-tricks.com/animated-intro-rxjs/" target="_blank" rel="external">An Animated Intro to RxJS</a></p>
<p>你可能听说过RxJS，ReactiveX，或反应式编程，或者甚至只听过函数式编程。这些术语在谈论最新和最前沿的前端技术时变得越来越突出。如果你像我一样，当你第一次尝试学习它时，你感到很困惑。<br><a id="more"></a></p>
<p>根据<a href="http://reactivex.io/" target="_blank" rel="external">ReactiveX.io</a>：</p>
<blockquote>
<p>ReactiveX是一个库，用于通过使用可观察序列来组成异步和基于事件的程序。</p>
</blockquote>
<p>这句话包含了很多要消化的内容。在本文中，我们将采用一种不同的方法来学习RxJS（ReactiveX的JavaScript实现）和<code>Observables</code>，通过创建反应式动画。</p>
<h1 id="理解Observable"><a href="#理解Observable" class="headerlink" title="理解Observable"></a>理解Observable</h1><p>数组是元素的集合，例如[1, 2, 3, 4, 5]。你可以立即得到所有的元素，你可以做的事情像<code>map</code>，<code>filter</code>和映射他们。这允许你以任何你想要的方式转换元素的集合。</p>
<p>现在假设阵列中的每个元素随时间发生; 也就是说，你不是立即得到所有的元素，而是一次一个。你可能得到第一个元素在第1秒，下一个在第3秒，依此类推。以下是如何表示：</p>
<p><img src="https://cdn.css-tricks.com/wp-content/uploads/2017/02/rx-article-1.svg" alt="a steam of values"></p>
<p>这可以被描述为值的流，或事件序列，或更确切地，称为<code>observable</code>。</p>
<blockquote>
<p><code>observable</code>是随时间的值的集合。</p>
</blockquote>
<p>就像使用数组一样，您可以对这些值进行映射，过滤等操作，以创建和组合新的<code>observable</code>。最后，你可以订阅这些<code>observable</code>，并在<code>steam</code>的值之后执行你想要做的事。这是RxJS的源。</p>
<h1 id="RxJS起步"><a href="#RxJS起步" class="headerlink" title="RxJS起步"></a>RxJS起步</h1><p>开始使用RxJS的最简单的方法是使用CDN，虽然有<a href="http://reactivex.io/rxjs/manual/installation.html" target="_blank" rel="external">很多方法可以安装</a>，这取决于项目的需要。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- the latest, minified version of RxJS --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/@reactivex/rxjs@latest/dist/global/Rx.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>一旦你的项目中有RxJS，你可以从任何东西中创建一个observable ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> aboutAnything = <span class="number">42</span>;</div><div class="line"></div><div class="line"><span class="comment">// 从变量创建</span></div><div class="line"><span class="comment">// The observable emits that value, then completes.</span></div><div class="line"><span class="keyword">const</span> meaningOfLife$ = Rx.Observable.just(aboutAnything);</div><div class="line"></div><div class="line"><span class="comment">// 从数组或可遍历的结构中创建</span></div><div class="line"><span class="comment">// The observable emits each item from the array, then completes.</span></div><div class="line"><span class="keyword">const</span> myNumber$ = Rx.Observable.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</div><div class="line"></div><div class="line"><span class="comment">// From a promise.</span></div><div class="line"><span class="comment">// The observable emits the result eventually, then completes (or errors).</span></div><div class="line"><span class="keyword">const</span> myData$ = Rx.Observable.fromPromise(fetch(<span class="string">'http://example.com/users'</span>));</div><div class="line"></div><div class="line"><span class="comment">// 从事件中创建</span></div><div class="line"><span class="comment">// The observable continuously emits events from the event listener.</span></div><div class="line"><span class="keyword">const</span> mouseMove$ = Rx.Observable</div><div class="line">  .fromEvent(<span class="built_in">document</span>.documentElement, <span class="string">'mousemove'</span>);</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：变量末尾的美元符号<code>$</code>是一个约定，表示该变量是一个可观察者。<code>Observable</code>可以用来对任何可以表示为随时间变化的值的流进行建模，例如事件，Promises，计时器，间隔和动画。</p>
</blockquote>
<p>因为，这些可观察的东西不做任何事情，至少直到你实际观察他们。一个简单的订阅将做到这一点，使用创建<code>.subscribe()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">myNumber$.subscribe(<span class="function"><span class="params">number</span> =&gt;</span> <span class="built_in">console</span>.log(number));</div><div class="line"></div><div class="line"><span class="comment">// Result:</span></div><div class="line"><span class="comment">// &gt; 1</span></div><div class="line"><span class="comment">// &gt; 2</span></div><div class="line"><span class="comment">// &gt; 3</span></div><div class="line"><span class="comment">// &gt; 4</span></div><div class="line"><span class="comment">// &gt; 5</span></div></pre></td></tr></table></figure>
<p>让我们实践看看：</p>
<iframe height="400" width="100%" src="//codepen.io/davidkpiano/embed/d6f5fa72a9b7b6c2c9141de6fa1ab93f?height=400&theme-id=1&slug-hash=d6f5fa72a9b7b6c2c9141de6fa1ab93f&default-tab=js%2Cresult&user=davidkpiano&embed-version=2&pen-title="></iframe>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> docElm = <span class="built_in">document</span>.documentElement;</div><div class="line"><span class="keyword">const</span> cardElm = <span class="built_in">document</span>.querySelector(<span class="string">'#card'</span>);</div><div class="line"><span class="keyword">const</span> titleElm = <span class="built_in">document</span>.querySelector(<span class="string">'#title'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> mouseMove$ = Rx.Observable</div><div class="line">  .fromEvent(docElm, <span class="string">'mousemove'</span>);</div><div class="line"></div><div class="line">mouseMove$.subscribe(<span class="function"><span class="params">event</span> =&gt;</span> &#123;</div><div class="line">  titleElm.innerHTML = <span class="string">`<span class="subst">$&#123;event.clientX&#125;</span>, <span class="subst">$&#123;event.clientY&#125;</span>`</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>从<code>mouseMove$</code>观察到的，每次<code>mousemove</code>事件发生时，订阅改变<code>titleElm</code>的<code>.innerHTML</code>的鼠标的位置。该<a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-map" target="_blank" rel="external"><code>.map</code></a>操作（据工作原理类似<code>Array.prototype.map</code>方法）可帮助简化事情：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Produces e.g., &#123;x: 42, y: 100&#125; instead of the entire event</span></div><div class="line"><span class="keyword">const</span> mouseMove$ = Rx.Observable</div><div class="line">  .fromEvent(docElm, <span class="string">'mousemove'</span>)</div><div class="line">  .map(<span class="function"><span class="params">event</span> =&gt;</span> (&#123; <span class="attr">x</span>: event.clientX, <span class="attr">y</span>: event.clientY &#125;));</div></pre></td></tr></table></figure>
<p>使用一些数学和内联样式，您可以使卡片朝向鼠标旋转。<code>pos.y / clientHeight</code>和<code>pos.x / clientWidth</code>计算为0和1之间的值，所以乘以由50减去一半（25）产生的值从-25到25，这正是我们需要为我们的旋转值：</p>
<iframe width="100%" height="500" src="//codepen.io/davidkpiano/embed/55cb38a26b9166c41017c6512ea00209?height=500&theme-id=1&slug-hash=55cb38a26b9166c41017c6512ea00209&default-tab=js%2Cresult&user=davidkpiano&embed-version=2&pen-title="></iframe>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> docElm = <span class="built_in">document</span>.documentElement;</div><div class="line"><span class="keyword">const</span> cardElm = <span class="built_in">document</span>.querySelector(<span class="string">'#card'</span>);</div><div class="line"><span class="keyword">const</span> titleElm = <span class="built_in">document</span>.querySelector(<span class="string">'#title'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> &#123; clientWidth, clientHeight &#125; = docElm;</div><div class="line"></div><div class="line"><span class="keyword">const</span> mouseMove$ = Rx.Observable</div><div class="line">  .fromEvent(docElm, <span class="string">'mousemove'</span>)</div><div class="line">  .map(<span class="function"><span class="params">event</span> =&gt;</span> (&#123; <span class="attr">x</span>: event.clientX, <span class="attr">y</span>: event.clientY &#125;))</div><div class="line"></div><div class="line">mouseMove$.subscribe(<span class="function"><span class="params">pos</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> rotX = (pos.y / clientHeight * <span class="number">-50</span>) - <span class="number">25</span>;</div><div class="line">  <span class="keyword">const</span> rotY = (pos.x / clientWidth * <span class="number">50</span>) - <span class="number">25</span>;</div><div class="line"></div><div class="line">  cardElm.style = <span class="string">`</span></div><div class="line">    transform: rotateX(<span class="subst">$&#123;rotX&#125;</span>deg) rotateY(<span class="subst">$&#123;rotY&#125;</span>deg);</div><div class="line">  `;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h1 id="使用-merge-合并"><a href="#使用-merge-合并" class="headerlink" title="使用 .merge 合并"></a>使用 <code>.merge</code> 合并</h1><p>现在让我们假设你想让这个适应触摸设备，不管是鼠标事件或是触摸动作。没有任何混乱的回调，你可以通过RxJS使用很多方法来结合<code>Observable</code>。在这个例子中，可以使用<code>.merge</code>实现。就像交通多条车道合并成一个单一的车道，这将返回一个包含所有数据的<code>Observable</code>通过合并多个<code>Observable</code>.</p>
<p><img src="https://cdn.css-tricks.com/wp-content/uploads/2017/02/merge.png" alt="来源：http://rxmarbles.com/#merge"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> touchMove$ = Rx.Observable</div><div class="line">  .fromEvent(docElm, <span class="string">'touchmove'</span>)</div><div class="line">  .map(<span class="function"><span class="params">event</span> =&gt;</span> (&#123;</div><div class="line">    <span class="attr">x</span>: event.touches[<span class="number">0</span>].clientX,</div><div class="line">    <span class="attr">y</span>: event.touches[<span class="number">0</span>].clientY</div><div class="line">  &#125;));</div><div class="line"></div><div class="line"><span class="keyword">const</span> move$ = Rx.Observable.merge(mouseMove$, touchMove$);</div><div class="line"></div><div class="line">move$.subscribe(<span class="function"><span class="params">pos</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>继续，尝试在触摸屏设备上平移左右：</p>
<iframe width="100%" height="500" src="//codepen.io/davidkpiano/embed/4a430c13f4faae099e5a34cb2a82ce6d?height=500&theme-id=1&slug-hash=4a430c13f4faae099e5a34cb2a82ce6d&default-tab=js%2Cresult&user=davidkpiano&embed-version=2&pen-title="></iframe>

<p>还有很多其他有用的<code>Observable</code><a href="http://reactivex.io/documentation/operators.html#combining" target="_blank" rel="external">合并方法</a>，如<code>.switch()</code>，<code>.combineLatest()</code>和<code>.withLatestFrom()</code>，我们继续关注下一个点。</p>
<h1 id="添加平滑的运动"><a href="#添加平滑的运动" class="headerlink" title="添加平滑的运动"></a>添加平滑的运动</h1><p>旋转卡动作有点太死板。只要鼠标（或手指）停止，旋转即刻停止。为了解决这个问题，线性内插（线性插值）都可以使用。一般技术中描述这个<a href="https://codepen.io/rachsmith/post/animation-tip-lerp" target="_blank" rel="external">伟大的教程由雷切尔·史密斯</a>。本质上，而不是从A点跳到B，线性插值会在每一个动画运行一小部分。这将产生一个平滑的过渡，甚至当鼠标/触摸移动已停止。</p>
<p>让我们创建一个函数实现这个功能：计算给定初始值和终值下一个值，采用线性插值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">lerp</span>(<span class="params">start, end</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> dx = end.x - start.x;</div><div class="line">  <span class="keyword">const</span> dy = end.y - start.y;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">x</span>: start.x + dx * <span class="number">0.1</span>,</div><div class="line">    <span class="attr">y</span>: start.y + dy * <span class="number">0.1</span>,</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>非常简约。我们有一个纯函数每次返回一个新的，线性内插的位置值，通过移动当前的（开始）接近每个动画帧上的下一个（完）位置10％的位置。</p>
<h1 id="调度和-interval"><a href="#调度和-interval" class="headerlink" title="调度和.interval"></a>调度和.interval</h1><p>问题是，我们如何在RxJS中表示动画帧？原来，RxJS有一个叫做<code>Schedulers</code>的东西，它控制什么时候从一个<code>observable</code>发出数据，当订阅都开始接收值。</p>
<p>使用<a href="http://reactivex.io/documentation/operators/interval.html" target="_blank" rel="external"><code>Rx.Observable.interval()</code></a>，您可以创建一个<code>observable</code>，它在固定的时间间隔发出值，例如每隔一秒（Rx.Observable.interval(1000)）。如果创建一个非常微小的时间间隔，例如<code>Rx.Observable.interval(0)</code>，并希望它只在每个动画帧上发出值，那么在动画帧内<code>Rx.Scheduler.animationFrame</code>每隔16到17ms就会发出一个值，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> animationFrame$ = Rx.Observable.interval(<span class="number">0</span>, Rx.Scheduler.animationFrame);</div></pre></td></tr></table></figure>
<h1 id="结合-withLatestFrom"><a href="#结合-withLatestFrom" class="headerlink" title="结合.withLatestFrom"></a>结合<code>.withLatestFrom</code></h1><p>要创建平滑线性插值，您只需要关心每个动画帧的最新鼠标或触摸位置。要做到这一点，有一个操作符叫<code>.withLatestFrom()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> smoothMove$ = animationFrame$</div><div class="line">  .withLatestFrom(move$, (frame, move) =&gt; move);</div></pre></td></tr></table></figure>
<p>现在，<code>smoothMove$</code>是一个新的<code>observable</code>，<code>move$</code> 只有当<code>animationFrame$</code>发出一个值时，才会发出最新的值。这是必须的 - 你并不想要的动画帧外发出的值（除非你真的喜欢jank）。第二个参数是描述当组合来自每个可观察的最新值时要做什么的函数。在这种情况下，唯一重要的值是<code>move</code>值，这是所有返回的值。</p>
<p><img src="https://cdn.css-tricks.com/wp-content/uploads/2017/02/with-latest-from.png" alt="withLatestFrom"></p>
<h1 id="与过渡-scan"><a href="#与过渡-scan" class="headerlink" title="与过渡.scan"></a>与过渡<code>.scan</code></h1><p>现在你有一个<code>observable</code>从<code>move$</code>每个动画帧发出最新的值，是时候添加线性插值了。<a href="http://reactivex.io/documentation/operators/scan.html" target="_blank" rel="external"><code>.scan()</code></a>运算符“积累”从可观察到的当前值和下一个值，提供给需要这些值的函数。</p>
<p><img src="https://cdn.css-tricks.com/wp-content/uploads/2017/02/scan.png" alt="#scan"></p>
<p>这对于我们的线性插值用例是完美的。记住，我们的<code>lerp(start, end)</code>函数有两个参数：<code>start（current）</code>值和<code>end（next）</code>值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> smoothMove$ = animationFrame$</div><div class="line">  .withLatestFrom(move$, (frame, move) =&gt; move)</div><div class="line">  .scan(<span class="function">(<span class="params">current, next</span>) =&gt;</span> lerp(current, next));</div><div class="line">  <span class="comment">// or simplified: .scan(lerp)</span></div></pre></td></tr></table></figure>
<p>现在，您可以订阅<code>smoothMove$</code>代替<code>move$</code>在操作中查看线性插值：</p>
<iframe width="100%" height="500" src="//codepen.io/davidkpiano/embed/127ee82ad742b4dddd657703e2259852?height=500&theme-id=1&slug-hash=127ee82ad742b4dddd657703e2259852&default-tab=js%2Cresult&user=davidkpiano&embed-version=2&pen-title="></iframe>

<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p><code>RxJS</code> 不是一个动画库，当然，但对于处理随时间变化的值，它的可组合以及声明性的方式是<code>ReactiveX</code>演示动画的核心概念。反应式编程是考虑编程的另类方式，具有许多优点：</p>
<ul>
<li>它是声明性的，可组合的和不可变的，避免回调地狱，并使你的代码更简洁，可重用和模块化。</li>
<li>它在处理所有类型的异步数据时非常有用，无论是获取数据，通过<code>WebSockets</code>进行通信，监听来自多个源的外部事件，甚至是动画。</li>
<li>“关注的分离” - 您使用<code>Observable</code>和运算符声明性地表示您期望的数据，然后在一个单独的上下文环境中处理<code>.subscribe()</code>，而不会在您的原代码上产生副作用。</li>
<li>有这么多语言的实现了它 - <code>Java</code>，<code>PHP</code>，<code>Python</code>，<code>Ruby</code>，<code>C＃</code>，<code>Swift</code>和其他你可能没有听说过的。</li>
<li>它不是一个框架，它与许多流行的框架（如React，Angular和Vue）可以非常好地融合在一起。</li>
<li>你可以得到行家指点，如果你想要，但<code>ReactiveX</code>从被提出到现在实施了近十年前（2009年），由创意所产生的<a href="http://conal.net/papers/icfp97/" target="_blank" rel="external"><code>Conal Elliott</code>和保罗·胡达克</a> 2年前（1997年），在描述功能性反应的动画（惊喜惊喜）。不用说，它经过了足够的测试。</li>
</ul>
<p>本文探讨了一些有用的部分和<code>RxJS</code>的概念-创建与订阅<code>.fromEvent()</code>和<code>.interval()</code>，对订阅操作<code>.map()</code>和<code>.scan()</code>，多个订阅相结合<code>.merge()</code>和<code>.withLatestFrom()</code>，并与引入调度<code>Rx.Scheduler.animationFrame</code>。有很多其他有用的资源学习RxJS：</p>
<ul>
<li><a href="http://reactivex.io/rxjs/" target="_blank" rel="external">ReactiveX：RxJS</a> - 官方文档</li>
<li><a href="http://rxmarbles.com/" target="_blank" rel="external">RxMarbles</a> - 用于可视化观察</li>
<li><a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754" target="_blank" rel="external">Reactive编程的介绍</a></li>
</ul>
<p>如果你想进一步深入<code>RxJS动画</code>（和使用更多的CSS变量），请查看<a href="http://slides.com/davidkhourshid/reactanim#/" target="_blank" rel="external">我的幻灯片从<code>CSS Dev Conf 2016</code></a>和<a href="https://www.youtube.com/watch?v=lTCukb6Zn3g" target="_blank" rel="external">我2016年的演讲从JSConf冰岛</a>关于反应式动画与CSS变量。这里有一些使用RxJS创建的动画可能对触发灵感有帮助：</p>
<ul>
<li><a href="http://codepen.io/davidkpiano/pen/Vmyyzd" target="_blank" rel="external">3D数字时钟</a></li>
<li><a href="http://codepen.io/davidkpiano/pen/mAoaxP" target="_blank" rel="external">心脏app概念</a></li>
<li><a href="http://codepen.io/Enki/pen/eBwKgO" target="_blank" rel="external">透视使用RxJS拖动</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文译自 &lt;a href=&quot;https://css-tricks.com/animated-intro-rxjs/&quot;&gt;An Animated Intro to RxJS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;你可能听说过RxJS，ReactiveX，或反应式编程，或者甚至只听过函数式编程。这些术语在谈论最新和最前沿的前端技术时变得越来越突出。如果你像我一样，当你第一次尝试学习它时，你感到很困惑。&lt;br&gt;
    
    </summary>
    
      <category term="RxJS" scheme="http://robin-front.github.io/categories/RxJS/"/>
    
    
      <category term="RxJS" scheme="http://robin-front.github.io/tags/RxJS/"/>
    
  </entry>
  
  <entry>
    <title>通过动图简单通俗地了解Flexbox的工作原理</title>
    <link href="http://robin-front.github.io/2017/03/13/%E9%80%9A%E8%BF%87%E5%8A%A8%E5%9B%BE%E7%AE%80%E5%8D%95%E9%80%9A%E4%BF%97%E5%9C%B0%E4%BA%86%E8%A7%A3Flexbox%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://robin-front.github.io/2017/03/13/通过动图简单通俗地了解Flexbox的工作原理/</id>
    <published>2017-03-13T03:31:42.000Z</published>
    <updated>2017-03-13T03:31:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文译自 <a href="https://medium.freecodecamp.com/even-more-about-how-flexbox-works-explained-in-big-colorful-animated-gifs-a5a74812b053#.iwqlenuqq" target="_blank" rel="external">Scott Domes</a></p>
<p>Flex属性是一个复合属性，而大部分教程中都只设置一个值，但其实它包含了 <code>flex-basis</code>、<code>flex-grow</code>、<code>flex-shrink</code>.<br>让我们深入了解Flexbox - 以及如何利用它来构建适应性强和漂亮的布局.<br><a id="more"></a></p>
<h3 id="属性一：-Flex-Basis"><a href="#属性一：-Flex-Basis" class="headerlink" title="属性一： Flex-Basis"></a>属性一： Flex-Basis</h3><p>在<a href="https://medium.freecodecamp.com/an-animated-guide-to-flexbox-d280cf6afc35#.s7qtdlnbf" target="_blank" rel="external">上一篇文章</a>中，我们主要把它用于外部容器中。这一次，我们试着把它用在容器内的子元素中。</p>
<p>这是一个很不起眼的属性，但也很直接。</p>
<p><code>Flex-basis</code> 控制着一个元素的默认大小，在其他 flex 属性应用之前。</p>
<p>在下面的 GIF 看来，它的作用和 <code>width</code> 的作用一样：</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*S3LKFr_BICUtAWA5LOFxVw.gif" alt="flex-basis"></p>
<p>是什么让 <code>flex-basis</code> 表现得和 <code>width</code> 一样？事实上，它对应着 flex 的坐标轴。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*_Ruy6jFG7gUpSf76IUcJTQ.png" alt="flex axes"></p>
<blockquote>
<p>flex-basis 影响无素在主轴上的大小</p>
</blockquote>
<p>让我们看看保持 <code>flex-basis</code> 的值不变，但是改变主轴方向会有什么变化：</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*W4QU1Fw9kDLEH2m-J9VGyw.gif" alt="flex direction"></p>
<p>注意到，我从手动设置高度变成手动设置宽度。 <code>Flex-basis</code> 影响宽度还是高度取决于 <code>flex-direction</code> 的值。</p>
<h3 id="属性二：Flex-Grow"><a href="#属性二：Flex-Grow" class="headerlink" title="属性二：Flex Grow"></a>属性二：Flex Grow</h3><p>现在，我们来点更复杂的。</p>
<p>首先，让我们设置给所有方块设置相同的宽度，120px:</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*dON3-0RooiPyfDr0DBEOmA.png" alt="same width"></p>
<p>现在，当它加上属性 <code>flex-grow</code>（默认值为0）.这意味着，不允许方块自动充满容器。</p>
<p>没理解？现在给每个方块的 <code>flex-grow</code> 属性设置为 <code>1</code>：</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*cK-yB4z_L6bmEqoG5qDoRA.png" alt="flex-grow"></p>
<p>所有方块共同充满了容器的整个宽度，并且是平均分。 <code>flex-grow</code> 属性覆盖了 <code>width</code> 属性。</p>
<p>让人困惑的是 <code>flex-grow</code> 的值到底是什么意思？ <code>flex-grow: 1</code> 意味着什么？</p>
<p>好吧，下图是给每个方块设置 <code>flex-grow</code> 值为 <code>999</code> 的表现：</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*p2fLcy13xFU9GjtM4cbHEw.png" alt="flex-grow:999"></p>
<p>这真是。。完全一样。</p>
<p>那是因为 <code>flex-grow</code> 不是一个绝对的值，而是一个相对的值。</p>
<p>重要的不是一个方块 <code>flex-grow</code> 值的本身，而是这个值和其他方块的值的关系。</p>
<p>如果给每个方块设置 <code>flex-grow: 1</code>， 然后调整第3个方块的 <code>flex-grow</code> 属性，可以看到如下变化：</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*gHyLHG52cySgLmy0x-edZA.gif" alt="flex-grow change"></p>
<p>想要真正明白这里发生了什么，让我们快速略过一个简单的数学计算。</p>
<p>每个正方形都以flex-grow为1开始。如果我们将每个正方形的flex-grow相加，则总和为6。因此，容器被分成6个单独的部分。<em>每个正方形增长到可用空间的1/6以填满容器。</em></p>
<p>当设置第3个方块的<code>flex-grow</code> 为 2， 现在容器被分成7份，因为 <code>flex-grow</code> 属性的值的总和为 <code>1+1+2+1+1+1</code>.</p>
<p>方块3获得 2/7 的宽度，剩下的获得 1/7。</p>
<p>当设置第3个方块为 <code>flex-grow: 3</code>， 容器被分成8份（1+1+3+1+1+1）, 方块3占 3/8, 剩下的占 1/8.</p>
<p>以此类推。</p>
<p><code>flex-grow</code>是占所有值总和的比例。如果给所有方块设置<code>flex-grow: 4</code>, 方块3设置 <code>flex-grow: 12</code>, 效果和给它们分别设置 1 和 3 是一样的。</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*JnjR4ULs8de0so1bdUPogw.png" alt="flex-grow"></p>
<p>最后一点，<code>flex-grow</code> 和 <code>flex-basis</code> 都和主轴对应。我们的方块只会增长宽度，除非设置 <code>flex-direction</code> 为 <code>column</code>.</p>
<h3 id="属性三：-Flex-Shrink"><a href="#属性三：-Flex-Shrink" class="headerlink" title="属性三： Flex Shrink"></a>属性三： Flex Shrink</h3><p><code>flex-shrink</code> 和 <code>flex-grow</code>正好相反，决定每个方块可以收缩多少。</p>
<p>它只有在元素必须收缩以适应其容器时才起作用 - 即当容器太小时。</p>
<p>它的主要用途是指定哪些元素要缩小，哪些元素不用缩小。默认情况下，每个方块的 <code>flex-shrink</code> 值为1 - 这意味着它会随着容器的收缩而收缩。</p>
<p>让我们看看它的表现。在下面的GIFS中，正方形的<code>flex-grow</code>为1，因此它们填充了容器，并且<code>flex-shrink</code>为1，因此它们被允许收缩.</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*FVO9kX3wwqakhcT9JWS2Ww.gif" alt="flex-shrink"></p>
<p>现在让我们将方块3的<code>flex-shrink</code>设置为0.它禁止收缩，所以它会增长以适应容器，但它拒绝收缩到其设置的120px宽度以下。</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*GrLzJ4jH3v2Z5Va_TMOXkQ.gif" alt="flex-shrink"></p>
<p><code>flex-shrink</code>的默认值是1 - 这意味着你的元素会收缩，除非设置为0去禁止它。</p>
<p>同样，<code>flex-shrink</code> 是按比例的。如果一个盒子的<code>flex-shrink</code>为6，其余的<code>flex-shrink</code>为2，一个盒子将以3倍的速度缩减，当空间被压缩。</p>
<p>注意这里说的是：具有3x弹性收缩的方块将比其他方块缩短3倍。<em>这并不意味着它将收缩1/3的宽度。</em></p>
<p>稍后，我们会深入了解这到底会收缩或增长多少，在此之前，先来看一下最后一个属性，并把所有混在一起。</p>
<h3 id="属性四：-Flex"><a href="#属性四：-Flex" class="headerlink" title="属性四： Flex"></a>属性四： Flex</h3><p>flex 是 grow, shrink 以及 basis 的缩写，复合属性。</p>
<p>它的默认值是 0(grow) 1（shrink）auto(basis).</p>
<p>最后一个例子，让我们简化到两个 boxs</p>
<p>这是它们的属性：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.square</span><span class="selector-id">#one</span> &#123;</div><div class="line">  <span class="attribute">flex</span>: <span class="number">2</span> <span class="number">1</span> <span class="number">300px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.square</span><span class="selector-id">#two</span> &#123;</div><div class="line">  <span class="attribute">flex</span>: <span class="number">1</span> <span class="number">2</span> <span class="number">300px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>两者都有相同的 <code>flex-basis</code>属性。这意味着如果它们都有足够的空间（容器是600px加上边距和填充空间），它们都将是300px宽度。</p>
<p>但随着容器的增长，Square 1（具有更高的flex-grow）将增长两倍。随着盒子的收缩，Square 2（具有更高的flex-shrink）将缩短两倍。</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*BKZt7AT5eFee4KRhe82gew.gif" alt="all together"></p>
<h4 id="它是如何增长和收缩的"><a href="#它是如何增长和收缩的" class="headerlink" title="它是如何增长和收缩的"></a>它是如何增长和收缩的</h4><p>这里有可能会混淆：当Square 1增长时，它不会增长到Square 2的两倍。同样，当Square 2缩小时，它不会缩小到Square 1的一半大小 - 即使比率的收缩率为2比1。</p>
<blockquote>
<p>这不是他们的大小 2比1或1比2.这是他们的收缩和增长的速度的比例。</p>
</blockquote>
<h4 id="一点数学计算"><a href="#一点数学计算" class="headerlink" title="一点数学计算"></a>一点数学计算</h4><p>容器的起始大小为640像素。在容器的每一边占用20px的填充后，这留下了足够的空间，两个方块恢复到它们的<code>flex-basis</code>的300px.</p>
<p>当容器设置为430px时，我们丢失了210px的空间。正方形1，flex-shrink:1，失去70px。方形2，flex-shrink: 2，失去140px。</p>
<p>当容器缩小到340px时，我们现在已经失去了300像素的空间。方块1损失100像素，方块2损失200像素.</p>
<p>损失的空间根据它们各自的收缩率（2:1）的比率来分割。</p>
<p><code>flex-grow</code>同样。当容器增长到940px，我们获得了300px的空间，Square 1获得了额外的200px，Square 2获得了额外的100px。</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*70-KTWYpA2LnLjqi0xDrJA.gif" alt="grow and shrink"></p>
<p>在上面的GIF中，您可以看到宽度如何根据比率进行调整，增量（Δ）显示与基于<code>flex-basis</code>的差异。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文译自 &lt;a href=&quot;https://medium.freecodecamp.com/even-more-about-how-flexbox-works-explained-in-big-colorful-animated-gifs-a5a74812b053#.iwqlenuqq&quot;&gt;Scott Domes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Flex属性是一个复合属性，而大部分教程中都只设置一个值，但其实它包含了 &lt;code&gt;flex-basis&lt;/code&gt;、&lt;code&gt;flex-grow&lt;/code&gt;、&lt;code&gt;flex-shrink&lt;/code&gt;.&lt;br&gt;让我们深入了解Flexbox - 以及如何利用它来构建适应性强和漂亮的布局.&lt;br&gt;
    
    </summary>
    
      <category term="Flexbox" scheme="http://robin-front.github.io/categories/Flexbox/"/>
    
    
      <category term="Flexbox" scheme="http://robin-front.github.io/tags/Flexbox/"/>
    
  </entry>
  
  <entry>
    <title>js遍历Object对象可枚举属性、不可枚举属性、原型链属性和自身属性</title>
    <link href="http://robin-front.github.io/2017/01/13/js%E9%81%8D%E5%8E%86Object%E5%8F%AF%E6%9E%9A%E4%B8%BE%E5%B1%9E%E6%80%A7%E3%80%81%E4%B8%8D%E5%8F%AF%E6%9E%9A%E4%B8%BE%E5%B1%9E%E6%80%A7%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%B1%9E%E6%80%A7%E5%92%8C%E8%87%AA%E8%BA%AB%E5%B1%9E%E6%80%A7/"/>
    <id>http://robin-front.github.io/2017/01/13/js遍历Object可枚举属性、不可枚举属性、原型链属性和自身属性/</id>
    <published>2017-01-13T02:19:27.000Z</published>
    <updated>2017-01-13T02:19:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>利用hasOwnProperty、getOwnPropertyNames、Object.keys、for…in遍历对象的可枚举属性、不可枚举属性、原型链上的属性和自身属性。<br><a id="more"></a></p>
<p>首先来看看各种方法的用法及兼容性。</p>
<h3 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty"></a>hasOwnProperty</h3><p>Object.prototype.hasOwnProperty(name) 方法用来判断某个对象是否含有指定的自身属性，它本身是对象原型链上的默认方法。</p>
<p>hasOwnProperty 方法是 ES3 就标准化了，所以不用担心兼容性问题。</p>
<p>但由于 hasOwnProperty 是原型链上的方法，所以有可能被对象的自身方法所屏蔽。如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;</div><div class="line">    <span class="attr">hasOwnProperty</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">bar</span>: <span class="string">'Here be dragons'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">foo.hasOwnProperty(<span class="string">'bar'</span>); <span class="comment">// 始终返回 false</span></div><div class="line"></div><div class="line"><span class="comment">// 如果担心这种情况，可以直接使用原型链上真正的 hasOwnProperty 方法</span></div><div class="line">(&#123;&#125;).hasOwnProperty.call(foo, <span class="string">'bar'</span>); <span class="comment">// true</span></div><div class="line"><span class="built_in">Object</span>.prototype.hasOwnProperty.call(foo, <span class="string">'bar'</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="getOwnPropertyNames"><a href="#getOwnPropertyNames" class="headerlink" title="getOwnPropertyNames"></a>getOwnPropertyNames</h3><p>Object.getOwnPropertyNames(obj)方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组, 该方法不会获取到原型链上的属性。如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 父类构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ParentClass</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">ParentClass.prototype.inheritedMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 继承</span></div><div class="line"><span class="keyword">var</span> ChildClass = <span class="built_in">Object</span>.create(ParentClass.prototype, &#123;</div><div class="line">  <span class="comment">// 不可枚举属性</span></div><div class="line">  getFoo: &#123;</div><div class="line">    <span class="attr">value</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.foo; &#125;,</div><div class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 自身可枚举属性</span></div><div class="line">ChildClass.foo = <span class="number">1</span>;</div><div class="line"><span class="comment">// 再定义一个原型链属性</span></div><div class="line">ChildClass.prototype.prototypeMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(my_obj).sort()); <span class="comment">// ["foo", "getFoo"]</span></div></pre></td></tr></table></figure>
<p>兼容性到 IE9, es 5标准。</p>
<h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><p>返回该对象的所有可枚举自身属性的属性名。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">//</span>具有随机键排序的数组类对象</div><div class="line">var an_obj = &#123; <span class="number">100</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">7</span>: <span class="string">'c'</span> &#125;;</div><div class="line">console.log(Object.keys(an_obj)); <span class="regexp">//</span> console: [<span class="string">'2'</span>, <span class="string">'7'</span>, <span class="string">'100'</span>]</div></pre></td></tr></table></figure>
<p>这些属性的顺序与手动遍历（如for..in）该对象属性时的一致。</p>
<blockquote>
<p>注意：Object.keys 和 getOwnPropertyNames ，在ES5，如果此方法的参数不是一个对象（原始的），那么它会造成 TypeError。在ES6，非对象的参数将被强制转换为一个对象。</p>
</blockquote>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Object.keys(<span class="string">"foo"</span>);</div><div class="line">Object.getOwnPropertyNames(<span class="string">"foo"</span>);</div><div class="line"><span class="regexp">//</span> <span class="symbol">TypeError:</span> <span class="string">"foo"</span> is <span class="keyword">not</span> an object (ES5 code)</div><div class="line"></div><div class="line">Object.keys(<span class="string">"foo"</span>);</div><div class="line"><span class="regexp">//</span> [<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>]                   (ES6 code)</div><div class="line">Object.getOwnPropertyNames(<span class="string">"foo"</span>);</div><div class="line"><span class="regexp">//</span> [<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"length"</span>]                   (ES6 code)</div></pre></td></tr></table></figure>
<p>兼容性到 IE9, es 5标准。</p>
<h3 id="for-in"><a href="#for-in" class="headerlink" title="for..in"></a>for..in</h3><p>手动遍历，可以遍历到自身和原型链上所有可枚举的属性。</p>
<h3 id="只获取自身可枚举属性"><a href="#只获取自身可枚举属性" class="headerlink" title="只获取自身可枚举属性"></a>只获取自身可枚举属性</h3><ul>
<li>直接用 <code>Object.keys()</code></li>
<li>IE9 以下可以通过<code>hasOwnProperty</code>实现：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!<span class="built_in">Object</span>.keys) <span class="built_in">Object</span>.keys = <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (o !== <span class="built_in">Object</span>(o))</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Object.keys called on a non-object'</span>);</div><div class="line">  <span class="keyword">var</span> k=[],p;</div><div class="line">  <span class="keyword">for</span> (p <span class="keyword">in</span> o) <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(o,p)) k.push(p);</div><div class="line">  <span class="keyword">return</span> k;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="只获取自身不可枚举属性"><a href="#只获取自身不可枚举属性" class="headerlink" title="只获取自身不可枚举属性"></a>只获取自身不可枚举属性</h3><ul>
<li>通过 <code>Object.keys()</code> 排除可枚举属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> target = myObject;</div><div class="line"><span class="keyword">var</span> enum_and_nonenum = <span class="built_in">Object</span>.getOwnPropertyNames(target);</div><div class="line"><span class="comment">// 排除可枚举属性</span></div><div class="line"><span class="keyword">var</span> enum_only = <span class="built_in">Object</span>.keys(target);</div><div class="line"><span class="keyword">var</span> nonenum_only = enum_and_nonenum.filter(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> indexInEnum = enum_only.indexOf(key);</div><div class="line">    <span class="keyword">if</span> (indexInEnum == <span class="number">-1</span>) &#123;</div><div class="line">        <span class="comment">// not found in enum_only keys mean the key is non-enumerable,</span></div><div class="line">        <span class="comment">// so return true so we keep this in the filter</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(nonenum_only);</div></pre></td></tr></table></figure>
<ul>
<li>通过<code>propertyIsEnumerable</code>判断，该方法返回Boolean值，不可枚举返回false。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> target = myObject;</div><div class="line"><span class="keyword">var</span> enum_and_nonenum = <span class="built_in">Object</span>.getOwnPropertyNames(target);</div><div class="line"><span class="keyword">var</span> enum_only = <span class="built_in">Object</span>.keys(target);</div><div class="line"><span class="keyword">var</span> nonenum_only = enum_and_nonenum.filter(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">    <span class="comment">// 筛选不可枚举属性</span></div><div class="line">    <span class="keyword">return</span> !target.propertyIsEnumerable(key)</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(nonenum_only);</div></pre></td></tr></table></figure>
<h3 id="只获取原型链上的可枚举属性"><a href="#只获取原型链上的可枚举属性" class="headerlink" title="只获取原型链上的可枚举属性"></a>只获取原型链上的可枚举属性</h3><ul>
<li>直接用 for..in</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.getPrototypeOf(targetObj); <span class="comment">// 跳过遍历自身属性，直接从原型上开始</span></div><div class="line"><span class="keyword">var</span> k=[],p;</div><div class="line"><span class="keyword">for</span> (p <span class="keyword">in</span> o) <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(o,p)) k.push(p);</div><div class="line"><span class="keyword">return</span> k;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意，这样遍历出来的属性也不一定能访问， 因为自身属性可能会屏蔽掉原型上的属性。</p>
</blockquote>
<h3 id="只获取原型链上的不可枚举属性"><a href="#只获取原型链上的不可枚举属性" class="headerlink" title="只获取原型链上的不可枚举属性"></a>只获取原型链上的不可枚举属性</h3><p>比较麻烦，如果使用 getOwnPropertyNames，只能单独获取一层原型链，必须一级一级遍历往上找，而且这也不一定有场景，因为原型链上的方法重名是会被屏蔽的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;利用hasOwnProperty、getOwnPropertyNames、Object.keys、for…in遍历对象的可枚举属性、不可枚举属性、原型链上的属性和自身属性。&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="getOwnPropertyNames" scheme="http://robin-front.github.io/tags/getOwnPropertyNames/"/>
    
      <category term="hasOwnProperty" scheme="http://robin-front.github.io/tags/hasOwnProperty/"/>
    
      <category term="Object.keys" scheme="http://robin-front.github.io/tags/Object-keys/"/>
    
  </entry>
  
  <entry>
    <title>比较instanceof与isPrototypeOf</title>
    <link href="http://robin-front.github.io/2017/01/12/%E6%AF%94%E8%BE%83instanceof%E4%B8%8EisPrototypeof/"/>
    <id>http://robin-front.github.io/2017/01/12/比较instanceof与isPrototypeof/</id>
    <published>2017-01-12T09:49:14.000Z</published>
    <updated>2017-01-12T09:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>在javascript中，instanceof 和 isPrototypeOf 都可以判断一个原型是否在另一个实例的原型链中，那他们有什么区别呢，为什么说 isPrototypeOf 可以替代 instanceof 。<br><a id="more"></a></p>
<h3 id="instanceof-用法"><a href="#instanceof-用法" class="headerlink" title="instanceof 用法"></a>instanceof 用法</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="comment">// init code</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span><span class="params">()</span> </span>&#123;</div><div class="line">      Super.call(<span class="keyword">this</span>);</div><div class="line">      <span class="comment">// other init code</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">Sub.prototype = <span class="keyword">new</span> Super();</div><div class="line"></div><div class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> Sub();</div></pre></td></tr></table></figure>
<p>对于上面的代码，用 instanceof 可以像这样确定他们的关系：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">instanceof</span> <span class="title">Super</span></span>; // true</div></pre></td></tr></table></figure>
<h3 id="isPrototypeOf-用法"><a href="#isPrototypeOf-用法" class="headerlink" title="isPrototypeOf 用法"></a>isPrototypeOf 用法</h3><p>复用上面的代码，用 isPrototypeOf 可以这样写：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Super.prototype.isPrototypeOf(<span class="function"><span class="keyword">sub</span>)</span>; // true</div></pre></td></tr></table></figure>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>乍一看，都可以用，但某种情况下是有区别的，例如：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var super = &#123;</div><div class="line">    <span class="regexp">//</span> some super properties</div><div class="line">&#125;</div><div class="line"></div><div class="line">var <span class="function"><span class="keyword">sub</span> = <span class="title">Object</span>.<span class="title">create</span></span>(super);</div><div class="line"><span class="function"><span class="keyword">sub</span>.<span class="title">someProp</span> = 5</span>;</div><div class="line"></div><div class="line">var <span class="function"><span class="keyword">sub</span> = <span class="title">Object</span>.<span class="title">create</span></span>(sub);</div><div class="line"></div><div class="line">console.log(super.isPrototypeOf(<span class="function"><span class="keyword">sub</span>))</span>;  // true</div><div class="line">console.log(<span class="function"><span class="keyword">sub</span> <span class="title">instanceof</span> <span class="title">super</span>)</span>;      // TypeError</div></pre></td></tr></table></figure>
<p>这时候 super 并不是构造函数，无法使用 instanceof, 只能使用 isPrototypeOf.</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>结论就是 isPrototypeOf 能使用的场景更广，完全可以替代 instanceof， 只是写起来没那么简洁。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在javascript中，instanceof 和 isPrototypeOf 都可以判断一个原型是否在另一个实例的原型链中，那他们有什么区别呢，为什么说 isPrototypeOf 可以替代 instanceof 。&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="instanceof" scheme="http://robin-front.github.io/tags/instanceof/"/>
    
      <category term="isPrototypeOf" scheme="http://robin-front.github.io/tags/isPrototypeOf/"/>
    
  </entry>
  
  <entry>
    <title>javascript通过Vibration API实现手机振动反馈提高用户体验</title>
    <link href="http://robin-front.github.io/2017/01/10/javascript%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E6%8C%AF%E5%8A%A8%E5%8F%8D%E9%A6%88%E6%8F%90%E9%AB%98%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C/"/>
    <id>http://robin-front.github.io/2017/01/10/javascript实现手机振动反馈提高用户体验/</id>
    <published>2017-01-10T05:35:00.000Z</published>
    <updated>2017-01-11T01:13:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>目前大多数的移动设备均具备硬件能力支持振动，让软件代码通过使设备摇晃来向用户提供物理反馈。Vibration API 为 Web应用程序提供访问此硬件的能力。如果设备不支持，则不会产生任何效果。<br><a id="more"></a></p>
<h3 id="振动描述"><a href="#振动描述" class="headerlink" title="振动描述"></a>振动描述</h3><p>振动被抽象成【开-关】脉冲的模式，且可以具有变化的长度。参数可以是单个整数，表示持续振动的毫秒数 (ms)；或可由多个整数组成的数组，达到振动和暂停循环的效果。只要单一 window.navigator.vibrate() 函式即可控制振动。</p>
<h3 id="单次振动"><a href="#单次振动" class="headerlink" title="单次振动"></a>单次振动</h3><p>你可指定单一数值，或用只有一个数值成员的数组，让设备振动 1 次：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">window</span><span class="selector-class">.navigator</span><span class="selector-class">.vibrate</span>(200);</div><div class="line"><span class="selector-tag">window</span><span class="selector-class">.navigator</span><span class="selector-class">.vibrate</span>(<span class="selector-attr">[200]</span>);</div></pre></td></tr></table></figure>
<p>以上两个例子都可以使设备振动 200 ms.</p>
<h3 id="多次振动"><a href="#多次振动" class="headerlink" title="多次振动"></a>多次振动</h3><p>一个数组的值描述了装置振动与不振动的交替时间段。数组中的每个值都转换为整数，然后交替解释为设备应该振动的毫秒数和不振动的毫秒数。例如:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">window</span><span class="selector-class">.navigator</span><span class="selector-class">.vibrate</span>(<span class="selector-attr">[200, 100, 200]</span>);</div></pre></td></tr></table></figure>
<p>这会使设备振动200 ms，然后暂停100 ms，然后再次振动设备200 ms。</p>
<p>您可以根据需要设定多个振动/暂停对，数组的值可以是偶数或奇数个； 值得注意的是，由于振动在每个振动周期结束时自动停止，因此您不必提供最后一个值去暂停，换句话说，数组长度只需要设置奇数个。</p>
<h3 id="停止振动"><a href="#停止振动" class="headerlink" title="停止振动"></a>停止振动</h3><p>当调用 window.navigator.vibrate() 的参数为「0」、空白数组，或数组全为「0」时，即可取消目前进行中的振动。</p>
<h3 id="持续振动"><a href="#持续振动" class="headerlink" title="持续振动"></a>持续振动</h3><p>一些基于setInterval和clearInterval操作将允许您创建持续的振动：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> vibrateInterval;</div><div class="line"></div><div class="line"><span class="comment">// Starts vibration at passed in level</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">startVibrate</span><span class="params">(duration)</span> </span>&#123;</div><div class="line">    navigator.vibrate(duration);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Stops vibration</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopVibrate</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// Clear interval and stop persistent vibrating</span></div><div class="line">    <span class="keyword">if</span>(vibrateInterval) clearInterval(vibrateInterval);</div><div class="line">    navigator.vibrate(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Start persistent vibration at given duration and interval</span></div><div class="line"><span class="comment">// Assumes a number value is given</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">startPeristentVibrate</span><span class="params">(duration, interval)</span> </span>&#123;</div><div class="line">    vibrateInterval = setInterval(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">        startVibrate(duration);</div><div class="line">    &#125;, interval);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然上面的代码片段没有考虑到振动参数为数组情况; 基于阵列的持久性振动将需要计算数组项的和，并基于该数量创建周期（可能具有额外的延迟）。</p>
<h3 id="生成振动节奏"><a href="#生成振动节奏" class="headerlink" title="生成振动节奏"></a>生成振动节奏</h3><p>可以通过<a href="https://naschq.github.io/vibe.js/" target="_blank" rel="external">vibe.js tool</a>这个工具来生成你需要的振动频率，然后复制它到你的代码里。</p>
<h3 id="lib"><a href="#lib" class="headerlink" title="lib"></a>lib</h3><p>我写了一个小lib，方便使用<a href="https://github.com/Robin-front/vibrate.js" target="_blank" rel="external">vibrate.js</a></p>
<p>demo: <a href="https://robin-front.github.io/vibrate.js/example/demo.html">DEMO</a></p>
<p>译自： <a href="https://developer.mozilla.org/en-US/docs/Web/API/Vibration_API" target="_blank" rel="external">MDN Vibration API</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前大多数的移动设备均具备硬件能力支持振动，让软件代码通过使设备摇晃来向用户提供物理反馈。Vibration API 为 Web应用程序提供访问此硬件的能力。如果设备不支持，则不会产生任何效果。&lt;br&gt;
    
    </summary>
    
      <category term="Vibration" scheme="http://robin-front.github.io/categories/Vibration/"/>
    
      <category term="html5" scheme="http://robin-front.github.io/categories/Vibration/html5/"/>
    
    
      <category term="Vibration" scheme="http://robin-front.github.io/tags/Vibration/"/>
    
  </entry>
  
  <entry>
    <title>由lodash引出数组Array的slice方法性能探究</title>
    <link href="http://robin-front.github.io/2016/11/25/%E7%94%B1lodash%E5%BC%95%E5%87%BA%E6%95%B0%E7%BB%84Array%E7%9A%84slice%E6%96%B9%E6%B3%95%E6%80%A7%E8%83%BD%E6%8E%A2%E7%A9%B6/"/>
    <id>http://robin-front.github.io/2016/11/25/由lodash引出数组Array的slice方法性能探究/</id>
    <published>2016-11-25T03:05:19.000Z</published>
    <updated>2016-11-25T03:05:19.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>lodash</code> 源码中，发现数组截取操作并没有直接使用<code>array</code>的<code>slice</code>方法，而是写了个 <code>baseSlice</code> 方法，更重要的是 <code>baseSlice</code> 方法里，也并没有使用 <code>slice</code> 方法，而是使用循环索引的方式去实现。这让我陷入思考，难道原生Array的<code>slice</code>方法还不如循环快？</p>
<a id="more"></a>
<p><code>lodash</code> 源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseSlice</span>(<span class="params">array, start, end</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> index = <span class="number">-1</span>,</div><div class="line">      length = array.length;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (start &lt; <span class="number">0</span>) &#123;</div><div class="line">    start = -start &gt; length ? <span class="number">0</span> : (length + start);</div><div class="line">  &#125;</div><div class="line">  end = end &gt; length ? length : end;</div><div class="line">  <span class="keyword">if</span> (end &lt; <span class="number">0</span>) &#123;</div><div class="line">    end += length;</div><div class="line">  &#125;</div><div class="line">  length = start &gt; end ? <span class="number">0</span> : ((end - start) &gt;&gt;&gt; <span class="number">0</span>);</div><div class="line">  start &gt;&gt;&gt;= <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> result = <span class="built_in">Array</span>(length);</div><div class="line">  <span class="keyword">while</span> (++index &lt; length) &#123;</div><div class="line">    result[index] = array[index + start];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>于是就开始写代码比较：</p>
<p>  操作长度为100的数组，执行10000次：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> baseArray = [];</div><div class="line"><span class="keyword">var</span> i = <span class="number">-1</span>;</div><div class="line"><span class="keyword">while</span> (++ i &lt; <span class="number">100</span>) &#123; <span class="comment">// 定义一个10000长度的数组以供使用</span></div><div class="line">  baseArray[i] = i;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.time(<span class="string">'slice with no args'</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</div><div class="line">  baseArray.slice();</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'slice with no args'</span>);</div><div class="line"><span class="built_in">console</span>.time(<span class="string">'slice with args'</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</div><div class="line">  baseArray.slice(<span class="number">20</span>, <span class="number">40</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'slice with args'</span>);</div><div class="line"><span class="built_in">console</span>.time(<span class="string">'index'</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</div><div class="line">  <span class="keyword">var</span> result = <span class="built_in">Array</span>(<span class="number">100</span>);</div><div class="line">  <span class="keyword">var</span> index = <span class="number">-1</span>;</div><div class="line">  <span class="keyword">var</span> length = baseArray.length;</div><div class="line">  <span class="keyword">while</span> (++index &lt; length) &#123;</div><div class="line">    result[index] = baseArray[index];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'index'</span>);</div><div class="line"><span class="built_in">console</span>.time(<span class="string">'index with no init array'</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</div><div class="line">  <span class="keyword">var</span> result = [];</div><div class="line">  <span class="keyword">var</span> index = <span class="number">-1</span>;</div><div class="line">  <span class="keyword">var</span> length = baseArray.length;</div><div class="line">  <span class="keyword">while</span> (++index &lt; <span class="number">20</span>) &#123;</div><div class="line">    result[index] = baseArray[index];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'index with no init array'</span>);</div></pre></td></tr></table></figure></p>
<p>对比结果：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// chrome 版本 54.0.2840.98 (64-bit)</span></div><div class="line">slice <span class="keyword">with</span> no args: <span class="number">93.3</span>ms</div><div class="line">slice <span class="keyword">with</span> args: <span class="number">175</span>ms</div><div class="line"><span class="keyword">index</span>: <span class="number">365</span>ms</div><div class="line"><span class="keyword">index</span> <span class="keyword">with</span> no init <span class="keyword">array</span>: <span class="number">546</span>ms</div><div class="line"><span class="comment">// safari 版本 9.0.2 (11601.3.9)</span></div><div class="line">slice <span class="keyword">with</span> no args: <span class="number">122.152</span>ms</div><div class="line">slice <span class="keyword">with</span> args: <span class="number">117.181</span>ms</div><div class="line"><span class="keyword">index</span>: <span class="number">60076.301</span>ms</div><div class="line"><span class="keyword">index</span> <span class="keyword">with</span> no init <span class="keyword">array</span>: <span class="number">62055.406</span>ms</div><div class="line"><span class="comment">//firefox 50.0</span></div><div class="line">slice <span class="keyword">with</span> no args: <span class="number">462.07</span>ms</div><div class="line">slice <span class="keyword">with</span> args: <span class="number">442.25</span>ms</div><div class="line"><span class="keyword">index</span>: <span class="number">194206.08</span>ms</div><div class="line"><span class="keyword">index</span> <span class="keyword">with</span> no init <span class="keyword">array</span>: <span class="number">184714.59</span>ms</div></pre></td></tr></table></figure>
<p>由于mac ox无法测试IE,<br>可以看出，chrome总体要比safafi、firefox快很多；<br>slice方法上，safari和chrome差不多， chrome下slice有参数比无参数慢；<br>新建数组Array()和 []性能差不多；</p>
<p>这么看来，那用原生 slice 明显会更好，为什么 lodash 要用循环索引呢？难道是因为一般应用数组都不会这么大，那改成长度为100的数组进行操作；<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// chrome</span></div><div class="line">slice <span class="keyword">with</span> no args: <span class="number">6</span>ms</div><div class="line">slice <span class="keyword">with</span> args: <span class="number">4.12</span>ms</div><div class="line"><span class="keyword">index</span>: <span class="number">5.82</span>ms</div><div class="line"><span class="keyword">index</span> <span class="keyword">with</span> no init <span class="keyword">array</span>: <span class="number">7.96</span>ms</div><div class="line"><span class="comment">// safari</span></div><div class="line">slice <span class="keyword">with</span> no args: <span class="number">9.158</span>ms</div><div class="line">slice <span class="keyword">with</span> args: <span class="number">8.432</span>ms</div><div class="line"><span class="keyword">index</span>: <span class="number">640.311</span>ms</div><div class="line"><span class="keyword">index</span> <span class="keyword">with</span> no init <span class="keyword">array</span>: <span class="number">643.174</span>ms</div><div class="line"><span class="comment">//firefox</span></div><div class="line">slice <span class="keyword">with</span> no args: <span class="number">17.56</span>ms</div><div class="line">slice <span class="keyword">with</span> args: <span class="number">17.53</span>ms</div><div class="line"><span class="keyword">index</span>: <span class="number">2174.15</span>ms</div><div class="line"><span class="keyword">index</span> <span class="keyword">with</span> no init <span class="keyword">array</span>: <span class="number">2198.15</span>ms</div></pre></td></tr></table></figure></p>
<p>发现结论并没有改变。<br>然后就向lodash提了question, 回复是：</p>
<blockquote>
<p>The perf wins of Array#slice vs. baseSlice depends on the size of the array. That is a minor point though as the perf of that method is not likely to be an issue. The reason we use baseSlice is because we treat arrays as dense while Array#slice will respect sparse arrays.</p>
</blockquote>
<p>大概意思是，他觉得性能没有太大的差别，Array#slice和baseSlice性能强弱取决于数组的大小。这里采用baseSlice是因为他们要视所有为密集数据，而Array#slice会处理稀疏数组。</p>
<p>然后就有下面的测试：</p>
<p>使用 Array#slice和baseSlice 分别截取数组其中一段，循环1000000次：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> baseArray = [];</div><div class="line"><span class="keyword">var</span> i = <span class="number">-1</span>;</div><div class="line"><span class="keyword">while</span> (++ i &lt; <span class="number">100000</span>) &#123; <span class="comment">// 定义一个10000长度的数组以供使用,这里数组长度并不影响性能，性能影响主要在于截取的长度。</span></div><div class="line">  baseArray[i] = i;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.time(<span class="string">'slice with args'</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)&#123;</div><div class="line">  baseArray.slice(<span class="number">0</span>, <span class="number">20</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'slice with args'</span>);</div><div class="line"><span class="built_in">console</span>.time(<span class="string">'index'</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)&#123;</div><div class="line">  <span class="keyword">var</span> result = <span class="built_in">Array</span>(<span class="number">20</span>);</div><div class="line">  <span class="keyword">var</span> index = <span class="number">-1</span>;</div><div class="line">  <span class="keyword">while</span> (++index &lt; <span class="number">20</span>) &#123;</div><div class="line">    result[index] = baseArray[index];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'index'</span>);</div></pre></td></tr></table></figure>
<p>不同截取长度在chrome下的效果：<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 截取长度 20</span></div><div class="line">slice <span class="keyword">with</span> args: <span class="number">110</span>ms</div><div class="line"><span class="keyword">index</span>: <span class="number">78.9</span>ms</div><div class="line"><span class="comment">// 截取长度 30</span></div><div class="line">slice <span class="keyword">with</span> args: <span class="number">114</span>ms</div><div class="line"><span class="keyword">index</span>: <span class="number">112</span>ms</div><div class="line"><span class="comment">// 截取长度 30</span></div><div class="line">slice <span class="keyword">with</span> args: <span class="number">132</span>ms</div><div class="line"><span class="keyword">index</span>: <span class="number">146</span>ms</div></pre></td></tr></table></figure></p>
<p>由此看出，截取长度为30左右时，Array#slice和loop方式性能基本一样，而 Array#slice 基本不受截取长度的影响。<br>所以结论是，当长度为30以下时，lodash的方法是比较高效的，当然，这影响微乎其微。像_.chunk方法，一般场景分组都不会太长。</p>
<p>疑惑是，对我的回复的后半句我没怎么看懂，密集数据和稀疏数据对这有什么影响呢？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;lodash&lt;/code&gt; 源码中，发现数组截取操作并没有直接使用&lt;code&gt;array&lt;/code&gt;的&lt;code&gt;slice&lt;/code&gt;方法，而是写了个 &lt;code&gt;baseSlice&lt;/code&gt; 方法，更重要的是 &lt;code&gt;baseSlice&lt;/code&gt; 方法里，也并没有使用 &lt;code&gt;slice&lt;/code&gt; 方法，而是使用循环索引的方式去实现。这让我陷入思考，难道原生Array的&lt;code&gt;slice&lt;/code&gt;方法还不如循环快？&lt;/p&gt;
    
    </summary>
    
      <category term="lodash" scheme="http://robin-front.github.io/categories/lodash/"/>
    
      <category term="array" scheme="http://robin-front.github.io/categories/lodash/array/"/>
    
      <category term="slice" scheme="http://robin-front.github.io/categories/lodash/array/slice/"/>
    
    
      <category term="lodash" scheme="http://robin-front.github.io/tags/lodash/"/>
    
      <category term="array" scheme="http://robin-front.github.io/tags/array/"/>
    
      <category term="slice" scheme="http://robin-front.github.io/tags/slice/"/>
    
  </entry>
  
  <entry>
    <title>Debounce-and-Throttle-的可視化解釋</title>
    <link href="http://robin-front.github.io/2016/11/17/Debounce-and-Throttle-%E7%9A%84%E5%8F%AF%E8%A6%96%E5%8C%96%E8%A7%A3%E9%87%8B/"/>
    <id>http://robin-front.github.io/2016/11/17/Debounce-and-Throttle-的可視化解釋/</id>
    <published>2016-11-17T02:22:22.000Z</published>
    <updated>2016-11-21T03:19:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>Debounce 和 Throttle是两个概念，我们可以在JavaScript中使用，以提高我们对执行功能的控制，在事件处理的时候特别有用。</p>
<a id="more"></a>
<h3 id="比喻"><a href="#比喻" class="headerlink" title="比喻"></a>比喻</h3><p>这两种技术都回答同样的问题“一个功能可以随着时间被推移多久？”</p>
<ul>
<li>Debounce：把它看成是“多个分组事件之一”。试想一下，你回家，再进入电梯，门正在关闭……，突然你的邻居出现在大厅，并试图跳上电梯。要有礼貌！并打开大门，他说：你等等，让我一起上。相同的情况下，可以与第三人再次发生，等等…这可能会延缓出发几分钟。</li>
<li>Throttle：把它看成是一个阀，它规定了执行的流程。我们可以判断函数可以在一定时间内被调用的最大次数。因此，再用电梯比喻..你有足够的礼貌，持续10秒等人，但一旦时间到了，你一定要走！</li>
</ul>
<p>无 Debounce 或 Throttle 事件处理程序就像一次只能一个人用的电梯：没有那么高效。</p>
<p>我希望这个坏比喻对你有所帮助，但有时言语并不会对掌握这些概念有多大的帮助，所以我创建了一个演示去理解 Debounce 和 Throttle 概念，并把它们应用到mousemove事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">elevator_departure</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">  alert(name + <span class="string">" was the last one. Nobody else? Let's go then"</span>);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> debounced_elevator_departure = $.debounce(<span class="number">200</span>, <span class="literal">false</span>, elevator_departure);</div><div class="line"></div><div class="line">debounced_elevator_departure(<span class="string">'John'</span>);</div><div class="line">debounced_elevator_departure(<span class="string">'Mike'</span>);</div><div class="line">debounced_elevator_departure(<span class="string">'Peter'</span>);</div><div class="line"><span class="comment">// You will see *only* one message, "Peter was the last one. Nobody else? Let's go then";</span></div></pre></td></tr></table></figure>
<p>我发现这3个人在JavaScript中都通过debounce和throttle执行了。我真的建议你先读一下 <a href="http://benalman.com/projects/jquery-throttle-debounce-plugin/" target="_blank" rel="external"><code>Ben Alman&#39;s</code></a> 的文章，以便更好地理解  debounce 和 throttle. <code>underscore</code> 和 <code>lodash</code> 有不同的实现方式，但参数都是一样的（除了 <code>throttle</code>没有 <code>trailing</code>）.</p>
<ul>
<li><a href="http://underscorejs.org/" target="_blank" rel="external">Underscore.js</a> by Jeremy Ashkenas *</li>
<li><a href="http://lodash.com/" target="_blank" rel="external">Lodash.js</a> by John-David Dalton *</li>
<li><a href="http://benalman.com/projects/jquery-throttle-debounce-plugin/" target="_blank" rel="external">jQuery Plugin</a> by Ben Alman.</li>
</ul>
<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>这里是视觉演示:</p>
<iframe src="http://drupalmotion.com/sites/default/files/demos/debounce-throttle/index.html" height="350px" width="1000px"></iframe>

<p>这是截图：<br><img src="http://drupalmotion.com/sites/default/files/pics/screenshot.png" alt="debounce-throttle"></p>
<p>注意：</p>
<ul>
<li>这个的源代码演示在<a href="https://github.com/dcorb/debounce-throttle" target="_blank" rel="external">GitHub上托管</a>。</li>
<li>如果你看到动画在浏览器中并不流畅，请在一个单独的页面打开演示，或者尝试在Chrome中。</li>
<li>我通过在鼠标区域 <code>tapping</code>来去在<code>Android</code>环境下演示它</li>
<li>每个单元代表约30毫秒，但JS是单线程的，所以浏览器是不是准确。这个演示并不是想成为一个最佳实践，只是为了更好地去理解概念。</li>
<li>当你做了<code>setTimeout</code>，时间间隔可能不同，在每个浏览器在4ms和15ms的之间（<a href="http://www.nczonline.net/blog/2011/12/14/timer-resolution-in-browsers/" target="_blank" rel="external">尼古拉斯Zakas的文章</a>），甚至是<code>setTimeout(fn,0)</code>至少需要4毫秒。在另一方面，时间为1毫秒为最小单位的。</li>
<li>在<code>mousemove</code>第一行中的事件也有做节流（80毫秒）。这对理解演示有所帮助。</li>
<li>要获得 <code>trailing</code>选项<code>$.throttle</code>，你需要传递<code>false</code>。</li>
<li>不要忘了，这一切都是builder，他们返回一个函数，所以你只需要执行一次。</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="debounce-案例"><a href="#debounce-案例" class="headerlink" title="debounce 案例"></a>debounce 案例</h4><p>用它减少执行频繁的事件。例子：</p>
<ul>
<li>当将要处理的textarea的快速打字：你不想执行处理函数，直到用户停止输入再来处理文本。</li>
<li>当数据保存到通过AJAX服务器：你不想每秒调用非常缓慢的邮件服务器</li>
</ul>
<h4 id="throttle-案例"><a href="#throttle-案例" class="headerlink" title="throttle 案例"></a>throttle 案例</h4><p>和<code>debounce</code> 一样，但如果想每隔一段时间必须执行事件，可以使用它：</p>
<ul>
<li>假设用户不停地快速输入30秒，可能你会想每5秒执行一次函数；</li>
<li>一些对性能有影响的事件但又必须处理：scroll, mouseweel, mousemove。一个简单的鼠标滚轮运动可以在一秒钟内触发几十个事件。</li>
</ul>
<p>本文翻译自 <a href="http://drupalmotion.com/article/debounce-and-throttle-visual-explanation" target="_blank" rel="external">Debounce and Throttle: a visual explanation</a></p>
<p>========= update on 11-21 =========</p>
<h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><h4 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> validation = _.debounce(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  ... <span class="comment">// 校验输入，逻辑可能还会有点复杂</span></div><div class="line">&#125;, <span class="number">250</span>)</div><div class="line">jQuery(<span class="string">'input'</span>).keyup(validation) <span class="comment">// 输入完成或停顿250ms后才去执行校验，如果不停输入10s，则10s内都不会触发</span></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  debounce第三个参数为可选参数，</div><div class="line"> *  leading为true时，则在事件开始时首先执行一次， 默认值为 false；</div><div class="line"> *  trailing为true时，则在结束时触发, 默认值为 true；</div><div class="line"> *  maxWait设置每隔多长时间必须触发；</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123; ... &#125;</div><div class="line">jQuery(<span class="string">'input'</span>).on(<span class="string">'keyup'</span>, _.debounce(foo, <span class="number">300</span>, &#123;</div><div class="line">  <span class="string">'leading'</span>: <span class="literal">true</span>, <span class="comment">// 注意： 执行的前提是定时器为undefined</span></div><div class="line">  <span class="string">'trailing'</span>: <span class="literal">false</span>,</div><div class="line">  <span class="string">'maxWait'</span>: <span class="number">1000</span></div><div class="line">&#125;));</div><div class="line"></div><div class="line"><span class="comment">// debounce还可以被取消</span></div><div class="line">jQuery(<span class="string">'button'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  validation.cancel();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mousemove</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line">jQuery(<span class="string">'#div'</span>).on(<span class="string">'mousemove'</span>, _.throttle(mousemove, <span class="number">100</span>)) <span class="comment">// 每100ms必须触发一次</span></div><div class="line"></div><div class="line"><span class="comment">// mousemove会在定时器开始时触发, 但5分钟内不会有第二次</span></div><div class="line">jQuery(<span class="string">'#div'</span>).on(<span class="string">'mousemove'</span>, _.throttle(mousemove, <span class="number">300000</span>, &#123;</div><div class="line">  <span class="string">'leading'</span>: <span class="literal">true</span>, <span class="comment">// 定时器前沿触发，默认值为true</span></div><div class="line">  <span class="string">'trailing'</span>: <span class="literal">false</span> <span class="comment">// 定时器后沿触发，默认值为true</span></div><div class="line">&#125;));</div><div class="line"><span class="comment">// throttle 同样可以被取消</span></div><div class="line">jQuery(<span class="built_in">window</span>).on(<span class="string">'popstate'</span>, throttled.cancel);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Debounce 和 Throttle是两个概念，我们可以在JavaScript中使用，以提高我们对执行功能的控制，在事件处理的时候特别有用。&lt;/p&gt;
    
    </summary>
    
      <category term="函数节流" scheme="http://robin-front.github.io/categories/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81/"/>
    
    
      <category term="debounce" scheme="http://robin-front.github.io/tags/debounce/"/>
    
      <category term="throttle" scheme="http://robin-front.github.io/tags/throttle/"/>
    
  </entry>
  
  <entry>
    <title>使用 npm shrinkwrap 来管理项目依赖</title>
    <link href="http://robin-front.github.io/2016/10/20/%E4%BD%BF%E7%94%A8-npm-shrinkwrap-%E6%9D%A5%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96/"/>
    <id>http://robin-front.github.io/2016/10/20/使用-npm-shrinkwrap-来管理项目依赖/</id>
    <published>2016-10-20T09:35:22.000Z</published>
    <updated>2016-10-20T09:35:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>管理依赖是一个复杂软件开发过程中必定会遇到的问题。</p>
<p>在Node.js项目开发的时候，我们也经常需要安装和升级对应的依赖。虽然 npm 以及语意化的版本号 (semantic versioning, semver) 让开发过程中依赖的获取和升级变得非常容易， 但不严格的版本号限制，也带来了版本号的不确定性。主要的问题可能有三个：</p>
<ul>
<li>npm 建议使用 semver 的应用程序版本，但这也完全依赖第三方包遵守这一规则。如果你依赖于的包不遵循 semver ，或者依赖的包的新版本有重大更改（而你使用了 ^ 的宽泛版本安装），这潜在可能是会导致问题的。</li>
<li>另一个问题的出现是由于 npm 安装依赖的机制。npm 的安装包是有层次结构的，手动控制要安装的软件包的版本号可以实现，但是你只能在 package.json 使用精确的版本号控制你的直接依赖包，但那些多层以上的依赖就没办法控制了；一个第三方包不严谨的版本依赖生命可能破坏你的依赖管理。</li>
<li>在开发阶段执行得到的版本，和后续部署时得到的可能是不一致的，更不可控的是，你依赖的第三方包也有这样的情况会导致潜在的上线风险。</li>
</ul>
<p>如果要控制上线的风险，我们就必需要解决这个问题，这时候，就需要使用 npm shrinkwrap 这个命令来解决问题。<br><a id="more"></a></p>
<h3 id="npm-shrinkwrap"><a href="#npm-shrinkwrap" class="headerlink" title="npm shrinkwrap"></a>npm shrinkwrap</h3><p><code>npm shrinkwrap</code> 可以按照当前项目 <code>node_modules</code> 目录内的安装包情况生成稳定的版本号描述。</p>
<p>比方说，有一个包 A<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"A"</span>,</div><div class="line">  <span class="attr">"version"</span>: <span class="string">"0.1.0"</span>,</div><div class="line">  <span class="attr">"dependencies"</span>: &#123;</div><div class="line">    <span class="attr">"B"</span>: <span class="string">"&lt;0.1.0"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>还有一个包 B<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"B"</span>,</div><div class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.1"</span>,</div><div class="line">  <span class="attr">"dependencies"</span>: &#123;</div><div class="line">    <span class="attr">"C"</span>: <span class="string">"&lt;0.1.0"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以及包 C<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"C"</span>,</div><div class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.1"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你的项目只依赖于 A，于是 <code>npm install</code> 会得到这样的目录结构<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">A@<span class="number">0.1</span><span class="number">.0</span></div><div class="line">  `-- B@<span class="number">0.0</span><span class="number">.1</span></div><div class="line">      `-- C@<span class="number">0.0</span><span class="number">.1</span></div></pre></td></tr></table></figure></p>
<p>这时候，B@0.0.2 发布了，这时候在一个新的环境下执行 <code>npm install</code> 将得到<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">A@<span class="number">0.1</span><span class="number">.0</span></div><div class="line">    `-- B@<span class="number">0.0</span><span class="number">.2</span></div><div class="line">        `-- C@<span class="number">0.0</span><span class="number">.1</span></div></pre></td></tr></table></figure></p>
<p>这时候两次安装得到的版本号就不一致了。而通过 shrinkwrap 命令，我们可以保证在所有环境下安装得到稳定的结果。</p>
<p>在项目引入新包的时候，或者 A 的开发者执行一下 npm shrinkwrap，可以在项目根目录得到一个 npm-shrinkwrap.json 文件。</p>
<p>这个文件内容如下<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"A"</span>,</div><div class="line">  <span class="attr">"version"</span>: <span class="string">"0.1.0"</span>,</div><div class="line">  <span class="attr">"dependencies"</span>: &#123;</div><div class="line">    <span class="attr">"B"</span>: &#123;</div><div class="line">      <span class="attr">"version"</span>: <span class="string">"0.0.1"</span>,</div><div class="line">      <span class="attr">"dependencies"</span>: &#123;</div><div class="line">        <span class="attr">"C"</span>: &#123;</div><div class="line">          <span class="attr">"version"</span>: <span class="string">"0.0.1"</span></div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>shrinkwrap 命令根据目前安装在node_modules的文件情况锁定依赖版本。在项目中执行 <code>npm install</code> 的时候，npm 会检查在根目录下有没有 npm-shrinkwrap.json 文件，如果 shrinkwrap 文件存在的话，npm 会使用它（而不是 package.json）来确定安装的各个包的版本号信息。</p>
<p>这样一来，在安装时候确定的所有版本信息会稳定的固化在 shrinkwrap 里。无论是A，B 和 C中的版本如何变化，或者它们的 package.json 文件如何修改，你始终能保证，在你项目中执行 <code>npm install</code> 的到的版本号时稳定的。</p>
<h3 id="在开发中使用-shrinkwrap"><a href="#在开发中使用-shrinkwrap" class="headerlink" title="在开发中使用 shrinkwrap"></a>在开发中使用 shrinkwrap</h3><h5 id="在开发过程中，引入一个新包的流程如下"><a href="#在开发过程中，引入一个新包的流程如下" class="headerlink" title="在开发过程中，引入一个新包的流程如下"></a>在开发过程中，引入一个新包的流程如下</h5><ul>
<li><code>npm install PACKAGE_NAME@VERSION --save</code> 获取特定版本的包</li>
<li>测试功能</li>
<li>测试功能正常后，执行 <code>npm shrinkwrap</code> 把依赖写入 shrinkwrap 文件</li>
<li>在代码仓库中提交 <code>shrinkwrap / package.json</code>描述</li>
</ul>
<h5 id="升级一个包的流程应该是这样"><a href="#升级一个包的流程应该是这样" class="headerlink" title="升级一个包的流程应该是这样"></a>升级一个包的流程应该是这样</h5><ul>
<li><code>npm outdated</code> 获取项目所有依赖的更新信息</li>
<li><code>npm install PACKAGE_NAME@VERSION --save</code> 获取特定版本的包</li>
<li>测试功能</li>
<li>测试功能正常后，执行 <code>npm shrinkwrap</code>把依赖写入 shrinkwrap 文件</li>
<li>在代码仓库中提交 <code>shrinkwrap / package.json</code>描述</li>
</ul>
<h5 id="删除一个包的流程如下"><a href="#删除一个包的流程如下" class="headerlink" title="删除一个包的流程如下"></a>删除一个包的流程如下</h5><ul>
<li><code>npm uninstall PACKAGE_NAME --save</code> 删除这个包</li>
<li>测试功能</li>
<li>测试功能正常后，执行 <code>npm shrinkwrap</code> 把更新的依赖写入 shrinkwrap 文件</li>
<li>在代码仓库中提交 <code>shrinkwrap / package.json</code> 描述</li>
<li>比一般的安装多了一步手工生成 shrinkwrap 文件。在实际工作中，有时候我们会忘记这一步，导致上线时候没有获取到依赖包的特定版本。</li>
</ul>
<p>本文转自<a href="http://tech.meituan.com/npm-shrinkwrap.html" target="_blank" rel="external">使用 npm shrinkwrap 来管理项目依赖</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;管理依赖是一个复杂软件开发过程中必定会遇到的问题。&lt;/p&gt;
&lt;p&gt;在Node.js项目开发的时候，我们也经常需要安装和升级对应的依赖。虽然 npm 以及语意化的版本号 (semantic versioning, semver) 让开发过程中依赖的获取和升级变得非常容易， 但不严格的版本号限制，也带来了版本号的不确定性。主要的问题可能有三个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;npm 建议使用 semver 的应用程序版本，但这也完全依赖第三方包遵守这一规则。如果你依赖于的包不遵循 semver ，或者依赖的包的新版本有重大更改（而你使用了 ^ 的宽泛版本安装），这潜在可能是会导致问题的。&lt;/li&gt;
&lt;li&gt;另一个问题的出现是由于 npm 安装依赖的机制。npm 的安装包是有层次结构的，手动控制要安装的软件包的版本号可以实现，但是你只能在 package.json 使用精确的版本号控制你的直接依赖包，但那些多层以上的依赖就没办法控制了；一个第三方包不严谨的版本依赖生命可能破坏你的依赖管理。&lt;/li&gt;
&lt;li&gt;在开发阶段执行得到的版本，和后续部署时得到的可能是不一致的，更不可控的是，你依赖的第三方包也有这样的情况会导致潜在的上线风险。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果要控制上线的风险，我们就必需要解决这个问题，这时候，就需要使用 npm shrinkwrap 这个命令来解决问题。&lt;br&gt;
    
    </summary>
    
      <category term="npm" scheme="http://robin-front.github.io/categories/npm/"/>
    
    
      <category term="npm" scheme="http://robin-front.github.io/tags/npm/"/>
    
      <category term="shrinkwrap" scheme="http://robin-front.github.io/tags/shrinkwrap/"/>
    
  </entry>
  
  <entry>
    <title>用Git-Hooks进行自动部署,让提交发布自动化</title>
    <link href="http://robin-front.github.io/2016/08/11/%E7%94%A8Git-Hooks%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2-%E8%AE%A9%E6%8F%90%E4%BA%A4%E5%8F%91%E5%B8%83%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    <id>http://robin-front.github.io/2016/08/11/用Git-Hooks进行自动部署-让提交发布自动化/</id>
    <published>2016-08-11T11:51:56.000Z</published>
    <updated>2016-08-11T11:51:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前了解的自动化部署都是<code>jekins</code>这样集成化的成熟的工具。最近因为有朋友提交代码时，不想登陆服务器拉取代码，才了解到 <code>git hooks</code>。看来还是git使用不到位。之前一直都是本地开发并提交代码，测试时，人工登陆测试服务器去拉取最新代码。<br><a id="more"></a></p>
<p>网上资料还是比较多的，最后在本机测试是成功了的。</p>
<p>主要选要明白几个关键点：</p>
<ul>
<li>git init –bare</li>
<li>post-receive 文件</li>
<li>SSH 认证</li>
</ul>
<p>这几个都比较容易找到资料。</p>
<h3 id="git-init-–bare"><a href="#git-init-–bare" class="headerlink" title="git init –bare"></a>git init –bare</h3><p>和 <code>git init</code> 不一样的是，<code>git init --bare</code>并不存储实际代码，仓库文件夹不会看到任何项目代码，反而生成了一些 <code>.git</code>之外的文件夹，其中 <code>hooks</code>文件夹就是存放git命令操作后需要执行的脚本。<br>需要新建两个文件夹，一个执行<code>git init --bare</code>作为远端仓库，一个执行<code>git init</code>作为服务器项目目录。<br>本地开发目录和服务器项目目录的<code>remote</code>都要指向 服务器的远端仓库。</p>
<h3 id="post-receive-文件"><a href="#post-receive-文件" class="headerlink" title="post-receive 文件"></a>post-receive 文件</h3><p>post-receive 文件是git push 之后，执行的脚本文件，自动部署的脚本代码就写在这里。<br>如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"><span class="built_in">unset</span> GIT_DIR</div><div class="line"><span class="built_in">echo</span> <span class="string">"远程开始更新"</span></div><div class="line">NowPath=`<span class="built_in">pwd</span>`</div><div class="line"><span class="built_in">echo</span> <span class="variable">$NowPath</span></div><div class="line">DeployPath=<span class="string">"../deploy"</span></div><div class="line"></div><div class="line"><span class="built_in">cd</span> <span class="variable">$DeployPath</span></div><div class="line">git pull origin master</div><div class="line"><span class="built_in">echo</span> <span class="string">"远程更新完毕"</span></div><div class="line"><span class="built_in">cd</span> <span class="variable">$NowPath</span></div><div class="line"><span class="built_in">exit</span> 0</div></pre></td></tr></table></figure></p>
<p>这里有一点比较容易出问题的就是路径，最好还是使用绝对路径。<br>脚本里还可以加入任何想执行的脚本，比如打包编译。</p>
<blockquote>
<p>不过要注意使用 chmod +x post-receive 改变一下权限，服务器端的配置就基本完成了。</p>
</blockquote>
<h3 id="SSH认证"><a href="#SSH认证" class="headerlink" title="SSH认证"></a>SSH认证</h3><p>这个在 mac os x 和 linux都没有问题，我用别人的windows配置的时候经常都会出现认证失败，就算认证成功了，也无法执行脚本，对这个还是不太熟悉。我猜可能是 cmd 的问题，ssh 登陆后还遇到过乱码。</p>
<p>这些都配置好之后，本地开发只需要提交代码，服务器就可以预览最新代码了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前了解的自动化部署都是&lt;code&gt;jekins&lt;/code&gt;这样集成化的成熟的工具。最近因为有朋友提交代码时，不想登陆服务器拉取代码，才了解到 &lt;code&gt;git hooks&lt;/code&gt;。看来还是git使用不到位。之前一直都是本地开发并提交代码，测试时，人工登陆测试服务器去拉取最新代码。&lt;br&gt;
    
    </summary>
    
      <category term="git" scheme="http://robin-front.github.io/categories/git/"/>
    
    
      <category term="git" scheme="http://robin-front.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>webpack-sourcemap选项应该选哪个</title>
    <link href="http://robin-front.github.io/2016/08/08/webpack-sourcemap%E9%80%89%E9%A1%B9%E5%BA%94%E8%AF%A5%E9%80%89%E5%93%AA%E4%B8%AA/"/>
    <id>http://robin-front.github.io/2016/08/08/webpack-sourcemap选项应该选哪个/</id>
    <published>2016-08-08T09:08:53.000Z</published>
    <updated>2016-08-08T09:08:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用 webpack 也有一段时间了，但是每次看到别的项目配置，还是会去浏览一遍。这次刚好看到一个 <code>devtool: &#39;#eval-source-map&#39;</code>，就有些好奇，之前都是默认使用 <code>#source-map</code> 并没有过多去注意它。google一下，发现这个 devtool 选项还不少，那我们到底选哪个呢，它们有哪些区别。<br><a id="more"></a></p>
<p>先来看看官方文档的相关描述：</p>
<p><img src="https://raw.githubusercontent.com/Robin-front/blog/master/source/images/201608/webpack-sourcemap.png" alt="devtool"></p>
<p>有构建速度，重新构建速度，打包速度，来源 这几项的展示。</p>
<p>然后可以看看这一篇文章，对这几个选项描述得比较详细：</p>
<p><a href="https://chemzqm.me/webpack-sourcemap" target="_blank" rel="external">https://chemzqm.me/webpack-sourcemap</a></p>
<p>摘出主要部分：</p>
<ul>
<li><code>eval</code> 文档上解释的很明白，每个模块都封装到 <code>eval</code> 包裹起来，并在后面添加 <code>//# sourceURL</code></li>
<li><code>source-map</code> 这是最原始的 <code>source-map</code> 实现方式，其实现是打包代码同时创建一个新的 <code>sourcemap</code> 文件， 并在打包文件的末尾添加 <code>//# sourceURL</code> 注释行告诉 JS 引擎文件在哪儿</li>
<li><code>hidden-source-map</code> 文档上也说了，就是 soucremap 但没注释，没注释怎么找文件呢？貌似只能靠后缀，譬如 <code>xxx/bundle.js</code> 文件，某些引擎会尝试去找 <code>xxx/bundle.js.map</code></li>
<li><code>inline-source-map</code> 为每一个文件添加 <code>sourcemap</code> 的 DataUrl，注意这里的文件是打包前的每一个文件而不是最后打包出来的，同时这个 <code>DataUrl</code> 是包含一个文件完整 <code>souremap</code> 信息的 <code>Base64</code> 格式化后的字符串，而不是一个 url。</li>
<li><code>eval-source-map</code> 这个就是把 <code>eval</code> 的 <code>sourceURL</code> 换成了完整 <code>souremap</code> 信息的 DataUrl</li>
<li><code>cheap-source-map</code> 不包含列信息，不包含 <code>loader</code> 的 <code>sourcemap</code>，（譬如 <code>babel</code> 的 sourcemap）</li>
<li><code>cheap-module-source-map</code> 不包含列信息，同时 <code>loader</code> 的 <code>sourcemap</code> 也被简化为只包含对应行的。最终的 <code>sourcemap</code> 只有一份，它是 <code>webpack</code> 对 <code>loader</code> 生成的 <code>sourcemap</code> 进行简化，然后再次生成的。</li>
</ul>
<p>webpack 不仅支持这 7 种，而且它们还是可以任意组合的，就如文档所说，你可以设置 souremap 选项为 <code>cheap-module-inline-source-map</code>。</p>
<p>结合官方的列表比较和引用的这篇文章的介绍，就比较容易选择合适的选项了。建议开发时使用 <code>#cheap-module-eval-source-map</code>，测试环境或线上有需要的话使用 <code>#cheap-module-source-map</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 webpack 也有一段时间了，但是每次看到别的项目配置，还是会去浏览一遍。这次刚好看到一个 &lt;code&gt;devtool: &amp;#39;#eval-source-map&amp;#39;&lt;/code&gt;，就有些好奇，之前都是默认使用 &lt;code&gt;#source-map&lt;/code&gt; 并没有过多去注意它。google一下，发现这个 devtool 选项还不少，那我们到底选哪个呢，它们有哪些区别。&lt;br&gt;
    
    </summary>
    
      <category term="webpack" scheme="http://robin-front.github.io/categories/webpack/"/>
    
    
      <category term="webpack" scheme="http://robin-front.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>使用ApplicationCache离线缓存做一个h5离线应用</title>
    <link href="http://robin-front.github.io/2016/06/30/%E4%BD%BF%E7%94%A8ApplicationCache%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98%E5%81%9A%E4%B8%80%E4%B8%AAh5%E7%A6%BB%E7%BA%BF%E5%BA%94%E7%94%A8/"/>
    <id>http://robin-front.github.io/2016/06/30/使用ApplicationCache离线缓存做一个h5离线应用/</id>
    <published>2016-06-30T14:41:14.000Z</published>
    <updated>2016-06-30T14:41:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>原生app可以离线操作，在以前是相对web app的优势，web必须联网才能刷新使用。虽然所有浏览器都有缓存机制，但它们并不一定总能起到预期的作用。HTML5 使用 ApplicationCache 接口解决了由离线带来的部分难题。即使用户在离线状态下按了刷新按钮，您的应用也会正常加载和运行。<br><a id="more"></a></p>
<p>使用缓存接口可为您的应用带来以下三个优势：</p>
<ul>
<li>离线浏览 - 用户可在离线时浏览您的完整网站</li>
<li>速度 - 缓存资源为本地资源，因此加载速度较快。</li>
<li>服务器负载更少 - 浏览器只会从发生了更改的服务器下载资源。</li>
</ul>
<h3 id="引用清单文件"><a href="#引用清单文件" class="headerlink" title="引用清单文件"></a>引用清单文件</h3><h4 id="manifest属性"><a href="#manifest属性" class="headerlink" title="manifest属性"></a>manifest属性</h4><p>要启用某个应用的应用缓存，请在文档的 html 标记中添加 manifest 属性：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">"app.manifest"</span>&gt;</span></div><div class="line">  ...</div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>您应在要缓存的网络应用的每个页面上都添加 manifest 属性。如果网页不包含 manifest 属性，浏览器就不会缓存该网页（除非清单文件中明确列出了该属性）。这就意味着用户浏览的每个包含 manifest 的网页都会隐式添加到应用缓存。因此，您无需在清单中列出每个网页。</p>
<p>manifest 属性可指向绝对网址或相对路径，但绝对网址必须与相应的网络应用同源。</p>
<h4 id="清单文件格式与-MIME-类型设置"><a href="#清单文件格式与-MIME-类型设置" class="headerlink" title="清单文件格式与 MIME 类型设置"></a>清单文件格式与 MIME 类型设置</h4><p>清单文件可使用任何文件扩展名，但必须以正确的 <code>text/cache-manifest</code> MIME 类型提供。<br>下面是几件网络服务的配置例子：</p>
<p>Apache:<br>新建或者编辑现有的 <code>.htaccess</code> 文件，在里面加上一行<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AddType <span class="built_in">text</span>/cache-manifest .manifest</div></pre></td></tr></table></figure></p>
<p>Nginx:<br>修改 <code>mime.types</code> 文件，在里面增加 manifest 文件的映射<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">text</span>/cache-manifest manifest</div></pre></td></tr></table></figure></p>
<p>Tomcat：<br>修改 <code>web.xml</code> 文件，在里面增加<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">mime-mapping</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">extension</span>&gt;</span>manifest<span class="tag">&lt;/<span class="name">extension</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">mime-type</span>&gt;</span>text/cache-manifest<span class="tag">&lt;/<span class="name">mime-type</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">mime-mapping</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h4 id="清单文件结构"><a href="#清单文件结构" class="headerlink" title="清单文件结构"></a>清单文件结构</h4><p>基本的清单格式：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CACHE MANIFEST</div><div class="line">index<span class="selector-class">.html</span></div><div class="line">stylesheet<span class="selector-class">.css</span></div><div class="line">images/logo<span class="selector-class">.png</span></div><div class="line">scripts/main.js</div></pre></td></tr></table></figure>
<p>您需要注意以下几点：</p>
<ul>
<li>CACHE MANIFEST 字符串应在第一行，且必不可少。</li>
<li>网站的缓存数据量不得超过 5 MB。不过，如果您要编写的是针对 <a href="http://code.google.com/chrome/apps/docs/developers_guide.html" target="_blank" rel="external">Chrome 网上应用店</a>的应用，可使用 unlimitedStorage 取消该限制。</li>
<li>如果清单文件或其中指定的资源无法下载，就无法进行整个缓存更新进程。在这种情况下，浏览器将继续使用原应用缓存。</li>
</ul>
<p>完整的清单格式：</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">CACHE MANIFEST</div><div class="line"><span class="meta"># daksfljs3kl23j3k43  hash 以便做版本控制</span></div><div class="line"></div><div class="line"><span class="meta"># 默认部分，显式缓存这些文件</span></div><div class="line">CACHE:</div><div class="line">/favicon.ico</div><div class="line">index.html</div><div class="line">stylesheet.css</div><div class="line">images/logo.png</div><div class="line">scripts/main.js</div><div class="line"></div><div class="line"><span class="meta"># 此部分下列出的文件是需要连接到服务器的白名单资源。无论用户是否处于离线状态，对这些资源的所有请求都会绕过缓存。</span></div><div class="line">NETWORK:</div><div class="line">login.php</div><div class="line">/myapi</div><div class="line">http:<span class="comment">//api.twitter.com</span></div><div class="line"></div><div class="line"><span class="meta"># 此部分是可选的，用于指定无法访问资源时的后备网页。其中第一个 URI 代表资源，第二个代表后备网页。两个 URI 必须相关，并且必须与清单文件同源。</span></div><div class="line"><span class="meta"># offline.jpg will be served in place of all images in images/large/</span></div><div class="line"><span class="meta"># offline.html will be served in place of all other .html files</span></div><div class="line">FALLBACK:</div><div class="line">images/large/ images/offline.jpg</div><div class="line">*.html /offline.html</div></pre></td></tr></table></figure>
<p>应用缓存只在其清单文件发生更改时才会更新。例如，如果您修改了图片资源或更改了 JavaScript 函数，这些更改不会重新缓存。<em>您必须修改清单文件本身才能让浏览器刷新缓存文件。</em></p>
<blockquote>
<p>这些部分可按任意顺序排列，且每个部分均可在同一清单中重复出现;<br>可使用通配符。</p>
</blockquote>
<p><em>请注意：</em> HTTP 缓存标头以及对通过 SSL 提供的网页设置的缓存限制将被替换为缓存清单。因此，通过 https 提供的网页可实现离线运行。chrome 未来将会禁止非 https 网页使用 <code>ApplicationCache</code> 功能（updated 2016-06-30）</p>
<h3 id="更新缓存"><a href="#更新缓存" class="headerlink" title="更新缓存"></a>更新缓存</h3><p>应用在离线后将保持缓存状态，除非发生以下某种情况：</p>
<ul>
<li>用户清除了浏览器对您网站的数据存储。</li>
<li>清单文件经过修改。请注意：更新清单中列出的某个文件并不意味着浏览器会重新缓存该资源。清单文件本身必须进行更改。</li>
<li>应用缓存通过编程方式进行更新。</li>
</ul>
<h3 id="缓存状态"><a href="#缓存状态" class="headerlink" title="缓存状态"></a>缓存状态</h3><p>window.applicationCache 对象是对浏览器的应用缓存的编程访问方式。其 status 属性可用于查看缓存的当前状态：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> appCache = <span class="built_in">window</span>.applicationCache;</div><div class="line"></div><div class="line"><span class="keyword">switch</span> (appCache.status) &#123;</div><div class="line">  <span class="keyword">case</span> appCache.UNCACHED: <span class="comment">// UNCACHED == 0</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'UNCACHED'</span>;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> appCache.IDLE: <span class="comment">// IDLE == 1</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'IDLE'</span>;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> appCache.CHECKING: <span class="comment">// CHECKING == 2</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'CHECKING'</span>;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> appCache.DOWNLOADING: <span class="comment">// DOWNLOADING == 3</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'DOWNLOADING'</span>;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> appCache.UPDATEREADY:  <span class="comment">// UPDATEREADY == 4</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'UPDATEREADY'</span>;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> appCache.OBSOLETE: <span class="comment">// OBSOLETE == 5</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'OBSOLETE'</span>;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">default</span>:</div><div class="line">    <span class="keyword">return</span> <span class="string">'UKNOWN CACHE STATUS'</span>;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>用 js  调用 <code>applicationCache.update()</code> 将尝试更新用户的缓存（前提是已更改清单文件）。最后，当 <code>applicationCache.status</code> 处于 <code>UPDATEREADY</code> 状态时，调用 <code>applicationCache.swapCache()</code> 即可将原缓存换成新缓存。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> appCache = <span class="built_in">window</span>.applicationCache;</div><div class="line"></div><div class="line">appCache.update(); <span class="comment">// Attempt to update the user's cache.</span></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">if (appCache.status == <span class="built_in">window</span>.applicationCache.UPDATEREADY) &#123;</div><div class="line">  appCache.swapCache();  <span class="comment">// The fetch was successful, swap in the new cache.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>请注意：以这种方式使用 update() 和 swapCache() 不会向用户提供更新的资源。此流程只是让浏览器检查是否有新的清单、下载指定的更新内容以及重新填充应用缓存。因此，还需要对网页进行两次重新加载才能向用户提供新的内容，其中第一次是获得新的应用缓存，第二次是刷新网页内容。</p>
<p>好消息是，您可以避免重新加载两次的麻烦。要使用户更新到最新版网站，可设置监听器，以监听网页加载时的 updateready 事件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Check if a new cache is available on page load.</span></div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="built_in">window</span>.applicationCache.addEventListener(<span class="string">'updateready'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.applicationCache.status == <span class="built_in">window</span>.applicationCache.UPDATEREADY) &#123;</div><div class="line">      <span class="comment">// Browser downloaded a new app cache.</span></div><div class="line">      <span class="comment">// Swap it in and reload the page to get the new hotness.</span></div><div class="line">      <span class="built_in">window</span>.applicationCache.swapCache();</div><div class="line">      <span class="keyword">if</span> (confirm(<span class="string">'A new version of this site is available. Load it?'</span>)) &#123;</div><div class="line">        <span class="built_in">window</span>.location.reload();</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// Manifest didn't changed. Nothing new to server.</span></div><div class="line">    &#125;</div><div class="line">  &#125;, <span class="literal">false</span>);</div><div class="line"></div><div class="line">&#125;, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<h3 id="applicationCache-事件"><a href="#applicationCache-事件" class="headerlink" title="applicationCache 事件"></a>applicationCache 事件</h3><p>事件会用于监听缓存的状态。浏览器会对下载进度、应用缓存更新和错误状态等情况触发相应事件。以下代码段为每种缓存事件类型设置了事件监听器：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> appCache = <span class="built_in">window</span>.applicationCache;</div><div class="line">unction handleCacheEvent(e) &#123;</div><div class="line">  <span class="comment">//...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleCacheError</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  alert(<span class="string">'Error: Cache failed to update!'</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// Fired after the first cache of the manifest.</span></div><div class="line">appCache.addEventListener(<span class="string">'cached'</span>, handleCacheEvent, <span class="literal">false</span>);</div><div class="line"></div><div class="line"><span class="comment">// Checking for an update. Always the first event fired in the sequence.</span></div><div class="line">appCache.addEventListener(<span class="string">'checking'</span>, handleCacheEvent, <span class="literal">false</span>);</div><div class="line"></div><div class="line"><span class="comment">// An update was found. The browser is fetching resources.</span></div><div class="line">appCache.addEventListener(<span class="string">'downloading'</span>, handleCacheEvent, <span class="literal">false</span>);</div><div class="line"></div><div class="line"><span class="comment">// The manifest returns 404 or 410, the download failed,</span></div><div class="line"><span class="comment">// or the manifest changed while the download was in progress.</span></div><div class="line">appCache.addEventListener(<span class="string">'error'</span>, handleCacheError, <span class="literal">false</span>);</div><div class="line"></div><div class="line"><span class="comment">// Fired after the first download of the manifest.</span></div><div class="line">appCache.addEventListener(<span class="string">'noupdate'</span>, handleCacheEvent, <span class="literal">false</span>);</div><div class="line"></div><div class="line"><span class="comment">// Fired if the manifest file returns a 404 or 410.</span></div><div class="line"><span class="comment">// This results in the application cache being deleted.</span></div><div class="line">appCache.addEventListener(<span class="string">'obsolete'</span>, handleCacheEvent, <span class="literal">false</span>);</div><div class="line"></div><div class="line"><span class="comment">// Fired for each resource listed in the manifest as it is being fetched.</span></div><div class="line">appCache.addEventListener(<span class="string">'progress'</span>, handleCacheEvent, <span class="literal">false</span>);</div><div class="line"></div><div class="line"><span class="comment">// Fired when the manifest resources have been newly redownloaded.</span></div><div class="line">appCache.addEventListener(<span class="string">'updateready'</span>, handleCacheEvent, <span class="literal">false</span>);</div></pre></td></tr></table></figure></p>
<p>如果清单文件或其中指定的资源无法下载，整个更新都将失败。在这种情况下，浏览器将继续使用原应用缓存。</p>
<p>原文： <a href="http://www.html5rocks.com/zh/tutorials/appcache/beginner/" target="_blank" rel="external">应用缓存初级使用指南</a><br><a href="https://html.spec.whatwg.org/#applicationcache" target="_blank" rel="external">html标准</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原生app可以离线操作，在以前是相对web app的优势，web必须联网才能刷新使用。虽然所有浏览器都有缓存机制，但它们并不一定总能起到预期的作用。HTML5 使用 ApplicationCache 接口解决了由离线带来的部分难题。即使用户在离线状态下按了刷新按钮，您的应用也会正常加载和运行。&lt;br&gt;
    
    </summary>
    
      <category term="ApplicationCache" scheme="http://robin-front.github.io/categories/ApplicationCache/"/>
    
      <category term="html5" scheme="http://robin-front.github.io/categories/ApplicationCache/html5/"/>
    
    
      <category term="ApplicationCache" scheme="http://robin-front.github.io/tags/ApplicationCache/"/>
    
      <category term="html5" scheme="http://robin-front.github.io/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>正确检测Javascript数据类型</title>
    <link href="http://robin-front.github.io/2016/06/08/%E6%AD%A3%E7%A1%AE%E6%A3%80%E6%B5%8BJavascript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://robin-front.github.io/2016/06/08/正确检测Javascript数据类型/</id>
    <published>2016-06-08T15:53:10.000Z</published>
    <updated>2016-06-08T15:53:10.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>对于任何变量来说，使用typeof 总是以字符串形式返回以下6种类型之一：</p>
<ul>
<li>number</li>
<li>string</li>
<li>boolean</li>
<li>object</li>
<li>function</li>
<li>undefined</li>
</ul>
<blockquote>
<p>要注意 null 使用 typeof 检测时返回的是 ‘object’<br>对于 null 可以使用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">type</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> (o === <span class="literal">null</span>) ? <span class="string">'null'</span> : <span class="keyword">typeof</span>(o)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="constructor-构造函数属性值"><a href="#constructor-构造函数属性值" class="headerlink" title="constructor(构造函数属性值)"></a>constructor(构造函数属性值)</h3><p>使用 constructor 属性可以判断绝大部分数据的类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>; a.constructor <span class="comment">// number</span></div><div class="line"><span class="keyword">var</span> a = &#123;&#125;; a.constructor <span class="comment">// object</span></div><div class="line"><span class="keyword">var</span> a = []; a.constructor <span class="comment">// array</span></div><div class="line"><span class="keyword">var</span> a = <span class="literal">true</span>; a.constructor <span class="comment">// boolean</span></div><div class="line"><span class="keyword">var</span> a = <span class="string">'true'</span>; a.constructor <span class="comment">// string</span></div><div class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"></span>)</span>&#123;&#125;; a.constructor <span class="comment">// function</span></div></pre></td></tr></table></figure>
<blockquote>
<p>但是对于 <code>undefined</code> 和 <code>null</code> 特殊值，不能能使用 constructor,会直接抛出异常。可以先转换布尔值，如果为 true，则说明不是 undefined 和null , 再调用 constructor属性</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">type</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> !o ? o : (o).constructor</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h3><p>使用 toString() 方法检测对象类型是最安全、最准确的。它返回的字符串形式如下 [object class], 其中， object表示对象的通用类型，class表示对象的内部类型。</p>
<blockquote>
<p>但是，要获取对象class值的唯一方法是必须调用 Object 对象定义的默认 toString() 方法，因为不同对象都会预定义自己的 toString() 方法，所以不能直接调用对象的 toString() 方法。<br>var a = new Date()<br>a.toString() // 当前的UTC时间字符串</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Date</span>()</div><div class="line"><span class="built_in">Object</span>.prototype.toString.apply(a)</div></pre></td></tr></table></figure>
<p>完善的检测方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回值有： 'undefined', 'null', 'number', 'boolean', 'object', 'function', 'regexp', 'string', 'array', 'date', 'error'</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">typeOf</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> _toString =  <span class="built_in">Object</span>.prototype.toString;</div><div class="line">  <span class="keyword">var</span> _type = &#123;</div><div class="line">    <span class="string">'undefined'</span>: <span class="string">'undefined'</span>,</div><div class="line">    <span class="string">'number'</span>: <span class="string">'number'</span>,</div><div class="line">    <span class="string">'boolean'</span>: <span class="string">'boolean'</span>,</div><div class="line">    <span class="string">'string'</span>: <span class="string">'string'</span>,</div><div class="line">    <span class="string">'[object Function]'</span>: <span class="string">'function'</span>,</div><div class="line">    <span class="string">'[object RegExp]'</span>: <span class="string">'regexp'</span>,</div><div class="line">    <span class="string">'[object Array]'</span>: <span class="string">'array'</span>,</div><div class="line">    <span class="string">'[object Date]'</span>: <span class="string">'date'</span>,</div><div class="line">    <span class="string">'[object Error]'</span>: <span class="string">'error'</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> _type[<span class="keyword">typeof</span> o] || _type[_toString.call(o)] || (o ? <span class="string">'object'</span> : <span class="string">'null'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;typeof&quot;&gt;&lt;a href=&quot;#typeof&quot; class=&quot;headerlink&quot; title=&quot;typeof&quot;&gt;&lt;/a&gt;typeof&lt;/h3&gt;&lt;p&gt;对于任何变量来说，使用typeof 总是以字符串形式返回以下6种类型之一
    
    </summary>
    
      <category term="Javascript" scheme="http://robin-front.github.io/categories/Javascript/"/>
    
    
      <category term="Javascript" scheme="http://robin-front.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>git小记</title>
    <link href="http://robin-front.github.io/2016/05/16/git%E5%B0%8F%E8%AE%B0/"/>
    <id>http://robin-front.github.io/2016/05/16/git小记/</id>
    <published>2016-05-16T12:57:45.000Z</published>
    <updated>2016-05-16T12:57:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>有一些不太常用的git命令记录下<br><a id="more"></a></p>
<h3 id="git-amend"><a href="#git-amend" class="headerlink" title="git amend"></a>git amend</h3><p>当一些更改已提交，却发现漏提交了一部分文件，这时就可以用这个命令，可以把漏的部分追加到上一次提交</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git add forgotten_file.rb</div><div class="line">git commit ––amend</div></pre></td></tr></table></figure>
<h3 id="reset-soft"><a href="#reset-soft" class="headerlink" title="reset soft"></a>reset soft</h3><p>刚刚提交，却又发现刚才的代码还有bug，想再次修改后再提交</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset ––soft HEAD^</div></pre></td></tr></table></figure>
<p>注意与 <code>git reset --hard HEAD^</code> 不同的是，<code>--soft</code>并不同把上一次提交的代码删除，只是把它变成未提交的状态，而<code>--hard</code>却会完全撤消上一次提交的代码。</p>
<h3 id="git-blame"><a href="#git-blame" class="headerlink" title="git blame"></a>git blame</h3><p>当你想查出，一个文件里，每一行代码是谁编辑的，可以使用这个命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git blame robin.md</div></pre></td></tr></table></figure>
<h3 id="git-checkout-tags-v1-0"><a href="#git-checkout-tags-v1-0" class="headerlink" title="git checkout tags/v1.0"></a>git checkout tags/v1.0</h3><p>当分支名和标签名相同时，需要这样写</p>
<h3 id="branch-at"><a href="#branch-at" class="headerlink" title="branch_at"></a>branch_at</h3><p>当你想从某一历史版本中开一个分支，而不是最新的版本中开分支，可以这样写：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch test_branch eadnadk213dsafdsafkl234j32ll34l2l</div></pre></td></tr></table></figure></p>
<h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><p>当远程mater分支已更改， 本地又基于旧版本的master进行的提交，可以重新指定基于远程master，之后再提交，避免冲突时把远程的代码merge 掉：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git rebase origin/master master</div><div class="line">git push origin master</div></pre></td></tr></table></figure>
<h3 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h3><p>reflog是git用来记录引用变化的一种机制，比如记录分支的变化或者是HEAD引用的变化。可以用来查找操作记录以及恢复数据</p>
<h3 id="git-submodule-add"><a href="#git-submodule-add" class="headerlink" title="git submodule add"></a>git submodule add</h3><p>添加外部项目为子模块</p>
<h3 id="git-rebase-i"><a href="#git-rebase-i" class="headerlink" title="git rebase -i"></a>git rebase -i</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一些不太常用的git命令记录下&lt;br&gt;
    
    </summary>
    
      <category term="git" scheme="http://robin-front.github.io/categories/git/"/>
    
    
      <category term="git" scheme="http://robin-front.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>pm2一个带有负载均衡功能的Node应用的进程管理器</title>
    <link href="http://robin-front.github.io/2016/05/04/pm2%E4%B8%80%E4%B8%AA%E5%B8%A6%E6%9C%89%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8A%9F%E8%83%BD%E7%9A%84Node%E5%BA%94%E7%94%A8%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    <id>http://robin-front.github.io/2016/05/04/pm2一个带有负载均衡功能的Node应用的进程管理器/</id>
    <published>2016-05-04T14:04:27.000Z</published>
    <updated>2016-05-04T14:04:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>PM2是一个提供了内置的负载均衡的Node.js应用程序进程管理器。它可以让你保持应用程序永远在线，无需停机地重启应用，也有助于系统管理员工作。<br><a id="more"></a></p>
<h3 id="安装-PM2"><a href="#安装-PM2" class="headerlink" title="安装 PM2"></a>安装 PM2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install pm2 -g</div></pre></td></tr></table></figure>
<h3 id="启动应用"><a href="#启动应用" class="headerlink" title="启动应用"></a>启动应用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pm2 start app.js</div></pre></td></tr></table></figure>
<p>这样，应用就已经在后台启动，并被监测保持在线。</p>
<h3 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h3><p>PM2 内嵌一个简单强大的模块系统，可以直接像下面这样安装模块<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pm2 install &lt;module_name&gt;</div></pre></td></tr></table></figure></p>
<ul>
<li><a href="https://github.com/pm2-hive/pm2-logrotate" target="_blank" rel="external">pm2-logrotate</a> 日志管理及分割模块</li>
<li><a href="https://github.com/pm2-hive/pm2-webshell" target="_blank" rel="external">pm2-webshell</a> 强大的浏览器模拟终端</li>
<li><a href="https://github.com/pm2-hive/pm2-auto-pull" target="_blank" rel="external">pm2-auto-pull</a> 持续集成，自动拉取代码</li>
</ul>
<h3 id="更新PM2"><a href="#更新PM2" class="headerlink" title="更新PM2"></a>更新PM2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Install latest pm2 version</span></div><div class="line">$ npm install pm2 -g</div><div class="line"><span class="comment"># Save process list, exit old PM2 &amp; restore all processes</span></div><div class="line">$ pm2 update</div></pre></td></tr></table></figure>
<h3 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h3><h4 id="命令概览"><a href="#命令概览" class="headerlink" title="命令概览"></a>命令概览</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">$ npm install pm2 -g            <span class="comment"># Install PM2</span></div><div class="line">$ pm2 start app.js              <span class="comment"># Start, Daemonize and auto restart application</span></div><div class="line">$ pm2 start app.js -i 4         <span class="comment"># Start 4 instances of application in cluster mode</span></div><div class="line">                                <span class="comment"># it will load balance network queries to each app</span></div><div class="line">$ pm2 start app.js --name=<span class="string">"api"</span> <span class="comment"># Start application and name it "api"</span></div><div class="line">$ pm2 start app.js --watch      <span class="comment"># Restart application on file change</span></div><div class="line">$ pm2 start script.sh           <span class="comment"># Start bash script</span></div><div class="line"></div><div class="line">$ pm2 list                      <span class="comment"># List all processes started with PM2</span></div><div class="line">$ pm2 monit                     <span class="comment"># Display memory and cpu usage of each app</span></div><div class="line">$ pm2 show [app-name]           <span class="comment"># Show all informations about application</span></div><div class="line"></div><div class="line">$ pm2 logs                      <span class="comment"># Display logs of all apps</span></div><div class="line">$ pm2 logs [app-name]           <span class="comment"># Display logs for a specific app</span></div><div class="line">$ pm2 flush</div><div class="line"></div><div class="line">$ pm2 stop all                  <span class="comment"># Stop all apps</span></div><div class="line">$ pm2 stop 0                    <span class="comment"># Stop process with id 0</span></div><div class="line">$ pm2 restart all               <span class="comment"># Restart all apps</span></div><div class="line">$ pm2 reload all                <span class="comment"># Reload all apps in cluster mode</span></div><div class="line">$ pm2 gracefulReload all        <span class="comment"># Graceful reload all apps in cluster mode</span></div><div class="line">$ pm2 delete all                <span class="comment"># Kill and delete all apps</span></div><div class="line">$ pm2 delete 0                  <span class="comment"># Delete app with id 0</span></div><div class="line">$ pm2 scale api 10              <span class="comment"># Scale app with name api to 10 instances</span></div><div class="line">$ pm2 reset [app-name]          <span class="comment"># Reset number of restart for [app-name]</span></div><div class="line"></div><div class="line">$ pm2 startup                   <span class="comment"># Generate a startup script to respawn PM2 on boot</span></div><div class="line">$ pm2 save                      <span class="comment"># Save current process list</span></div><div class="line">$ pm2 resurrect                 <span class="comment"># Restore previously save processes</span></div><div class="line">$ pm2 update                    <span class="comment"># Save processes, kill PM2 and restore processes</span></div><div class="line">$ pm2 generate                  <span class="comment"># Generate a sample json configuration file</span></div><div class="line"></div><div class="line">$ pm2 deploy app.json prod setup    <span class="comment"># Setup "prod" remote server</span></div><div class="line">$ pm2 deploy app.json prod          <span class="comment"># Update "prod" remote server</span></div><div class="line">$ pm2 deploy app.json prod revert 2 <span class="comment"># Revert "prod" remote server by 2</span></div><div class="line"></div><div class="line">$ pm2 module:generate [name]    <span class="comment"># Generate sample module with name [name]</span></div><div class="line">$ pm2 install pm2-logrotate     <span class="comment"># Install module (here a log rotation system)</span></div><div class="line">$ pm2 uninstall pm2-logrotate   <span class="comment"># Uninstall module</span></div><div class="line">$ pm2 publish                   <span class="comment"># Increment version, git push and npm publish</span></div></pre></td></tr></table></figure>
<h4 id="开启进程的多种方式"><a href="#开启进程的多种方式" class="headerlink" title="开启进程的多种方式"></a>开启进程的多种方式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ pm2 start app.js --watch      <span class="comment"># Restart application on file change</span></div><div class="line">$ pm2 start script.sh           <span class="comment"># Start bash script</span></div><div class="line">$ pm2 start app.js -- <span class="_">-a</span> 34     <span class="comment"># Start app and pass option -a 34</span></div><div class="line">$ pm2 start app.json            <span class="comment"># Start all applications declared in app.json</span></div><div class="line">$ pm2 start my-python-script.py --interpreter python</div></pre></td></tr></table></figure>
<h4 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h4><p>列出所有进程：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pm2 list</div></pre></td></tr></table></figure></p>
<p>管理进程<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ pm2 stop     &lt;app_name|id|<span class="string">'all'</span>|json_conf&gt;</div><div class="line">$ pm2 restart  &lt;app_name|id|<span class="string">'all'</span>|json_conf&gt;</div><div class="line">$ pm2 delete   &lt;app_name|id|<span class="string">'all'</span>|json_conf&gt;</div></pre></td></tr></table></figure></p>
<p>查看进程的详情<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pm2 describe &lt;id|app_name&gt;</div></pre></td></tr></table></figure></p>
<h4 id="CPU-内存监测"><a href="#CPU-内存监测" class="headerlink" title="CPU / 内存监测"></a>CPU / 内存监测</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pm2 monit</div></pre></td></tr></table></figure>
<h4 id="日志工具"><a href="#日志工具" class="headerlink" title="日志工具"></a>日志工具</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pm2 logs [<span class="string">'all'</span>|<span class="string">'PM2'</span>|app_name|app_id] [--err|--out] [--lines &lt;n&gt;] [--raw] [--timestamp [format]]</div></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ pm2 logs</div><div class="line">$ pm2 logs WEB-API --err</div><div class="line">$ pm2 logs all --raw</div><div class="line">$ pm2 logs --lines 5</div><div class="line">$ pm2 logs --timestamp <span class="string">"HH:mm:ss"</span></div><div class="line">$ pm2 logs WEB-API --lines 0 --timestamp <span class="string">"HH:mm"</span> --out</div><div class="line">$ pm2 logs PM2 --timestamp</div><div class="line"></div><div class="line">$ pm2 flush          // Clear all the logs</div></pre></td></tr></table></figure>
<h4 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h4><p>PM2可以自动生成并配置开机启动脚本，让服务器在重启的时候可以保持应用在线</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ pm2 startup</div><div class="line"><span class="comment"># auto-detect platform</span></div><div class="line">$ pm2 startup [platform]</div><div class="line"><span class="comment"># render startup-script for a specific platform, the [platform] could be one of:</span></div><div class="line"><span class="comment">#   ubuntu|centos|redhat|gentoo|systemd|darwin|amazon</span></div></pre></td></tr></table></figure>
<p><a href="http://pm2.keymetrics.io/docs/usage/quick-start/" target="_blank" rel="external">更多查看&gt;&gt;</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PM2是一个提供了内置的负载均衡的Node.js应用程序进程管理器。它可以让你保持应用程序永远在线，无需停机地重启应用，也有助于系统管理员工作。&lt;br&gt;
    
    </summary>
    
      <category term="Node" scheme="http://robin-front.github.io/categories/Node/"/>
    
    
      <category term="Node" scheme="http://robin-front.github.io/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>Node.js的cluster模块发挥CPU的多核优势</title>
    <link href="http://robin-front.github.io/2016/04/24/Node-js%E7%9A%84cluster%E6%A8%A1%E5%9D%97%E5%8F%91%E6%8C%A5CPU%E7%9A%84%E5%A4%9A%E6%A0%B8%E4%BC%98%E5%8A%BF/"/>
    <id>http://robin-front.github.io/2016/04/24/Node-js的cluster模块发挥CPU的多核优势/</id>
    <published>2016-04-24T14:20:00.000Z</published>
    <updated>2016-04-24T14:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个Node.js应用程序只能使用在一个线程中。为了充分发挥多核CPU的优势，Node.js中提供了一个 <code>cluster</code>模块，允许在多个子进程中运行不同的Node.js应用程序。<code>cluster</code>模块是对 <code>child_process.fork()</code>的一个封装。<br><a id="more"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个Node.js应用程序只能使用在一个线程中。为了充分发挥多核CPU的优势，Node.js中提供了一个 &lt;code&gt;cluster&lt;/code&gt;模块，允许在多个子进程中运行不同的Node.js应用程序。&lt;code&gt;cluster&lt;/code&gt;模块是对 &lt;code&gt;child_process.fork()&lt;/code&gt;的一个封装。&lt;br&gt;
    
    </summary>
    
      <category term="Node" scheme="http://robin-front.github.io/categories/Node/"/>
    
    
      <category term="Node" scheme="http://robin-front.github.io/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>子进程child_process让Node.js具备命令行的功能</title>
    <link href="http://robin-front.github.io/2016/04/22/%E5%AD%90%E8%BF%9B%E7%A8%8Bchild-process%E8%AE%A9Node-js%E5%85%B7%E5%A4%87%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E5%8A%9F%E8%83%BD/"/>
    <id>http://robin-front.github.io/2016/04/22/子进程child-process让Node-js具备命令行的功能/</id>
    <published>2016-04-21T16:02:56.000Z</published>
    <updated>2016-04-21T16:02:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>Node</code>中使用子进程的目的，正是希望从<code>Node</code>应用程序中通过命令行的方式访问计算机资源。<br><a id="more"></a></p>
<p>共有四种不同的技术来创建一个子进程</p>
<h3 id="child-process-spawn"><a href="#child-process-spawn" class="headerlink" title="child_process.spawn"></a>child_process.spawn</h3><p><code>spawn</code>是创建子进程最常见的方法。例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> spawn = <span class="built_in">require</span>(<span class="string">'child_process'</span>).spawn,</div><div class="line">    pwd = spawn(<span class="string">'pwd'</span>);</div><div class="line"></div><div class="line">pwd.stdout.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'stdout:'</span> + data);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">pwd.stderr.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'stderr'</span> + data);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">pwd.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">code</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'child process close with code'</span> + code);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">pwd.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">code</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'child process exit with code'</span> + code);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li>参数作为数组传入</li>
<li>子进程对 <code>stdout</code> 和 <code>stderr</code> 相关事件可以进行捕获</li>
<li>子进程退出代码为 1，表示发生了错误；没有错误时，退出代码为 0</li>
<li>尽量使用<code>close</code>事件而不是<code>exit</code>事件，在进程结束后访问其数据可能会导致应用程序崩溃</li>
</ul>
<p>如何使用 <code>stdin</code> 标准输入对象呢：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> spawn = <span class="built_in">require</span>(<span class="string">'child_process'</span>).spawn,</div><div class="line">    find = spawn(<span class="string">'find'</span>, [<span class="string">'.'</span>, <span class="string">'-ls'</span>]),</div><div class="line">    grep = spawn(<span class="string">'grep'</span>, [<span class="string">'test'</span>]);</div><div class="line"></div><div class="line">grep.stdout.setEncoding(<span class="string">'utf8'</span>);</div><div class="line"></div><div class="line">find.stdout.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">  grep.stdin.write(data);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">grep.stdout.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(data);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>上面这段例子模拟了<code>Unix</code>管道（|）功能，可以将一个命令的结果传递给另一个命令作为输入。</p>
<h3 id="child-process-exec-和-child-process-execFile"><a href="#child-process-exec-和-child-process-execFile" class="headerlink" title="child_process.exec 和 child_process.execFile"></a>child_process.exec 和 child_process.execFile</h3><p>通过 <code>child_process.exec</code> 和 <code>child_process.execFile</code> 来启动 <code>shell</code> 执行命令可以缓存命令执行的结果</p>
<p><code>child_process.execFile</code> 的第一个参数是命令或执行文件路径， 第二个参数是可选参数列表， 第三个参数是回调函数，该回调函数有三个参数： error, stdout 和 stderr。如果没有发生错误，执行结果会保存到 stdout。</p>
<p><code>child_process.exec</code> 则没有可选参数列表，只有 <code>execFile</code> 方法的第一个和第三个参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> execFile = <span class="built_in">require</span>(<span class="string">'child_process'</span>).execFile,</div><div class="line">    child;</div><div class="line"></div><div class="line">child = execFile(<span class="string">'ls'</span>, [<span class="string">'-l'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">error, stdout, stderr</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span> (error == <span class="literal">null</span>) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'stdout: '</span> + stdout);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>execFile</code> 方法会更安全，因为它的命令行参数作为数组传入。</p>
<h3 id="child-process-fork"><a href="#child-process-fork" class="headerlink" title="child_process.fork"></a>child_process.fork</h3><p><code>fork</code> 其实是对 <code>spawn</code>的封装，目的是为了启动子进程并运行 <code>Node.js</code>模块。</p>
<p>例：<br><code>fork(&#39;./child.js&#39;)</code> 相当于 <code>spawn(&#39;node&#39;, [&#39;./child.js&#39;])</code></p>
<p>此方法会在父进程与子进程之间建立一个真实的通信管道，用于进程之间的通信。但通过<code>fork</code>生成的每个子进程都需要一个全新的 V8 实例，这需要耗费更多时间和内存。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> n = child_process.fork(<span class="string">'./child.js'</span>);</div><div class="line">n.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">m</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'PARENT got message:'</span>, m);</div><div class="line">&#125;);</div><div class="line">n.send(&#123; <span class="attr">hello</span>: <span class="string">'world'</span> &#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p><code>send</code> 方法用于进程间通信， 通过监听<code>message</code>事件来获取消息</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;code&gt;Node&lt;/code&gt;中使用子进程的目的，正是希望从&lt;code&gt;Node&lt;/code&gt;应用程序中通过命令行的方式访问计算机资源。&lt;br&gt;
    
    </summary>
    
      <category term="Node" scheme="http://robin-front.github.io/categories/Node/"/>
    
    
      <category term="Node" scheme="http://robin-front.github.io/tags/Node/"/>
    
  </entry>
  
</feed>
