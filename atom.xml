<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>三寸稚笔</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://robin-front.github.io/"/>
  <updated>2017-06-01T10:16:43.000Z</updated>
  <id>http://robin-front.github.io/</id>
  
  <author>
    <name>robin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RXJS我该选用哪个操作符之-创建篇</title>
    <link href="http://robin-front.github.io/2017/06/01/RXJS%E6%88%91%E8%AF%A5%E9%80%89%E7%94%A8%E5%93%AA%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8B-%E5%88%9B%E5%BB%BA%E7%AF%87/"/>
    <id>http://robin-front.github.io/2017/06/01/RXJS我该选用哪个操作符之-创建篇/</id>
    <published>2017-06-01T10:16:43.000Z</published>
    <updated>2017-06-01T10:16:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>RXJS该怎么上手？这么多操作符该用哪个？RXJS比较强大，操作符众多，想熟悉需要比较长时间的运用，所以大部分新手都比较疑惑应该使用哪些操作符去实现自己的数据流的操作。</p>
<p>更多详情请翻阅 <a href="https://robin-front.github.io/RxJS-doc-chinese">RXJS中文翻译文档</a></p>
<h1 id="我该选用哪个操作符-创建操作符"><a href="#我该选用哪个操作符-创建操作符" class="headerlink" title="我该选用哪个操作符? - 创建操作符"></a>我该选用哪个操作符? - 创建操作符</h1><p>使用此页面查找<a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/index.html"><code>Observable</code></a>符合您需求的类型创建操作：
<a id="more"></a></p>
<table style="display: table">
<thead>静态方法</thead>
<tbody>
    <!-- Observable factories -->
    <tr>
        <td rowspan="26">我想创建一个新的序列</td>
        <td rowspan="4">使用自定义逻辑</td>
        <td colspan="2"></td>
        <td>
            <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/create.html">Observable.create</a>
        </td>
    </tr>
    <tr>
        <td rowspan="3">像一个for循环</td>
        <td></td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/generate.html">Observable.generate</a></td>
    </tr>
    <tr>
        <td rowspan="2">并随时间发射值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/generatewithrelativetime.html">Observable.generateWithRelativeTime</a></td>
    </tr>
    <tr>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/generatewithabsolutetime.html">Observable.generateWithAbsoluteTime</a></td>
    </tr>
    <tr>
        <td rowspan="2">它返回一个值</td>
        <td colspan="2"></td>
        <td>
            <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/return.html">Observable.return/just</a>
        </td>
    </tr>
    <tr>
        <td colspan="2">多次</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/repeat.html">Observable.repeat</a></td>
    </tr>
    <tr>
        <td colspan="3">这会抛出错误</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/throw.html">Observable.throw</a></td>
    </tr>
    <tr>
        <td colspan="3">完成了</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/empty.html">Observable.empty</a></td>
    </tr>
    <tr>
        <td colspan="3">从来没有做任何事情</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/never.html">Observable.never</a></td>
    </tr>
    <tr>
        <td rowspan="2">从事件</td>
        <td colspan="2"></td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/fromevent.html">Observable.fromEvent</a></td>
    </tr>
    <tr>
        <td colspan="2">它使用自定义函数来添加和删除事件处理程序</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/fromeventpattern.html">Observable.fromEventPattern</a></td>
    </tr>
    <tr>
        <td colspan="3">来自一个<a title="ES6 Promise" href="https://www.promisejs.org" target="_blank" rel="external">ES6 Promise</a></td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/frompromise.html">Observable.fromPromise</a></td>
    </tr>
    <tr>
        <td rowspan="6">它可迭代</td>
        <td rowspan="2">覆盖到数组中的值</td>
        <td></td>
        <td>
            <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/fromarray.html">Observable.fromArray</a><br>
        </td>
    </tr>
    <tr>
      <td>对象键/值对</td>
      <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/pairs.html">Observable.pairs</a></td>
    </tr>
    <tr>
        <td colspan="2">异步元素</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/for.html">Observable.for</a></td>
    </tr>
    <tr>
        <td colspan="2">数值范围内的值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/range.html">Observable.range</a></td>
    </tr>
    <tr>
        <td colspan="2">来自一个可迭代的数组或类似数组的对象的值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/from.html">Observable.from</a></td>
    </tr>
    <tr>
        <td colspan="2">来自参数</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/of.html">Observable.of</a></td>
    </tr>
    <tr>
        <td rowspan="2">根据定时器发出值</td>
        <td colspan="2"></td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/interval.html">Observable.interval</a></td>
    </tr>
    <tr>
        <td colspan="2">具有可选的初始延迟</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/timer.html">Observable.timer</a></td>
    </tr>
    <tr>
        <td rowspan="2" colspan="2">不传参调用函数</td>
        <td>在特定的调度程序</td>
        <td>
            <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/start.html">Observable.start</a>
        </td>
    </tr>
    <tr>
        <td>异步</td>
        <td>
            <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/startasync.html">Observable.startAsync</a>
        </td>
    </tr>
    <tr>
        <td rowspan="4">取决于订阅时</td>
        <td colspan="2">基于布尔条件</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/if.html">Observable.if</a></td>
    </tr>
    <tr>
        <td colspan="2">f从一组预先设定的序列</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/case.html">Observable.case</a></td>
    </tr>
    <tr>
        <td colspan="1" rowspan="2">使用自定义逻辑</td>
        <td></td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/defer.html">Observable.defer</a></td>
    </tr>
    <tr>
        <td>它取决于资源</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/using.html">Observable.using</a></td>
    </tr>
    <!-- Function factories -->
    <tr>
        <td rowspan="3">我想包装一个函数</td>
        <td colspan="2"></td>
        <td rowspan="3">并产生一个序列的结果</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/toasync.html">Observable.toAsync</a></td>
    </tr>
        <td colspan="2">它接受回调</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/fromcallback.html">Observable.fromCallback</a></td>
    
    <tr>
        <td colspan="2">它接受Node.js回调</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/fromnodecallback.html">Observable.fromNodeCallback</a></td>
    </tr>
    <!-- Flatteners -->
    <tr>
        <td rowspan="30">我想结合多个序列</td>
        <td colspan="3">并且仅从产生值的序列中接收值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/amb.html">Observable.amb</a></td>
    </tr>
    <tr>
        <td colspan="3">所有人都已经完成通知</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/forkjoin.html">Observable.forkJoin</a></td>
    </tr>
    <tr>
        <td colspan="3">并输出所有这些值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/merge.html">Observable.merge</a></td>
    </tr>
    <tr>
        <td rowspan="2">为了</td>
        <td colspan="2">不改变时重复使用最新值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/operators/combinelatest.html">Observable.combineLatest</a></td>
    </tr>
    <tr>
        <td colspan="2">每个值只使用一次</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/zip.html">Observable.zip</a></td>
    </tr>
    <tr>
        <td rowspan="3">通过订阅每个序列为了</td>
        <td colspan="2">当前一个序列完成时</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/concat.html">Observable.concat</a></td>
    </tr>
    <tr>
        <td colspan="2">当另一个序列抛出错误时</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/catch.html">Observable.catch</a></td>
    </tr>
    <tr>
        <td colspan="2">不管先前的序列是完成还是抛出错误</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/onerrorresumenext.html">Observable.onErrorResumeNext</a></td>
    </tr>
    <tr>
        <td colspan="3">通过响应不同的值组合<a href="http://en.wikipedia.org/wiki/Join-calculus" target="_blank" rel="external">（连接微积分）</a></td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/when.html">Observable.when</a></td>
    </tr>
</tbody></table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RXJS该怎么上手？这么多操作符该用哪个？RXJS比较强大，操作符众多，想熟悉需要比较长时间的运用，所以大部分新手都比较疑惑应该使用哪些操作符去实现自己的数据流的操作。&lt;/p&gt;
&lt;p&gt;更多详情请翻阅 &lt;a href=&quot;https://robin-front.github.io/RxJS-doc-chinese&quot;&gt;RXJS中文翻译文档&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;我该选用哪个操作符-创建操作符&quot;&gt;&lt;a href=&quot;#我该选用哪个操作符-创建操作符&quot; class=&quot;headerlink&quot; title=&quot;我该选用哪个操作符? - 创建操作符&quot;&gt;&lt;/a&gt;我该选用哪个操作符? - 创建操作符&lt;/h1&gt;&lt;p&gt;使用此页面查找&lt;a href=&quot;https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/index.html&quot;&gt;&lt;code&gt;Observable&lt;/code&gt;&lt;/a&gt;符合您需求的类型创建操作：
    
    </summary>
    
      <category term="RXJS" scheme="http://robin-front.github.io/categories/RXJS/"/>
    
    
      <category term="RXJS" scheme="http://robin-front.github.io/tags/RXJS/"/>
    
  </entry>
  
  <entry>
    <title>RXJS我该选用哪个操作符之-实例操作符篇</title>
    <link href="http://robin-front.github.io/2017/06/01/RXJS%E6%88%91%E8%AF%A5%E9%80%89%E7%94%A8%E5%93%AA%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8B-%E5%AE%9E%E4%BE%8B%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%AF%87/"/>
    <id>http://robin-front.github.io/2017/06/01/RXJS我该选用哪个操作符之-实例操作符篇/</id>
    <published>2017-06-01T09:54:53.000Z</published>
    <updated>2017-06-01T09:54:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>RXJS比较强大，操作符众多，想熟悉需要比较长时间的运用，所以大部分新手都比较疑惑应该使用哪些操作符去实现自己的数据流的操作。</p>
<p>更多详情请翻阅 <a href="https://robin-front.github.io/RxJS-doc-chinese">RXJS中文翻译文档</a></p>
<h1 id="我该选用哪个操作符-实例操作符"><a href="#我该选用哪个操作符-实例操作符" class="headerlink" title="我该选用哪个操作符? - 实例操作符"></a>我该选用哪个操作符? - 实例操作符</h1><p>使用此页面通过类型查找<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md" target="_blank" rel="external"><code>Observable</code></a> 适合您需要的实例运算符：
<a id="more"></a></p>
<table style="display: table">
<thead>实例操作符</thead>
<tbody>
    <!-- Observable operators -->
    <tr>
        <td rowspan="71">使用现有的序列</td>
        <td colspan="3">我想改变每个值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/select.html">map/select</a></td>
    </tr>
    <tr>
        <td colspan="3">我想从每个值拉一个属性</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/pluck.html">pluck</a></td>
    </tr>
    <tr>
        <td colspan="3">我想在不影响值的情况下被通知值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/do.html">do/tap</a><br>
            <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/doonnext.html">doOnNext/tapOnNext</a><br>
            <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/doonerror.html">doOnError/tapOnError</a><br>
            <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/dooncompleted.html">doOnCompleted/tapOnCompleted</a></td>
    </tr>
    <tr>
        <td rowspan="6">我想包含值</td>
        <td colspan="2">基于自定义逻辑</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/where.html">filter/where</a></td>
    </tr>
    <tr>
        <td rowspan="2">从序列开头</td>
        <td></td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/take.html">take</a></td>
    </tr>
    <tr>
        <td>基于自定义逻辑</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/takewhile.html">takeWhile</a></td>
    </tr>
    <tr>
    </tr>
    <tr>
        <td colspan="2">从序列的末尾</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/takelast.html">takeLast</a></td>
    </tr>
    <tr>
        <td colspan="2">直到另一个序列发射一个值或完成</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/takeuntil.html">takeUntil</a></td>
    </tr>
    <tr>
        <td rowspan="7">我想忽略值</td>
        <td colspan="2">全部</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/ignoreelements.html">ignoreElements</a></td>
    </tr>
    <tr>
        <td rowspan="2">从序列的开头</td>
        <td></td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/skip.html">skip</a></td>
    </tr>
    <tr>
        <td>基于自定义逻辑</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/skipwhile.html">skipWhile</a></td>
    </tr>
    <tr>
        <td colspan="2">从序列的末尾</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/skiplast.html">skipLast</a></td>
    </tr>
    <tr>
        <td colspan="2">直到另一个序列发出一个值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/skipuntil.html">skipUntil</a></td>
    </tr>
    <tr>
        <td colspan="2">与以前的值相同</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/distinctuntilchanged.html">distinctUntilChanged</a></td>
    </tr>
    <tr>
        <td colspan="2">这（触发）太频繁</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/throttle.html">throttle</a></td>
    </tr>
    <tr>
        <td rowspan="4">我想计算</td>
        <td>总和</td>
        <td rowspan="2">这些值的</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/sum.html">sum</a></td>
    </tr>
    <tr>
        <td>平均值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/average.html">average</a></td>
    </tr>
    <tr>
        <td rowspan="2">使用自定义逻辑</td>
        <td>并且只输出最终值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/aggregate.html">aggregate</a><br>
            <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/reduce.html">reduce</a>
        </td>
    </tr>
    <tr>
        <td>并在计算出值时输出（每一步的）值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/scan.html">scan</a></td>
    </tr>
    <tr>
        <td rowspan="3">我想用元数据包装它的消息</td>
        <td colspan="2">描述每个消息</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/materialize.html">materialize</a></td>
    </tr>
    <tr>
        <td colspan="2">包括从最后一个价值以来的时间</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/timeinterval.html">timeInterval</a></td>
    </tr>
    <tr>
        <td colspan="2">包括时间戳</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/timestamp.html">timestamp</a></td>
    </tr>
    <tr>
        <td rowspan="2">经过一段时间的不活动</td>
        <td colspan="2">我想抛出一个错误</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/timeout.html">timeout</a></td>
    </tr>
    <tr>
        <td colspan="2">我想切换到另一个序列</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/timeout.html">timeout</a></td>
    </tr>
    <tr>
        <td rowspan="2">我想确保只有一个值</td>
        <td colspan="2">并且如果存在多于或少于一个值则抛出错误</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/single.html">single</a></td>
    </tr>
    <tr>
        <td colspan="2">并且如果没有值，则使用默认值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/singleordefault.html">singleOrDefault</a></td>
    </tr>
    <tr>
        <td rowspan="3">我只想取第一个值</td>
        <td colspan="2">并且如果没有值，则抛出错误</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/first.html">first</a></td>
    </tr>
    <tr>
        <td colspan="2">并且如果没有值，则使用默认值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/firstordefault.html">firstOrDefault</a></td>
    </tr>
    <tr>
        <td colspan="2">在一段时间内</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/sample.html">sample</a></td>
    </tr>
    <tr>
        <td rowspan="2">我只想取最后的值</td>
        <td colspan="2">如果没有值，则报错</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/last.html">last</a></td>
    </tr>
    <tr>
        <td colspan="2">并且如果没有值，则使用默认值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/lastordefault.html">lastOrDefault</a></td>
    </tr>
    <tr>
        <td colspan="3">我想知道它包含多少值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/count.html">count</a></td>
    </tr>
    <tr>
        <td colspan="3">我想知道它是否包含一个指定的值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/includes.html">contains</a></td>
    </tr>
    <tr>
        <td rowspan="2">我想知道条件是否满足</td>
        <td colspan="2">只需要任一值满足</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/any.html">any/some</a></td>
    </tr>
    <tr>
        <td colspan="2">需要所有值都满足</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/every.html">all/every</a></td>
    </tr>
    <tr>
        <td rowspan="2" colspan="2">我想把消息延迟一段特定的时间</td>
        <td></td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/delay.html">delay</a></td>
    </tr>
    <tr>
        <td>基于自定义逻辑</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/delaywithselector.html">delayWithSelector</a></td>
    </tr>
    <tr>
        <td rowspan="11">我想给值分组</td>
        <td colspan="2">直到序列完成</td>
        <td>
          <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/toarray.html">toArray</a><br>
          <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/tomap.html">toMap</a><br>
          <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/toset.html">toSet</a>
        </td>
    </tr>
    <tr>
        <td rowspan="2">使用自定义逻辑</td>
        <td>作为数组</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/buffer.html">buffer</a></td>
    </tr>
    <tr>
        <td>作为序列</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/window.html">window</a></td>
    </tr>
    <tr>
        <td rowspan="2">根据特定大小分批</td>
        <td>作为数组</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/bufferwithcount.html">bufferWithCount</a></td>
    </tr>
    <tr>
        <td>作为序列</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/windowwithcount.html">windowWithCount</a></td>
    </tr>
    <tr>
        <td rowspan="2">基于时间</td>
        <td>作为数组</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/bufferwithtime.html">bufferWithTime</a></td>
    </tr>
    <tr>
        <td>作为序列</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/windowwithtime.html">windowWithTime</a></td>
    </tr>
    <tr>
        <td rowspan="2">基于时间或计数，以先发生者为准</td>
        <td>作为数组</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/bufferwithtimeorcount.html">bufferWithTimeOrCount</a></td>
    </tr>
    <tr>
        <td>作为序列</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/windowwithtimeorcount.html">windowWithTimeOrCount</a></td>
    </tr>
    <tr>
        <td rowspan="2">基于一个指定的key</td>
        <td>直到序列完成</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/groupby.html">groupBy</a></td>
    </tr>
    <tr>
        <td>并控制每组的生命周期</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/groupbyuntil.html">groupByUntil</a></td>
    </tr>
    <tr>
        <td rowspan="6">我想为每个值开始一个新的序列</td>
        <td colspan="2">并且并行地从所有序列中发出值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/selectmany.html">flatMap/selectMany</a></td>
    </tr>
    <tr>
        <td colspan="2">并按顺序从每个序列中输出值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/concatmap.html">concatMap/selectConcat</a></td>
    </tr>
    <tr>
        <td colspan="2">并在新值到达时取消先前的序列</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/flatmaplatest.html">flatMapLatest/selectSwitch</a></td>
    </tr>
    <tr>
        <td colspan="2">并递归地为每个新值启动一个新的序列</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/expand.html">expand</a></td>
    </tr>
    <tr>
        <td colspan="2">并根据onNext，onError和onCompleted并行地从所有序列发出值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/flatmapobserver.html">flatMapObserver/selectManyObserver</a></td>
    </tr>
    <tr>
        <td colspan="2">并根据onNext，onError和onCompleted顺序地从所有序列发出值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/flatmapobserver.html">concatMapObserver/selectConcatObserver</a></td>
    </tr>
    <tr>
        <td>我想把它与另一个结合起来</td>
        <td colspan="2">两者都完成时发出通知</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/forkjoin.html">forkJoin</a></td>
    </tr>
    <tr>
        <td colspan="3">我想执行复杂的操作，而不会打破流畅的调用</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/let.html">let</a></td>
    </tr>
    <tr>
        <td rowspan="5">我想在多个订阅者之间共享订阅</td>
        <td colspan="2">使用特定的<code>subject</code>实现</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/multicast.html">multicast</a></td>
    </tr>
    <tr>
        <td colspan="2"></td>
        <td>
          <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/publish.html">publish</a><br>
          <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/share.html">share</a>
        </td>
    </tr>
    <tr>
        <td colspan="2">并向未来订阅者提供最后的值</td>
        <td>
          <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/publishlast.html">publishLast</a><br>
          <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/sharelast.html">shareLast</a>
        </td>
    </tr>
    <tr>
        <td colspan="2">并向未来订阅者重播默认值或最新值</td>
        <td>
          <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/publishvalue.html">publishValue</a><br>
          <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/sharevalue.html">shareValue</a>
        </td>
    </tr>
    <tr>
        <td colspan="2">并向未来的订阅者重播n个值</td>
        <td>
          <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/publish.html">replay</a><br>
          <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/share.html">shareReplay</a>
        </td>
    </tr>
    <tr>
        <td rowspan="3">发生错误时</td>
        <td colspan="2">我想重新订阅</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/retry.html">retry</a></td>
    </tr>
    <tr>
        <td rowspan="2">我想开始一个新序列</td>
        <td></td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/catch.html">catch</a></td>
    </tr>
    <tr>
        <td>取决于错误</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/catch.html">catch</a></td>
    </tr>
    <tr>
        <td rowspan="2">当完成时</td>
        <td colspan="2">我想重新订阅</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/repeat.html">repeat</a></td>
    </tr>
    <tr>
        <td colspan="2">我想开始一个新序列</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/concat.html">concat</a></td>
    </tr>
    <tr>
        <td>当完成或抛出错误时</td>
        <td colspan="2">我想开始一个新序列</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/onerrorresumenext.html">onErrorResumeNext</a></td>
    </tr>
    <tr>
        <td>当完成，抛出错误或退订时</td>
        <td colspan="2">我想执行一个函数</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/finally.html">finally</a></td>
    </tr>
    <tr>
        <td rowspan="2">我想改变路由的调度程序</td>
        <td colspan="2">调用<code>subscribe</code>（订阅）</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/subscribeon.html">subscribeOn</a></td>
    </tr>
    <tr>
        <td colspan="2">消息</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/observeon.html">observeOn</a></td>
    </tr>
    <tr>
        <td rowspan="9">使用两个序列</td>
        <td>我想决定从哪个接收值</td>
        <td colspan="2">取决于哪个序列先发出值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/amb.html">amb</a></td>
    </tr>
    <tr>
        <td colspan="3">我想确定它们的值是否相等</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/sequenceequal.html">sequenceEqual</a></td>
    </tr>
    <tr>
        <td rowspan="5">我想合并它们的值</td>
        <td colspan="2">只有当第一个序列发射时，使用每个序列的最新值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/withlatestfrom.html">withLatestFrom</a></td>
    </tr>
    <tr>
        <td rowspan="2">为了</td>
        <td>不改变时重复使用最新值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/combinelatest.html">combineLatest</a></td>
    </tr>
    <tr>
        <td>每个值只使用一次</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/zip.html">zip</a></td>
    </tr>
    <tr>
        <td rowspan="2">重复分享我选择的“生命周期”</td>
        <td>并通知每个组合</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/join.html">join</a></td>
    </tr>
    <tr>
        <td>并给每个“左”的序列的值给“右”的序列</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/groupjoin.html">groupJoin</a></td>
    </tr>
    <tr>
        <td colspan="3">我想包含两者的值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/merge.html">merge</a></td>
    </tr>
</tbody></table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RXJS比较强大，操作符众多，想熟悉需要比较长时间的运用，所以大部分新手都比较疑惑应该使用哪些操作符去实现自己的数据流的操作。&lt;/p&gt;
&lt;p&gt;更多详情请翻阅 &lt;a href=&quot;https://robin-front.github.io/RxJS-doc-chinese&quot;&gt;RXJS中文翻译文档&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;我该选用哪个操作符-实例操作符&quot;&gt;&lt;a href=&quot;#我该选用哪个操作符-实例操作符&quot; class=&quot;headerlink&quot; title=&quot;我该选用哪个操作符? - 实例操作符&quot;&gt;&lt;/a&gt;我该选用哪个操作符? - 实例操作符&lt;/h1&gt;&lt;p&gt;使用此页面通过类型查找&lt;a href=&quot;https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md&quot;&gt;&lt;code&gt;Observable&lt;/code&gt;&lt;/a&gt; 适合您需要的实例运算符：
    
    </summary>
    
      <category term="RXJS" scheme="http://robin-front.github.io/categories/RXJS/"/>
    
    
      <category term="RXJS" scheme="http://robin-front.github.io/tags/RXJS/"/>
    
  </entry>
  
  <entry>
    <title>Marko和react,preact,vue相比快在哪里</title>
    <link href="http://robin-front.github.io/2017/06/01/Marko%E5%92%8Creact-preact-vue%E7%9B%B8%E6%AF%94%E5%BF%AB%E5%9C%A8%E5%93%AA%E9%87%8C/"/>
    <id>http://robin-front.github.io/2017/06/01/Marko和react-preact-vue相比快在哪里/</id>
    <published>2017-06-01T02:48:00.000Z</published>
    <updated>2017-06-01T02:48:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://hackernoon.com/why-is-marko-fast-a20796cb8ae3" target="_blank" rel="external">译文：why-is-marko-fast</a></p>
<p>在eBay，我们正在使用<code>[Marko](http://markojs.com/)</code>每天处理超过十亿的请求，这就要求我们精简我们的开源UI库Marko。我们大大优化了Marko ，以实现快速渲染，<a href="http://www.ebaytechblog.com/2014/12/08/async-fragments-rediscovering-progressive-html-rendering-with-marko/" target="_blank" rel="external">高级性能技术</a>，并实现了最小的页面重量（〜10kb gzipped）。性能只是一个方面，因为我们还必须扩展Marko以支持数百个团队的开发，从而允许开发人员有效地创建可维护和强大的Web应用程序。</p>
<p>我们已经创建了我们自己的<a href="https://github.com/marko-js/isomorphic-ui-benchmarks" target="_blank" rel="external">benchMarks</a>进行比较，也已经将Marko添加到<a href="https://github.com/raxjs/server-side-rendering-comparison/pull/11" target="_blank" rel="external">其他基准测试</a>中，但是基准测试并不总是值得信赖的。尽管我们尽可能公平地对待我们的基准，但最重要的是在现实世界的应用中的表现，而不是专注于微观基准。这就是V8团队转而采用新的方法来衡量和理解现实JavaScript性能的一个原因。</p>
<p>同样，我们已经观察过我们的开发人员实际开发中如何编写他们的Marko组件，并且发现了可以进一步优化的模式。而不是关注本文中的基准测试，我想关注我们应用于Marko的优化细节。
<a id="more"></a></p>
<h2 id="多个编译输出"><a href="#多个编译输出" class="headerlink" title="多个编译输出"></a>多个编译输出</h2><p>Marko是一个在服务器和浏览器中运行的同构UI库。正如<a href="https://medium.com/@mlrawlings" target="_blank" rel="external">Michael Rawlings</a>在“ <a href="https://hackernoon.com/server-side-rendering-shootout-with-marko-preact-rax-react-and-vue-25e1ae17800f" target="_blank" rel="external">服务器端渲染染</a> ”中提到的，当在服务器上呈现时，Marko直接呈现可以作为HTTP响应发送的文档（HTML）的字符串表示形式。</p>
<p>在浏览器中呈现时，必须解析HTML字符串才能更新DOM。因此，Marko通过程序将视图编译为直接呈现到虚拟文档（VDOM）树，这可以针对浏览器有效地更新真实的DOM。</p>
<p>给出以下模板：</p>
<p><a href="https://gist.github.com/anonymous/5ccdaadcb42dc0f5a4b2e6a956111562/raw/fa23a13e458bf8bb79dfbdc659f1248c012a799a/template.marko" target="_blank" rel="external"></a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;Hello $&#123;input.name&#125;!<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div></pre></td></tr></table></figure>
<h3 id="编译为服务器"><a href="#编译为服务器" class="headerlink" title="编译为服务器"></a>编译为服务器</h3><p>编译输出针对服务器上的HTML输出进行了优化：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> marko_template = <span class="built_in">require</span>(<span class="string">"marko/html"</span>).t(__filename),</div><div class="line">    marko_helpers = <span class="built_in">require</span>(<span class="string">"marko/runtime/html/helpers"</span>),</div><div class="line">    marko_escapeXml = marko_helpers.x;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">input, out</span>) </span>&#123;</div><div class="line">  out.w(<span class="string">"&lt;div&gt;Hello "</span> +</div><div class="line">    marko_escapeXml(input.name) +</div><div class="line">    <span class="string">"!&lt;/div&gt;"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="编译为浏览器"><a href="#编译为浏览器" class="headerlink" title="编译为浏览器"></a>编译为浏览器</h3><p>编译输出针对浏览器中的虚拟DOM渲染进行了优化：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> marko_template = <span class="built_in">require</span>(<span class="string">"marko/vdom"</span>).t(__filename);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">input, out</span>) </span>&#123;</div><div class="line">  out.e(<span class="string">"DIV"</span>, <span class="literal">null</span>, <span class="number">3</span>)</div><div class="line">    .t(<span class="string">"Hello "</span>)</div><div class="line">    .t(input.name)</div><div class="line">    .t(<span class="string">"!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="模块化运行时"><a href="#模块化运行时" class="headerlink" title="模块化运行时"></a>模块化运行时</h3><p>Marko运行时并不作为单个JavaScript文件分发。相反，Marko编译器会生成一个JavaScript模块，该模块仅导入实际需要的运行时部分。这允许我们向Marko添加新功能，而不会使现有应用程序膨胀。例如，给出以下模板：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">var</span> color = <span class="string">'red'</span>;</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;backgroundColor:</span> <span class="attr">color</span>&#125;&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>在上面的示例中，需要额外的运行时代码来根据所提供<code>style</code>的JavaScript对象呈现属性。导入<code>styleAttr</code>助手的编译代码如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> marko_styleAttr = <span class="built_in">require</span>(<span class="string">"marko/runtime/vdom/helper-styleAttr"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">input, out</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> color = <span class="string">'red'</span>;</div><div class="line">  out.e(<span class="string">"DIV"</span>, &#123;</div><div class="line">      <span class="attr">style</span>: marko_styleAttr(&#123;</div><div class="line">          <span class="attr">backgroundColor</span>: color</div><div class="line">        &#125;)</div><div class="line">    &#125;, <span class="number">0</span>, <span class="number">4</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="高性能的服务器端渲染"><a href="#高性能的服务器端渲染" class="headerlink" title="高性能的服务器端渲染"></a>高性能的服务器端渲染</h3><p>与基于专门进行虚拟DOM渲染的JSX的解决方案相比，Marko在服务器端渲染方面具有巨大的优势。当渲染到服务器上的虚拟DOM树时，它是一个两步的过程来呈现HTML：</p>
<ul>
<li>首先在内存中生成一个完整的虚拟DOM树</li>
<li>第二遍将虚拟DOM树序列化为可以通过线路发送的HTML字符串（这需要遍历整个树结构）</li>
</ul>
<p>相比之下，Marko直接一次性渲染一整个HTML流。没有中间树数据结构。</p>
<h3 id="静态子树的编译时优化"><a href="#静态子树的编译时优化" class="headerlink" title="静态子树的编译时优化"></a>静态子树的编译时优化</h3><p>给出以下模板：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;This is a &lt;strong&gt;<span class="keyword">static</span>&lt;<span class="regexp">/strong&gt; node&lt;/</span>div&gt;</div></pre></td></tr></table></figure>
<p>Marko将会认识到，模板片段每次都会产生相同的输出，因此会像以下编译输出一样创建一个虚拟DOM节点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> marko_node0 = marko_createElement(<span class="string">"DIV"</span>, <span class="literal">null</span>, <span class="number">3</span>, ...)</div><div class="line">  .t(<span class="string">"This is a "</span>)</div><div class="line">  .e(<span class="string">"STRONG"</span>, <span class="literal">null</span>, <span class="number">1</span>)</div><div class="line">    .t(<span class="string">"static"</span>)</div><div class="line">  .t(<span class="string">" node"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">input, out</span>) </span>&#123;</div><div class="line">  out.n(marko_node0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>渲染静态子树几乎是零成本。此外，Marko将跳过对比/修补静态子树。</p>
<p>同样，在服务器上，Marko会将模板的静态部分合并成一个字符串：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">input, out</span>) </span>&#123;</div><div class="line">  out.w(<span class="string">"&lt;div&gt;This is a &lt;strong&gt;static&lt;/strong&gt; node&lt;/div&gt;"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="静态属性的编译时优化"><a href="#静态属性的编译时优化" class="headerlink" title="静态属性的编译时优化"></a>静态属性的编译时优化</h3><p>Marko还将优化动态元素的静态属性。</p>
<p>给出以下模板：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div.hello&gt;Hello $&#123;input.name&#125;!<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>Marko将产生以下编译输出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> marko_attrs0 = &#123;</div><div class="line">        <span class="string">"class"</span>: <span class="string">"hello"</span></div><div class="line">      &#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">input, out</span>) </span>&#123;</div><div class="line">  out.e(<span class="string">"DIV"</span>, marko_attrs0, <span class="number">3</span>)</div><div class="line">    .t(<span class="string">"Hello "</span>)</div><div class="line">    .t(input.name)</div><div class="line">    .t(<span class="string">"!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>请注意，属性对象只创建一次，它用于每个渲染。另外，静态属性不会发生 <code>diffing</code>/<code>patching</code>。</p>
<h3 id="智能编译器"><a href="#智能编译器" class="headerlink" title="智能编译器"></a>智能编译器</h3><p>使用Marko，我们倾向于在编译时尽可能多地执行。这使我们的编译器更加复杂，但它在运行时给我们带来了很大的收获。我们有〜90％的代码覆盖率和超过2000个测试，以确保编译器正常工作。此外，在许多情况下，Marko编译器为给定的模板提供运行时提示，以便运行时可以针对特定模式进行优化。例如，识别的Marko如果HTML元素仅具有<code>class</code>/<code>id</code>/<code>style</code>定义和做版本比较时/修补运行时优化了这些虚拟DOM节点（Marko编译器生成的代码，标记简单的虚拟DOM节点用于针对 <code>diffing</code>/<code>patching</code> 逻辑）。</p>
<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>如果你正在建立一个UI组件，您将很可能需要编写代码来处理不同的DOM事件（<code>click</code>，<code>submit</code>，等）。开发人员常常编写使用<code>el.addEventListener(...)</code>或使用诸如jQuery的库来添加DOM事件监听器的代码。当您使用Marko构建UI组件时，您仍然可以执行此操作，但是在初始化大量组件时，在附加侦听器时会出现开销。相反，Marko建议使用声明式事件绑定，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;button type=<span class="string">"button"</span> on-click(<span class="string">"handleClick"</span>)&gt;</div><div class="line">  Click Me</div><div class="line">&lt;<span class="regexp">/button&gt;</span></div></pre></td></tr></table></figure>
<p>当使用声明性事件绑定时，事实上没有附加任何DOM事件侦听器。相反，Marko会为每个DOM事件（在启动时完成）为页面的根DOM元素附加一个监听器。当Marko在根节点处收到事件时，它将把事件委托给该事件的相应组件。这是通过查看<code>event.target</code>属性来查看事件发生的位置，然后向上遍历树来查找需要通知的组件。因此，当根目录捕获DOM事件时，会做更多的工作，但这种方法使用的内存少得多，并减少了初始化时需要完成的。将事件委派给组件的额外开销并不明显，因此这是一个非常有益的优化。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://hackernoon.com/why-is-marko-fast-a20796cb8ae3&quot;&gt;译文：why-is-marko-fast&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在eBay，我们正在使用&lt;code&gt;[Marko](http://markojs.com/)&lt;/code&gt;每天处理超过十亿的请求，这就要求我们精简我们的开源UI库Marko。我们大大优化了Marko ，以实现快速渲染，&lt;a href=&quot;http://www.ebaytechblog.com/2014/12/08/async-fragments-rediscovering-progressive-html-rendering-with-marko/&quot;&gt;高级性能技术&lt;/a&gt;，并实现了最小的页面重量（〜10kb gzipped）。性能只是一个方面，因为我们还必须扩展Marko以支持数百个团队的开发，从而允许开发人员有效地创建可维护和强大的Web应用程序。&lt;/p&gt;
&lt;p&gt;我们已经创建了我们自己的&lt;a href=&quot;https://github.com/marko-js/isomorphic-ui-benchmarks&quot;&gt;benchMarks&lt;/a&gt;进行比较，也已经将Marko添加到&lt;a href=&quot;https://github.com/raxjs/server-side-rendering-comparison/pull/11&quot;&gt;其他基准测试&lt;/a&gt;中，但是基准测试并不总是值得信赖的。尽管我们尽可能公平地对待我们的基准，但最重要的是在现实世界的应用中的表现，而不是专注于微观基准。这就是V8团队转而采用新的方法来衡量和理解现实JavaScript性能的一个原因。&lt;/p&gt;
&lt;p&gt;同样，我们已经观察过我们的开发人员实际开发中如何编写他们的Marko组件，并且发现了可以进一步优化的模式。而不是关注本文中的基准测试，我想关注我们应用于Marko的优化细节。
    
    </summary>
    
      <category term="Marko" scheme="http://robin-front.github.io/categories/Marko/"/>
    
    
      <category term="Marko" scheme="http://robin-front.github.io/tags/Marko/"/>
    
  </entry>
  
  <entry>
    <title>npm@5发布有哪些改进</title>
    <link href="http://robin-front.github.io/2017/06/01/npm-5%E5%8F%91%E5%B8%83%E6%9C%89%E5%93%AA%E4%BA%9B%E6%94%B9%E8%BF%9B/"/>
    <id>http://robin-front.github.io/2017/06/01/npm-5发布有哪些改进/</id>
    <published>2017-06-01T02:15:45.000Z</published>
    <updated>2017-06-01T02:15:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn-images-1.medium.com/max/800/1*9nI6dL1Z-8cqFpCX96zVFA.gif" alt="npm@5 is now latest"></p>
<p>从今天开始，如果您输入“<code>npm install npm@latest -g</code>”，那么您将被更新为npm版本5。另外，在所有<a href="https://medium.com/@nodejs/node-js-8-big-improvements-for-the-debugging-and-native-module-ecosystem-58454861f2fc" target="_blank" rel="external">Node.js 8</a>的新安装中都捆绑了<code>npm@5</code> ，它已经替代了<code>Node.js 7</code>在Node Project的当前版本中。</p>
<p>在过去一年半的时间里，我们一直在努力解决大量的痛点，其中有些是创建npm以来就已经存在的。今天的发布是对npm速度，一致性和用户体验的最大改进。</p>
<p>发布说明中有什么新内容和更改内容的明确列表，但这里有一些亮点：
<a id="more"></a></p>
<h2 id="速度很快"><a href="#速度很快" class="headerlink" title="速度很快"></a>速度很快</h2><p>重新编排了包元数据，软件包下载和软件包缓存，这大大加快了工作。一般来说，期望性能提升20-100％; 我们还看到一些安装和版本冲突的运行速度提高了5倍。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/0*K1Wb1ERhtAHLRG0m." alt="speed improvements in npm@5"></p>
<p>由于npm最初的设计，开发人员已经改变了他们如何使用npm。npm生态系统不仅呈指数级增长，而且从2014年起，平均npm软件包中的依赖关系数量增加了250％。现在，更多的开发人员现在可以在本地安装Babel，Webpack和Tap等有用工具，而不是全局。这是一个最佳实践，但这意味着“<code>npm install</code>”可以做更多的工作。</p>
<p>鉴于我们社区的规模，任何速度上升都会为数百万用户带来巨大的节省，更不用说我们的所有组织和npm企业客户。使npm @ 5变快成为一个很显然的目标。</p>
<h2 id="目标一致"><a href="#目标一致" class="headerlink" title="目标一致"></a>目标一致</h2><h3 id="默认锁文件"><a href="#默认锁文件" class="headerlink" title="默认锁文件"></a>默认锁文件</h3><p><code>Shrinkwrap</code>很早就已经是npm的一部分，但<code>npm@5</code>使<code>lockfiles</code>成为默认，所以所有的npm安装现在都是可重现的。在安装给定版本的软件包时，每次安装它您获得的文件将是相同的。</p>
<p>我们发现无数常见且耗时的问题可能与不同开发人员环境利用不同软件包版本时发生的“漂移”相关。使用默认锁文件，这不再是问题。你不会浪费时间，试图找出一个错误，只是为了了解它来自运行不同版本的图书馆的人。</p>
<h3 id="SHA-512哈希"><a href="#SHA-512哈希" class="headerlink" title="SHA-512哈希"></a>SHA-512哈希</h3><p><code>npm@5</code>增加了对<code>Node.js</code>支持的任何tarball Hash功能的支持，并以SHA-512 hash发布。通过检查所有下载的软件包，您可以防止数据损坏和恶意攻击，并且您可以相信您从npm下载的代码是一致和安全的。</p>
<h3 id="自愈缓存"><a href="#自愈缓存" class="headerlink" title="自愈缓存"></a>自愈缓存</h3><p>我们的新缓存很容易损坏，但也更具弹性。多个npm进程不会破坏共享缓存，<code>npm@5</code>将检查插入和提取的数据，以防止安装损坏的数据。如果缓存项失败完整性检查，<code>npm@5</code>将自动删除它并重新获取。</p>
<h3 id="更易使用"><a href="#更易使用" class="headerlink" title="更易使用"></a>更易使用</h3><p>根据您的反馈，我们通过<code>npm @ 5</code>中的优化改进了用户体验。其中很大一部分是输出更多的有用的提示信息。最好的例子是，npm不再显示<code>package</code>上的整个树; 相反，您将看到有关安装内容的摘要报告。由于平均每个<code>package</code>中的依赖关系较大，因此我们进行了此更改。逐个文件读出结果是超过一定数量就会显得非常笨重。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*9nI6dL1Z-8cqFpCX96zVFA.gif&quot; alt=&quot;npm@5 is now latest&quot;&gt;&lt;/p&gt;
&lt;p&gt;从今天开始，如果您输入“&lt;code&gt;npm install npm@latest -g&lt;/code&gt;”，那么您将被更新为npm版本5。另外，在所有&lt;a href=&quot;https://medium.com/@nodejs/node-js-8-big-improvements-for-the-debugging-and-native-module-ecosystem-58454861f2fc&quot;&gt;Node.js 8&lt;/a&gt;的新安装中都捆绑了&lt;code&gt;npm@5&lt;/code&gt; ，它已经替代了&lt;code&gt;Node.js 7&lt;/code&gt;在Node Project的当前版本中。&lt;/p&gt;
&lt;p&gt;在过去一年半的时间里，我们一直在努力解决大量的痛点，其中有些是创建npm以来就已经存在的。今天的发布是对npm速度，一致性和用户体验的最大改进。&lt;/p&gt;
&lt;p&gt;发布说明中有什么新内容和更改内容的明确列表，但这里有一些亮点：
    
    </summary>
    
      <category term="npm" scheme="http://robin-front.github.io/categories/npm/"/>
    
    
      <category term="npm" scheme="http://robin-front.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>JSX是什么鬼(WTF is JSX)</title>
    <link href="http://robin-front.github.io/2017/05/30/JSX%E6%98%AF%E4%BB%80%E4%B9%88%E9%AC%BC/"/>
    <id>http://robin-front.github.io/2017/05/30/JSX是什么鬼/</id>
    <published>2017-05-30T01:52:45.000Z</published>
    <updated>2017-05-30T01:52:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>JSX实际上很简单：只需要花1分钟阅读这个，你会明白有关这个有趣的替代模板的一切。
<a id="more"></a></p>
<p>替换标题：“融入JSX”</p>
<h2 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h2><p>您可以声明每个文件或每个函数来告诉您的<code>transpiler</code>（例如：<code>Babel</code>）每个节点在运行时应调用的函数的名称（请参阅“<a href="https://jasonformat.com/wtf-is-jsx/#Transpilation" target="_blank" rel="external">Transpilation</a>”）。</p>
<p>在下面的例子中，我们说的是“ <code>h()</code>为每个节点注入一个函数”：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** @jsx h */</span></div></pre></td></tr></table></figure>
<h2 id="Transpilation"><a href="#Transpilation" class="headerlink" title="Transpilation"></a>Transpilation</h2><p>如果你还没有使用解析器，你应该是尝试一下。使用ES6 / ES2015 编写，调试，测试和运行JavaScript时更为高效。<code>Babel</code>是最受欢迎和推荐的透析器，所以我会假设你正在使用它。</p>
<p>除了将ES6 / ES7 +语法转换为 ES5 以外，Babel还包括对JSX 开箱即用的转换支持。您不需要添加或更改任何内容以使用此功能。</p>
<p>通过查看一个非常简单的例子来了解它的工作原理是最简单的：</p>
<p><em>转换前</em> :( 你写的代码）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** @jsx h */</span></div><div class="line"><span class="keyword">let</span> foo = <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"foo"</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div></pre></td></tr></table></figure>
<p><em>转换后</em> :(你运行的代码）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = h(<span class="string">'div'</span>, &#123;<span class="attr">id</span>:<span class="string">"foo"</span>&#125;, <span class="string">'Hello!'</span>);</div></pre></td></tr></table></figure>
<p>你可能看第二个代码片段的时候，认为使用函数构建UI不会那么糟糕</p>
<p>这就是为什么我坐上了 <code>JSX</code> 的车：如果它从地球上消失了，用手写的输出依然会很舒服。</p>
<blockquote>
<p>JSX只是一种已经相当不错的语法的糖。</p>
</blockquote>
<p>人们甚至把它用于整个项目：<a href="https://github.com/dominictarr/hyperscript" target="_blank" rel="external">hyperscript</a></p>
<h2 id="我们来构建一个JSX渲染器"><a href="#我们来构建一个JSX渲染器" class="headerlink" title="我们来构建一个JSX渲染器"></a>我们来构建一个JSX渲染器</h2><p>首先，我们需要定义转换代码后调用的 <code>h()</code> 函数。</p>
<p>你调用任何你想要的，我使用<code>h()</code>，因为这种类型的“构建器”功能的原始想法被称为hyperscript (“hyper<del>text</del>“ + “<del>java</del>script”).。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">nodeName, attributes, ...args</span>) </span>&#123;  </div><div class="line">      <span class="keyword">let</span> children = args.length ? [].concat(...args) : <span class="literal">null</span>;</div><div class="line">      <span class="keyword">return</span> &#123; nodeName, attributes, children &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好的，这看起来很简单（ps: 只处理了 children）</p>
<blockquote>
<p>不熟悉ES6 / ES2015？</p>
<ul>
<li>这…在参数列表是一个rest param。它将“其余”的参数收集到数组中。</li>
<li>该concat(…args)位是一个扩展运算符：它需要该数组并将其扩展为参数concat()。这里使用的concat()是将子节点推入数组。</li>
</ul>
</blockquote>
<p>现在我们有这些嵌套的JSON对象我们的<code>h()</code>函数吐出来，所以我们最终得到一个这样的“树”：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">nodeName</span>: <span class="string">"div"</span>,</div><div class="line">  <span class="attr">attributes</span>: &#123;</div><div class="line">    <span class="string">"id"</span>: <span class="string">"foo"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">children</span>: [<span class="string">"Hello!"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以我们只需要一个接受该格式并抛出实际DOM节点的函数：(即沉染vdom)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode</span>) </span>&#123;  </div><div class="line">    <span class="comment">// 字符串只转换成 文本节点：</span></div><div class="line">    <span class="keyword">if</span> (vnode.split) <span class="keyword">return</span> <span class="built_in">document</span>.createTextNode(vnode);</div><div class="line"></div><div class="line">    <span class="comment">// 使用 VDOM 的 nodeName 创建一个DOM 标签</span></div><div class="line">    <span class="keyword">let</span> n = <span class="built_in">document</span>.createElement(vnode.nodeName);</div><div class="line"></div><div class="line">    <span class="comment">// 拷贝所有属性到新节点上</span></div><div class="line">    <span class="keyword">let</span> a = vnode.attributes || &#123;&#125;;</div><div class="line">    <span class="built_in">Object</span>.keys(a).forEach( <span class="function"><span class="params">k</span> =&gt;</span> n.setAttribute(k, a[k]) );</div><div class="line"></div><div class="line">    <span class="comment">// 渲染并添加子节点</span></div><div class="line">    (vnode.children || []).forEach( <span class="function"><span class="params">c</span> =&gt;</span> n.appendChild(render(c)) );</div><div class="line"></div><div class="line">    <span class="keyword">return</span> n;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>：） 不难理解这是如何工作的。
如果有帮助，您可以将“虚拟DOM”视为一个非常简单的配置，用于构建给定的DOM结构。</p>
<blockquote>
<p>虚拟DOM的好处是它非常轻巧。小对象引用其他小对象，一个由易于优化的应用程序逻辑构成的结构。</p>
<p>这也意味着它不受任何渲染逻辑或缓慢的DOM方法的束缚。</p>
</blockquote>
<h2 id="使用JSX"><a href="#使用JSX" class="headerlink" title="使用JSX"></a>使用JSX</h2><p>我们知道<code>JSX</code>被转换成<code>h()</code>函数调用。
那些函数调用创建一个简单的“虚拟”DOM树。
我们可以使用该<code>render()</code>函数来制作一个匹配的“真实”DOM树。
这就是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// JSX -&gt; VDOM:</span></div><div class="line"><span class="keyword">let</span> vdom = <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"foo"</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// VDOM -&gt; DOM:</span></div><div class="line"><span class="keyword">let</span> dom = render(vdom);</div><div class="line"></div><div class="line"><span class="comment">// add the tree to &lt;body&gt;:</span></div><div class="line"><span class="built_in">document</span>.body.appendChild(dom);</div></pre></td></tr></table></figure>
<h4 id="Partials，迭代与逻辑：没有新的语法"><a href="#Partials，迭代与逻辑：没有新的语法" class="headerlink" title="Partials，迭代与逻辑：没有新的语法"></a>Partials，迭代与逻辑：没有新的语法</h4><blockquote>
<p>我们拥有所有的JavaScript语法，而不是模板语言引入的有限概念。（PS:这是JSX胜过模板语言的地方）</p>
</blockquote>
<p>“Partials”是由无逻辑/有限逻辑模板引擎引入的概念，用于在不同的上下文中重复使用视图块。</p>
<p>迭代似乎是每个新的模板语言都重新发明的东西（我和任何人一样有罪）。使用JSX，没有新的语法来学习：迭代您在JavaScript程序中的其他任何地方。您选择最适合给定任务迭代式的：<code>[].forEach()</code>，<code>[].map()</code>，<code>for</code>和<code>while</code>循环等</p>
<p>逻辑，像迭代，是模板语言喜欢重新发明的东西。一方面，无逻辑模板在将逻辑嵌入到视图方法非常弱：有限的结构，如<code>\{\{ \#if value}}</code>将逻辑推入控制器层，鼓励膨胀。这规避了构建语言来描述更复杂的逻辑，避免可预见性和安全隐患。</p>
<p>在另一方面，使用代码生成（一种从粗略到不可原谅的技术）的引擎通常具有执行逻辑或甚至迭代任意JavaScript表达式的能力。这是一个很好的理由，不惜一切代价避免这种情况：您的代码被从原始位置（也许是一个模块，闭包或标记内）中剥离出来，并对“别的地方”评估。这对我来说是不可预测的或足够安全的。</p>
<blockquote>
<p>JSX允许所有 JavaScript的语言功能，而不依赖于在构建步骤中生成奇怪的代码，没有eval()和扩展。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将数组中的字符串以列表的形式展示</span></div><div class="line"><span class="keyword">let</span> items = [<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>];</div><div class="line"></div><div class="line"><span class="comment">// 创建列表li</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">item</span>(<span class="params">text</span>) </span>&#123;  </div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;text&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 一个使用迭代和复用的视图</span></div><div class="line"><span class="keyword">let</span> list = render(  </div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></div><div class="line">    &#123; items.map(item) &#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">);</div></pre></td></tr></table></figure>
<p><code>render()</code>返回一个DOM节点（在上述情况下是返回<ul>列表），所以我们只需要把它放到DOM中：</ul></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.body.appendChild(list);</div></pre></td></tr></table></figure>
<h2 id="把它放在一起"><a href="#把它放在一起" class="headerlink" title="把它放在一起"></a>把它放在一起</h2><p>以下是小型虚拟DOM渲染器和使用它的视图的完整源码。
具有一些样式的CodePen可在下面获得。</p>
<blockquote>
<p>同样，我也写了一个例子：<a href="https://github.com/Robin-front/code-code-hut/tree/master/jsx" target="_blank" rel="external">在任何地方使用JSX渲染DOM</a></p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">const ITEMS = 'hello there people'.split(' ');</div><div class="line"></div><div class="line">// turn an Array into list items:</div><div class="line">let list = items =&gt; items.map( p =&gt; &lt;li&gt; &#123;p&#125; &lt;/li&gt; );</div><div class="line"></div><div class="line">// view with a call out ("partial") to generate a list from an Array:</div><div class="line">let vdom = (  </div><div class="line">    &lt;div id="foo"&gt;</div><div class="line">        &lt;p&gt;Look, a simple JSX DOM renderer!&lt;/p&gt;</div><div class="line">        &lt;ul&gt;&#123; list(ITEMS) &#125;&lt;/ul&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">);</div><div class="line"></div><div class="line">// render() converts our "virtual DOM" (see below) to a real DOM tree:</div><div class="line">let dom = render(vdom);</div><div class="line"></div><div class="line">// append the new nodes somewhere:</div><div class="line">document.body.appendChild(dom);</div><div class="line"></div><div class="line">// Remember that "virtual DOM"? It's just JSON - each "VNode" is an object with 3 properties.</div><div class="line">let json = JSON.stringify(vdom, null, '  ');</div><div class="line"></div><div class="line">// The whole process (JSX -&gt; VDOM -&gt; DOM) in one step:</div><div class="line">document.body.appendChild(  </div><div class="line">    render( &lt;pre id="vdom"&gt;&#123; json &#125;&lt;/pre&gt; )</div><div class="line">);</div></pre></td></tr></table></figure>
<h2 id="Codepen演示"><a href="#Codepen演示" class="headerlink" title="Codepen演示"></a><a href="https://codepen.io/developit/embed/aOYywe/" target="_blank" rel="external">Codepen演示</a></h2><iframe src="https://codepen.io/developit/embed/aOYywe/?height=600&theme-id=16424&default-tab=result" frameborder="no" crolling="no" width="100%" height="600"></iframe>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JSX实际上很简单：只需要花1分钟阅读这个，你会明白有关这个有趣的替代模板的一切。
    
    </summary>
    
      <category term="JSX" scheme="http://robin-front.github.io/categories/JSX/"/>
    
      <category term="react" scheme="http://robin-front.github.io/categories/JSX/react/"/>
    
    
      <category term="react" scheme="http://robin-front.github.io/tags/react/"/>
    
      <category term="JSX" scheme="http://robin-front.github.io/tags/JSX/"/>
    
  </entry>
  
  <entry>
    <title>RxJS事件桥接</title>
    <link href="http://robin-front.github.io/2017/05/05/RxJS%E4%BA%8B%E4%BB%B6%E6%A1%A5%E6%8E%A5/"/>
    <id>http://robin-front.github.io/2017/05/05/RxJS事件桥接/</id>
    <published>2017-05-05T08:51:51.000Z</published>
    <updated>2017-05-05T08:51:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事件桥接"><a href="#事件桥接" class="headerlink" title="事件桥接"></a>事件桥接</h1><p>RxJS 提供工厂方法来桥接 DOM 或 Node.js 中已存在的异步数据源，所以，你可以使用丰富的创作、过滤和资源管理功能对RxJS提供的任何类型的数据流进行操作。这篇文章探讨 <a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/fromevent.md" target="_blank" rel="external"><code>fromEvent</code></a> 和 <a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/fromeventpattern.md" target="_blank" rel="external"><code>fromEventPattern</code></a>操作符，它允许导入一个 DOM 或者普通事件到 RxJS 的数据流。每次引发事件时，一个 <code>OnNext</code> 消息将传递到数据流。然后，可以像其他任何数据流一样操作事件数据流。</p>
<p>RxJS 不打算取代现有的异步编程模型如 <code>Promises</code> 或 <code>callbacks</code>。但是，当你尝试组合事件， RxJS的工厂方法会提供简便的方法给你，你完全感受不到当前使用了何种编程模式。这真的很方便维护（比如取消订阅）和筛选（比如选择合适的数据）数据源。在本节和下节中，你可以尝试 RxJS 的这些特性如何协助你完成异步编程。</p>
<p>自然，RxJS 支持一批库和他们的勾子函数去使用他们的事件系统，比如 <a href="http://jquery.com/" target="_blank" rel="external">jQuery</a>, <a href="http://zeptojs.com/" target="_blank" rel="external">Zepto.js</a>, <a href="https://angularjs.org/" target="_blank" rel="external">AngularJS</a>, <a href="http://emberjs.com/" target="_blank" rel="external">Ember.js</a> 和 <a href="http://backbonejs.org" target="_blank" rel="external">Backbone.js</a>。这种行为，不管怎样只能重写本地绑定。默认情况下， RxJS 也支持 <a href="http://nodejs.org" target="_blank" rel="external">Node.js</a> <code>EventEmitter</code> 的事件勾子。
<a id="more"></a></p>
<h2 id="将一个-DOM-事件转换成-RxJS-数据流"><a href="#将一个-DOM-事件转换成-RxJS-数据流" class="headerlink" title="将一个 DOM 事件转换成 RxJS 数据流"></a>将一个 DOM 事件转换成 RxJS 数据流</h2><p>接下来这个例子为鼠标移动事件创建了一个 DOM 事件操作，并且在页面上打印出鼠标的坐标。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = <span class="built_in">document</span>.getElementById(<span class="string">'result'</span>);</div><div class="line"></div><div class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'mousemove'</span>, e =&gt; result.innerHTML = e.clientX + <span class="string">', '</span> + e.clientY, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<p>导入一个事件到 RxJS, 你可以使用 <a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/fromevent.md" target="_blank" rel="external"><code>fromEvent</code></a> 操作符，并且传入被桥接的事件参数。然后它会将事件转换成数据流。</p>
<p>下面这个例子，我们将 DOM 的 <code>mousemove</code> 事件流转换成事件流（可观察对象）。每次鼠标移动事件被触发时，订阅都会接收到一个 <code>onNext</code> 事件。然后我们可以检查这种通知的事件参数并获得鼠标的坐标。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = <span class="built_in">document</span>.getElementById(<span class="string">'result'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'mousemove'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(<span class="function"><span class="params">e</span> =&gt;</span> result.innerHTML = e.clientX + <span class="string">', '</span> + e.clientY);</div></pre></td></tr></table></figure>
<p>在这个例子中要注意，（鼠标）移动变成一个数据流以便我们进一步操作。 <a href="querying.md">Querying Observable Sequences</a> 这篇文章将会展示如何将该序列投射到点类型集合中并筛选其内容，以便应用程序只接收满足一定条件的值。</p>
<p>事件处理程序的销毁由 <code>subscribe</code> 方法返回的 <code>Disposable</code> 对象处理。调用 <code>dispose</code> 将会释放由该序列所使用的所有资源，包括底层事件处理程序。这本质上是取消订阅事件。</p>
<p><code>fromEvent</code> 方法还支持向多个项目添加事件处理程序，比如一整个 DOM 节点列表。下面这个例子将会给列表中的每个元素添加 ‘click’ 事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = <span class="built_in">document</span>.getElementById(<span class="string">'result'</span>);</div><div class="line"><span class="keyword">var</span> sources = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.fromEvent(sources, <span class="string">'click'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(<span class="function"><span class="params">e</span> =&gt;</span> result.innerHTML = e.clientX + <span class="string">', '</span> + e.clientY);</div></pre></td></tr></table></figure>
<p>另外，<code>fromEvent</code> 也支持类库，像 <a href="http://jquery.com/" target="_blank" rel="external">jQuery</a>, <a href="http://zeptojs.com/" target="_blank" rel="external">Zepto.js</a>, <a href="https://angularjs.org/" target="_blank" rel="external">AngularJS</a>, <a href="http://emberjs.com/" target="_blank" rel="external">Ember.js</a> and <a href="http://backbonejs.org" target="_blank" rel="external">Backbone.js</a>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $result = $(<span class="string">'#result'</span>);</div><div class="line"><span class="keyword">var</span> $sources = $(<span class="string">'div'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.fromEvent($sources, <span class="string">'click'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(<span class="function"><span class="params">e</span> =&gt;</span> $result.html(e.clientX + <span class="string">', '</span> + e.clientY));</div></pre></td></tr></table></figure>
<p>如果表现不如预期，你可以通过设置 <code>Rx.config.useNativeEvents</code> 为 <code>true</code> 去重写它，这会无视任何类库。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 只使用原生事件，尽管引用了 jQuery</span></div><div class="line">Rx.config.useNativeEvents = <span class="literal">true</span>;</div><div class="line"></div><div class="line"><span class="comment">// 只使用原生事件</span></div><div class="line"><span class="keyword">var</span> result = <span class="built_in">document</span>.getElementById(<span class="string">'result'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'mousemove'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(<span class="function"><span class="params">e</span> =&gt;</span> result.innerHTML = e.clientX + <span class="string">', '</span> + e.clientY);</div></pre></td></tr></table></figure>
<p>另外，您可以轻松地给事件系统的事件添加许多快捷方式，比如 <code>mousemove</code>， 甚至是 <a href="http://www.w3.org/TR/pointerevents/" target="_blank" rel="external">Pointer</a> and <a href="http://www.w3.org/TR/touch-events/" target="_blank" rel="external">Touch</a> 事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Rx.dom = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> events = <span class="string">"blur focus focusin focusout load resize scroll unload click dblclick "</span> +</div><div class="line">  <span class="string">"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave "</span> +</div><div class="line">  <span class="string">"change select submit keydown keypress keyup error contextmenu"</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (root.PointerEvent) &#123;</div><div class="line">  events += <span class="string">" pointerdown pointerup pointermove pointerover pointerout pointerenter pointerleave"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (root.TouchEvent) &#123;</div><div class="line">  events += <span class="string">" touchstart touchend touchmove touchcancel"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">events.split(<span class="string">' '</span>).forEach(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</div><div class="line">  Rx.dom[e] = <span class="function">(<span class="params">element, selector</span>) =&gt;</span> Rx.Observable.fromEvent(element, e, selector)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>现在我们可以重写单个鼠标拖拽事件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> draggable = <span class="built_in">document</span>.getElementById(<span class="string">'draggable'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> mousedrag = Rx.dom.mousedown(draggable).flatMap(<span class="function"><span class="params">md</span> =&gt;</span> &#123;</div><div class="line">  md.preventDefault();</div><div class="line"></div><div class="line">  <span class="keyword">var</span> start = getLocation(md);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> Rx.dom.mousemove(<span class="built_in">document</span>)</div><div class="line">    .map(<span class="function"><span class="params">mm</span> =&gt;</span> getDelta(start, mm))</div><div class="line">    .takeUntil(Rx.dom.mouseup(draggable));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>注意这在 <a href="https://github.com/Reactive-Extensions/RxJS-DOM" target="_blank" rel="external">RxJS-DOM</a> 项目中已经可用，但你自己实现也只需要很少量的代码。</p>
<h2 id="将-Node-js-事件转换成-RxJS-数据流"><a href="#将-Node-js-事件转换成-RxJS-数据流" class="headerlink" title="将 Node.js 事件转换成 RxJS 数据流"></a>将 Node.js 事件转换成 RxJS 数据流</h2><p>Node.js 也支持类似 <a href="http://nodejs.org/api/events.html#events_class_events_eventemitter" target="_blank" rel="external"><code>EventEmitter</code></a>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Rx = <span class="built_in">require</span>(<span class="string">'rx'</span>),</div><div class="line">  EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter;</div><div class="line"></div><div class="line"><span class="keyword">var</span> eventEmitter = <span class="keyword">new</span> EventEmitter();</div><div class="line"></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.fromEvent(eventEmitter, <span class="string">'data'</span>)</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'data: '</span> + data));</div><div class="line"></div><div class="line">eventEmitter.emit(<span class="string">'data'</span>, <span class="string">'foo'</span>);</div><div class="line"><span class="comment">// =&gt; data: foo</span></div></pre></td></tr></table></figure>
<h2 id="使用-FromEventPattern-桥接自定义事件"><a href="#使用-FromEventPattern-桥接自定义事件" class="headerlink" title="使用 FromEventPattern 桥接自定义事件"></a>使用 FromEventPattern 桥接自定义事件</h2><p>下面有一个使用类库实现事件订阅和退订的实例。<a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/fromeventpattern.md" target="_blank" rel="external"><code>fromEventPattern</code></a> 方法就是为了这个目的而创建的，用来桥接这些自定义事件。</p>
<p>举个例子，你可以想使用 jQuery <a href="http://api.jquery.com/on/" target="_blank" rel="external"><code>on</code></a> 方法去桥接。我们可以将下列代码转换为基于表格行单击的 alert。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$( <span class="string">"#dataTable tbody"</span> ).on(<span class="string">'click'</span>, <span class="string">'tr'</span>, e =&gt; alert($( e.target ).text()));</div></pre></td></tr></table></figure>
<p>使用 <code>fromEventPattern</code> 方法转换后的代码看起来像下面这样。每个函数在处理函数中传递，允许您调用 <code>on</code> 和 <code>off</code> 方法来正确处理事件的处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $tbody = $(<span class="string">'#dataTable tbody'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.fromEventPattern(</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">addHandler</span> (<span class="params">h</span>) </span>&#123; $tbody.on(<span class="string">'click'</span>, <span class="string">'tr'</span>, h); &#125;,</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">delHandler</span> (<span class="params">h</span>) </span>&#123; $tbody.off(<span class="string">'click'</span>, <span class="string">'tr'</span>, h); &#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(<span class="function"><span class="params">e</span> =&gt;</span> alert($( e.target ).text()));</div></pre></td></tr></table></figure>
<p>除了这种常用的支持外，我们也支持 <code>addHandler</code> 返回一个对象，它可以通过 <code>removeHandler</code> 去完全退订。在这个例子中，我们将使用 <a href="http://dojotoolkit.org" target="_blank" rel="external">Dojo Toolkit</a> 和 <a href="http://dojotoolkit.org/api/1.9/dojo/on.html" target="_blank" rel="external"><code>on</code></a> 模块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">'dojo/on'</span>, <span class="string">'dojo/dom'</span>, <span class="string">'rx'</span>, <span class="string">'rx.async'</span>, <span class="string">'rx.binding'</span>], (on, dom, rx) =&gt; &#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> input = dom.byId(<span class="string">'input'</span>);</div><div class="line"></div><div class="line">    <span class="keyword">var</span> source = Rx.Observable.fromEventPattern(</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">addHandler</span> (<span class="params">h</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> on(input, <span class="string">'click'</span>, h);</div><div class="line">        &#125;,</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">delHandler</span> (<span class="params">_, signal</span>) </span>&#123;</div><div class="line">            signal.remove();</div><div class="line">        &#125;</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="keyword">var</span> subscription = source.subscribe(</div><div class="line">        <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Next: Clicked!'</span>),</div><div class="line">        err =&gt; <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + err),</div><div class="line">        () =&gt; <span class="built_in">console</span>.log(<span class="string">'Completed'</span>));</div><div class="line"></div><div class="line">    on.emit(input, <span class="string">'click'</span>);</div><div class="line">    <span class="comment">// =&gt; Next: Clicked!</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h2><p>概念</p>
<ul>
<li><a href="querying_observable_sequences.md">Querying Observable Sequences</a></li>
</ul>
<p><a href="https://robin-front.github.io/RxJS-doc-chinese/content/getting_started_with_rxjs/creating_and_querying_observable_sequences/bridging_to_events.html">本文翻译在: RxJS中文文档</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;事件桥接&quot;&gt;&lt;a href=&quot;#事件桥接&quot; class=&quot;headerlink&quot; title=&quot;事件桥接&quot;&gt;&lt;/a&gt;事件桥接&lt;/h1&gt;&lt;p&gt;RxJS 提供工厂方法来桥接 DOM 或 Node.js 中已存在的异步数据源，所以，你可以使用丰富的创作、过滤和资源管理功能对RxJS提供的任何类型的数据流进行操作。这篇文章探讨 &lt;a href=&quot;https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/fromevent.md&quot;&gt;&lt;code&gt;fromEvent&lt;/code&gt;&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/fromeventpattern.md&quot;&gt;&lt;code&gt;fromEventPattern&lt;/code&gt;&lt;/a&gt;操作符，它允许导入一个 DOM 或者普通事件到 RxJS 的数据流。每次引发事件时，一个 &lt;code&gt;OnNext&lt;/code&gt; 消息将传递到数据流。然后，可以像其他任何数据流一样操作事件数据流。&lt;/p&gt;
&lt;p&gt;RxJS 不打算取代现有的异步编程模型如 &lt;code&gt;Promises&lt;/code&gt; 或 &lt;code&gt;callbacks&lt;/code&gt;。但是，当你尝试组合事件， RxJS的工厂方法会提供简便的方法给你，你完全感受不到当前使用了何种编程模式。这真的很方便维护（比如取消订阅）和筛选（比如选择合适的数据）数据源。在本节和下节中，你可以尝试 RxJS 的这些特性如何协助你完成异步编程。&lt;/p&gt;
&lt;p&gt;自然，RxJS 支持一批库和他们的勾子函数去使用他们的事件系统，比如 &lt;a href=&quot;http://jquery.com/&quot;&gt;jQuery&lt;/a&gt;, &lt;a href=&quot;http://zeptojs.com/&quot;&gt;Zepto.js&lt;/a&gt;, &lt;a href=&quot;https://angularjs.org/&quot;&gt;AngularJS&lt;/a&gt;, &lt;a href=&quot;http://emberjs.com/&quot;&gt;Ember.js&lt;/a&gt; 和 &lt;a href=&quot;http://backbonejs.org&quot;&gt;Backbone.js&lt;/a&gt;。这种行为，不管怎样只能重写本地绑定。默认情况下， RxJS 也支持 &lt;a href=&quot;http://nodejs.org&quot;&gt;Node.js&lt;/a&gt; &lt;code&gt;EventEmitter&lt;/code&gt; 的事件勾子。
    
    </summary>
    
      <category term="RxJS" scheme="http://robin-front.github.io/categories/RxJS/"/>
    
    
      <category term="RxJS" scheme="http://robin-front.github.io/tags/RxJS/"/>
    
      <category term="bridging" scheme="http://robin-front.github.io/tags/bridging/"/>
    
      <category term="event" scheme="http://robin-front.github.io/tags/event/"/>
    
  </entry>
  
  <entry>
    <title>使用RxJS创建和订阅单一数据流</title>
    <link href="http://robin-front.github.io/2017/05/04/%E5%88%9B%E5%BB%BA%E5%92%8C%E8%AE%A2%E9%98%85%E5%8D%95%E4%B8%80%E6%95%B0%E6%8D%AE%E6%B5%81/"/>
    <id>http://robin-front.github.io/2017/05/04/创建和订阅单一数据流/</id>
    <published>2017-05-04T10:06:14.000Z</published>
    <updated>2017-05-04T10:06:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://robin-front.gitbooks.io/rxjs-doc-chinese/content/content/getting_started_with_rxjs/creating_and_querying_observable_sequences/creating_and_subscribing_to_simple_observable_sequences.html" target="_blank" rel="external">来自</a></p>
<h1 id="创建和订阅单一可观察序列"><a href="#创建和订阅单一可观察序列" class="headerlink" title="创建和订阅单一可观察序列"></a>创建和订阅单一可观察序列</h1><p>你不需要去实现 <code>Observable</code> 类去创建一个可观察序列。 同样的，你也不需要去实现 <code>Observer</code> 去订阅数据流。通过安装 Rx 库，你可以利用 <code>Observable</code>类型，它提供了许多操作符来根据零个，一个或多个元素去创建一个数据流。另外， RxJS 还提供 <code>subscribe</code> 方法允许你使用 <code>onNext</code>, <code>onError</code> 和 <code>onCompleted</code> 函数。</p>
<a id="more"></a>
<h2 id="从零创建一个数据流"><a href="#从零创建一个数据流" class="headerlink" title="从零创建一个数据流"></a>从零创建一个数据流</h2><p>在使用操作符之前，让我们看一看怎样使用 <a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/create.md" target="_blank" rel="external"><code>Rx.Observable.create</code></a> 方法从零创建 <code>Observable</code> 。</p>
<p>首先， 我们需要确认引用了 <code>rx.js</code> 核心文件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"rx.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如果我们使用 <a href="http://node.js" target="_blank" rel="external">Node.js</a>， 我们可以这样引入:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Rx = <span class="built_in">require</span>(<span class="string">'rx'</span>);</div></pre></td></tr></table></figure>
<p>在这个例子中， 我们将只产生一个单一值42，然后标记为完成。 如果不需要清除，返回值是完全可选的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> source = Rx.Observable.create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// 产生一个单一值然后完成。</span></div><div class="line">  observer.onNext(<span class="number">42</span>);</div><div class="line">  observer.onCompleted();</div><div class="line"></div><div class="line">  <span class="comment">// 任何清除的逻辑写在这里</span></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'disposed'</span>)</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onNext: %s'</span>, x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'onError: %s'</span>, e),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; onNext: 42</span></div><div class="line"><span class="comment">// =&gt; onCompleted</span></div><div class="line"></div><div class="line">subscription.dispose();</div><div class="line"><span class="comment">// =&gt; disposed</span></div></pre></td></tr></table></figure>
<p>对于大多数操作， 这完全是多余的，但这展示了非常基础的大部分 RxJS 操作符是如何工作的。</p>
<h2 id="创建及订阅单一数据流"><a href="#创建及订阅单一数据流" class="headerlink" title="创建及订阅单一数据流"></a>创建及订阅单一数据流</h2><p>接下来的例子使用 <code>Observable</code> 类的 <a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/range.md" target="_blank" rel="external"><code>range</code></a> 操作符来创建一个包含一些数字的单一数据流。观察者使用 <code>Observable</code> 类的 <code>Subscribe</code> 订阅这个数据流集合， 并且处理回调 <code>onNext</code>, <code>onError</code> and <code>onCompleted</code>。在我们的例子中，创建了一个从 x 开始的整数序列，然后接下来产生 y 个。</p>
<p>只要订阅了数据流，数据就会发送给观察者。<code>onNext</code>函数会打印出这个值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个从 1 开始，包含 5 个整数的数据流</span></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.range(<span class="number">1</span>, <span class="number">5</span>);</div><div class="line"></div><div class="line"><span class="comment">// 打印每个值</span></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onNext: %s'</span>, x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'onError: %s'</span>, e),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; onNext: 1</span></div><div class="line"><span class="comment">// =&gt; onNext: 2</span></div><div class="line"><span class="comment">// =&gt; onNext: 3</span></div><div class="line"><span class="comment">// =&gt; onNext: 4</span></div><div class="line"><span class="comment">// =&gt; onNext: 5</span></div><div class="line"><span class="comment">// =&gt; onCompleted</span></div></pre></td></tr></table></figure>
<p>当一个观察者订阅了一个数据流， <code>subscribe</code> 方法背后使用的异步操作取决于操作符。因些， <code>subscribe</code> 的调用是异步的，因为调用者在完成序列观察之前不会被阻塞。这篇文章 <a href="schedulers.md">Using Schedulers</a> 提供了更多信息。</p>
<p>注意 <a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/susbcribe.md" target="_blank" rel="external"><code>subscribe</code></a> 方法返回一个 <code>Disposable</code>，所以你可以很容易地退订和销毁它。当你在可观察对象上调用 <code>dispose</code> 方法时，观察者将会停止监听数据流。正常来说，你不需要精确地调用 <code>dispose</code> 除非你需要提前退订，或者当数据流的生命周期比观察者的还长。 Rx 的订阅被设计成 <code>触发-丢弃</code> 的场景，并不需要终结者。注意到，可观察对象的操作符的默认表现是 只要有可能（比如，<code>onCompleted</code> 或 <code>onError</code> 消息被发送时），订阅就会被销毁。举个例子，下面的代码将会订阅 a 和 b 两个数据流。如果 a 抛出一个错误， x 会立即退订 b 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = Rx.Observable.zip(a, b, (a1, b1) =&gt; a1 + b1).subscribe();</div></pre></td></tr></table></figure>
<p>还可以调整代码示例以使用观察者的 <code>Create</code> 运算符，创建并从指定的 <code>OnNext</code>, <code>OnError</code>, 和 <code>OnCompleted</code> 回调返回一个观察者。然后你可以传递 <code>observer</code> 给 <code>observable</code> 的 <code>subscribe</code> 方法。下面的例子展示了这种写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建包含 5个整数的数据流，从 1 开始</span></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.range(<span class="number">1</span>, <span class="number">5</span>);</div><div class="line"></div><div class="line"><span class="comment">// 创建观察者</span></div><div class="line"><span class="keyword">var</span> observer = Rx.Observer.create(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onNext: %s'</span>, x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'onError: %s'</span>, e),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="comment">// 打印每个结果</span></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(observer);</div><div class="line"></div><div class="line"><span class="comment">// =&gt; onNext: 1</span></div><div class="line"><span class="comment">// =&gt; onNext: 2</span></div><div class="line"><span class="comment">// =&gt; onNext: 3</span></div><div class="line"><span class="comment">// =&gt; onNext: 4</span></div><div class="line"><span class="comment">// =&gt; onNext: 5</span></div><div class="line"><span class="comment">// =&gt; onCompleted</span></div></pre></td></tr></table></figure>
<p>另外，从零创建一个数据流，你也可以将已存在的 数据， 事件，回调以及 <code>promise</code> 转换成数据流。下一节的主题将会教你怎么做。</p>
<p>注意，这一节只展示了可以从零创建数据流的很少一部分操作符。学习更多其他的  <code>LINQ</code> 操作符， 可以查看 <a href="querying_observable_squences.md">Querying Observable Sequences</a>.</p>
<h2 id="使用定时器"><a href="#使用定时器" class="headerlink" title="使用定时器"></a>使用定时器</h2><p>接下来的例子使用 <a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/timer.md" target="_blank" rel="external"><code>timer</code></a> 操作符去创建一个数据流。 这个数据流将在5秒后输出第一个值，接着每1秒输出后面的值。为了说明， 我们配合 <a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/timestamp.md" target="_blank" rel="external"><code>timestamp</code></a> 操作符去查询，使每一个被推出来的值将在发布时追加时间戳。这样，当我们订阅这个数据源时，我们可以接收到值和时间戳。</p>
<p>首先，我们需要确认我们是否在浏览器引入了相关的文件。注意 RxJS NPM 包已经默认包含了所有操作符。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"rx.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"rx.time.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>下面是我们的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'Current time: '</span> + <span class="built_in">Date</span>.now());</div><div class="line"></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.timer(</div><div class="line">  <span class="number">5000</span>, <span class="comment">/* 5 秒 */</span></div><div class="line">  <span class="number">1000</span> <span class="comment">/* 1 秒 */</span>)</div><div class="line">   .timestamp();</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x.value + <span class="string">': '</span> + x.timestamp));</div><div class="line"></div><div class="line"><span class="comment">/* 输出可能像这样子 */</span></div><div class="line"><span class="comment">// Current time: 1382560697820</span></div><div class="line"><span class="comment">// 0: 1382560702820</span></div><div class="line"><span class="comment">// 1: 1382560703820</span></div><div class="line"><span class="comment">// 2: 1382560704820</span></div></pre></td></tr></table></figure>
<p>通过使用 <code>timestamp</code> 操作符，我们可以证实，第一个值确实是开始5秒后输出，然后每1秒输出一个值。</p>
<h2 id="将数组和可迭代对象转换为数据流"><a href="#将数组和可迭代对象转换为数据流" class="headerlink" title="将数组和可迭代对象转换为数据流"></a>将数组和可迭代对象转换为数据流</h2><p>使用 <a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/from.md" target="_blank" rel="external"><code>Rx.Observable.from</code></a> 操作符，你可以将一个数组转换为数据流。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"></div><div class="line"><span class="comment">// 将数组转换为数据流</span></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.from(array);</div><div class="line"></div><div class="line"><span class="comment">// 输出每个值</span></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onNext: %s'</span>, x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'onError: %s'</span>, e),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; onNext: 1</span></div><div class="line"><span class="comment">// =&gt; onNext: 2</span></div><div class="line"><span class="comment">// =&gt; onNext: 3</span></div><div class="line"><span class="comment">// =&gt; onNext: 4</span></div><div class="line"><span class="comment">// =&gt; onNext: 5</span></div><div class="line"><span class="comment">// =&gt; onCompleted</span></div></pre></td></tr></table></figure>
<p>你也可以转换类数组结构，比如包含 <code>length</code> 属性和数字索引的对象。这种情况下，我们只简单有一个包含长度为5的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arrayLike = &#123; <span class="attr">length</span>: <span class="number">5</span> &#125;;</div><div class="line"></div><div class="line"><span class="comment">// 转换数组为数据流</span></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.from(arrayLike, (v, k) =&gt; k);</div><div class="line"></div><div class="line"><span class="comment">// 输出每个值</span></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onNext: %s'</span>, x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'onError: %s'</span>, e),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; onNext: 1</span></div><div class="line"><span class="comment">// =&gt; onNext: 2</span></div><div class="line"><span class="comment">// =&gt; onNext: 3</span></div><div class="line"><span class="comment">// =&gt; onNext: 4</span></div><div class="line"><span class="comment">// =&gt; onNext: 5</span></div><div class="line"><span class="comment">// =&gt; onCompleted</span></div></pre></td></tr></table></figure>
<p>另外，我们也可以使用 ES6 可迭代对象，如 <code>Map</code> 和 <code>Set</code> 使用 <code>from</code> 转换成数据流。下面这个例子，我们将获取一个 <code>Set</code> 对象，并且将它转换成数据流。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</div><div class="line"></div><div class="line"><span class="comment">// 转换 Set 为数据流</span></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.from(set);</div><div class="line"></div><div class="line"><span class="comment">// 转出每个值</span></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onNext: %s'</span>, x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'onError: %s'</span>, e),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; onNext: 1</span></div><div class="line"><span class="comment">// =&gt; onNext: 2</span></div><div class="line"><span class="comment">// =&gt; onNext: 3</span></div><div class="line"><span class="comment">// =&gt; onNext: 4</span></div><div class="line"><span class="comment">// =&gt; onNext: 5</span></div><div class="line"><span class="comment">// =&gt; onCompleted</span></div></pre></td></tr></table></figure>
<p>我们也可以将它应用在 <code>Map</code> 对象上面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'key1'</span>, <span class="number">1</span>], [<span class="string">'key2'</span>, <span class="number">2</span>]]);</div><div class="line"></div><div class="line"><span class="comment">// 将 Map 转换成数据流</span></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.from(map);</div><div class="line"></div><div class="line"><span class="comment">// 打印每个值</span></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onNext: %s'</span>, x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'onError: %s'</span>, e),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; onNext: key1, 1</span></div><div class="line"><span class="comment">// =&gt; onNext: key2, 2</span></div><div class="line"><span class="comment">// =&gt; onCompleted</span></div></pre></td></tr></table></figure>
<p><code>from</code> 方法也支持 ES6 generators，可以你的浏览器已经支持，或将要支持。这允许我们实现一些像 <code>斐波那契序列</code> 等，并将它们转换成数据流。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibonacci</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> fn1 = <span class="number">1</span>;</div><div class="line">  <span class="keyword">var</span> fn2 = <span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span> (<span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">var</span> current = fn2;</div><div class="line">    fn2 = fn1;</div><div class="line">    fn1 = fn1 + current;</div><div class="line">    <span class="keyword">yield</span> current;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 将 generator 转换成数据流</span></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.from(fibonacci()).take(<span class="number">5</span>);</div><div class="line"></div><div class="line"><span class="comment">// 打印每个值</span></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onNext: %s'</span>, x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'onError: %s'</span>, e),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; onNext: 1</span></div><div class="line"><span class="comment">// =&gt; onNext: 1</span></div><div class="line"><span class="comment">// =&gt; onNext: 2</span></div><div class="line"><span class="comment">// =&gt; onNext: 3</span></div><div class="line"><span class="comment">// =&gt; onNext: 5</span></div><div class="line"><span class="comment">// =&gt; onCompleted</span></div></pre></td></tr></table></figure>
<h2 id="冷（惰性）-vs-热（非惰性）-数据流"><a href="#冷（惰性）-vs-热（非惰性）-数据流" class="headerlink" title="冷（惰性） vs. 热（非惰性） 数据流"></a>冷（惰性） vs. 热（非惰性） 数据流</h2><p>冷数据流的开始运行取决于订阅，比如，数据流只有当 <code>subscribe</code> 调用的时候才开始输出值。用户之间也没有共享值。这些是与热数据流的不同之处，热数据像流鼠标移动事件或股票代码这样的订阅时就已经不断输出值。当观察者订阅热数据流时，它将会获取流的实时值。热数据流是与所有订阅者共享的，每个订阅者按顺序推送下一个值。举个例子，就算没有人订阅一个特定的股票，股票市场也将继续根据市场动向更新其价值。当有注册者对这支股票感兴趣时，它会自动获得股票的最新值。</p>
<p>下面的示例演示了一个冷数据流。这个例子中，我们使用了 <code>Interval</code> 操作符去创建一个单一数据流并在特定的时间间隔输出值，这个例子中是间隔1秒。</p>
<p>两个观察者订阅这个数据流并打印输出值。你会注意到数据流会为每个订阅者重置，第二个订阅者也是从第1个值开始的。</p>
<p>首先，我们需要确保在浏览器中引入了相关文件。注意 RxJS NPM 包已经默认包含了所有操作符。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"rx.lite.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后是例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">1000</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription1 = source.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Observer 1: onNext: '</span> + x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'Observer 1: onError: '</span> + e.message),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'Observer 1: onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription2 = source.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Observer 2: onNext: '</span> + x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'Observer 2: onError: '</span> + e.message),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'Observer 2: onCompleted'</span>));</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  subscription1.dispose();</div><div class="line">  subscription2.dispose();</div><div class="line">&#125;, <span class="number">5000</span>);</div><div class="line"></div><div class="line"><span class="comment">// =&gt; Observer 1: onNext: 0</span></div><div class="line"><span class="comment">// =&gt; Observer 2: onNext: 0</span></div><div class="line"><span class="comment">// =&gt; Observer 1: onNext: 1</span></div><div class="line"><span class="comment">// =&gt; Observer 2: onNext: 1</span></div><div class="line"><span class="comment">// =&gt; Observer 1: onNext: 2</span></div><div class="line"><span class="comment">// =&gt; Observer 2: onNext: 2</span></div><div class="line"><span class="comment">// =&gt; Observer 1: onNext: 3</span></div><div class="line"><span class="comment">// =&gt; Observer 2: onNext: 3</span></div></pre></td></tr></table></figure>
<p>接下来的例子中，我们使用 <a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/publish.md" target="_blank" rel="external"><code>publish</code></a> 操作符将前面的冷数据源转换成热数据源，返回一个 <code>ConnectableObservable</code> 实例，我们称为 <code>hot</code>。<a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/publish.md" target="_blank" rel="external"><code>publish</code></a> 操作符通过向多个订阅服务器广播单个订阅来提供共享订阅的机制。<code>hot</code>变量作为代理订阅 <code>source</code>，因为它从 <code>source</code> 接收值，推到自己的用户. 我们使用 <a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/connect.md" target="_blank" rel="external"><code>ConnectableObservable.prototype.connect</code></a> 建立订阅的备份源，并开始接收值。因为 <code>ConnectableObservable</code> 继承自 <code>Observable</code>， 我们可以在它运行之前使用 <code>subscribe</code> 去订阅这个热数据流。 在这个例子中要注意，当 <code>subscription1</code>订阅它的时候热数据流还没有开始。因些，没有值输出给订阅者。只有调用 <code>Connect</code> 之后，输出值才会推送给 <code>subscription1</code>。3秒的延迟之后，<code>subscription2</code> 订阅了热数据流，并且立即开始接收当前输出值（当前值是3），一直到最后。输出结果看起来像这样：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// =&gt; Current <span class="built_in">time</span>: <span class="number">1382562433256</span></div><div class="line">// =&gt; Current <span class="keyword">Time</span> <span class="built_in">after</span> <span class="number">1</span>st subscription: <span class="number">1382562433260</span></div><div class="line">// =&gt; Current <span class="keyword">Time</span> <span class="built_in">after</span> connect: <span class="number">1382562436261</span></div><div class="line">// =&gt; Observer <span class="number">1</span>: onNext: <span class="number">0</span></div><div class="line">// =&gt; Observer <span class="number">1</span>: onNext: <span class="number">1</span></div><div class="line">// =&gt; Current <span class="keyword">Time</span> <span class="built_in">after</span> <span class="number">2</span>nd subscription: <span class="number">1382562439262</span></div><div class="line">// =&gt; Observer <span class="number">1</span>: onNext: <span class="number">2</span></div><div class="line">// =&gt; Observer <span class="number">2</span>: onNext: <span class="number">2</span></div><div class="line">// =&gt; Observer <span class="number">1</span>: onNext: <span class="number">3</span></div><div class="line">// =&gt; Observer <span class="number">2</span>: onNext: <span class="number">3</span></div><div class="line">// =&gt; Observer <span class="number">1</span>: onNext: <span class="number">4</span></div><div class="line">// =&gt; Observer <span class="number">2</span>: onNext: <span class="number">4</span></div></pre></td></tr></table></figure>
<p>首先，我们需要确认我们引入了相关文件。注意 RxJS NPM包已经默认包含了所有操作符。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"rx.lite.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>接下来是例子！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'Current time: '</span> + <span class="built_in">Date</span>.now());</div><div class="line"></div><div class="line"><span class="comment">// 创建一个数据流</span></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">1000</span>);</div><div class="line"></div><div class="line"><span class="comment">// 将数据流转换成热数据流</span></div><div class="line"><span class="keyword">var</span> hot = source.publish();</div><div class="line"></div><div class="line"><span class="comment">// 第一个订阅时没有值输出</span></div><div class="line"><span class="keyword">var</span> subscription1 = hot.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Observer 1: onNext: %s'</span>, x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'Observer 1: onError: %s'</span>, e),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'Observer 1: onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Current Time after 1st subscription: '</span> + <span class="built_in">Date</span>.now());</div><div class="line"></div><div class="line"><span class="comment">// 空闲 3 秒</span></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line"></div><div class="line">  <span class="comment">// 热数据源连接并开始输出值给订阅者</span></div><div class="line">  hot.connect();</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Current Time after connect: '</span> + <span class="built_in">Date</span>.now());</div><div class="line"></div><div class="line">  <span class="comment">// 又空闲 3 秒</span></div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Current Time after 2nd subscription: '</span> + <span class="built_in">Date</span>.now());</div><div class="line"></div><div class="line">    <span class="keyword">var</span> subscription2 = hot.subscribe(</div><div class="line">      <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Observer 2: onNext: %s'</span>, x),</div><div class="line">      e =&gt; <span class="built_in">console</span>.log(<span class="string">'Observer 2: onError: %s'</span>, e),</div><div class="line">      () =&gt; <span class="built_in">console</span>.log(<span class="string">'Observer 2: onCompleted'</span>));</div><div class="line"></div><div class="line">  &#125;, <span class="number">3000</span>);</div><div class="line">&#125;, <span class="number">3000</span>);</div><div class="line"></div><div class="line"><span class="comment">// =&gt; Current Time after connect: 1431197578426</span></div><div class="line"><span class="comment">// =&gt; Observer 1: onNext: 0</span></div><div class="line"><span class="comment">// =&gt; Observer 1: onNext: 1</span></div><div class="line"><span class="comment">// =&gt; Observer 1: onNext: 2</span></div><div class="line"><span class="comment">// =&gt; Current Time after 2nd subscription: 1431197581434</span></div><div class="line"><span class="comment">// =&gt; Observer 1: onNext: 3</span></div><div class="line"><span class="comment">// =&gt; Observer 2: onNext: 3</span></div><div class="line"><span class="comment">// =&gt; Observer 1: onNext: 4</span></div><div class="line"><span class="comment">// =&gt; Observer 2: onNext: 4</span></div><div class="line"><span class="comment">// =&gt; Observer 1: onNext: 5</span></div><div class="line"><span class="comment">// =&gt; Observer 2: onNext: 5</span></div><div class="line"><span class="comment">// =&gt; ...</span></div></pre></td></tr></table></figure>
<p><strong>类推</strong></p>
<p>这有助于思考冷热数据源的关系，就像一个人看（<code>subscribe</code>）电影和表演。</p>
<ul>
<li>冷数据流：电影。</li>
<li>热数据流：现场演出</li>
<li>重播热数据流：录播现场演出</li>
</ul>
<p>你管你何时观看电影，你看电影和别人看都是独立的，尽管所有观看者看的都是相同的内容。另一方面，一个表演是与多个观看都一起分享的。如果你迟到了，你将会错过一部分。不管怎样，如果记录下来了（在 RxJS中可以使用 <code>BehaviorSubject</code> 或 <code>ReplaySubject</code>），你也可像看电影一样看现场演出。<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/refcount.md" target="_blank" rel="external"><code>.publish().refCount()</code></a> 现场表演是艺术家在没有人观看的情况下退出比赛，当观众中至少有一人出现时，他会重新开始演奏。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://robin-front.gitbooks.io/rxjs-doc-chinese/content/content/getting_started_with_rxjs/creating_and_querying_observable_sequences/creating_and_subscribing_to_simple_observable_sequences.html&quot;&gt;来自&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;创建和订阅单一可观察序列&quot;&gt;&lt;a href=&quot;#创建和订阅单一可观察序列&quot; class=&quot;headerlink&quot; title=&quot;创建和订阅单一可观察序列&quot;&gt;&lt;/a&gt;创建和订阅单一可观察序列&lt;/h1&gt;&lt;p&gt;你不需要去实现 &lt;code&gt;Observable&lt;/code&gt; 类去创建一个可观察序列。 同样的，你也不需要去实现 &lt;code&gt;Observer&lt;/code&gt; 去订阅数据流。通过安装 Rx 库，你可以利用 &lt;code&gt;Observable&lt;/code&gt;类型，它提供了许多操作符来根据零个，一个或多个元素去创建一个数据流。另外， RxJS 还提供 &lt;code&gt;subscribe&lt;/code&gt; 方法允许你使用 &lt;code&gt;onNext&lt;/code&gt;, &lt;code&gt;onError&lt;/code&gt; 和 &lt;code&gt;onCompleted&lt;/code&gt; 函数。&lt;/p&gt;
    
    </summary>
    
      <category term="RxJS" scheme="http://robin-front.github.io/categories/RxJS/"/>
    
    
      <category term="RxJS" scheme="http://robin-front.github.io/tags/RxJS/"/>
    
      <category term="Observable" scheme="http://robin-front.github.io/tags/Observable/"/>
    
  </entry>
  
  <entry>
    <title>Coverage针对js和css的代码覆盖检测-Chrome_devtools的新功能</title>
    <link href="http://robin-front.github.io/2017/04/06/Coverage%E9%92%88%E5%AF%B9js%E5%92%8Ccss%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E6%A3%80%E6%B5%8B-Chrome-devtools%E7%9A%84%E6%96%B0%E5%8A%9F%E8%83%BD/"/>
    <id>http://robin-front.github.io/2017/04/06/Coverage针对js和css的代码覆盖检测-Chrome-devtools的新功能/</id>
    <published>2017-04-06T03:21:26.000Z</published>
    <updated>2017-04-06T03:21:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>也许你之前用过一些像 <code>css usage</code>、<code>css used</code> 这样的浏览器插件去检测代码覆盖率。但现在，Chrome的实验版本<a href="https://www.google.com/chrome/browser/canary.html" target="_blank" rel="external">Canary</a>终于实现了代码覆盖率检测，这意味着它将很快普及到正式版本。这是一个令人兴奋的功能，在使用JavaScript和CSS时非常有用，所以我会做一个快速的演示，并探索它如何使用。</p>
<a id="more"></a>
<h2 id="它做了些什么事情"><a href="#它做了些什么事情" class="headerlink" title="它做了些什么事情"></a>它做了些什么事情</h2><p>代码覆盖可以在您运行您的Web应用程序的时候，遍历每个JS / CSS文件，看看哪些代码行运行，哪些代码没有运行。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*gD8lX40PSemDOZgvT695Mg.png" alt="coverage"></p>
<p>在这里，我做了一个简单的静态网页，Chrome生成了页面上存在的CSS和JS文件的问题汇总。右侧的栏显示每个文件的相对大小，红色表示未使用的代码，绿色显示运行的代码。</p>
<p>记录代码覆盖范围与devtools时间轴类似，您点击开始记录，然后在您的站点进行正常的交互。完成后，Chrome会进行一些计算并生成读数。在这里，我很好奇网站上有多少未使用的CSS，所以我导航到各个子页面，以确保我触及到每个css。果然，这里有很多改进的空间，因为我的网站上的css的97％没有使用！</p>
<p><img src="https://cdn-images-1.medium.com/max/1200/1*1SUTeKlhRee3MyKdxkUGtQ.png" alt="coverage"></p>
<p>Chrome还可让您深入研究单个文件的代码范围。在这里，左边的红色/绿色条显示哪一行执行了，哪一行没有。请注意，当检查最小化的文件时，可以按文件左下角的按钮来“<code>prettify</code>”代码。</p>
<h2 id="这有什么用"><a href="#这有什么用" class="headerlink" title="这有什么用"></a>这有什么用</h2><p>在一个复杂的或长期的项目上工作时，很容易积累冗余代码。如果你使用 <code>webpack</code> 或另一个JS构建系统，可以防止大多数无用的JS代码。但是对于CSS来说，这样做可能会有点棘手。有了这个覆盖工具，在Chrome是一个伟大的方式来快速了解多少冗余的代码在运行，哪些文件需要优化。</p>
<h2 id="如何才能使用它"><a href="#如何才能使用它" class="headerlink" title="如何才能使用它"></a>如何才能使用它</h2><p>下载Chrome的实验版本<a href="https://www.google.com/chrome/browser/canary.html" target="_blank" rel="external">Canary</a>或等待此功能更新到正式版本。</p>
<p>【译文参考】：<a href="https://blog.logrocket.com/using-the-chrome-devtools-new-code-coverage-feature-ca96c3dddcaf" target="_blank" rel="external">https://blog.logrocket.com/using-the-chrome-devtools-new-code-coverage-feature-ca96c3dddcaf</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;也许你之前用过一些像 &lt;code&gt;css usage&lt;/code&gt;、&lt;code&gt;css used&lt;/code&gt; 这样的浏览器插件去检测代码覆盖率。但现在，Chrome的实验版本&lt;a href=&quot;https://www.google.com/chrome/browser/canary.html&quot;&gt;Canary&lt;/a&gt;终于实现了代码覆盖率检测，这意味着它将很快普及到正式版本。这是一个令人兴奋的功能，在使用JavaScript和CSS时非常有用，所以我会做一个快速的演示，并探索它如何使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Chrome_devtools" scheme="http://robin-front.github.io/categories/Chrome-devtools/"/>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/Chrome-devtools/javascript/"/>
    
    
      <category term="coverage" scheme="http://robin-front.github.io/tags/coverage/"/>
    
      <category term="Chrome_devtools" scheme="http://robin-front.github.io/tags/Chrome-devtools/"/>
    
  </entry>
  
  <entry>
    <title>学习RxJS需要知道的奇淫技巧</title>
    <link href="http://robin-front.github.io/2017/04/05/%E5%AD%A6%E4%B9%A0RxJS%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7/"/>
    <id>http://robin-front.github.io/2017/04/05/学习RxJS需要知道的奇淫技巧/</id>
    <published>2017-04-05T09:06:03.000Z</published>
    <updated>2017-04-05T09:06:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-Rx-的奇淫技巧"><a href="#使用-Rx-的奇淫技巧" class="headerlink" title="使用 Rx 的奇淫技巧"></a>使用 Rx 的奇淫技巧</h1><h3 id="尝试画珠宝图"><a href="#尝试画珠宝图" class="headerlink" title="尝试画珠宝图"></a>尝试画珠宝图</h3><p>为你想创建的流画一个珠宝图。 通过画珠宝图，你将会很清楚你应该使用哪些操作符。</p>
<p>珠宝图就是每个珠宝表示当前的一个事件或状态。珠宝图需要包含输入和输出流。</p>
<p><img src="https://raw.githubusercontent.com/Reactive-Extensions/RxJS/master/doc/designguidelines/images/throttleWithTimeout.png" alt="throttleWithSelector"></p>
<a id="more"></a>
<p>通过画珠宝图，我们可以看到，我们在异步调用事件回调之前，需要延迟检测用户的输入。在这个例图里展示的是<code>throttle</code>操作符的延迟。从一个流创建另一个流，我们会使用 <code>flatMap</code> 或 <code>selectMany</code> 操作符。然后就有了下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dictionarySuggest = userInput.throttle(<span class="number">250</span>).flatMap(<span class="function"><span class="params">input</span> =&gt;</span> serverCall(input));</div></pre></td></tr></table></figure>
<h4 id="何时忽略这条指南"><a href="#何时忽略这条指南" class="headerlink" title="何时忽略这条指南"></a>何时忽略这条指南</h4><p>如果你感觉你已经可以很熟练地编写出你想要的流，你可以省去画珠宝图这一步。不管怎样，就算是 Rx 团队的成员在写代码的时候也仍然会先画一画珠宝图。</p>
<h3 id="调用-subscribe-时传递多个参数"><a href="#调用-subscribe-时传递多个参数" class="headerlink" title="调用 subscribe 时传递多个参数"></a>调用 <code>subscribe</code> 时传递多个参数</h3><p>为了方便， Rx 提供一个<code>subscribe</code>方法来加载观察者的回调函数。</p>
<p>观察者只需要实现这三个方法（<code>onNext</code>, <code>onError</code> &amp; <code>onCompleted</code>）。 <code>subscribe</code>方法的扩展允许开发人员使用这些方法的默认选项。</p>
<p>比如： 当调用<code>subscribe</code>方法时只有一个<code>onNext</code>参数，<code>onError</code>将捕获来自事件流的异常。<code>onCompleted</code>在这里什么也不会做。</p>
<p>大部分情况下，处理异常是很重要的（不管是对于恢复还是中断应用程序）。</p>
<p>知道事件流是否完成也经常是很重要的。举个例子，告诉用户他的操作是否完成了。</p>
<p>所以，最好提供完整的三个参数给 <code>subscribe</code> 操作符。</p>
<p>RxJS还提供了三种方便的方法，其仅订阅所期望的序列的一部分。其他的处理程序会默认为原来的行为。有三个这样的功能：</p>
<ul>
<li><code>subscribeOnNext</code>: 只对应 <code>onNext</code> 消息</li>
<li><code>subscribeOnError</code>: 只对应 <code>onError</code> 消息</li>
<li><code>subscribeOnCompleted</code>: 只对应 <code>onCompleted</code> 消息.</li>
</ul>
<h4 id="何时忽略这条指南-1"><a href="#何时忽略这条指南-1" class="headerlink" title="何时忽略这条指南"></a>何时忽略这条指南</h4><ul>
<li>当流确定不会有完成状态，比如 <code>keyup</code>事件。</li>
<li>当流确定不会抛出异常，比如一个事件，一个完全确定的流。</li>
<li>当默认行为是符合预期的时候。</li>
</ul>
<h3 id="考虑通过特定的调度程序并发引入操作符"><a href="#考虑通过特定的调度程序并发引入操作符" class="headerlink" title="考虑通过特定的调度程序并发引入操作符"></a>考虑通过特定的调度程序并发引入操作符</h3><p>相比使用<code>observeon</code>操作符来改变可观察序列产生消息的执行上下文，更好的做法是在正确的地方开始创建并发。 通过正确的调度器将会减少 <code>ObserveOn</code>操作符的使用。</p>
<h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Rx.Observable.range(<span class="number">0</span>, <span class="number">90000</span>, Rx.Scheduler.requestAnimationFrame).subscribe(draw);</div></pre></td></tr></table></figure>
<p>在这个例子中，来自<code>range</code>操作符的回调将会通过<code>window.requestAnimationFrame</code>传递。在这个例子中， <code>range</code>操作符的回调将被调用。默认情况下，当递归调用立即执行时，<code>range</code>过载将会代替 <code>onNext</code>在<code>Rx.Scheduler.currentThread</code>上的调用。 通过提供<code>Rx.Scheduler.requestAnimationFrame</code>调度程序， 所有来自observable的消息都将会在 <code>window.requestAnimationFrame</code>回调中产生。</p>
<h4 id="何时忽略这条指南-2"><a href="#何时忽略这条指南-2" class="headerlink" title="何时忽略这条指南"></a>何时忽略这条指南</h4><p>当结合来自不同执行上下文的几个事件时，使用指南4.4将所有消息尽可能晚地放在特定的执行上下文。</p>
<h3 id="尽可能少且尽可能迟地调用observeOn-操作符"><a href="#尽可能少且尽可能迟地调用observeOn-操作符" class="headerlink" title="尽可能少且尽可能迟地调用observeOn 操作符"></a>尽可能少且尽可能迟地调用<code>observeOn</code> 操作符</h3><p>通过使用 <code>observeOn</code> 操作符， 一个预定的功能是通过原始的消息流来获取信息。这可能会改变时序信息以及对系统施加额外的压力。在查询中延迟使用这个操作符可以改善这两个问题。</p>
<h4 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = xs.throttle(<span class="number">1000</span>)</div><div class="line">  .flatMap(<span class="function"><span class="params">x</span> =&gt;</span> ys.takeUntil(zs).sample(<span class="number">250</span>).map(<span class="function"><span class="params">y</span> =&gt;</span> x + y))</div><div class="line">  .merge(ws)</div><div class="line">  .filter(<span class="function"><span class="params">x</span> =&gt;</span> x &lt; <span class="number">10</span>)</div><div class="line">  .observeOn(Rx.Scheduler.requestAnimationFrame);</div></pre></td></tr></table></figure>
<p>这个例子合并了多个 运行在不同上下文的 observable 。这个查询筛选掉了大部分信息。将<code>observeOn</code>操作符放在查询中的前面会对筛选出来的消息做额外的工作。最后才调用 <code>observeOn</code> 将会最大限度地提高性能。</p>
<h4 id="何时忽略这条指南-3"><a href="#何时忽略这条指南-3" class="headerlink" title="何时忽略这条指南"></a>何时忽略这条指南</h4><p>如果你使用的 observable 并没有指定不同的上下文环境。这种情况下可以不必使用 <code>observeOn</code> 操作符。</p>
<h3 id="关注内存限制"><a href="#关注内存限制" class="headerlink" title="关注内存限制"></a>关注内存限制</h3><p>RxJS 有很多操作符和类可以在内存中创建 observable, 比如：<code>replay</code> 操作符。当这些内存存储着 observable 时，这些缓存的大小将取决于 observable 的操作。如果缓存过大，将会造成内存溢出。有许多缓冲操作符提供策略来限制缓冲区，不管是从时间方面还是大小。提供这个限制将解决内存压力问题。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = xs.replay(<span class="literal">null</span>, <span class="number">10000</span>, <span class="number">1000</span> * <span class="number">60</span> <span class="comment">/* 1 hr */</span>).refCount();</div></pre></td></tr></table></figure>
<p>这个例子中，<code>replay</code> 操作符创建了一个 buffer. 我们有限制这个 buffer 最多包含 10,000 条信息以及最多保留这些信息1小时。</p>
<h4 id="何时忽略这条指南-4"><a href="#何时忽略这条指南-4" class="headerlink" title="何时忽略这条指南"></a>何时忽略这条指南</h4><p>当 observable 创建了大量的信息只填充了一小块 buffer， 或者当 buffer本身有大小限制。</p>
<h3 id="使用-do-tap-操作符的副作用很明显"><a href="#使用-do-tap-操作符的副作用很明显" class="headerlink" title="使用 do/tap 操作符的副作用很明显"></a>使用 <code>do</code>/<code>tap</code> 操作符的副作用很明显</h3><p>有很多 Rx 操作符使用函数作为参数，这可以在这些参数中传递任何有效的用户代码。这些代码可以改变全局状态（比如改变全局变量，读写硬盘等等）。</p>
<p>Rx 是通过每个操作符组合起来运行的（除了共享操作符，例如“publish”）。这将使副作用发生在每个订阅。</p>
<p>如果这种表现是期望的行为，最好弄清楚在 <code>do</code>/<code>tap</code> 操作符中有副作用的这部分代码。这些方法会过载，只能调用指定的方法，比如 <code>doOnNext</code>/<code>tapOnNext</code>，<code>doOnError</code>/<code>tapOnError</code>,<code>doOnCompleted</code>/<code>tapOnCompleted</code></p>
<h4 id="例-1"><a href="#例-1" class="headerlink" title="例"></a>例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = xs.filter(<span class="function"><span class="params">x</span> =&gt;</span> x.failed).tap(<span class="function"><span class="params">x</span> =&gt;</span> log(x));</div></pre></td></tr></table></figure>
<p>这个例子中，过滤失败的消息。将它们分发到订阅observable的代码之前记录该消息。此记录有一个副作用（比如：将消息放置在计算机的事件日志中）并明确地通过调用<code>do</code>/<code>tap</code>操作符。</p>
<h3 id="假设消息可以传达，直到退订完成"><a href="#假设消息可以传达，直到退订完成" class="headerlink" title="假设消息可以传达，直到退订完成"></a>假设消息可以传达，直到退订完成</h3><p>由于RxJS 使用推模式，消息可以通过不同的上下文环境发送。 当退订的时候，消息可能还在路上。当退订还没有完成的时候，这些消息仍然可以被传达。当控制权被返回时，消息将不能再传达。退订过程可以是在一个不同的上下文环境中进行。</p>
<h4 id="何时忽略这条指南-5"><a href="#何时忽略这条指南-5" class="headerlink" title="何时忽略这条指南"></a>何时忽略这条指南</h4><p>一旦 <code>onCompleted</code> 或 <code>onError</code> 方法被调用，RxJS语法可以保证订阅已结束。</p>
<h3 id="使用-publish-操作符分享副作用"><a href="#使用-publish-操作符分享副作用" class="headerlink" title="使用 publish 操作符分享副作用"></a>使用 <code>publish</code> 操作符分享副作用</h3><p>因为许多 observable是冷门的<a href="http://channel9.msdn.com/Blogs/J.Van.Gogh/Rx-API-in-depth-Hot-and-Cold-observables" target="_blank" rel="external">(see cold vs. hot on Channel 9)</a>, 每个订阅都有单独的副作用。 某些情况下，这些副作用只发生一次。<code>publish</code> 操作符通过向多个用户广播单个订阅来提供共享订阅的机制。</p>
<p>有几个过载<code>publish</code>运算符。最方便的过载是那些提供了一个函数封装 observable 共享的副作用的参数。</p>
<h4 id="例-2"><a href="#例-2" class="headerlink" title="例"></a>例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xs = Rx.Observable.create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Side effect'</span>);</div><div class="line">  observer.onNext(<span class="string">'hi!'</span>);</div><div class="line">  observer.onCompleted();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">xs.publish(<span class="function"><span class="params">sharedXs</span> =&gt;</span> &#123;</div><div class="line">  sharedXs.subscribe(<span class="built_in">console</span>.log);</div><div class="line">  sharedXs.subscribe(<span class="built_in">console</span>.log);</div><div class="line">  <span class="keyword">return</span> sharedXs;</div><div class="line">&#125;).subscribe();</div></pre></td></tr></table></figure>
<p>这个例子中，<code>xs</code> 是一个有副作用的（写入console） observable。正常情况下，每个单独的订阅都会触发这些副作用。 <code>publish</code> 操作符使用<code>xs</code>单独给所有订阅者 <code>sharedXs</code> 变量去订阅。</p>
<h4 id="何时忽略这条指南-6"><a href="#何时忽略这条指南-6" class="headerlink" title="何时忽略这条指南"></a>何时忽略这条指南</h4><p>只有当 <code>publish</code> 操作符需要共享副作用时才使用这条指南。在大多数情况下，您可以创建单独的订阅，没有任何问题：不管是订阅没有副作用的或是副作用可以执行多次没有任何问题的。</p>
<p><a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/designguidelines#4-using-rx" target="_blank" rel="external">参考</a>
<a href="https://robin-front.gitbooks.io/rxjs-doc-chinese/content/content/guidelines/using.html" target="_blank" rel="external">同步翻译至RxJS中文文档</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用-Rx-的奇淫技巧&quot;&gt;&lt;a href=&quot;#使用-Rx-的奇淫技巧&quot; class=&quot;headerlink&quot; title=&quot;使用 Rx 的奇淫技巧&quot;&gt;&lt;/a&gt;使用 Rx 的奇淫技巧&lt;/h1&gt;&lt;h3 id=&quot;尝试画珠宝图&quot;&gt;&lt;a href=&quot;#尝试画珠宝图&quot; class=&quot;headerlink&quot; title=&quot;尝试画珠宝图&quot;&gt;&lt;/a&gt;尝试画珠宝图&lt;/h3&gt;&lt;p&gt;为你想创建的流画一个珠宝图。 通过画珠宝图，你将会很清楚你应该使用哪些操作符。&lt;/p&gt;
&lt;p&gt;珠宝图就是每个珠宝表示当前的一个事件或状态。珠宝图需要包含输入和输出流。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Reactive-Extensions/RxJS/master/doc/designguidelines/images/throttleWithTimeout.png&quot; alt=&quot;throttleWithSelector&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="RxJS" scheme="http://robin-front.github.io/categories/RxJS/"/>
    
    
      <category term="RxJS" scheme="http://robin-front.github.io/tags/RxJS/"/>
    
  </entry>
  
  <entry>
    <title>为什么选择 RxJS?</title>
    <link href="http://robin-front.github.io/2017/04/04/why-rxjs/"/>
    <id>http://robin-front.github.io/2017/04/04/why-rxjs/</id>
    <published>2017-04-04T09:48:15.000Z</published>
    <updated>2017-04-04T09:48:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Why-RxJS"><a href="#Why-RxJS" class="headerlink" title="Why RxJS?"></a>Why RxJS?</h2><p>你可能会问，为什么选择 RxJS?  为什么不是 Promises? Promises 可以很好地解决异步操作，像使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" target="_blank" rel="external">XMLHttpRequest</a> 去查询服务器, 它预期会返回值并且最终完成请求。  <code>The Reactive Extensions</code> 统一了 <code>JavaScript</code> 中的 <code>Promises</code>, <code>callbacks</code> 以及事件数据，比如 DOM输入, <code>Web Workers</code>, <code>Web Sockets</code>. 一旦我们统一了这些概念，就可以进行各种各样的组合.</p>
<a id="more"></a>
<p>为了让您了解丰富的组合，我们可以创建一个自动完成功能，它从文本输入中接收用户输入，然后查询服务，确保不会对每个键盘输入的进行泛滥地调用，而是以一种更自然的方式调用。</p>
<p>首先，我们将引用JavaScript文件，包括jQuery，尽管RxJS没有依赖于jQuery …
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://code.jquery.com/jquery.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"rx.lite.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>接下来，我们将从输入框获取用户输入，使用<a href="content/observable/observable_methods/fromevent.html"><code>Rx.Observable.fromEvent</code></a> 方法监听 <code>keyup</code> 事件.  如果 <a href="http://jquery.com" target="_blank" rel="external">jQuery</a>, <a href="http://zeptojs.com/" target="_blank" rel="external">Zepto</a>, <a href="https://angularjs.org/" target="_blank" rel="external">AngularJS</a> and <a href="http://emberjs.com/" target="_blank" rel="external">Ember.js</a> 可用，将会使用它们来绑定事件, 否则将使用原生事件绑定. 这跟您的框架思考事件的一致方式，因此没有任何惊喜。
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $input = $(<span class="string">'#input'</span>),</div><div class="line">    $results = $(<span class="string">'#results'</span>);</div><div class="line"></div><div class="line"><span class="comment">/* 只从 keyup 事件获得输入值 */</span></div><div class="line"><span class="keyword">var</span> keyups = Rx.Observable.fromEvent($input, <span class="string">'keyup'</span>)</div><div class="line">    .map(<span class="function"><span class="params">e</span> =&gt;</span> e.target.value)</div><div class="line">    .filter(<span class="function"><span class="params">text</span> =&gt;</span> text.length &gt; <span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="comment">/* 函数节流输出设置为 500ms */</span></div><div class="line"><span class="keyword">var</span> throttled = keyups.throttle(<span class="number">500</span> <span class="comment">/* ms */</span>);</div><div class="line"></div><div class="line"><span class="comment">/* 现在判断值是否有改变，只获取不同的值 */</span></div><div class="line"><span class="keyword">var</span> distinct = throttled.distinctUntilChanged();</div></pre></td></tr></table></figure></p>
<p>现在，让我们来查询维基百科！在RxJS中，我们可以立即通过<code>Rx.Observable.fromPromise</code>方法绑定到任何<a href="https://github.com/promises-aplus/promises-spec" target="_blank" rel="external">Promises A+</a>的实现上，或者直接返回它，并将其封装。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">searchWikipedia</span> (<span class="params">term</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> $.ajax(&#123;</div><div class="line">        <span class="attr">url</span>: <span class="string">'http://en.wikipedia.org/w/api.php'</span>,</div><div class="line">        <span class="attr">dataType</span>: <span class="string">'jsonp'</span>,</div><div class="line">        <span class="attr">data</span>: &#123;</div><div class="line">            <span class="attr">action</span>: <span class="string">'opensearch'</span>,</div><div class="line">            <span class="attr">format</span>: <span class="string">'json'</span>,</div><div class="line">            <span class="attr">search</span>: term</div><div class="line">        &#125;</div><div class="line">    &#125;).promise();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一旦创建，现在我们可以将不同的节流输入绑定在一起，然后查询服务。在这种情况下，我们将调用<code>flatMapLatest</code>获取该值，并确保我们不会有任何混乱的调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> suggestions = distinct.flatMapLatest(searchWikipedia);</div></pre></td></tr></table></figure>
<p>最后，我们将在可观察对象上调用<code>subscribe</code>方法开始拉数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">suggestions.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">var</span> res = data[<span class="number">1</span>];</div><div class="line"></div><div class="line">    <span class="comment">/* Do something 像数据绑定 */</span></div><div class="line">    $results.empty();</div><div class="line"></div><div class="line">    $.each(res, (_, value) =&gt; $(<span class="string">'&lt;li&gt;'</span> + value + <span class="string">'&lt;/li&gt;'</span>).appendTo($results));</div><div class="line">&#125;, error =&gt; &#123;</div><div class="line">    <span class="comment">/* handle any errors */</span></div><div class="line">    $results.empty();</div><div class="line"></div><div class="line">    $(<span class="string">'&lt;li&gt;Error: '</span> + error + <span class="string">'&lt;/li&gt;'</span>).appendTo($results);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><a href="https://github.com/Reactive-Extensions/RxJS#why-rxjs" target="_blank" rel="external">翻译参考</a>
<a href="https://robin-front.gitbooks.io/rxjs-doc-chinese/content/why_rxjs.html" target="_blank" rel="external">同步发布RxJS中文文档</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Why-RxJS&quot;&gt;&lt;a href=&quot;#Why-RxJS&quot; class=&quot;headerlink&quot; title=&quot;Why RxJS?&quot;&gt;&lt;/a&gt;Why RxJS?&lt;/h2&gt;&lt;p&gt;你可能会问，为什么选择 RxJS?  为什么不是 Promises? Promises 可以很好地解决异步操作，像使用 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;XMLHttpRequest&lt;/a&gt; 去查询服务器, 它预期会返回值并且最终完成请求。  &lt;code&gt;The Reactive Extensions&lt;/code&gt; 统一了 &lt;code&gt;JavaScript&lt;/code&gt; 中的 &lt;code&gt;Promises&lt;/code&gt;, &lt;code&gt;callbacks&lt;/code&gt; 以及事件数据，比如 DOM输入, &lt;code&gt;Web Workers&lt;/code&gt;, &lt;code&gt;Web Sockets&lt;/code&gt;. 一旦我们统一了这些概念，就可以进行各种各样的组合.&lt;/p&gt;
    
    </summary>
    
      <category term="RxJS" scheme="http://robin-front.github.io/categories/RxJS/"/>
    
    
      <category term="RxJS" scheme="http://robin-front.github.io/tags/RxJS/"/>
    
  </entry>
  
  <entry>
    <title>Lerp的应用-利用简单线性插值来平滑动画效果</title>
    <link href="http://robin-front.github.io/2017/03/20/Lerp%E7%9A%84%E5%BA%94%E7%94%A8-%E5%88%A9%E7%94%A8%E7%AE%80%E5%8D%95%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC%E6%9D%A5%E5%B9%B3%E6%BB%91%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C/"/>
    <id>http://robin-front.github.io/2017/03/20/Lerp的应用-利用简单线性插值来平滑动画效果/</id>
    <published>2017-03-20T03:04:39.000Z</published>
    <updated>2017-03-20T03:04:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇的 <a href="http://robin-front.github.io/2017/03/19/RxJS%E7%9A%84%E5%8A%A8%E7%94%BB%E7%AE%80%E4%BB%8B/">RxJS的动画简介</a> 里提到一个动画平滑的小技巧, 这里展示几个例子，它真的很简单却很有用。</p>
<p><code>Lerp</code>是两点之间的线性插值的别称。这是一个实现起来相当简单的效果，但可以真正改善你的动画的外观，如果你将一个对象从点A移动到点B.
<a id="more"></a></p>
<h1 id="它是如何工作的？"><a href="#它是如何工作的？" class="headerlink" title="它是如何工作的？"></a>它是如何工作的？</h1><p>如果您有一个对象的当前位置和目标的位置，您可以线性内插这些点之间的距离的百分比，并在每个动画帧上更新该位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">lerp</span>(<span class="params">position, targetPosition</span>) </span>&#123;</div><div class="line"><span class="comment">// 计算当前位置与目标位置差值的 20%</span></div><div class="line">  position.x += (targetPosition.x - position.x)*<span class="number">0.2</span>;</div><div class="line">  position.y += (targetPosition.y - position.y)*<span class="number">0.2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过这样做，对象移动的量随着位置和目标之间的距离减小而变小。这意味着对象将越来越接近它的目标，速度将减慢，这创造一个很好的缓和效果。</p>
<h1 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h1><p>这里有一个球跟随用户的鼠标或触摸运动的例子。如果我们使球移动到鼠标移动的地方，球的移动可以非常快但看起来有点脱节。如果我们快速移动鼠标，我们也可以看到单独的“球影”。</p>
<iframe width="100%" height="300" src="//codepen.io/anon/embed/avXmyV?slug-hash=avXmyV&default-tab=result&height=300&theme-id=1970&user=anon"></iframe>

<p>这里是同样的演示，除了这次我们使用lerp。不是将球立即向右移动到鼠标位置，我们每次将它移动10％的距离。</p>
<iframe width="100%" height="300" src="//codepen.io/anon/embed/yYZapV?slug-hash=yYZapV&default-tab=result&height=300&theme-id=1970&user=anon"></iframe>

<p>注意球的运动很平滑，整体更令人愉快的效果。</p>
<p>这里是使用lerp的另一个例子。这次我们有一个滚动指示器，当您向下滚动“页面”时更新。</p>
<iframe width="100%" height="300" src="//codepen.io/anon/embed/rOPMvz?slug-hash=rOPMvz&default-tab=result&height=300&theme-id=1970&user=anon"></iframe>

<iframe width="100%" height="300" src="//codepen.io/anon/embed/epxdxe?slug-hash=epxdxe&default-tab=result&height=300&theme-id=1970&user=anon"></iframe>

<p>所以，lerp“把戏”是一个伟大的工具，我们的网络动画套路，以对抗线性或锯齿状的运动。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇的 &lt;a href=&quot;http://robin-front.github.io/2017/03/19/RxJS%E7%9A%84%E5%8A%A8%E7%94%BB%E7%AE%80%E4%BB%8B/&quot;&gt;RxJS的动画简介&lt;/a&gt; 里提到一个动画平滑的小技巧, 这里展示几个例子，它真的很简单却很有用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Lerp&lt;/code&gt;是两点之间的线性插值的别称。这是一个实现起来相当简单的效果，但可以真正改善你的动画的外观，如果你将一个对象从点A移动到点B.
    
    </summary>
    
      <category term="animate" scheme="http://robin-front.github.io/categories/animate/"/>
    
    
      <category term="animate" scheme="http://robin-front.github.io/tags/animate/"/>
    
  </entry>
  
  <entry>
    <title>RxJS的动画简介</title>
    <link href="http://robin-front.github.io/2017/03/19/RxJS%E7%9A%84%E5%8A%A8%E7%94%BB%E7%AE%80%E4%BB%8B/"/>
    <id>http://robin-front.github.io/2017/03/19/RxJS的动画简介/</id>
    <published>2017-03-19T06:40:21.000Z</published>
    <updated>2017-03-19T06:40:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文译自 <a href="https://css-tricks.com/animated-intro-rxjs/" target="_blank" rel="external">An Animated Intro to RxJS</a></p>
<p>你可能听说过RxJS，ReactiveX，或反应式编程，或者甚至只听过函数式编程。这些术语在谈论最新和最前沿的前端技术时变得越来越突出。如果你像我一样，当你第一次尝试学习它时，你感到很困惑。
<a id="more"></a></p>
<p>根据<a href="http://reactivex.io/" target="_blank" rel="external">ReactiveX.io</a>：</p>
<blockquote>
<p>ReactiveX是一个库，用于通过使用可观察序列来组成异步和基于事件的程序。</p>
</blockquote>
<p>这句话包含了很多要消化的内容。在本文中，我们将采用一种不同的方法来学习RxJS（ReactiveX的JavaScript实现）和<code>Observables</code>，通过创建反应式动画。</p>
<h1 id="理解Observable"><a href="#理解Observable" class="headerlink" title="理解Observable"></a>理解Observable</h1><p>数组是元素的集合，例如[1, 2, 3, 4, 5]。你可以立即得到所有的元素，你可以做的事情像<code>map</code>，<code>filter</code>和映射他们。这允许你以任何你想要的方式转换元素的集合。</p>
<p>现在假设阵列中的每个元素随时间发生; 也就是说，你不是立即得到所有的元素，而是一次一个。你可能得到第一个元素在第1秒，下一个在第3秒，依此类推。以下是如何表示：</p>
<p><img src="https://cdn.css-tricks.com/wp-content/uploads/2017/02/rx-article-1.svg" alt="a steam of values"></p>
<p>这可以被描述为值的流，或事件序列，或更确切地，称为<code>observable</code>。</p>
<blockquote>
<p><code>observable</code>是随时间的值的集合。</p>
</blockquote>
<p>就像使用数组一样，您可以对这些值进行映射，过滤等操作，以创建和组合新的<code>observable</code>。最后，你可以订阅这些<code>observable</code>，并在<code>steam</code>的值之后执行你想要做的事。这是RxJS的源。</p>
<h1 id="RxJS起步"><a href="#RxJS起步" class="headerlink" title="RxJS起步"></a>RxJS起步</h1><p>开始使用RxJS的最简单的方法是使用CDN，虽然有<a href="http://reactivex.io/rxjs/manual/installation.html" target="_blank" rel="external">很多方法可以安装</a>，这取决于项目的需要。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- the latest, minified version of RxJS --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/@reactivex/rxjs@latest/dist/global/Rx.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>一旦你的项目中有RxJS，你可以从任何东西中创建一个observable ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> aboutAnything = <span class="number">42</span>;</div><div class="line"></div><div class="line"><span class="comment">// 从变量创建</span></div><div class="line"><span class="comment">// The observable emits that value, then completes.</span></div><div class="line"><span class="keyword">const</span> meaningOfLife$ = Rx.Observable.just(aboutAnything);</div><div class="line"></div><div class="line"><span class="comment">// 从数组或可遍历的结构中创建</span></div><div class="line"><span class="comment">// The observable emits each item from the array, then completes.</span></div><div class="line"><span class="keyword">const</span> myNumber$ = Rx.Observable.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</div><div class="line"></div><div class="line"><span class="comment">// From a promise.</span></div><div class="line"><span class="comment">// The observable emits the result eventually, then completes (or errors).</span></div><div class="line"><span class="keyword">const</span> myData$ = Rx.Observable.fromPromise(fetch(<span class="string">'http://example.com/users'</span>));</div><div class="line"></div><div class="line"><span class="comment">// 从事件中创建</span></div><div class="line"><span class="comment">// The observable continuously emits events from the event listener.</span></div><div class="line"><span class="keyword">const</span> mouseMove$ = Rx.Observable</div><div class="line">  .fromEvent(<span class="built_in">document</span>.documentElement, <span class="string">'mousemove'</span>);</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：变量末尾的美元符号<code>$</code>是一个约定，表示该变量是一个可观察者。<code>Observable</code>可以用来对任何可以表示为随时间变化的值的流进行建模，例如事件，Promises，计时器，间隔和动画。</p>
</blockquote>
<p>因为，这些可观察的东西不做任何事情，至少直到你实际观察他们。一个简单的订阅将做到这一点，使用创建<code>.subscribe()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">myNumber$.subscribe(<span class="function"><span class="params">number</span> =&gt;</span> <span class="built_in">console</span>.log(number));</div><div class="line"></div><div class="line"><span class="comment">// Result:</span></div><div class="line"><span class="comment">// &gt; 1</span></div><div class="line"><span class="comment">// &gt; 2</span></div><div class="line"><span class="comment">// &gt; 3</span></div><div class="line"><span class="comment">// &gt; 4</span></div><div class="line"><span class="comment">// &gt; 5</span></div></pre></td></tr></table></figure>
<p>让我们实践看看：</p>
<iframe height="400" width="100%" src="//codepen.io/davidkpiano/embed/d6f5fa72a9b7b6c2c9141de6fa1ab93f?height=400&theme-id=1&slug-hash=d6f5fa72a9b7b6c2c9141de6fa1ab93f&default-tab=js%2Cresult&user=davidkpiano&embed-version=2&pen-title="></iframe>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> docElm = <span class="built_in">document</span>.documentElement;</div><div class="line"><span class="keyword">const</span> cardElm = <span class="built_in">document</span>.querySelector(<span class="string">'#card'</span>);</div><div class="line"><span class="keyword">const</span> titleElm = <span class="built_in">document</span>.querySelector(<span class="string">'#title'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> mouseMove$ = Rx.Observable</div><div class="line">  .fromEvent(docElm, <span class="string">'mousemove'</span>);</div><div class="line"></div><div class="line">mouseMove$.subscribe(<span class="function"><span class="params">event</span> =&gt;</span> &#123;</div><div class="line">  titleElm.innerHTML = <span class="string">`<span class="subst">$&#123;event.clientX&#125;</span>, <span class="subst">$&#123;event.clientY&#125;</span>`</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>从<code>mouseMove$</code>观察到的，每次<code>mousemove</code>事件发生时，订阅改变<code>titleElm</code>的<code>.innerHTML</code>的鼠标的位置。该<a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-map" target="_blank" rel="external"><code>.map</code></a>操作（据工作原理类似<code>Array.prototype.map</code>方法）可帮助简化事情：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Produces e.g., &#123;x: 42, y: 100&#125; instead of the entire event</span></div><div class="line"><span class="keyword">const</span> mouseMove$ = Rx.Observable</div><div class="line">  .fromEvent(docElm, <span class="string">'mousemove'</span>)</div><div class="line">  .map(<span class="function"><span class="params">event</span> =&gt;</span> (&#123; <span class="attr">x</span>: event.clientX, <span class="attr">y</span>: event.clientY &#125;));</div></pre></td></tr></table></figure>
<p>使用一些数学和内联样式，您可以使卡片朝向鼠标旋转。<code>pos.y / clientHeight</code>和<code>pos.x / clientWidth</code>计算为0和1之间的值，所以乘以由50减去一半（25）产生的值从-25到25，这正是我们需要为我们的旋转值：</p>
<iframe width="100%" height="500" src="//codepen.io/davidkpiano/embed/55cb38a26b9166c41017c6512ea00209?height=500&theme-id=1&slug-hash=55cb38a26b9166c41017c6512ea00209&default-tab=js%2Cresult&user=davidkpiano&embed-version=2&pen-title="></iframe>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> docElm = <span class="built_in">document</span>.documentElement;</div><div class="line"><span class="keyword">const</span> cardElm = <span class="built_in">document</span>.querySelector(<span class="string">'#card'</span>);</div><div class="line"><span class="keyword">const</span> titleElm = <span class="built_in">document</span>.querySelector(<span class="string">'#title'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> &#123; clientWidth, clientHeight &#125; = docElm;</div><div class="line"></div><div class="line"><span class="keyword">const</span> mouseMove$ = Rx.Observable</div><div class="line">  .fromEvent(docElm, <span class="string">'mousemove'</span>)</div><div class="line">  .map(<span class="function"><span class="params">event</span> =&gt;</span> (&#123; <span class="attr">x</span>: event.clientX, <span class="attr">y</span>: event.clientY &#125;))</div><div class="line"></div><div class="line">mouseMove$.subscribe(<span class="function"><span class="params">pos</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> rotX = (pos.y / clientHeight * <span class="number">-50</span>) - <span class="number">25</span>;</div><div class="line">  <span class="keyword">const</span> rotY = (pos.x / clientWidth * <span class="number">50</span>) - <span class="number">25</span>;</div><div class="line"></div><div class="line">  cardElm.style = <span class="string">`</span></div><div class="line">    transform: rotateX(<span class="subst">$&#123;rotX&#125;</span>deg) rotateY(<span class="subst">$&#123;rotY&#125;</span>deg);</div><div class="line">  `;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h1 id="使用-merge-合并"><a href="#使用-merge-合并" class="headerlink" title="使用 .merge 合并"></a>使用 <code>.merge</code> 合并</h1><p>现在让我们假设你想让这个适应触摸设备，不管是鼠标事件或是触摸动作。没有任何混乱的回调，你可以通过RxJS使用很多方法来结合<code>Observable</code>。在这个例子中，可以使用<code>.merge</code>实现。就像交通多条车道合并成一个单一的车道，这将返回一个包含所有数据的<code>Observable</code>通过合并多个<code>Observable</code>.</p>
<p><img src="https://cdn.css-tricks.com/wp-content/uploads/2017/02/merge.png" alt="来源：http://rxmarbles.com/#merge"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> touchMove$ = Rx.Observable</div><div class="line">  .fromEvent(docElm, <span class="string">'touchmove'</span>)</div><div class="line">  .map(<span class="function"><span class="params">event</span> =&gt;</span> (&#123;</div><div class="line">    <span class="attr">x</span>: event.touches[<span class="number">0</span>].clientX,</div><div class="line">    <span class="attr">y</span>: event.touches[<span class="number">0</span>].clientY</div><div class="line">  &#125;));</div><div class="line"></div><div class="line"><span class="keyword">const</span> move$ = Rx.Observable.merge(mouseMove$, touchMove$);</div><div class="line"></div><div class="line">move$.subscribe(<span class="function"><span class="params">pos</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>继续，尝试在触摸屏设备上平移左右：</p>
<iframe width="100%" height="500" src="//codepen.io/davidkpiano/embed/4a430c13f4faae099e5a34cb2a82ce6d?height=500&theme-id=1&slug-hash=4a430c13f4faae099e5a34cb2a82ce6d&default-tab=js%2Cresult&user=davidkpiano&embed-version=2&pen-title="></iframe>

<p>还有很多其他有用的<code>Observable</code><a href="http://reactivex.io/documentation/operators.html#combining" target="_blank" rel="external">合并方法</a>，如<code>.switch()</code>，<code>.combineLatest()</code>和<code>.withLatestFrom()</code>，我们继续关注下一个点。</p>
<h1 id="添加平滑的运动"><a href="#添加平滑的运动" class="headerlink" title="添加平滑的运动"></a>添加平滑的运动</h1><p>旋转卡动作有点太死板。只要鼠标（或手指）停止，旋转即刻停止。为了解决这个问题，线性内插（线性插值）都可以使用。一般技术中描述这个<a href="https://codepen.io/rachsmith/post/animation-tip-lerp" target="_blank" rel="external">伟大的教程由雷切尔·史密斯</a>。本质上，而不是从A点跳到B，线性插值会在每一个动画运行一小部分。这将产生一个平滑的过渡，甚至当鼠标/触摸移动已停止。</p>
<p>让我们创建一个函数实现这个功能：计算给定初始值和终值下一个值，采用线性插值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">lerp</span>(<span class="params">start, end</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> dx = end.x - start.x;</div><div class="line">  <span class="keyword">const</span> dy = end.y - start.y;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">x</span>: start.x + dx * <span class="number">0.1</span>,</div><div class="line">    <span class="attr">y</span>: start.y + dy * <span class="number">0.1</span>,</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>非常简约。我们有一个纯函数每次返回一个新的，线性内插的位置值，通过移动当前的（开始）接近每个动画帧上的下一个（完）位置10％的位置。</p>
<h1 id="调度和-interval"><a href="#调度和-interval" class="headerlink" title="调度和.interval"></a>调度和.interval</h1><p>问题是，我们如何在RxJS中表示动画帧？原来，RxJS有一个叫做<code>Schedulers</code>的东西，它控制什么时候从一个<code>observable</code>发出数据，当订阅都开始接收值。</p>
<p>使用<a href="http://reactivex.io/documentation/operators/interval.html" target="_blank" rel="external"><code>Rx.Observable.interval()</code></a>，您可以创建一个<code>observable</code>，它在固定的时间间隔发出值，例如每隔一秒（Rx.Observable.interval(1000)）。如果创建一个非常微小的时间间隔，例如<code>Rx.Observable.interval(0)</code>，并希望它只在每个动画帧上发出值，那么在动画帧内<code>Rx.Scheduler.animationFrame</code>每隔16到17ms就会发出一个值，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> animationFrame$ = Rx.Observable.interval(<span class="number">0</span>, Rx.Scheduler.animationFrame);</div></pre></td></tr></table></figure>
<h1 id="结合-withLatestFrom"><a href="#结合-withLatestFrom" class="headerlink" title="结合.withLatestFrom"></a>结合<code>.withLatestFrom</code></h1><p>要创建平滑线性插值，您只需要关心每个动画帧的最新鼠标或触摸位置。要做到这一点，有一个操作符叫<code>.withLatestFrom()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> smoothMove$ = animationFrame$</div><div class="line">  .withLatestFrom(move$, (frame, move) =&gt; move);</div></pre></td></tr></table></figure>
<p>现在，<code>smoothMove$</code>是一个新的<code>observable</code>，<code>move$</code> 只有当<code>animationFrame$</code>发出一个值时，才会发出最新的值。这是必须的 - 你并不想要的动画帧外发出的值（除非你真的喜欢jank）。第二个参数是描述当组合来自每个可观察的最新值时要做什么的函数。在这种情况下，唯一重要的值是<code>move</code>值，这是所有返回的值。</p>
<p><img src="https://cdn.css-tricks.com/wp-content/uploads/2017/02/with-latest-from.png" alt="withLatestFrom"></p>
<h1 id="与过渡-scan"><a href="#与过渡-scan" class="headerlink" title="与过渡.scan"></a>与过渡<code>.scan</code></h1><p>现在你有一个<code>observable</code>从<code>move$</code>每个动画帧发出最新的值，是时候添加线性插值了。<a href="http://reactivex.io/documentation/operators/scan.html" target="_blank" rel="external"><code>.scan()</code></a>运算符“积累”从可观察到的当前值和下一个值，提供给需要这些值的函数。</p>
<p><img src="https://cdn.css-tricks.com/wp-content/uploads/2017/02/scan.png" alt="#scan"></p>
<p>这对于我们的线性插值用例是完美的。记住，我们的<code>lerp(start, end)</code>函数有两个参数：<code>start（current）</code>值和<code>end（next）</code>值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> smoothMove$ = animationFrame$</div><div class="line">  .withLatestFrom(move$, (frame, move) =&gt; move)</div><div class="line">  .scan(<span class="function">(<span class="params">current, next</span>) =&gt;</span> lerp(current, next));</div><div class="line">  <span class="comment">// or simplified: .scan(lerp)</span></div></pre></td></tr></table></figure>
<p>现在，您可以订阅<code>smoothMove$</code>代替<code>move$</code>在操作中查看线性插值：</p>
<iframe width="100%" height="500" src="//codepen.io/davidkpiano/embed/127ee82ad742b4dddd657703e2259852?height=500&theme-id=1&slug-hash=127ee82ad742b4dddd657703e2259852&default-tab=js%2Cresult&user=davidkpiano&embed-version=2&pen-title="></iframe>

<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p><code>RxJS</code> 不是一个动画库，当然，但对于处理随时间变化的值，它的可组合以及声明性的方式是<code>ReactiveX</code>演示动画的核心概念。反应式编程是考虑编程的另类方式，具有许多优点：</p>
<ul>
<li>它是声明性的，可组合的和不可变的，避免回调地狱，并使你的代码更简洁，可重用和模块化。</li>
<li>它在处理所有类型的异步数据时非常有用，无论是获取数据，通过<code>WebSockets</code>进行通信，监听来自多个源的外部事件，甚至是动画。</li>
<li>“关注的分离” - 您使用<code>Observable</code>和运算符声明性地表示您期望的数据，然后在一个单独的上下文环境中处理<code>.subscribe()</code>，而不会在您的原代码上产生副作用。</li>
<li>有这么多语言的实现了它 - <code>Java</code>，<code>PHP</code>，<code>Python</code>，<code>Ruby</code>，<code>C＃</code>，<code>Swift</code>和其他你可能没有听说过的。</li>
<li>它不是一个框架，它与许多流行的框架（如React，Angular和Vue）可以非常好地融合在一起。</li>
<li>你可以得到行家指点，如果你想要，但<code>ReactiveX</code>从被提出到现在实施了近十年前（2009年），由创意所产生的<a href="http://conal.net/papers/icfp97/" target="_blank" rel="external"><code>Conal Elliott</code>和保罗·胡达克</a> 2年前（1997年），在描述功能性反应的动画（惊喜惊喜）。不用说，它经过了足够的测试。</li>
</ul>
<p>本文探讨了一些有用的部分和<code>RxJS</code>的概念-创建与订阅<code>.fromEvent()</code>和<code>.interval()</code>，对订阅操作<code>.map()</code>和<code>.scan()</code>，多个订阅相结合<code>.merge()</code>和<code>.withLatestFrom()</code>，并与引入调度<code>Rx.Scheduler.animationFrame</code>。有很多其他有用的资源学习RxJS：</p>
<ul>
<li><a href="http://reactivex.io/rxjs/" target="_blank" rel="external">ReactiveX：RxJS</a> - 官方文档</li>
<li><a href="http://rxmarbles.com/" target="_blank" rel="external">RxMarbles</a> - 用于可视化观察</li>
<li><a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754" target="_blank" rel="external">Reactive编程的介绍</a></li>
</ul>
<p>如果你想进一步深入<code>RxJS动画</code>（和使用更多的CSS变量），请查看<a href="http://slides.com/davidkhourshid/reactanim#/" target="_blank" rel="external">我的幻灯片从<code>CSS Dev Conf 2016</code></a>和<a href="https://www.youtube.com/watch?v=lTCukb6Zn3g" target="_blank" rel="external">我2016年的演讲从JSConf冰岛</a>关于反应式动画与CSS变量。这里有一些使用RxJS创建的动画可能对触发灵感有帮助：</p>
<ul>
<li><a href="http://codepen.io/davidkpiano/pen/Vmyyzd" target="_blank" rel="external">3D数字时钟</a></li>
<li><a href="http://codepen.io/davidkpiano/pen/mAoaxP" target="_blank" rel="external">心脏app概念</a></li>
<li><a href="http://codepen.io/Enki/pen/eBwKgO" target="_blank" rel="external">透视使用RxJS拖动</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文译自 &lt;a href=&quot;https://css-tricks.com/animated-intro-rxjs/&quot;&gt;An Animated Intro to RxJS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;你可能听说过RxJS，ReactiveX，或反应式编程，或者甚至只听过函数式编程。这些术语在谈论最新和最前沿的前端技术时变得越来越突出。如果你像我一样，当你第一次尝试学习它时，你感到很困惑。
    
    </summary>
    
      <category term="RxJS" scheme="http://robin-front.github.io/categories/RxJS/"/>
    
    
      <category term="RxJS" scheme="http://robin-front.github.io/tags/RxJS/"/>
    
  </entry>
  
  <entry>
    <title>通过动图简单通俗地了解Flexbox的工作原理</title>
    <link href="http://robin-front.github.io/2017/03/13/%E9%80%9A%E8%BF%87%E5%8A%A8%E5%9B%BE%E7%AE%80%E5%8D%95%E9%80%9A%E4%BF%97%E5%9C%B0%E4%BA%86%E8%A7%A3Flexbox%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://robin-front.github.io/2017/03/13/通过动图简单通俗地了解Flexbox的工作原理/</id>
    <published>2017-03-13T03:31:42.000Z</published>
    <updated>2017-03-13T03:31:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文译自 <a href="https://medium.freecodecamp.com/even-more-about-how-flexbox-works-explained-in-big-colorful-animated-gifs-a5a74812b053#.iwqlenuqq" target="_blank" rel="external">Scott Domes</a></p>
<p>Flex属性是一个复合属性，而大部分教程中都只设置一个值，但其实它包含了 <code>flex-basis</code>、<code>flex-grow</code>、<code>flex-shrink</code>.
让我们深入了解Flexbox - 以及如何利用它来构建适应性强和漂亮的布局.
<a id="more"></a></p>
<h3 id="属性一：-Flex-Basis"><a href="#属性一：-Flex-Basis" class="headerlink" title="属性一： Flex-Basis"></a>属性一： Flex-Basis</h3><p>在<a href="https://medium.freecodecamp.com/an-animated-guide-to-flexbox-d280cf6afc35#.s7qtdlnbf" target="_blank" rel="external">上一篇文章</a>中，我们主要把它用于外部容器中。这一次，我们试着把它用在容器内的子元素中。</p>
<p>这是一个很不起眼的属性，但也很直接。</p>
<p><code>Flex-basis</code> 控制着一个元素的默认大小，在其他 flex 属性应用之前。</p>
<p>在下面的 GIF 看来，它的作用和 <code>width</code> 的作用一样：</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*S3LKFr_BICUtAWA5LOFxVw.gif" alt="flex-basis"></p>
<p>是什么让 <code>flex-basis</code> 表现得和 <code>width</code> 一样？事实上，它对应着 flex 的坐标轴。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*_Ruy6jFG7gUpSf76IUcJTQ.png" alt="flex axes"></p>
<blockquote>
<p>flex-basis 影响无素在主轴上的大小</p>
</blockquote>
<p>让我们看看保持 <code>flex-basis</code> 的值不变，但是改变主轴方向会有什么变化：</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*W4QU1Fw9kDLEH2m-J9VGyw.gif" alt="flex direction"></p>
<p>注意到，我从手动设置高度变成手动设置宽度。 <code>Flex-basis</code> 影响宽度还是高度取决于 <code>flex-direction</code> 的值。</p>
<h3 id="属性二：Flex-Grow"><a href="#属性二：Flex-Grow" class="headerlink" title="属性二：Flex Grow"></a>属性二：Flex Grow</h3><p>现在，我们来点更复杂的。</p>
<p>首先，让我们设置给所有方块设置相同的宽度，120px:</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*dON3-0RooiPyfDr0DBEOmA.png" alt="same width"></p>
<p>现在，当它加上属性 <code>flex-grow</code>（默认值为0）.这意味着，不允许方块自动充满容器。</p>
<p>没理解？现在给每个方块的 <code>flex-grow</code> 属性设置为 <code>1</code>：</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*cK-yB4z_L6bmEqoG5qDoRA.png" alt="flex-grow"></p>
<p>所有方块共同充满了容器的整个宽度，并且是平均分。 <code>flex-grow</code> 属性覆盖了 <code>width</code> 属性。</p>
<p>让人困惑的是 <code>flex-grow</code> 的值到底是什么意思？ <code>flex-grow: 1</code> 意味着什么？</p>
<p>好吧，下图是给每个方块设置 <code>flex-grow</code> 值为 <code>999</code> 的表现：</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*p2fLcy13xFU9GjtM4cbHEw.png" alt="flex-grow:999"></p>
<p>这真是。。完全一样。</p>
<p>那是因为 <code>flex-grow</code> 不是一个绝对的值，而是一个相对的值。</p>
<p>重要的不是一个方块 <code>flex-grow</code> 值的本身，而是这个值和其他方块的值的关系。</p>
<p>如果给每个方块设置 <code>flex-grow: 1</code>， 然后调整第3个方块的 <code>flex-grow</code> 属性，可以看到如下变化：</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*gHyLHG52cySgLmy0x-edZA.gif" alt="flex-grow change"></p>
<p>想要真正明白这里发生了什么，让我们快速略过一个简单的数学计算。</p>
<p>每个正方形都以flex-grow为1开始。如果我们将每个正方形的flex-grow相加，则总和为6。因此，容器被分成6个单独的部分。<em>每个正方形增长到可用空间的1/6以填满容器。</em></p>
<p>当设置第3个方块的<code>flex-grow</code> 为 2， 现在容器被分成7份，因为 <code>flex-grow</code> 属性的值的总和为 <code>1+1+2+1+1+1</code>.</p>
<p>方块3获得 2/7 的宽度，剩下的获得 1/7。</p>
<p>当设置第3个方块为 <code>flex-grow: 3</code>， 容器被分成8份（1+1+3+1+1+1）, 方块3占 3/8, 剩下的占 1/8.</p>
<p>以此类推。</p>
<p><code>flex-grow</code>是占所有值总和的比例。如果给所有方块设置<code>flex-grow: 4</code>, 方块3设置 <code>flex-grow: 12</code>, 效果和给它们分别设置 1 和 3 是一样的。</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*JnjR4ULs8de0so1bdUPogw.png" alt="flex-grow"></p>
<p>最后一点，<code>flex-grow</code> 和 <code>flex-basis</code> 都和主轴对应。我们的方块只会增长宽度，除非设置 <code>flex-direction</code> 为 <code>column</code>.</p>
<h3 id="属性三：-Flex-Shrink"><a href="#属性三：-Flex-Shrink" class="headerlink" title="属性三： Flex Shrink"></a>属性三： Flex Shrink</h3><p><code>flex-shrink</code> 和 <code>flex-grow</code>正好相反，决定每个方块可以收缩多少。</p>
<p>它只有在元素必须收缩以适应其容器时才起作用 - 即当容器太小时。</p>
<p>它的主要用途是指定哪些元素要缩小，哪些元素不用缩小。默认情况下，每个方块的 <code>flex-shrink</code> 值为1 - 这意味着它会随着容器的收缩而收缩。</p>
<p>让我们看看它的表现。在下面的GIFS中，正方形的<code>flex-grow</code>为1，因此它们填充了容器，并且<code>flex-shrink</code>为1，因此它们被允许收缩.</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*FVO9kX3wwqakhcT9JWS2Ww.gif" alt="flex-shrink"></p>
<p>现在让我们将方块3的<code>flex-shrink</code>设置为0.它禁止收缩，所以它会增长以适应容器，但它拒绝收缩到其设置的120px宽度以下。</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*GrLzJ4jH3v2Z5Va_TMOXkQ.gif" alt="flex-shrink"></p>
<p><code>flex-shrink</code>的默认值是1 - 这意味着你的元素会收缩，除非设置为0去禁止它。</p>
<p>同样，<code>flex-shrink</code> 是按比例的。如果一个盒子的<code>flex-shrink</code>为6，其余的<code>flex-shrink</code>为2，一个盒子将以3倍的速度缩减，当空间被压缩。</p>
<p>注意这里说的是：具有3x弹性收缩的方块将比其他方块缩短3倍。<em>这并不意味着它将收缩1/3的宽度。</em></p>
<p>稍后，我们会深入了解这到底会收缩或增长多少，在此之前，先来看一下最后一个属性，并把所有混在一起。</p>
<h3 id="属性四：-Flex"><a href="#属性四：-Flex" class="headerlink" title="属性四： Flex"></a>属性四： Flex</h3><p>flex 是 grow, shrink 以及 basis 的缩写，复合属性。</p>
<p>它的默认值是 0(grow) 1（shrink）auto(basis).</p>
<p>最后一个例子，让我们简化到两个 boxs</p>
<p>这是它们的属性：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.square</span><span class="selector-id">#one</span> &#123;</div><div class="line">  <span class="attribute">flex</span>: <span class="number">2</span> <span class="number">1</span> <span class="number">300px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.square</span><span class="selector-id">#two</span> &#123;</div><div class="line">  <span class="attribute">flex</span>: <span class="number">1</span> <span class="number">2</span> <span class="number">300px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>两者都有相同的 <code>flex-basis</code>属性。这意味着如果它们都有足够的空间（容器是600px加上边距和填充空间），它们都将是300px宽度。</p>
<p>但随着容器的增长，Square 1（具有更高的flex-grow）将增长两倍。随着盒子的收缩，Square 2（具有更高的flex-shrink）将缩短两倍。</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*BKZt7AT5eFee4KRhe82gew.gif" alt="all together"></p>
<h4 id="它是如何增长和收缩的"><a href="#它是如何增长和收缩的" class="headerlink" title="它是如何增长和收缩的"></a>它是如何增长和收缩的</h4><p>这里有可能会混淆：当Square 1增长时，它不会增长到Square 2的两倍。同样，当Square 2缩小时，它不会缩小到Square 1的一半大小 - 即使比率的收缩率为2比1。</p>
<blockquote>
<p>这不是他们的大小 2比1或1比2.这是他们的收缩和增长的速度的比例。</p>
</blockquote>
<h4 id="一点数学计算"><a href="#一点数学计算" class="headerlink" title="一点数学计算"></a>一点数学计算</h4><p>容器的起始大小为640像素。在容器的每一边占用20px的填充后，这留下了足够的空间，两个方块恢复到它们的<code>flex-basis</code>的300px.</p>
<p>当容器设置为430px时，我们丢失了210px的空间。正方形1，flex-shrink:1，失去70px。方形2，flex-shrink: 2，失去140px。</p>
<p>当容器缩小到340px时，我们现在已经失去了300像素的空间。方块1损失100像素，方块2损失200像素.</p>
<p>损失的空间根据它们各自的收缩率（2:1）的比率来分割。</p>
<p><code>flex-grow</code>同样。当容器增长到940px，我们获得了300px的空间，Square 1获得了额外的200px，Square 2获得了额外的100px。</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*70-KTWYpA2LnLjqi0xDrJA.gif" alt="grow and shrink"></p>
<p>在上面的GIF中，您可以看到宽度如何根据比率进行调整，增量（Δ）显示与基于<code>flex-basis</code>的差异。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文译自 &lt;a href=&quot;https://medium.freecodecamp.com/even-more-about-how-flexbox-works-explained-in-big-colorful-animated-gifs-a5a74812b053#.iwqlenuqq&quot;&gt;Scott Domes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Flex属性是一个复合属性，而大部分教程中都只设置一个值，但其实它包含了 &lt;code&gt;flex-basis&lt;/code&gt;、&lt;code&gt;flex-grow&lt;/code&gt;、&lt;code&gt;flex-shrink&lt;/code&gt;.
让我们深入了解Flexbox - 以及如何利用它来构建适应性强和漂亮的布局.
    
    </summary>
    
      <category term="Flexbox" scheme="http://robin-front.github.io/categories/Flexbox/"/>
    
    
      <category term="Flexbox" scheme="http://robin-front.github.io/tags/Flexbox/"/>
    
  </entry>
  
  <entry>
    <title>js遍历Object对象可枚举属性、不可枚举属性、原型链属性和自身属性</title>
    <link href="http://robin-front.github.io/2017/01/13/js%E9%81%8D%E5%8E%86Object%E5%8F%AF%E6%9E%9A%E4%B8%BE%E5%B1%9E%E6%80%A7%E3%80%81%E4%B8%8D%E5%8F%AF%E6%9E%9A%E4%B8%BE%E5%B1%9E%E6%80%A7%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%B1%9E%E6%80%A7%E5%92%8C%E8%87%AA%E8%BA%AB%E5%B1%9E%E6%80%A7/"/>
    <id>http://robin-front.github.io/2017/01/13/js遍历Object可枚举属性、不可枚举属性、原型链属性和自身属性/</id>
    <published>2017-01-13T02:19:27.000Z</published>
    <updated>2017-01-13T02:19:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>利用hasOwnProperty、getOwnPropertyNames、Object.keys、for…in遍历对象的可枚举属性、不可枚举属性、原型链上的属性和自身属性。
<a id="more"></a></p>
<p>首先来看看各种方法的用法及兼容性。</p>
<h3 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty"></a>hasOwnProperty</h3><p>Object.prototype.hasOwnProperty(name) 方法用来判断某个对象是否含有指定的自身属性，它本身是对象原型链上的默认方法。</p>
<p>hasOwnProperty 方法是 ES3 就标准化了，所以不用担心兼容性问题。</p>
<p>但由于 hasOwnProperty 是原型链上的方法，所以有可能被对象的自身方法所屏蔽。如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;</div><div class="line">    <span class="attr">hasOwnProperty</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">bar</span>: <span class="string">'Here be dragons'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">foo.hasOwnProperty(<span class="string">'bar'</span>); <span class="comment">// 始终返回 false</span></div><div class="line"></div><div class="line"><span class="comment">// 如果担心这种情况，可以直接使用原型链上真正的 hasOwnProperty 方法</span></div><div class="line">(&#123;&#125;).hasOwnProperty.call(foo, <span class="string">'bar'</span>); <span class="comment">// true</span></div><div class="line"><span class="built_in">Object</span>.prototype.hasOwnProperty.call(foo, <span class="string">'bar'</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="getOwnPropertyNames"><a href="#getOwnPropertyNames" class="headerlink" title="getOwnPropertyNames"></a>getOwnPropertyNames</h3><p>Object.getOwnPropertyNames(obj)方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组, 该方法不会获取到原型链上的属性。如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 父类构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ParentClass</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">ParentClass.prototype.inheritedMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 继承</span></div><div class="line"><span class="keyword">var</span> ChildClass = <span class="built_in">Object</span>.create(ParentClass.prototype, &#123;</div><div class="line">  <span class="comment">// 不可枚举属性</span></div><div class="line">  getFoo: &#123;</div><div class="line">    <span class="attr">value</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.foo; &#125;,</div><div class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 自身可枚举属性</span></div><div class="line">ChildClass.foo = <span class="number">1</span>;</div><div class="line"><span class="comment">// 再定义一个原型链属性</span></div><div class="line">ChildClass.prototype.prototypeMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(my_obj).sort()); <span class="comment">// ["foo", "getFoo"]</span></div></pre></td></tr></table></figure>
<p>兼容性到 IE9, es 5标准。</p>
<h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><p>返回该对象的所有可枚举自身属性的属性名。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">//</span>具有随机键排序的数组类对象</div><div class="line">var an_obj = &#123; <span class="number">100</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">7</span>: <span class="string">'c'</span> &#125;;</div><div class="line">console.log(Object.keys(an_obj)); <span class="regexp">//</span> console: [<span class="string">'2'</span>, <span class="string">'7'</span>, <span class="string">'100'</span>]</div></pre></td></tr></table></figure>
<p>这些属性的顺序与手动遍历（如for..in）该对象属性时的一致。</p>
<blockquote>
<p>注意：Object.keys 和 getOwnPropertyNames ，在ES5，如果此方法的参数不是一个对象（原始的），那么它会造成 TypeError。在ES6，非对象的参数将被强制转换为一个对象。</p>
</blockquote>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Object.keys(<span class="string">"foo"</span>);</div><div class="line">Object.getOwnPropertyNames(<span class="string">"foo"</span>);</div><div class="line"><span class="regexp">//</span> <span class="symbol">TypeError:</span> <span class="string">"foo"</span> is <span class="keyword">not</span> an object (ES5 code)</div><div class="line"></div><div class="line">Object.keys(<span class="string">"foo"</span>);</div><div class="line"><span class="regexp">//</span> [<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>]                   (ES6 code)</div><div class="line">Object.getOwnPropertyNames(<span class="string">"foo"</span>);</div><div class="line"><span class="regexp">//</span> [<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"length"</span>]                   (ES6 code)</div></pre></td></tr></table></figure>
<p>兼容性到 IE9, es 5标准。</p>
<h3 id="for-in"><a href="#for-in" class="headerlink" title="for..in"></a>for..in</h3><p>手动遍历，可以遍历到自身和原型链上所有可枚举的属性。</p>
<h3 id="只获取自身可枚举属性"><a href="#只获取自身可枚举属性" class="headerlink" title="只获取自身可枚举属性"></a>只获取自身可枚举属性</h3><ul>
<li>直接用 <code>Object.keys()</code></li>
<li>IE9 以下可以通过<code>hasOwnProperty</code>实现：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!<span class="built_in">Object</span>.keys) <span class="built_in">Object</span>.keys = <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (o !== <span class="built_in">Object</span>(o))</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Object.keys called on a non-object'</span>);</div><div class="line">  <span class="keyword">var</span> k=[],p;</div><div class="line">  <span class="keyword">for</span> (p <span class="keyword">in</span> o) <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(o,p)) k.push(p);</div><div class="line">  <span class="keyword">return</span> k;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="只获取自身不可枚举属性"><a href="#只获取自身不可枚举属性" class="headerlink" title="只获取自身不可枚举属性"></a>只获取自身不可枚举属性</h3><ul>
<li>通过 <code>Object.keys()</code> 排除可枚举属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> target = myObject;</div><div class="line"><span class="keyword">var</span> enum_and_nonenum = <span class="built_in">Object</span>.getOwnPropertyNames(target);</div><div class="line"><span class="comment">// 排除可枚举属性</span></div><div class="line"><span class="keyword">var</span> enum_only = <span class="built_in">Object</span>.keys(target);</div><div class="line"><span class="keyword">var</span> nonenum_only = enum_and_nonenum.filter(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> indexInEnum = enum_only.indexOf(key);</div><div class="line">    <span class="keyword">if</span> (indexInEnum == <span class="number">-1</span>) &#123;</div><div class="line">        <span class="comment">// not found in enum_only keys mean the key is non-enumerable,</span></div><div class="line">        <span class="comment">// so return true so we keep this in the filter</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(nonenum_only);</div></pre></td></tr></table></figure>
<ul>
<li>通过<code>propertyIsEnumerable</code>判断，该方法返回Boolean值，不可枚举返回false。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> target = myObject;</div><div class="line"><span class="keyword">var</span> enum_and_nonenum = <span class="built_in">Object</span>.getOwnPropertyNames(target);</div><div class="line"><span class="keyword">var</span> enum_only = <span class="built_in">Object</span>.keys(target);</div><div class="line"><span class="keyword">var</span> nonenum_only = enum_and_nonenum.filter(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">    <span class="comment">// 筛选不可枚举属性</span></div><div class="line">    <span class="keyword">return</span> !target.propertyIsEnumerable(key)</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(nonenum_only);</div></pre></td></tr></table></figure>
<h3 id="只获取原型链上的可枚举属性"><a href="#只获取原型链上的可枚举属性" class="headerlink" title="只获取原型链上的可枚举属性"></a>只获取原型链上的可枚举属性</h3><ul>
<li>直接用 for..in</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.getPrototypeOf(targetObj); <span class="comment">// 跳过遍历自身属性，直接从原型上开始</span></div><div class="line"><span class="keyword">var</span> k=[],p;</div><div class="line"><span class="keyword">for</span> (p <span class="keyword">in</span> o) <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(o,p)) k.push(p);</div><div class="line"><span class="keyword">return</span> k;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意，这样遍历出来的属性也不一定能访问， 因为自身属性可能会屏蔽掉原型上的属性。</p>
</blockquote>
<h3 id="只获取原型链上的不可枚举属性"><a href="#只获取原型链上的不可枚举属性" class="headerlink" title="只获取原型链上的不可枚举属性"></a>只获取原型链上的不可枚举属性</h3><p>比较麻烦，如果使用 getOwnPropertyNames，只能单独获取一层原型链，必须一级一级遍历往上找，而且这也不一定有场景，因为原型链上的方法重名是会被屏蔽的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;利用hasOwnProperty、getOwnPropertyNames、Object.keys、for…in遍历对象的可枚举属性、不可枚举属性、原型链上的属性和自身属性。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="getOwnPropertyNames" scheme="http://robin-front.github.io/tags/getOwnPropertyNames/"/>
    
      <category term="hasOwnProperty" scheme="http://robin-front.github.io/tags/hasOwnProperty/"/>
    
      <category term="Object.keys" scheme="http://robin-front.github.io/tags/Object-keys/"/>
    
  </entry>
  
  <entry>
    <title>比较instanceof与isPrototypeOf</title>
    <link href="http://robin-front.github.io/2017/01/12/%E6%AF%94%E8%BE%83instanceof%E4%B8%8EisPrototypeof/"/>
    <id>http://robin-front.github.io/2017/01/12/比较instanceof与isPrototypeof/</id>
    <published>2017-01-12T09:49:14.000Z</published>
    <updated>2017-01-12T09:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>在javascript中，instanceof 和 isPrototypeOf 都可以判断一个原型是否在另一个实例的原型链中，那他们有什么区别呢，为什么说 isPrototypeOf 可以替代 instanceof 。
<a id="more"></a></p>
<h3 id="instanceof-用法"><a href="#instanceof-用法" class="headerlink" title="instanceof 用法"></a>instanceof 用法</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="comment">// init code</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span><span class="params">()</span> </span>&#123;</div><div class="line">      Super.call(<span class="keyword">this</span>);</div><div class="line">      <span class="comment">// other init code</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">Sub.prototype = <span class="keyword">new</span> Super();</div><div class="line"></div><div class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> Sub();</div></pre></td></tr></table></figure>
<p>对于上面的代码，用 instanceof 可以像这样确定他们的关系：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">instanceof</span> <span class="title">Super</span></span>; // true</div></pre></td></tr></table></figure>
<h3 id="isPrototypeOf-用法"><a href="#isPrototypeOf-用法" class="headerlink" title="isPrototypeOf 用法"></a>isPrototypeOf 用法</h3><p>复用上面的代码，用 isPrototypeOf 可以这样写：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Super.prototype.isPrototypeOf(<span class="function"><span class="keyword">sub</span>)</span>; // true</div></pre></td></tr></table></figure>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>乍一看，都可以用，但某种情况下是有区别的，例如：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var super = &#123;</div><div class="line">    <span class="regexp">//</span> some super properties</div><div class="line">&#125;</div><div class="line"></div><div class="line">var <span class="function"><span class="keyword">sub</span> = <span class="title">Object</span>.<span class="title">create</span></span>(super);</div><div class="line"><span class="function"><span class="keyword">sub</span>.<span class="title">someProp</span> = 5</span>;</div><div class="line"></div><div class="line">var <span class="function"><span class="keyword">sub</span> = <span class="title">Object</span>.<span class="title">create</span></span>(sub);</div><div class="line"></div><div class="line">console.log(super.isPrototypeOf(<span class="function"><span class="keyword">sub</span>))</span>;  // true</div><div class="line">console.log(<span class="function"><span class="keyword">sub</span> <span class="title">instanceof</span> <span class="title">super</span>)</span>;      // TypeError</div></pre></td></tr></table></figure>
<p>这时候 super 并不是构造函数，无法使用 instanceof, 只能使用 isPrototypeOf.</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>结论就是 isPrototypeOf 能使用的场景更广，完全可以替代 instanceof， 只是写起来没那么简洁。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在javascript中，instanceof 和 isPrototypeOf 都可以判断一个原型是否在另一个实例的原型链中，那他们有什么区别呢，为什么说 isPrototypeOf 可以替代 instanceof 。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="instanceof" scheme="http://robin-front.github.io/tags/instanceof/"/>
    
      <category term="isPrototypeOf" scheme="http://robin-front.github.io/tags/isPrototypeOf/"/>
    
  </entry>
  
  <entry>
    <title>javascript通过Vibration API实现手机振动反馈提高用户体验</title>
    <link href="http://robin-front.github.io/2017/01/10/javascript%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E6%8C%AF%E5%8A%A8%E5%8F%8D%E9%A6%88%E6%8F%90%E9%AB%98%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C/"/>
    <id>http://robin-front.github.io/2017/01/10/javascript实现手机振动反馈提高用户体验/</id>
    <published>2017-01-10T05:35:00.000Z</published>
    <updated>2017-01-11T01:13:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>目前大多数的移动设备均具备硬件能力支持振动，让软件代码通过使设备摇晃来向用户提供物理反馈。Vibration API 为 Web应用程序提供访问此硬件的能力。如果设备不支持，则不会产生任何效果。
<a id="more"></a></p>
<h3 id="振动描述"><a href="#振动描述" class="headerlink" title="振动描述"></a>振动描述</h3><p>振动被抽象成【开-关】脉冲的模式，且可以具有变化的长度。参数可以是单个整数，表示持续振动的毫秒数 (ms)；或可由多个整数组成的数组，达到振动和暂停循环的效果。只要单一 window.navigator.vibrate() 函式即可控制振动。</p>
<h3 id="单次振动"><a href="#单次振动" class="headerlink" title="单次振动"></a>单次振动</h3><p>你可指定单一数值，或用只有一个数值成员的数组，让设备振动 1 次：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">window</span><span class="selector-class">.navigator</span><span class="selector-class">.vibrate</span>(200);</div><div class="line"><span class="selector-tag">window</span><span class="selector-class">.navigator</span><span class="selector-class">.vibrate</span>(<span class="selector-attr">[200]</span>);</div></pre></td></tr></table></figure>
<p>以上两个例子都可以使设备振动 200 ms.</p>
<h3 id="多次振动"><a href="#多次振动" class="headerlink" title="多次振动"></a>多次振动</h3><p>一个数组的值描述了装置振动与不振动的交替时间段。数组中的每个值都转换为整数，然后交替解释为设备应该振动的毫秒数和不振动的毫秒数。例如:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">window</span><span class="selector-class">.navigator</span><span class="selector-class">.vibrate</span>(<span class="selector-attr">[200, 100, 200]</span>);</div></pre></td></tr></table></figure>
<p>这会使设备振动200 ms，然后暂停100 ms，然后再次振动设备200 ms。</p>
<p>您可以根据需要设定多个振动/暂停对，数组的值可以是偶数或奇数个； 值得注意的是，由于振动在每个振动周期结束时自动停止，因此您不必提供最后一个值去暂停，换句话说，数组长度只需要设置奇数个。</p>
<h3 id="停止振动"><a href="#停止振动" class="headerlink" title="停止振动"></a>停止振动</h3><p>当调用 window.navigator.vibrate() 的参数为「0」、空白数组，或数组全为「0」时，即可取消目前进行中的振动。</p>
<h3 id="持续振动"><a href="#持续振动" class="headerlink" title="持续振动"></a>持续振动</h3><p>一些基于setInterval和clearInterval操作将允许您创建持续的振动：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> vibrateInterval;</div><div class="line"></div><div class="line"><span class="comment">// Starts vibration at passed in level</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">startVibrate</span><span class="params">(duration)</span> </span>&#123;</div><div class="line">    navigator.vibrate(duration);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Stops vibration</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopVibrate</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// Clear interval and stop persistent vibrating</span></div><div class="line">    <span class="keyword">if</span>(vibrateInterval) clearInterval(vibrateInterval);</div><div class="line">    navigator.vibrate(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Start persistent vibration at given duration and interval</span></div><div class="line"><span class="comment">// Assumes a number value is given</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">startPeristentVibrate</span><span class="params">(duration, interval)</span> </span>&#123;</div><div class="line">    vibrateInterval = setInterval(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">        startVibrate(duration);</div><div class="line">    &#125;, interval);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然上面的代码片段没有考虑到振动参数为数组情况; 基于阵列的持久性振动将需要计算数组项的和，并基于该数量创建周期（可能具有额外的延迟）。</p>
<h3 id="生成振动节奏"><a href="#生成振动节奏" class="headerlink" title="生成振动节奏"></a>生成振动节奏</h3><p>可以通过<a href="https://naschq.github.io/vibe.js/" target="_blank" rel="external">vibe.js tool</a>这个工具来生成你需要的振动频率，然后复制它到你的代码里。</p>
<h3 id="lib"><a href="#lib" class="headerlink" title="lib"></a>lib</h3><p>我写了一个小lib，方便使用<a href="https://github.com/Robin-front/vibrate.js" target="_blank" rel="external">vibrate.js</a></p>
<p>demo: <a href="https://robin-front.github.io/vibrate.js/example/demo.html">DEMO</a></p>
<p>译自： <a href="https://developer.mozilla.org/en-US/docs/Web/API/Vibration_API" target="_blank" rel="external">MDN Vibration API</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前大多数的移动设备均具备硬件能力支持振动，让软件代码通过使设备摇晃来向用户提供物理反馈。Vibration API 为 Web应用程序提供访问此硬件的能力。如果设备不支持，则不会产生任何效果。
    
    </summary>
    
      <category term="Vibration" scheme="http://robin-front.github.io/categories/Vibration/"/>
    
      <category term="html5" scheme="http://robin-front.github.io/categories/Vibration/html5/"/>
    
    
      <category term="Vibration" scheme="http://robin-front.github.io/tags/Vibration/"/>
    
  </entry>
  
  <entry>
    <title>由lodash引出数组Array的slice方法性能探究</title>
    <link href="http://robin-front.github.io/2016/11/25/%E7%94%B1lodash%E5%BC%95%E5%87%BA%E6%95%B0%E7%BB%84Array%E7%9A%84slice%E6%96%B9%E6%B3%95%E6%80%A7%E8%83%BD%E6%8E%A2%E7%A9%B6/"/>
    <id>http://robin-front.github.io/2016/11/25/由lodash引出数组Array的slice方法性能探究/</id>
    <published>2016-11-25T03:05:19.000Z</published>
    <updated>2016-11-25T03:05:19.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>lodash</code> 源码中，发现数组截取操作并没有直接使用<code>array</code>的<code>slice</code>方法，而是写了个 <code>baseSlice</code> 方法，更重要的是 <code>baseSlice</code> 方法里，也并没有使用 <code>slice</code> 方法，而是使用循环索引的方式去实现。这让我陷入思考，难道原生Array的<code>slice</code>方法还不如循环快？</p>
<a id="more"></a>
<p><code>lodash</code> 源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseSlice</span>(<span class="params">array, start, end</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> index = <span class="number">-1</span>,</div><div class="line">      length = array.length;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (start &lt; <span class="number">0</span>) &#123;</div><div class="line">    start = -start &gt; length ? <span class="number">0</span> : (length + start);</div><div class="line">  &#125;</div><div class="line">  end = end &gt; length ? length : end;</div><div class="line">  <span class="keyword">if</span> (end &lt; <span class="number">0</span>) &#123;</div><div class="line">    end += length;</div><div class="line">  &#125;</div><div class="line">  length = start &gt; end ? <span class="number">0</span> : ((end - start) &gt;&gt;&gt; <span class="number">0</span>);</div><div class="line">  start &gt;&gt;&gt;= <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> result = <span class="built_in">Array</span>(length);</div><div class="line">  <span class="keyword">while</span> (++index &lt; length) &#123;</div><div class="line">    result[index] = array[index + start];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>于是就开始写代码比较：</p>
<p>  操作长度为100的数组，执行10000次：
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> baseArray = [];</div><div class="line"><span class="keyword">var</span> i = <span class="number">-1</span>;</div><div class="line"><span class="keyword">while</span> (++ i &lt; <span class="number">100</span>) &#123; <span class="comment">// 定义一个10000长度的数组以供使用</span></div><div class="line">  baseArray[i] = i;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.time(<span class="string">'slice with no args'</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</div><div class="line">  baseArray.slice();</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'slice with no args'</span>);</div><div class="line"><span class="built_in">console</span>.time(<span class="string">'slice with args'</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</div><div class="line">  baseArray.slice(<span class="number">20</span>, <span class="number">40</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'slice with args'</span>);</div><div class="line"><span class="built_in">console</span>.time(<span class="string">'index'</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</div><div class="line">  <span class="keyword">var</span> result = <span class="built_in">Array</span>(<span class="number">100</span>);</div><div class="line">  <span class="keyword">var</span> index = <span class="number">-1</span>;</div><div class="line">  <span class="keyword">var</span> length = baseArray.length;</div><div class="line">  <span class="keyword">while</span> (++index &lt; length) &#123;</div><div class="line">    result[index] = baseArray[index];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'index'</span>);</div><div class="line"><span class="built_in">console</span>.time(<span class="string">'index with no init array'</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</div><div class="line">  <span class="keyword">var</span> result = [];</div><div class="line">  <span class="keyword">var</span> index = <span class="number">-1</span>;</div><div class="line">  <span class="keyword">var</span> length = baseArray.length;</div><div class="line">  <span class="keyword">while</span> (++index &lt; <span class="number">20</span>) &#123;</div><div class="line">    result[index] = baseArray[index];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'index with no init array'</span>);</div></pre></td></tr></table></figure></p>
<p>对比结果：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// chrome 版本 54.0.2840.98 (64-bit)</span></div><div class="line">slice <span class="keyword">with</span> no args: <span class="number">93.3</span>ms</div><div class="line">slice <span class="keyword">with</span> args: <span class="number">175</span>ms</div><div class="line"><span class="keyword">index</span>: <span class="number">365</span>ms</div><div class="line"><span class="keyword">index</span> <span class="keyword">with</span> no init <span class="keyword">array</span>: <span class="number">546</span>ms</div><div class="line"><span class="comment">// safari 版本 9.0.2 (11601.3.9)</span></div><div class="line">slice <span class="keyword">with</span> no args: <span class="number">122.152</span>ms</div><div class="line">slice <span class="keyword">with</span> args: <span class="number">117.181</span>ms</div><div class="line"><span class="keyword">index</span>: <span class="number">60076.301</span>ms</div><div class="line"><span class="keyword">index</span> <span class="keyword">with</span> no init <span class="keyword">array</span>: <span class="number">62055.406</span>ms</div><div class="line"><span class="comment">//firefox 50.0</span></div><div class="line">slice <span class="keyword">with</span> no args: <span class="number">462.07</span>ms</div><div class="line">slice <span class="keyword">with</span> args: <span class="number">442.25</span>ms</div><div class="line"><span class="keyword">index</span>: <span class="number">194206.08</span>ms</div><div class="line"><span class="keyword">index</span> <span class="keyword">with</span> no init <span class="keyword">array</span>: <span class="number">184714.59</span>ms</div></pre></td></tr></table></figure>
<p>由于mac ox无法测试IE,
可以看出，chrome总体要比safafi、firefox快很多；
slice方法上，safari和chrome差不多， chrome下slice有参数比无参数慢；
新建数组Array()和 []性能差不多；</p>
<p>这么看来，那用原生 slice 明显会更好，为什么 lodash 要用循环索引呢？难道是因为一般应用数组都不会这么大，那改成长度为100的数组进行操作；
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// chrome</span></div><div class="line">slice <span class="keyword">with</span> no args: <span class="number">6</span>ms</div><div class="line">slice <span class="keyword">with</span> args: <span class="number">4.12</span>ms</div><div class="line"><span class="keyword">index</span>: <span class="number">5.82</span>ms</div><div class="line"><span class="keyword">index</span> <span class="keyword">with</span> no init <span class="keyword">array</span>: <span class="number">7.96</span>ms</div><div class="line"><span class="comment">// safari</span></div><div class="line">slice <span class="keyword">with</span> no args: <span class="number">9.158</span>ms</div><div class="line">slice <span class="keyword">with</span> args: <span class="number">8.432</span>ms</div><div class="line"><span class="keyword">index</span>: <span class="number">640.311</span>ms</div><div class="line"><span class="keyword">index</span> <span class="keyword">with</span> no init <span class="keyword">array</span>: <span class="number">643.174</span>ms</div><div class="line"><span class="comment">//firefox</span></div><div class="line">slice <span class="keyword">with</span> no args: <span class="number">17.56</span>ms</div><div class="line">slice <span class="keyword">with</span> args: <span class="number">17.53</span>ms</div><div class="line"><span class="keyword">index</span>: <span class="number">2174.15</span>ms</div><div class="line"><span class="keyword">index</span> <span class="keyword">with</span> no init <span class="keyword">array</span>: <span class="number">2198.15</span>ms</div></pre></td></tr></table></figure></p>
<p>发现结论并没有改变。
然后就向lodash提了question, 回复是：</p>
<blockquote>
<p>The perf wins of Array#slice vs. baseSlice depends on the size of the array. That is a minor point though as the perf of that method is not likely to be an issue. The reason we use baseSlice is because we treat arrays as dense while Array#slice will respect sparse arrays.</p>
</blockquote>
<p>大概意思是，他觉得性能没有太大的差别，Array#slice和baseSlice性能强弱取决于数组的大小。这里采用baseSlice是因为他们要视所有为密集数据，而Array#slice会处理稀疏数组。</p>
<p>然后就有下面的测试：</p>
<p>使用 Array#slice和baseSlice 分别截取数组其中一段，循环1000000次：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> baseArray = [];</div><div class="line"><span class="keyword">var</span> i = <span class="number">-1</span>;</div><div class="line"><span class="keyword">while</span> (++ i &lt; <span class="number">100000</span>) &#123; <span class="comment">// 定义一个10000长度的数组以供使用,这里数组长度并不影响性能，性能影响主要在于截取的长度。</span></div><div class="line">  baseArray[i] = i;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.time(<span class="string">'slice with args'</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)&#123;</div><div class="line">  baseArray.slice(<span class="number">0</span>, <span class="number">20</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'slice with args'</span>);</div><div class="line"><span class="built_in">console</span>.time(<span class="string">'index'</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)&#123;</div><div class="line">  <span class="keyword">var</span> result = <span class="built_in">Array</span>(<span class="number">20</span>);</div><div class="line">  <span class="keyword">var</span> index = <span class="number">-1</span>;</div><div class="line">  <span class="keyword">while</span> (++index &lt; <span class="number">20</span>) &#123;</div><div class="line">    result[index] = baseArray[index];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'index'</span>);</div></pre></td></tr></table></figure>
<p>不同截取长度在chrome下的效果：
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 截取长度 20</span></div><div class="line">slice <span class="keyword">with</span> args: <span class="number">110</span>ms</div><div class="line"><span class="keyword">index</span>: <span class="number">78.9</span>ms</div><div class="line"><span class="comment">// 截取长度 30</span></div><div class="line">slice <span class="keyword">with</span> args: <span class="number">114</span>ms</div><div class="line"><span class="keyword">index</span>: <span class="number">112</span>ms</div><div class="line"><span class="comment">// 截取长度 30</span></div><div class="line">slice <span class="keyword">with</span> args: <span class="number">132</span>ms</div><div class="line"><span class="keyword">index</span>: <span class="number">146</span>ms</div></pre></td></tr></table></figure></p>
<p>由此看出，截取长度为30左右时，Array#slice和loop方式性能基本一样，而 Array#slice 基本不受截取长度的影响。
所以结论是，当长度为30以下时，lodash的方法是比较高效的，当然，这影响微乎其微。像_.chunk方法，一般场景分组都不会太长。</p>
<p>疑惑是，对我的回复的后半句我没怎么看懂，密集数据和稀疏数据对这有什么影响呢？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;lodash&lt;/code&gt; 源码中，发现数组截取操作并没有直接使用&lt;code&gt;array&lt;/code&gt;的&lt;code&gt;slice&lt;/code&gt;方法，而是写了个 &lt;code&gt;baseSlice&lt;/code&gt; 方法，更重要的是 &lt;code&gt;baseSlice&lt;/code&gt; 方法里，也并没有使用 &lt;code&gt;slice&lt;/code&gt; 方法，而是使用循环索引的方式去实现。这让我陷入思考，难道原生Array的&lt;code&gt;slice&lt;/code&gt;方法还不如循环快？&lt;/p&gt;
    
    </summary>
    
      <category term="lodash" scheme="http://robin-front.github.io/categories/lodash/"/>
    
      <category term="array" scheme="http://robin-front.github.io/categories/lodash/array/"/>
    
      <category term="slice" scheme="http://robin-front.github.io/categories/lodash/array/slice/"/>
    
    
      <category term="lodash" scheme="http://robin-front.github.io/tags/lodash/"/>
    
      <category term="array" scheme="http://robin-front.github.io/tags/array/"/>
    
      <category term="slice" scheme="http://robin-front.github.io/tags/slice/"/>
    
  </entry>
  
  <entry>
    <title>Debounce-and-Throttle-的可視化解釋</title>
    <link href="http://robin-front.github.io/2016/11/17/Debounce-and-Throttle-%E7%9A%84%E5%8F%AF%E8%A6%96%E5%8C%96%E8%A7%A3%E9%87%8B/"/>
    <id>http://robin-front.github.io/2016/11/17/Debounce-and-Throttle-的可視化解釋/</id>
    <published>2016-11-17T02:22:22.000Z</published>
    <updated>2016-11-21T03:19:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>Debounce 和 Throttle是两个概念，我们可以在JavaScript中使用，以提高我们对执行功能的控制，在事件处理的时候特别有用。</p>
<a id="more"></a>
<h3 id="比喻"><a href="#比喻" class="headerlink" title="比喻"></a>比喻</h3><p>这两种技术都回答同样的问题“一个功能可以随着时间被推移多久？”</p>
<ul>
<li>Debounce：把它看成是“多个分组事件之一”。试想一下，你回家，再进入电梯，门正在关闭……，突然你的邻居出现在大厅，并试图跳上电梯。要有礼貌！并打开大门，他说：你等等，让我一起上。相同的情况下，可以与第三人再次发生，等等…这可能会延缓出发几分钟。</li>
<li>Throttle：把它看成是一个阀，它规定了执行的流程。我们可以判断函数可以在一定时间内被调用的最大次数。因此，再用电梯比喻..你有足够的礼貌，持续10秒等人，但一旦时间到了，你一定要走！</li>
</ul>
<p>无 Debounce 或 Throttle 事件处理程序就像一次只能一个人用的电梯：没有那么高效。</p>
<p>我希望这个坏比喻对你有所帮助，但有时言语并不会对掌握这些概念有多大的帮助，所以我创建了一个演示去理解 Debounce 和 Throttle 概念，并把它们应用到mousemove事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">elevator_departure</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">  alert(name + <span class="string">" was the last one. Nobody else? Let's go then"</span>);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> debounced_elevator_departure = $.debounce(<span class="number">200</span>, <span class="literal">false</span>, elevator_departure);</div><div class="line"></div><div class="line">debounced_elevator_departure(<span class="string">'John'</span>);</div><div class="line">debounced_elevator_departure(<span class="string">'Mike'</span>);</div><div class="line">debounced_elevator_departure(<span class="string">'Peter'</span>);</div><div class="line"><span class="comment">// You will see *only* one message, "Peter was the last one. Nobody else? Let's go then";</span></div></pre></td></tr></table></figure>
<p>我发现这3个人在JavaScript中都通过debounce和throttle执行了。我真的建议你先读一下 <a href="http://benalman.com/projects/jquery-throttle-debounce-plugin/" target="_blank" rel="external"><code>Ben Alman&#39;s</code></a> 的文章，以便更好地理解  debounce 和 throttle. <code>underscore</code> 和 <code>lodash</code> 有不同的实现方式，但参数都是一样的（除了 <code>throttle</code>没有 <code>trailing</code>）.</p>
<ul>
<li><a href="http://underscorejs.org/" target="_blank" rel="external">Underscore.js</a> by Jeremy Ashkenas *</li>
<li><a href="http://lodash.com/" target="_blank" rel="external">Lodash.js</a> by John-David Dalton *</li>
<li><a href="http://benalman.com/projects/jquery-throttle-debounce-plugin/" target="_blank" rel="external">jQuery Plugin</a> by Ben Alman.</li>
</ul>
<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>这里是视觉演示:</p>
<iframe src="http://drupalmotion.com/sites/default/files/demos/debounce-throttle/index.html" height="350px" width="1000px"></iframe>

<p>这是截图：
<img src="http://drupalmotion.com/sites/default/files/pics/screenshot.png" alt="debounce-throttle"></p>
<p>注意：</p>
<ul>
<li>这个的源代码演示在<a href="https://github.com/dcorb/debounce-throttle" target="_blank" rel="external">GitHub上托管</a>。</li>
<li>如果你看到动画在浏览器中并不流畅，请在一个单独的页面打开演示，或者尝试在Chrome中。</li>
<li>我通过在鼠标区域 <code>tapping</code>来去在<code>Android</code>环境下演示它</li>
<li>每个单元代表约30毫秒，但JS是单线程的，所以浏览器是不是准确。这个演示并不是想成为一个最佳实践，只是为了更好地去理解概念。</li>
<li>当你做了<code>setTimeout</code>，时间间隔可能不同，在每个浏览器在4ms和15ms的之间（<a href="http://www.nczonline.net/blog/2011/12/14/timer-resolution-in-browsers/" target="_blank" rel="external">尼古拉斯Zakas的文章</a>），甚至是<code>setTimeout(fn,0)</code>至少需要4毫秒。在另一方面，时间为1毫秒为最小单位的。</li>
<li>在<code>mousemove</code>第一行中的事件也有做节流（80毫秒）。这对理解演示有所帮助。</li>
<li>要获得 <code>trailing</code>选项<code>$.throttle</code>，你需要传递<code>false</code>。</li>
<li>不要忘了，这一切都是builder，他们返回一个函数，所以你只需要执行一次。</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="debounce-案例"><a href="#debounce-案例" class="headerlink" title="debounce 案例"></a>debounce 案例</h4><p>用它减少执行频繁的事件。例子：</p>
<ul>
<li>当将要处理的textarea的快速打字：你不想执行处理函数，直到用户停止输入再来处理文本。</li>
<li>当数据保存到通过AJAX服务器：你不想每秒调用非常缓慢的邮件服务器</li>
</ul>
<h4 id="throttle-案例"><a href="#throttle-案例" class="headerlink" title="throttle 案例"></a>throttle 案例</h4><p>和<code>debounce</code> 一样，但如果想每隔一段时间必须执行事件，可以使用它：</p>
<ul>
<li>假设用户不停地快速输入30秒，可能你会想每5秒执行一次函数；</li>
<li>一些对性能有影响的事件但又必须处理：scroll, mouseweel, mousemove。一个简单的鼠标滚轮运动可以在一秒钟内触发几十个事件。</li>
</ul>
<p>本文翻译自 <a href="http://drupalmotion.com/article/debounce-and-throttle-visual-explanation" target="_blank" rel="external">Debounce and Throttle: a visual explanation</a></p>
<p>========= update on 11-21 =========</p>
<h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><h4 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> validation = _.debounce(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  ... <span class="comment">// 校验输入，逻辑可能还会有点复杂</span></div><div class="line">&#125;, <span class="number">250</span>)</div><div class="line">jQuery(<span class="string">'input'</span>).keyup(validation) <span class="comment">// 输入完成或停顿250ms后才去执行校验，如果不停输入10s，则10s内都不会触发</span></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  debounce第三个参数为可选参数，</div><div class="line"> *  leading为true时，则在事件开始时首先执行一次， 默认值为 false；</div><div class="line"> *  trailing为true时，则在结束时触发, 默认值为 true；</div><div class="line"> *  maxWait设置每隔多长时间必须触发；</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123; ... &#125;</div><div class="line">jQuery(<span class="string">'input'</span>).on(<span class="string">'keyup'</span>, _.debounce(foo, <span class="number">300</span>, &#123;</div><div class="line">  <span class="string">'leading'</span>: <span class="literal">true</span>, <span class="comment">// 注意： 执行的前提是定时器为undefined</span></div><div class="line">  <span class="string">'trailing'</span>: <span class="literal">false</span>,</div><div class="line">  <span class="string">'maxWait'</span>: <span class="number">1000</span></div><div class="line">&#125;));</div><div class="line"></div><div class="line"><span class="comment">// debounce还可以被取消</span></div><div class="line">jQuery(<span class="string">'button'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  validation.cancel();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mousemove</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line">jQuery(<span class="string">'#div'</span>).on(<span class="string">'mousemove'</span>, _.throttle(mousemove, <span class="number">100</span>)) <span class="comment">// 每100ms必须触发一次</span></div><div class="line"></div><div class="line"><span class="comment">// mousemove会在定时器开始时触发, 但5分钟内不会有第二次</span></div><div class="line">jQuery(<span class="string">'#div'</span>).on(<span class="string">'mousemove'</span>, _.throttle(mousemove, <span class="number">300000</span>, &#123;</div><div class="line">  <span class="string">'leading'</span>: <span class="literal">true</span>, <span class="comment">// 定时器前沿触发，默认值为true</span></div><div class="line">  <span class="string">'trailing'</span>: <span class="literal">false</span> <span class="comment">// 定时器后沿触发，默认值为true</span></div><div class="line">&#125;));</div><div class="line"><span class="comment">// throttle 同样可以被取消</span></div><div class="line">jQuery(<span class="built_in">window</span>).on(<span class="string">'popstate'</span>, throttled.cancel);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Debounce 和 Throttle是两个概念，我们可以在JavaScript中使用，以提高我们对执行功能的控制，在事件处理的时候特别有用。&lt;/p&gt;
    
    </summary>
    
      <category term="函数节流" scheme="http://robin-front.github.io/categories/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81/"/>
    
    
      <category term="debounce" scheme="http://robin-front.github.io/tags/debounce/"/>
    
      <category term="throttle" scheme="http://robin-front.github.io/tags/throttle/"/>
    
  </entry>
  
  <entry>
    <title>使用 npm shrinkwrap 来管理项目依赖</title>
    <link href="http://robin-front.github.io/2016/10/20/%E4%BD%BF%E7%94%A8-npm-shrinkwrap-%E6%9D%A5%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96/"/>
    <id>http://robin-front.github.io/2016/10/20/使用-npm-shrinkwrap-来管理项目依赖/</id>
    <published>2016-10-20T09:35:22.000Z</published>
    <updated>2016-10-20T09:35:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>管理依赖是一个复杂软件开发过程中必定会遇到的问题。</p>
<p>在Node.js项目开发的时候，我们也经常需要安装和升级对应的依赖。虽然 npm 以及语意化的版本号 (semantic versioning, semver) 让开发过程中依赖的获取和升级变得非常容易， 但不严格的版本号限制，也带来了版本号的不确定性。主要的问题可能有三个：</p>
<ul>
<li>npm 建议使用 semver 的应用程序版本，但这也完全依赖第三方包遵守这一规则。如果你依赖于的包不遵循 semver ，或者依赖的包的新版本有重大更改（而你使用了 ^ 的宽泛版本安装），这潜在可能是会导致问题的。</li>
<li>另一个问题的出现是由于 npm 安装依赖的机制。npm 的安装包是有层次结构的，手动控制要安装的软件包的版本号可以实现，但是你只能在 package.json 使用精确的版本号控制你的直接依赖包，但那些多层以上的依赖就没办法控制了；一个第三方包不严谨的版本依赖生命可能破坏你的依赖管理。</li>
<li>在开发阶段执行得到的版本，和后续部署时得到的可能是不一致的，更不可控的是，你依赖的第三方包也有这样的情况会导致潜在的上线风险。</li>
</ul>
<p>如果要控制上线的风险，我们就必需要解决这个问题，这时候，就需要使用 npm shrinkwrap 这个命令来解决问题。
<a id="more"></a></p>
<h3 id="npm-shrinkwrap"><a href="#npm-shrinkwrap" class="headerlink" title="npm shrinkwrap"></a>npm shrinkwrap</h3><p><code>npm shrinkwrap</code> 可以按照当前项目 <code>node_modules</code> 目录内的安装包情况生成稳定的版本号描述。</p>
<p>比方说，有一个包 A
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"A"</span>,</div><div class="line">  <span class="attr">"version"</span>: <span class="string">"0.1.0"</span>,</div><div class="line">  <span class="attr">"dependencies"</span>: &#123;</div><div class="line">    <span class="attr">"B"</span>: <span class="string">"&lt;0.1.0"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>还有一个包 B
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"B"</span>,</div><div class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.1"</span>,</div><div class="line">  <span class="attr">"dependencies"</span>: &#123;</div><div class="line">    <span class="attr">"C"</span>: <span class="string">"&lt;0.1.0"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以及包 C
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"C"</span>,</div><div class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.1"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你的项目只依赖于 A，于是 <code>npm install</code> 会得到这样的目录结构
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">A@<span class="number">0.1</span><span class="number">.0</span></div><div class="line">  `-- B@<span class="number">0.0</span><span class="number">.1</span></div><div class="line">      `-- C@<span class="number">0.0</span><span class="number">.1</span></div></pre></td></tr></table></figure></p>
<p>这时候，B@0.0.2 发布了，这时候在一个新的环境下执行 <code>npm install</code> 将得到
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">A@<span class="number">0.1</span><span class="number">.0</span></div><div class="line">    `-- B@<span class="number">0.0</span><span class="number">.2</span></div><div class="line">        `-- C@<span class="number">0.0</span><span class="number">.1</span></div></pre></td></tr></table></figure></p>
<p>这时候两次安装得到的版本号就不一致了。而通过 shrinkwrap 命令，我们可以保证在所有环境下安装得到稳定的结果。</p>
<p>在项目引入新包的时候，或者 A 的开发者执行一下 npm shrinkwrap，可以在项目根目录得到一个 npm-shrinkwrap.json 文件。</p>
<p>这个文件内容如下
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"A"</span>,</div><div class="line">  <span class="attr">"version"</span>: <span class="string">"0.1.0"</span>,</div><div class="line">  <span class="attr">"dependencies"</span>: &#123;</div><div class="line">    <span class="attr">"B"</span>: &#123;</div><div class="line">      <span class="attr">"version"</span>: <span class="string">"0.0.1"</span>,</div><div class="line">      <span class="attr">"dependencies"</span>: &#123;</div><div class="line">        <span class="attr">"C"</span>: &#123;</div><div class="line">          <span class="attr">"version"</span>: <span class="string">"0.0.1"</span></div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>shrinkwrap 命令根据目前安装在node_modules的文件情况锁定依赖版本。在项目中执行 <code>npm install</code> 的时候，npm 会检查在根目录下有没有 npm-shrinkwrap.json 文件，如果 shrinkwrap 文件存在的话，npm 会使用它（而不是 package.json）来确定安装的各个包的版本号信息。</p>
<p>这样一来，在安装时候确定的所有版本信息会稳定的固化在 shrinkwrap 里。无论是A，B 和 C中的版本如何变化，或者它们的 package.json 文件如何修改，你始终能保证，在你项目中执行 <code>npm install</code> 的到的版本号时稳定的。</p>
<h3 id="在开发中使用-shrinkwrap"><a href="#在开发中使用-shrinkwrap" class="headerlink" title="在开发中使用 shrinkwrap"></a>在开发中使用 shrinkwrap</h3><h5 id="在开发过程中，引入一个新包的流程如下"><a href="#在开发过程中，引入一个新包的流程如下" class="headerlink" title="在开发过程中，引入一个新包的流程如下"></a>在开发过程中，引入一个新包的流程如下</h5><ul>
<li><code>npm install PACKAGE_NAME@VERSION --save</code> 获取特定版本的包</li>
<li>测试功能</li>
<li>测试功能正常后，执行 <code>npm shrinkwrap</code> 把依赖写入 shrinkwrap 文件</li>
<li>在代码仓库中提交 <code>shrinkwrap / package.json</code>描述</li>
</ul>
<h5 id="升级一个包的流程应该是这样"><a href="#升级一个包的流程应该是这样" class="headerlink" title="升级一个包的流程应该是这样"></a>升级一个包的流程应该是这样</h5><ul>
<li><code>npm outdated</code> 获取项目所有依赖的更新信息</li>
<li><code>npm install PACKAGE_NAME@VERSION --save</code> 获取特定版本的包</li>
<li>测试功能</li>
<li>测试功能正常后，执行 <code>npm shrinkwrap</code>把依赖写入 shrinkwrap 文件</li>
<li>在代码仓库中提交 <code>shrinkwrap / package.json</code>描述</li>
</ul>
<h5 id="删除一个包的流程如下"><a href="#删除一个包的流程如下" class="headerlink" title="删除一个包的流程如下"></a>删除一个包的流程如下</h5><ul>
<li><code>npm uninstall PACKAGE_NAME --save</code> 删除这个包</li>
<li>测试功能</li>
<li>测试功能正常后，执行 <code>npm shrinkwrap</code> 把更新的依赖写入 shrinkwrap 文件</li>
<li>在代码仓库中提交 <code>shrinkwrap / package.json</code> 描述</li>
<li>比一般的安装多了一步手工生成 shrinkwrap 文件。在实际工作中，有时候我们会忘记这一步，导致上线时候没有获取到依赖包的特定版本。</li>
</ul>
<p>本文转自<a href="http://tech.meituan.com/npm-shrinkwrap.html" target="_blank" rel="external">使用 npm shrinkwrap 来管理项目依赖</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;管理依赖是一个复杂软件开发过程中必定会遇到的问题。&lt;/p&gt;
&lt;p&gt;在Node.js项目开发的时候，我们也经常需要安装和升级对应的依赖。虽然 npm 以及语意化的版本号 (semantic versioning, semver) 让开发过程中依赖的获取和升级变得非常容易， 但不严格的版本号限制，也带来了版本号的不确定性。主要的问题可能有三个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;npm 建议使用 semver 的应用程序版本，但这也完全依赖第三方包遵守这一规则。如果你依赖于的包不遵循 semver ，或者依赖的包的新版本有重大更改（而你使用了 ^ 的宽泛版本安装），这潜在可能是会导致问题的。&lt;/li&gt;
&lt;li&gt;另一个问题的出现是由于 npm 安装依赖的机制。npm 的安装包是有层次结构的，手动控制要安装的软件包的版本号可以实现，但是你只能在 package.json 使用精确的版本号控制你的直接依赖包，但那些多层以上的依赖就没办法控制了；一个第三方包不严谨的版本依赖生命可能破坏你的依赖管理。&lt;/li&gt;
&lt;li&gt;在开发阶段执行得到的版本，和后续部署时得到的可能是不一致的，更不可控的是，你依赖的第三方包也有这样的情况会导致潜在的上线风险。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果要控制上线的风险，我们就必需要解决这个问题，这时候，就需要使用 npm shrinkwrap 这个命令来解决问题。
    
    </summary>
    
      <category term="npm" scheme="http://robin-front.github.io/categories/npm/"/>
    
    
      <category term="npm" scheme="http://robin-front.github.io/tags/npm/"/>
    
      <category term="shrinkwrap" scheme="http://robin-front.github.io/tags/shrinkwrap/"/>
    
  </entry>
  
  <entry>
    <title>用Git-Hooks进行自动部署,让提交发布自动化</title>
    <link href="http://robin-front.github.io/2016/08/11/%E7%94%A8Git-Hooks%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2-%E8%AE%A9%E6%8F%90%E4%BA%A4%E5%8F%91%E5%B8%83%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    <id>http://robin-front.github.io/2016/08/11/用Git-Hooks进行自动部署-让提交发布自动化/</id>
    <published>2016-08-11T11:51:56.000Z</published>
    <updated>2016-08-11T11:51:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前了解的自动化部署都是<code>jekins</code>这样集成化的成熟的工具。最近因为有朋友提交代码时，不想登陆服务器拉取代码，才了解到 <code>git hooks</code>。看来还是git使用不到位。之前一直都是本地开发并提交代码，测试时，人工登陆测试服务器去拉取最新代码。
<a id="more"></a></p>
<p>网上资料还是比较多的，最后在本机测试是成功了的。</p>
<p>主要选要明白几个关键点：</p>
<ul>
<li>git init –bare</li>
<li>post-receive 文件</li>
<li>SSH 认证</li>
</ul>
<p>这几个都比较容易找到资料。</p>
<h3 id="git-init-–bare"><a href="#git-init-–bare" class="headerlink" title="git init –bare"></a>git init –bare</h3><p>和 <code>git init</code> 不一样的是，<code>git init --bare</code>并不存储实际代码，仓库文件夹不会看到任何项目代码，反而生成了一些 <code>.git</code>之外的文件夹，其中 <code>hooks</code>文件夹就是存放git命令操作后需要执行的脚本。
需要新建两个文件夹，一个执行<code>git init --bare</code>作为远端仓库，一个执行<code>git init</code>作为服务器项目目录。
本地开发目录和服务器项目目录的<code>remote</code>都要指向 服务器的远端仓库。</p>
<h3 id="post-receive-文件"><a href="#post-receive-文件" class="headerlink" title="post-receive 文件"></a>post-receive 文件</h3><p>post-receive 文件是git push 之后，执行的脚本文件，自动部署的脚本代码就写在这里。
如：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"><span class="built_in">unset</span> GIT_DIR</div><div class="line"><span class="built_in">echo</span> <span class="string">"远程开始更新"</span></div><div class="line">NowPath=`<span class="built_in">pwd</span>`</div><div class="line"><span class="built_in">echo</span> <span class="variable">$NowPath</span></div><div class="line">DeployPath=<span class="string">"../deploy"</span></div><div class="line"></div><div class="line"><span class="built_in">cd</span> <span class="variable">$DeployPath</span></div><div class="line">git pull origin master</div><div class="line"><span class="built_in">echo</span> <span class="string">"远程更新完毕"</span></div><div class="line"><span class="built_in">cd</span> <span class="variable">$NowPath</span></div><div class="line"><span class="built_in">exit</span> 0</div></pre></td></tr></table></figure></p>
<p>这里有一点比较容易出问题的就是路径，最好还是使用绝对路径。
脚本里还可以加入任何想执行的脚本，比如打包编译。</p>
<blockquote>
<p>不过要注意使用 chmod +x post-receive 改变一下权限，服务器端的配置就基本完成了。</p>
</blockquote>
<h3 id="SSH认证"><a href="#SSH认证" class="headerlink" title="SSH认证"></a>SSH认证</h3><p>这个在 mac os x 和 linux都没有问题，我用别人的windows配置的时候经常都会出现认证失败，就算认证成功了，也无法执行脚本，对这个还是不太熟悉。我猜可能是 cmd 的问题，ssh 登陆后还遇到过乱码。</p>
<p>这些都配置好之后，本地开发只需要提交代码，服务器就可以预览最新代码了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前了解的自动化部署都是&lt;code&gt;jekins&lt;/code&gt;这样集成化的成熟的工具。最近因为有朋友提交代码时，不想登陆服务器拉取代码，才了解到 &lt;code&gt;git hooks&lt;/code&gt;。看来还是git使用不到位。之前一直都是本地开发并提交代码，测试时，人工登陆测试服务器去拉取最新代码。
    
    </summary>
    
      <category term="git" scheme="http://robin-front.github.io/categories/git/"/>
    
    
      <category term="git" scheme="http://robin-front.github.io/tags/git/"/>
    
  </entry>
  
</feed>
