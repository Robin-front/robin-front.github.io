<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>三寸稚笔</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://robin-front.github.io/"/>
  <updated>2017-06-14T15:28:54.000Z</updated>
  <id>http://robin-front.github.io/</id>
  
  <author>
    <name>robin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flow和TypeScript之间的区别和优劣</title>
    <link href="http://robin-front.github.io/2017/06/14/Flow%E5%92%8CTypeScript%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BC%98%E5%8A%A3/"/>
    <id>http://robin-front.github.io/2017/06/14/Flow和TypeScript之间的区别和优劣/</id>
    <published>2017-06-14T15:28:54.000Z</published>
    <updated>2017-06-14T15:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>采用Flow＆TypeScript, 两者上手流程之间的比较。</p>
<p>让我们想象一下我们想要采用一种类型检查器的场景…</p>
<p>本文译自： <a href="http://thejameskyle.com/adopting-flow-and-typescript.html" target="_blank" rel="external">adopting flow and typescript</a>
<a id="more"></a></p>
<p>最近我们已经注意到了我们的应用程序中的很多NaN的出现。我们搜索源代码并找到以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// math.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n;</div><div class="line">&#125;</div><div class="line">square(<span class="string">"oops"</span>);</div></pre></td></tr></table></figure>
<p>我们对自己叹了口气，也许决定添加一个类型检查器。我们退后一步，查看我们的选项： <a href="https://flow.org/" target="_blank" rel="external">Flow</a> 或 <a href="http://www.typescriptlang.org/" target="_blank" rel="external">TypeScript</a>。</p>
<p>这两个工具都有相当简单的方法给逐个文件应用：</p>
<ul>
<li>Flow: <code>// @flow</code> 向文件顶部添加注释</li>
<li>TypeScript：将扩展名更改为<code>.js</code>扩展<code>.ts</code> 名</li>
</ul>
<p>但是让我们比较一下这里面发生了什么。</p>
<h3 id="采用TypeScript"><a href="#采用TypeScript" class="headerlink" title="采用TypeScript"></a>采用TypeScript</h3><p>要采用TypeScript，我们首先重命名<code>math.js</code>为 <code>math.ts</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// math.ts</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n;</div><div class="line">&#125;</div><div class="line">square(<span class="string">"oops"</span>);</div></pre></td></tr></table></figure>
<p>现在我们将运行typescript：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(no errors)</div></pre></td></tr></table></figure>
<p>没有错误，是因为TypeScript要求我们给函数键入注释，然后才会根据注释检查类型。如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n: number</span>): <span class="title">number</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n;</div><div class="line">&#125;</div><div class="line">square(<span class="string">"oops"</span>);</div></pre></td></tr></table></figure>
<p>如果没有这些类型，TypeScript将根据您的配置执行下面两件事情之一：</p>
<ul>
<li><ol>
<li>隐含地将每个未知类型转换为<code>any</code>。这种任何类型将让您退出所有类型检查。</li>
</ol>
</li>
<li><ol>
<li>或者如果您使用了<code>--noImplicitAny</code>选项，它会为任何未知类型抛出错误，指明需要添加类型注释。</li>
</ol>
</li>
</ul>
<p>这意味着TypeScript 覆盖的代码量与您所写的类型相关。写入类型时，类型coverage将线性上升。</p>
<h3 id="类型覆盖（type-coverage）"><a href="#类型覆盖（type-coverage）" class="headerlink" title="类型覆盖（type coverage）"></a>类型覆盖（type coverage）</h3><p>在我们进一步讲解之前，我应该解释一下什么是类型覆盖。</p>
<p><img src="http://thejameskyle.com/img/type-coverage.png" alt="未有类型覆盖的代码用红色显示"></p>
<p>未有类型覆盖的代码用红色显示</p>
<p>如果你看到你的代码中的值和表达式，并问类型检查器“你知道这是什么类型吗”。</p>
<p>如果类型检查器知道它类型，则覆盖该值或表达式。如果类型检查器不知道类型，那么它没有被覆盖。</p>
<p>您希望您的程序尽可能多地提供类型覆盖，因为这样可以在更多地方抛出错误时提前告诉您。</p>
<p>没有类型覆盖，类型检查器什么都不是。</p>
<h3 id="采用Flow"><a href="#采用Flow" class="headerlink" title="采用Flow"></a>采用Flow</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// @flow</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n;</div><div class="line">&#125;</div><div class="line">square(<span class="string">"oops"</span>);</div></pre></td></tr></table></figure>
<p>然后我们将运行Flow并查看结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n;</div><div class="line">         ^   ^</div><div class="line">         <span class="built_in">Error</span> (x2)</div><div class="line">&#125;</div><div class="line">square(<span class="string">"oops"</span>);</div><div class="line"></div><div class="line"><span class="built_in">Error</span> (x2)</div><div class="line">string. The operand <span class="keyword">of</span> an arithmetic operation must be a number.</div></pre></td></tr></table></figure>
<p>紧接着就抛出了类型错误，告诉我们代码出了问题。</p>
<p>Flow 只需要我们键入文件和外部模块的导出。可以推测出其他一切。</p>
<p>这使得类型覆盖率快得多。只需几种类型，您可以快速获取具有非常高类型覆盖率的文件。</p>
<p>根据我的经验，我可以在短短几分钟内将文件覆盖约70-90％。</p>
<p>这是一个非常科学的差异图：</p>
<p><img src="http://thejameskyle.com/img/adopting-flow-and-typescript-graph.png" alt=""></p>
<p>这不是我一家之言，你可以自己尝试一下，看看几种类型的区别。</p>
<p>要查看Flow中文件的类型覆盖，可以运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flow coverage path/to/file.js --color</div></pre></td></tr></table></figure>
<p>您还可以使用 <a href="https://github.com/rpl/flow-coverage-report" target="_blank" rel="external">流量报告</a> 来帮助您。</p>
<blockquote>
<p>注意：我没有注意到TypeScript 有任何的类型报告工具（如果您知道一个，请给我发送一个链接）。但是，您可以测试代码是否覆盖，以确定当您出现错误时是否会报告错误。</p>
</blockquote>
<h3 id="这个的工作原理是什么"><a href="#这个的工作原理是什么" class="headerlink" title="这个的工作原理是什么"></a>这个的工作原理是什么</h3><p>这两种工具具有不同行为的原因归结于其架构之间的区别。</p>
<h4 id="TypeScript体系结构：AST导向"><a href="#TypeScript体系结构：AST导向" class="headerlink" title="TypeScript体系结构：AST导向"></a>TypeScript体系结构：AST导向</h4><p>TypeScript将遍历您的程序并构建已知类型的表。当它发现值和表达式时，它会立即为其分配类型。当TypeScript发现一个未知的类型时，它必须立即作出决定，这意味着将其分配给<code>any</code>或抛出错误。</p>
<h4 id="Flow-架构：图形导向"><a href="#Flow-架构：图形导向" class="headerlink" title="Flow 架构：图形导向"></a>Flow 架构：图形导向</h4><p>Flow 将建立一个你所有的值和表达式及其彼此之间的关系的图表。然后，它将开始为每个值和表达式分配类型。如果它找到一个未知的类型，它将使它成为一个“开放”类型，稍后再回来判断。</p>
<p>一旦Flow具有您的程序的完整蓝图，它将开始连接所有点，从一个值连接到另一个值地跟踪类型。打开类型接受流入它们的所有值的类型 - 生成的类型称为 “推断类型”。</p>
<p>你可以看这个是怎么回事。来看看我们在之前的类型错误：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n;</div><div class="line">         ^   ^</div><div class="line">         <span class="built_in">Error</span> (x2)</div><div class="line">&#125;</div><div class="line">square(<span class="string">"oops"</span>);</div><div class="line"></div><div class="line"><span class="built_in">Error</span> (x2)</div><div class="line">string. The operand <span class="keyword">of</span> an arithmetic operation must be a number.</div></pre></td></tr></table></figure>
<p>注意错误是指向<code>n * n</code>而不是 <code>square(&quot;oops&quot;)</code>。因为我们没有写入一个类型为n的 “oops”字符串流入它，并且Flow开始检查n，就好像它是一个字符串。</p>
<p>添加类型注释我们可以看到错误点移动了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n: number</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n;</div><div class="line">&#125;</div><div class="line">square(<span class="string">"oops"</span>);</div><div class="line">       ^ <span class="built_in">Error</span></div><div class="line"></div><div class="line"><span class="built_in">Error</span>: string.</div><div class="line">This type is incompatible <span class="keyword">with</span> the expected param type <span class="keyword">of</span> number.</div></pre></td></tr></table></figure>
<p>这提出了一个重要的一点：Flow可以在任何地方自动推断类型并不意味着你不应该添加类型注释你的代码。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>TypeScript和Flow都有非常好的上手过程。一个个文件地尝试是一个很好的经历。</p>
<p>但是，如果使用Flow，你就会有更高以及更快的覆盖类型，你就可以安心睡觉。</p>
<p>使用Flow，您可以添加类型以使错误更友好，而不仅只是发现它们。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;采用Flow＆TypeScript, 两者上手流程之间的比较。&lt;/p&gt;
&lt;p&gt;让我们想象一下我们想要采用一种类型检查器的场景…&lt;/p&gt;
&lt;p&gt;本文译自： &lt;a href=&quot;http://thejameskyle.com/adopting-flow-and-typescript.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;adopting flow and typescript&lt;/a&gt;
    
    </summary>
    
      <category term="Flow" scheme="http://robin-front.github.io/categories/Flow/"/>
    
      <category term="TypeScript" scheme="http://robin-front.github.io/categories/Flow/TypeScript/"/>
    
    
      <category term="Flow" scheme="http://robin-front.github.io/tags/Flow/"/>
    
      <category term="TypeScript" scheme="http://robin-front.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>使用RXJS组合、过滤和映射数据流的值</title>
    <link href="http://robin-front.github.io/2017/06/05/%E4%BD%BF%E7%94%A8RXJS%E7%BB%84%E5%90%88%E3%80%81%E8%BF%87%E6%BB%A4%E5%92%8C%E6%98%A0%E5%B0%84%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E5%80%BC/"/>
    <id>http://robin-front.github.io/2017/06/05/使用RXJS组合、过滤和映射数据流的值/</id>
    <published>2017-06-05T08:24:16.000Z</published>
    <updated>2017-06-05T08:24:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查询可观测序列"><a href="#查询可观测序列" class="headerlink" title="查询可观测序列"></a>查询可观测序列</h1><p>在<a href="https://robin-front.github.io/RxJS-doc-chinese/content/getting_started_with_rxjs/creating_and_querying_observable_sequences/bridging_to_events.md">事件桥接</a> 一文中，我们将现有的DOM和Node.js事件转换成可观察的序列以订阅它们。在本主题中，我们将把可观察序列的父级class视为IObservable对象，其中Rx组件提供通用LINQ操作符来操作这些对象。大多数操作符获取可观察的序列并对其执行一些逻辑并输出另一个可观测序列。另外，从代码示例可以看出，甚至可以在源序列上使用多个运算符，最终将结果序列调整到您的确切需求。
<a id="more"></a></p>
<p>本文翻译在： <a href="https://robin-front.github.io/RxJS-doc-chinese/content/getting_started_with_rxjs/creating_and_querying_observable_sequences/querying_observable_sequences.html">RXJS中文文档</a></p>
<h2 id="使用不同的运算符"><a href="#使用不同的运算符" class="headerlink" title="使用不同的运算符"></a>使用不同的运算符</h2><p>我们已经在以前的主题中使用<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservablecreatesubscribe" target="_blank" rel="external"><code>create</code></a>和<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservablerangestart-count-scheduler" target="_blank" rel="external"><code>range</code></a>运算符来创建和返回简单的序列。我们还使用<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservablefromeventelement-eventname" target="_blank" rel="external"><code>fromEvent</code></a>和<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservablefromeventpatternaddhandler-removehandler" target="_blank" rel="external"><code>fromEventPattern</code></a>运算符将现有事件转换成可观察的序列。在本主题中，我们将使用其他<code>Observable</code>类型的运算符，以便可以过滤，分组和转换数据。这些运算符将可观察到的序列作为输入，并生成输出另一个可观察序列。</p>
<h2 id="组合不同序列"><a href="#组合不同序列" class="headerlink" title="组合不同序列"></a>组合不同序列</h2><p>在本节中，我们会研究将各种可观察序列组合成单个可观察序列的操作符。请注意，当我们组合序列时，数据不会被转换。在以下示例中，我们使用Concat运算符将两个序列组合成一个序列并订阅它。为了说明的目的，我们将使用非常简单的<code>range(x, y)</code>运算符创建一个从x开始的整数序列，然后产生y个序列数字。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> source1 = Rx.Observable.range(<span class="number">1</span>, <span class="number">3</span>);</div><div class="line"><span class="keyword">var</span> source2 = Rx.Observable.range(<span class="number">1</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line">source1.concat(source2)</div><div class="line">   .subscribe(<span class="built_in">console</span>.log.bind(<span class="built_in">console</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; 1</span></div><div class="line"><span class="comment">// =&gt; 2</span></div><div class="line"><span class="comment">// =&gt; 3</span></div><div class="line"><span class="comment">// =&gt; 1</span></div><div class="line"><span class="comment">// =&gt; 2</span></div><div class="line"><span class="comment">// =&gt; 3</span></div></pre></td></tr></table></figure>
<p>注意，结果序列是1,2,3,1,2,3。这是因为当您使用<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypeconcatargs" target="_blank" rel="external"><code>concat</code></a>运算符时，第二个序列（source2）将在第一个序列（source1）完成推送其所有值之后才会激活。只有在source1完成之后，source2才会将值推送到最后的序列。然后，订阅者将从得到的序列中获取所有值。</p>
<p>与<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypemergemaxconcurrent--other" target="_blank" rel="external"><code>merge</code></a> 操作符进行比较。如果运行以下示例代码，您将获得1,1,2,2,3,3。这是因为两个序列同时处于活动状态，并且值在数据源中发生时被推出。结果序列仅在最后一个数据源完成推送值时完成。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> source1 = Rx.Observable.range(<span class="number">1</span>, <span class="number">3</span>);</div><div class="line"><span class="keyword">var</span> source2 = Rx.Observable.range(<span class="number">1</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line">source1.merge(source2)</div><div class="line">   .subscribe(<span class="built_in">console</span>.log.bind(<span class="built_in">console</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; 1</span></div><div class="line"><span class="comment">// =&gt; 1</span></div><div class="line"><span class="comment">// =&gt; 2</span></div><div class="line"><span class="comment">// =&gt; 2</span></div><div class="line"><span class="comment">// =&gt; 3</span></div><div class="line"><span class="comment">// =&gt; 3</span></div></pre></td></tr></table></figure>
<p><a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypecatchsecond--handler" target="_blank" rel="external"><code>catch</code></a> 操作符可以进行另一个比较。在这种情况下，如果source1完成没有任何错误，那么source2将不会启动。因此，如果运行以下示例代码，则获得1,2,3因为source2（产生4,5,6））被忽略。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> source1 = Rx.Observable.range(<span class="number">1</span>, <span class="number">3</span>);</div><div class="line"><span class="keyword">var</span> source2 = Rx.Observable.range(<span class="number">4</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line">source1.catch(source2)</div><div class="line">   .subscribe(<span class="built_in">console</span>.log.bind(<span class="built_in">console</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; 1</span></div><div class="line"><span class="comment">// =&gt; 2</span></div><div class="line"><span class="comment">// =&gt; 3</span></div></pre></td></tr></table></figure>
<p>最后，我们来看看<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypeonerrorresumenextsecond" target="_blank" rel="external"><code>onErrorResumeNext</code></a>。即使由于错误导致source1无法完成，该操作符也将移动到source2。在以下示例中，即使source1表示通过使用<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservablethrowexception-scheduler" target="_blank" rel="external"><code>throw</code></a>运算符终止异常的序列，用户将接收source2发布的值（1,2,3）。因此，如果您预期到任何一个源序列产生任何错误，那么使用它<code>onErrorResumeNext</code>来保证用户仍然会收到一些值是更安全的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> source1 = Rx.Observable.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'An error has occurred.'</span>));</div><div class="line"><span class="keyword">var</span> source2 = Rx.Observable.range(<span class="number">1</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line">source1.onErrorResumeNext(source2)</div><div class="line">   .subscribe(<span class="built_in">console</span>.log.bind(<span class="built_in">console</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; 1</span></div><div class="line"><span class="comment">// =&gt; 2</span></div><div class="line"><span class="comment">// =&gt; 3</span></div></pre></td></tr></table></figure>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p><a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypeselectselector-thisarg" target="_blank" rel="external"><code>select</code></a>或 <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypemapselector-thisarg" target="_blank" rel="external"><code>map</code></a> 操作符将可观察到的一个序列的每个元素转换成另一种形式。</p>
<p>在下面的示例中，我们将一系列字符串映射到一系列表示长度的整数中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> array = [<span class="string">'Reactive'</span>, <span class="string">'Extensions'</span>, <span class="string">'RxJS'</span>];</div><div class="line"></div><div class="line"><span class="keyword">var</span> seqString = Rx.Observable.from(array);</div><div class="line"></div><div class="line"><span class="keyword">var</span> seqNum = seqString.map(<span class="function"><span class="params">x</span> =&gt;</span> x.length);</div><div class="line"></div><div class="line">seqNum</div><div class="line">   .subscribe(<span class="built_in">console</span>.log.bind(<span class="built_in">console</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; 8</span></div><div class="line"><span class="comment">// =&gt; 10</span></div><div class="line"><span class="comment">// =&gt; 4</span></div></pre></td></tr></table></figure>
<p>在以下示例中，我们在“<a href="https://robin-front.github.io/RxJS-doc-chinese/content/getting_started_with_rxjs/creating_and_querying_observable_sequences/bridging_to_events.md">桥接现有事件</a>”主题中看到的事件转换示例的扩展，我们使用<code>select</code>或<code>map</code>运算符将事件参数投影到x和y点。这样，我们将鼠标移动事件序列转换为可以进一步解析和操作的数据类型，如下一个“过滤”部分所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> move = Rx.Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'mousemove'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> points = move.map(<span class="function"><span class="params">e</span> =&gt;</span> (&#123;<span class="attr">x</span>: e.clientX, <span class="attr">y</span>: e.clientY &#125;));</div><div class="line"></div><div class="line">points.subscribe(</div><div class="line">	<span class="function"><span class="params">pos</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Mouse at point '</span> + pos.x + <span class="string">', '</span> + pos.y));</div></pre></td></tr></table></figure>
<p>最后，我们来看看<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypeselectmanyselector-resultselector" target="_blank" rel="external"><code>selectMany</code></a> or <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypeflatmapselector-resultselector" target="_blank" rel="external"><code>flatMap</code></a>运算符。<code>selectMany</code>或<code>flatMap</code>操作符具有许多重载，其中一个就是需要选择器函数作为参数。这个选择器函数是由数据源推出的每个值去调用的。对于每一个值，选择器将其映射成一个迷你的可观察序列。最后，<code>selectMany</code>或者<code>flatMap</code>操作符将所有这些迷你序列扁平化成单个结果序列，然后将其推送到用户。</p>
<p>在数据源和由选择器函数产生的所有迷你可观察序列都已经完成之后，源序列返回<code>selectMany</code>或<code>flatMap</code>发布的<code>onCompleted</code>。当发生源数据流中的错误时触发<code>onError</code>，当一个异常被选择函数抛出，或者当在任何迷你观察序列的发生了错误。</p>
<p>在下面的例子中，我们首先创建一个数据源序列，每5秒产生一个整数，并决定使用生成的前两个值（使用<code>take</code>运算符）。然后，我们使用<code>selectMany</code>或者<code>flatMap</code>对另一个序列{100,101,102}这些整数进行映射。通过这样做，产生两个迷你观察序列{100,101,102}和{100,101,102}。它们最终平坦化成{100,101,102,100,101,102}的单个整数流，并被推送到观察者。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> source1 = Rx.Observable.interval(<span class="number">5000</span>).take(<span class="number">2</span>);</div><div class="line"><span class="keyword">var</span> proj = Rx.Observable.range(<span class="number">100</span>, <span class="number">3</span>);</div><div class="line"><span class="keyword">var</span> resultSeq = source1.flatMap(proj);</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription = resultSeq.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onNext: %s'</span>, x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'onError: %s'</span>, e.message),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; onNext: 100</span></div><div class="line"><span class="comment">// =&gt; onNext: 101</span></div><div class="line"><span class="comment">// =&gt; onNext: 102</span></div><div class="line"><span class="comment">// =&gt; onNext: 100</span></div><div class="line"><span class="comment">// =&gt; onNext: 101</span></div><div class="line"><span class="comment">// =&gt; onNext: 102</span></div><div class="line"><span class="comment">// =&gt; onCompleted</span></div></pre></td></tr></table></figure>
<h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><p>在下面的例子中，我们使用<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservablegenerateinitialstate-condition-iterate-resultselector-scheduler" target="_blank" rel="external"><code>generate</code></a> 运算符创建一个简单的可观察数字序列。该<code>generate</code>操作符有几个版本，包括有相对和绝对时间调度。在我们的示例中，它需要初始状态（在我们的示例中为0），一个条件函数终止（少于10次），迭代器（+1），结果选择器（当前值的平方函数））和打印只使用小于5的那些使用<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypefilterpredicate-thisarg" target="_blank" rel="external"><code>filter</code></a>或<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypewherepredicate-thisarg" target="_blank" rel="external"><code>where</code></a>运算符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> seq = Rx.Observable.generate(</div><div class="line">	<span class="number">0</span>,</div><div class="line">	i =&gt; i &lt; <span class="number">10</span>,</div><div class="line">	i =&gt; i + <span class="number">1</span>,</div><div class="line">	i =&gt; i * i);</div><div class="line"></div><div class="line"><span class="keyword">var</span> source = seq.filter(<span class="function"><span class="params">n</span> =&gt;</span> n &lt; <span class="number">5</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onNext: %s'</span>, x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'onError: %s'</span>, e.message),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; onNext: 0</span></div><div class="line"><span class="comment">// =&gt; onNext: 1</span></div><div class="line"><span class="comment">// =&gt; onNext: 4</span></div><div class="line"><span class="comment">// =&gt; onCompleted</span></div></pre></td></tr></table></figure>
<p>以下示例是本主题前面已经看到的映射示例的扩展。在该示例中，我们使用<code>select</code>或<code>map</code>运算符将事件参数投影到具有x和y的点。在下面的例子中，我们使用<code>filter</code>或<code>where</code>和<code>select</code>或<code>map</code>操作符只挑选那些鼠标移动，我们感兴趣的是，在这种情况下，我们鼠标移动过滤，以找出在第一平分线（其中x和y坐标是相等的）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> move = Rx.Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'mousemove'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> points = move.map(<span class="function"><span class="params">e</span> =&gt;</span> (&#123; <span class="attr">x</span>: e.clientX, <span class="attr">y</span>: e.clientY &#125;));</div><div class="line"></div><div class="line"><span class="keyword">var</span> overfirstbisector = points.filter(<span class="function"><span class="params">pos</span> =&gt;</span> pos.x === pos.y);</div><div class="line"></div><div class="line"><span class="keyword">var</span> movesub = overfirstbisector.subscribe(<span class="function"><span class="params">pos</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'mouse at '</span> + pos.x + <span class="string">', '</span> pos.y));</div></pre></td></tr></table></figure>
<h2 id="基于时间的操作"><a href="#基于时间的操作" class="headerlink" title="基于时间的操作"></a>基于时间的操作</h2><p>您可以使用缓冲区运算符执行基于时间的操作。</p>
<p>缓冲可观察序列意味着可观测序列的值基于指定的时间段或计数阈值被放入缓冲区。这在您预期有大量数据被序列推出的情况下特别有用，并且订阅者没有资源来处理这些值。通过基于时间或计数缓冲结果，并且只有在超过条件时才返回值序列（或者源序列完成时），用户可以按照自己的速度处理<code>OnNext</code>调用。</p>
<p>在下面的例子中，我们首先创建一个以每秒为时间单位的简单的整数序列。然后我们使用<code>bufferWithCount</code>运算符，并指定每个缓冲区将保存序列中的5个项目。在<code>onNext</code>当缓冲区已满被调用。然后我们使用缓冲区的总和<code>Array.reduce</code>。缓冲区自动刷新，另一个循环开始。打印输出将为10,35,60 …，其中10 = 0 + 1 + 2 + 3 + 4,35 = 5 + 6 + 7 + 8 + 9等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> seq = Rx.Observable.interval(<span class="number">1000</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> bufSeq = seq.bufferWithCount(<span class="number">5</span>);</div><div class="line"></div><div class="line">bufSeq</div><div class="line">	.map(<span class="function"><span class="params">arr</span> =&gt;</span> arr.reduce(<span class="function">(<span class="params">acc, x</span>) =&gt;</span> acc + x, <span class="number">0</span>))</div><div class="line">	.subscribe(<span class="built_in">console</span>.log.bind(<span class="built_in">console</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; 10</span></div><div class="line"><span class="comment">// =&gt; 35</span></div><div class="line"><span class="comment">// =&gt; 60</span></div><div class="line">...</div></pre></td></tr></table></figure>
<p>我们还可以创建一个指定时间跨度（以毫秒为单位）的缓冲区。在以下示例中，缓冲区将保存累积3秒钟的项目。打印输出将为3,12,21 …其中3 = 0 + 1 + 2,12 = 3 + 4 + 5，依此类推。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> seq = Rx.Observable.interval(<span class="number">1000</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> bufSeq = seq.bufferWithTime(<span class="number">3000</span>);</div><div class="line"></div><div class="line">bufSeq</div><div class="line">	.map(<span class="function"><span class="params">arr</span> =&gt;</span> arr.reduce(<span class="function">(<span class="params">acc, x</span>) =&gt;</span> acc + x, <span class="number">0</span>))</div><div class="line">	.subscribe(<span class="built_in">console</span>.log.bind(<span class="built_in">console</span>));</div></pre></td></tr></table></figure>
<p>请注意，如果您使用任何一个<code>buffer*</code>或<code>window*</code>运算符，则必须确保序列不为空，然后再过滤。</p>
<h2 id="按类别操作"><a href="#按类别操作" class="headerlink" title="按类别操作"></a>按类别操作</h2><p>按<a href="https://robin-front.github.io/RxJS-doc-chinese/content/getting_started_with_rxjs/creating_and_querying_observable_sequences/operators_by_category.md">类别划分的操作符</a>主题列出了按类别实施的<code>Observable</code>的所有主要操作符; 具体来说：创建，转换，合并，功能，数学，时间，异常，杂项，选择和原值。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;查询可观测序列&quot;&gt;&lt;a href=&quot;#查询可观测序列&quot; class=&quot;headerlink&quot; title=&quot;查询可观测序列&quot;&gt;&lt;/a&gt;查询可观测序列&lt;/h1&gt;&lt;p&gt;在&lt;a href=&quot;https://robin-front.github.io/RxJS-doc-chinese/content/getting_started_with_rxjs/creating_and_querying_observable_sequences/bridging_to_events.md&quot;&gt;事件桥接&lt;/a&gt; 一文中，我们将现有的DOM和Node.js事件转换成可观察的序列以订阅它们。在本主题中，我们将把可观察序列的父级class视为IObservable对象，其中Rx组件提供通用LINQ操作符来操作这些对象。大多数操作符获取可观察的序列并对其执行一些逻辑并输出另一个可观测序列。另外，从代码示例可以看出，甚至可以在源序列上使用多个运算符，最终将结果序列调整到您的确切需求。
    
    </summary>
    
      <category term="RXJS" scheme="http://robin-front.github.io/categories/RXJS/"/>
    
    
      <category term="RXJS" scheme="http://robin-front.github.io/tags/RXJS/"/>
    
  </entry>
  
  <entry>
    <title>如何调试Node.js|使用谷歌chrome浏览器调试Node.js</title>
    <link href="http://robin-front.github.io/2017/06/02/%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95Node-js%E4%BD%BF%E7%94%A8%E8%B0%B7%E6%AD%8Cchrome%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95Node-js/"/>
    <id>http://robin-front.github.io/2017/06/02/如何调试Node-js使用谷歌chrome浏览器调试Node-js/</id>
    <published>2017-06-02T09:46:03.000Z</published>
    <updated>2017-06-02T09:46:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>如何调试 Node.js, 还在使用 console.log 来调试 Node.js 吗，可以像调试前端页面一样调试 Node.js!
<a id="more"></a></p>
<p>译文：<a href="https://medium.com/the-node-js-collection/debugging-node-js-with-google-chrome-4965b5f910f4" target="_blank" rel="external">Debugging Node.js with Google Chrome</a></p>
<p>调试是从软件应用程序中识别和删除错误的任务，而不仅仅是打印代码中的值。本文介绍如何使用最新的Google Chrome DevTools高效地调试Node.js程序。</p>
<h2 id="为什么console-log不是最好的选择？"><a href="#为什么console-log不是最好的选择？" class="headerlink" title="为什么console.log不是最好的选择？"></a>为什么console.log不是最好的选择？</h2><p>使用<code>console.log</code>来调试你的代码，通常你会无限重复地做 “停止你的应用程序，添加一个console.log，并再次启动你的应用程序” 这样的操作。除了减缓您的应用程序的开发外，它还使您的书写变得脏乱并创建不必要的代码。最后，尝试注销变量以及其他可能的日志记录操作的噪点时，可能会在尝试找到正在调试的值时使调试变得困难。</p>
<h2 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h2><p>调试工具为用户提供的是几个重要的功能<code>console.log</code>无法提供。特别是，它们允许您在代码中的特定点暂停执行应用程序，并在程序仍在运行时检查和修改变量的值。</p>
<h2 id="设置Chrome-for-Node-js调试"><a href="#设置Chrome-for-Node-js调试" class="headerlink" title="设置Chrome for Node.js调试"></a>设置Chrome for Node.js调试</h2><p>使用<code>Chrome 57+</code>，<code>Node.js</code>调试功能是默认启用的，不需要像以前的版本那样从“实验功能”面板手动启用它。</p>
<p>如果您还没有完成，请将Google Chrome更新到最新版本，并确保使用<code>Node.js 6.4+</code>。</p>
<p>要开始调试，请使用 <code>- inspect</code>标志运行<code>Node.js</code>应用程序。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ node --inspect &lt;your_file&gt; .js</div></pre></td></tr></table></figure>
<p><img src="https://cdn-images-1.medium.com/max/800/1*NIVrIoEiniOt6cP-d-0LFQ.png" alt="在调试模式下运行Node.js应用程序"></p>
<p>接下来，忽略从终端中显示的“<code>chrome-devtools://</code>”开头的URL ，而是在Google Chrome中打开“ <code>about:inspect</code> ”。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*QAmWRyPtdfF5X7VuvDN1zg.png" alt="chrome DevTools"></p>
<p>最后点击“ Open dedicated DevTools for Node” 开始调试应用程序的代码。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*zQ1uLl_qiRIAJ7Lxw_LFAQ.png" alt="deloper tools for Node"></p>
<p>此外，关于调试<a href="https://nodejs.org/en/docs/guides/debugging-getting-started/" target="_blank" rel="external">Node.js App</a>的官方文档还提供了所有其他检查器工具和客户端选项的详细列表。</p>
<h2 id="Chrome-DevTools的应用"><a href="#Chrome-DevTools的应用" class="headerlink" title="Chrome DevTools的应用"></a>Chrome DevTools的应用</h2><p>要结束本文，我想说明一下<code>Chrome DevTools</code>在以下<code>Express</code>应用程序中的应用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</div><div class="line"><span class="keyword">const</span> app = express()</div><div class="line"></div><div class="line"><span class="keyword">const</span> PORT = process.env.PORT || <span class="number">3000</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">capitalize</span> (<span class="params">str</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> firstLetter = str.charAt(<span class="number">0</span>) <span class="comment">// we can check what's inside here</span></div><div class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;firstLetter.toUpperCase()&#125;</span><span class="subst">$&#123;str.slice(<span class="number">1</span>)&#125;</span>`</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">app.get(<span class="string">'/:name?'</span>, (req, res) =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> name = req.params.name ? capitalize(req.params.name) : <span class="string">'World'</span></div><div class="line">  res.send(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>!`</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">app.listen(PORT, () =&gt; <span class="built_in">console</span>.log(<span class="string">`App listening on *:<span class="subst">$&#123;PORT&#125;</span>`</span>))</div></pre></td></tr></table></figure>
<p>让我们从运行<code>- inspect</code>标志，并打开专用<code>DevTools for Node</code>如前所述。</p>
<p>此时，您将可以访问您可能已经熟悉的所有功能：断点(<code>breakpoints</code>)，压缩代码的源映射(<code>source map for transpiled code</code>)，堆快照检查(<code>heap snapshot inspection</code>)，分配分析(<code>allocation profiling</code>)，JavaScript值热插拔(<code>JavaScript values hot-swapping</code>)等。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*jTzAaK_zRNynCMvlDbx2rA.png" alt="使用断点来调试Express应用程序"></p>
<p>具体来说，如下图所示，您可以插入断点来停止执行程序，检查和“热交换”变量的值。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*URHvZNuF7RksLoDZRbYnpQ.png" alt="JavaScript值热拔插"></p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*mk2Ro3VX6iAw7YLWJzlmtw.png" alt="JavaScript值热拔插2"></p>
<p>使用Chrome作为调试工具的另外一件好事是您可以使用相同的界面🚀调试前端和后端JavaScript代码。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何调试 Node.js, 还在使用 console.log 来调试 Node.js 吗，可以像调试前端页面一样调试 Node.js!
    
    </summary>
    
      <category term="Node.js" scheme="http://robin-front.github.io/categories/Node-js/"/>
    
    
      <category term="debug" scheme="http://robin-front.github.io/tags/debug/"/>
    
      <category term="Node.js" scheme="http://robin-front.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>RXJS我该选用哪个操作符之-创建篇</title>
    <link href="http://robin-front.github.io/2017/06/01/RXJS%E6%88%91%E8%AF%A5%E9%80%89%E7%94%A8%E5%93%AA%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8B-%E5%88%9B%E5%BB%BA%E7%AF%87/"/>
    <id>http://robin-front.github.io/2017/06/01/RXJS我该选用哪个操作符之-创建篇/</id>
    <published>2017-06-01T10:16:43.000Z</published>
    <updated>2017-06-01T10:16:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>RXJS该怎么上手？这么多操作符该用哪个？RXJS比较强大，操作符众多，想熟悉需要比较长时间的运用，所以大部分新手都比较疑惑应该使用哪些操作符去实现自己的数据流的操作。</p>
<p>更多详情请翻阅 <a href="https://robin-front.github.io/RxJS-doc-chinese">RXJS中文翻译文档</a></p>
<h1 id="我该选用哪个操作符-创建操作符"><a href="#我该选用哪个操作符-创建操作符" class="headerlink" title="我该选用哪个操作符? - 创建操作符"></a>我该选用哪个操作符? - 创建操作符</h1><p>使用此页面查找<a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/index.html"><code>Observable</code></a>符合您需求的类型创建操作：
<a id="more"></a></p>
<table style="display: table">
<thead>静态方法</thead>
<tbody>
    <!-- Observable factories -->
    <tr>
        <td rowspan="26">我想创建一个新的序列</td>
        <td rowspan="4">使用自定义逻辑</td>
        <td colspan="2"></td>
        <td>
            <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/create.html">Observable.create</a>
        </td>
    </tr>
    <tr>
        <td rowspan="3">像一个for循环</td>
        <td></td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/generate.html">Observable.generate</a></td>
    </tr>
    <tr>
        <td rowspan="2">并随时间发射值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/generatewithrelativetime.html">Observable.generateWithRelativeTime</a></td>
    </tr>
    <tr>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/generatewithabsolutetime.html">Observable.generateWithAbsoluteTime</a></td>
    </tr>
    <tr>
        <td rowspan="2">它返回一个值</td>
        <td colspan="2"></td>
        <td>
            <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/return.html">Observable.return/just</a>
        </td>
    </tr>
    <tr>
        <td colspan="2">多次</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/repeat.html">Observable.repeat</a></td>
    </tr>
    <tr>
        <td colspan="3">这会抛出错误</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/throw.html">Observable.throw</a></td>
    </tr>
    <tr>
        <td colspan="3">完成了</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/empty.html">Observable.empty</a></td>
    </tr>
    <tr>
        <td colspan="3">从来没有做任何事情</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/never.html">Observable.never</a></td>
    </tr>
    <tr>
        <td rowspan="2">从事件</td>
        <td colspan="2"></td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/fromevent.html">Observable.fromEvent</a></td>
    </tr>
    <tr>
        <td colspan="2">它使用自定义函数来添加和删除事件处理程序</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/fromeventpattern.html">Observable.fromEventPattern</a></td>
    </tr>
    <tr>
        <td colspan="3">来自一个<a title="ES6 Promise" href="https://www.promisejs.org" target="_blank" rel="external">ES6 Promise</a></td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/frompromise.html">Observable.fromPromise</a></td>
    </tr>
    <tr>
        <td rowspan="6">它可迭代</td>
        <td rowspan="2">覆盖到数组中的值</td>
        <td></td>
        <td>
            <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/fromarray.html">Observable.fromArray</a><br>
        </td>
    </tr>
    <tr>
      <td>对象键/值对</td>
      <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/pairs.html">Observable.pairs</a></td>
    </tr>
    <tr>
        <td colspan="2">异步元素</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/for.html">Observable.for</a></td>
    </tr>
    <tr>
        <td colspan="2">数值范围内的值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/range.html">Observable.range</a></td>
    </tr>
    <tr>
        <td colspan="2">来自一个可迭代的数组或类似数组的对象的值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/from.html">Observable.from</a></td>
    </tr>
    <tr>
        <td colspan="2">来自参数</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/of.html">Observable.of</a></td>
    </tr>
    <tr>
        <td rowspan="2">根据定时器发出值</td>
        <td colspan="2"></td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/interval.html">Observable.interval</a></td>
    </tr>
    <tr>
        <td colspan="2">具有可选的初始延迟</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/timer.html">Observable.timer</a></td>
    </tr>
    <tr>
        <td rowspan="2" colspan="2">不传参调用函数</td>
        <td>在特定的调度程序</td>
        <td>
            <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/start.html">Observable.start</a>
        </td>
    </tr>
    <tr>
        <td>异步</td>
        <td>
            <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/startasync.html">Observable.startAsync</a>
        </td>
    </tr>
    <tr>
        <td rowspan="4">取决于订阅时</td>
        <td colspan="2">基于布尔条件</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/if.html">Observable.if</a></td>
    </tr>
    <tr>
        <td colspan="2">f从一组预先设定的序列</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/case.html">Observable.case</a></td>
    </tr>
    <tr>
        <td colspan="1" rowspan="2">使用自定义逻辑</td>
        <td></td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/defer.html">Observable.defer</a></td>
    </tr>
    <tr>
        <td>它取决于资源</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/using.html">Observable.using</a></td>
    </tr>
    <!-- Function factories -->
    <tr>
        <td rowspan="3">我想包装一个函数</td>
        <td colspan="2"></td>
        <td rowspan="3">并产生一个序列的结果</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/toasync.html">Observable.toAsync</a></td>
    </tr>
        <td colspan="2">它接受回调</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/fromcallback.html">Observable.fromCallback</a></td>
    
    <tr>
        <td colspan="2">它接受Node.js回调</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/fromnodecallback.html">Observable.fromNodeCallback</a></td>
    </tr>
    <!-- Flatteners -->
    <tr>
        <td rowspan="30">我想结合多个序列</td>
        <td colspan="3">并且仅从产生值的序列中接收值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/amb.html">Observable.amb</a></td>
    </tr>
    <tr>
        <td colspan="3">所有人都已经完成通知</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/forkjoin.html">Observable.forkJoin</a></td>
    </tr>
    <tr>
        <td colspan="3">并输出所有这些值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/merge.html">Observable.merge</a></td>
    </tr>
    <tr>
        <td rowspan="2">为了</td>
        <td colspan="2">不改变时重复使用最新值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/operators/combinelatest.html">Observable.combineLatest</a></td>
    </tr>
    <tr>
        <td colspan="2">每个值只使用一次</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/zip.html">Observable.zip</a></td>
    </tr>
    <tr>
        <td rowspan="3">通过订阅每个序列为了</td>
        <td colspan="2">当前一个序列完成时</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/concat.html">Observable.concat</a></td>
    </tr>
    <tr>
        <td colspan="2">当另一个序列抛出错误时</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/catch.html">Observable.catch</a></td>
    </tr>
    <tr>
        <td colspan="2">不管先前的序列是完成还是抛出错误</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/onerrorresumenext.html">Observable.onErrorResumeNext</a></td>
    </tr>
    <tr>
        <td colspan="3">通过响应不同的值组合<a href="http://en.wikipedia.org/wiki/Join-calculus" target="_blank" rel="external">（连接微积分）</a></td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/when.html">Observable.when</a></td>
    </tr>
</tbody></table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RXJS该怎么上手？这么多操作符该用哪个？RXJS比较强大，操作符众多，想熟悉需要比较长时间的运用，所以大部分新手都比较疑惑应该使用哪些操作符去实现自己的数据流的操作。&lt;/p&gt;
&lt;p&gt;更多详情请翻阅 &lt;a href=&quot;https://robin-front.github.io/RxJS-doc-chinese&quot;&gt;RXJS中文翻译文档&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;我该选用哪个操作符-创建操作符&quot;&gt;&lt;a href=&quot;#我该选用哪个操作符-创建操作符&quot; class=&quot;headerlink&quot; title=&quot;我该选用哪个操作符? - 创建操作符&quot;&gt;&lt;/a&gt;我该选用哪个操作符? - 创建操作符&lt;/h1&gt;&lt;p&gt;使用此页面查找&lt;a href=&quot;https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/index.html&quot;&gt;&lt;code&gt;Observable&lt;/code&gt;&lt;/a&gt;符合您需求的类型创建操作：
    
    </summary>
    
      <category term="RXJS" scheme="http://robin-front.github.io/categories/RXJS/"/>
    
    
      <category term="RXJS" scheme="http://robin-front.github.io/tags/RXJS/"/>
    
  </entry>
  
  <entry>
    <title>RXJS我该选用哪个操作符之-实例操作符篇</title>
    <link href="http://robin-front.github.io/2017/06/01/RXJS%E6%88%91%E8%AF%A5%E9%80%89%E7%94%A8%E5%93%AA%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8B-%E5%AE%9E%E4%BE%8B%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%AF%87/"/>
    <id>http://robin-front.github.io/2017/06/01/RXJS我该选用哪个操作符之-实例操作符篇/</id>
    <published>2017-06-01T09:54:53.000Z</published>
    <updated>2017-06-01T09:54:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>RXJS比较强大，操作符众多，想熟悉需要比较长时间的运用，所以大部分新手都比较疑惑应该使用哪些操作符去实现自己的数据流的操作。</p>
<p>更多详情请翻阅 <a href="https://robin-front.github.io/RxJS-doc-chinese">RXJS中文翻译文档</a></p>
<h1 id="我该选用哪个操作符-实例操作符"><a href="#我该选用哪个操作符-实例操作符" class="headerlink" title="我该选用哪个操作符? - 实例操作符"></a>我该选用哪个操作符? - 实例操作符</h1><p>使用此页面通过类型查找<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md" target="_blank" rel="external"><code>Observable</code></a> 适合您需要的实例运算符：
<a id="more"></a></p>
<table style="display: table">
<thead>实例操作符</thead>
<tbody>
    <!-- Observable operators -->
    <tr>
        <td rowspan="71">使用现有的序列</td>
        <td colspan="3">我想改变每个值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/select.html">map/select</a></td>
    </tr>
    <tr>
        <td colspan="3">我想从每个值拉一个属性</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/pluck.html">pluck</a></td>
    </tr>
    <tr>
        <td colspan="3">我想在不影响值的情况下被通知值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/do.html">do/tap</a><br>
            <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/doonnext.html">doOnNext/tapOnNext</a><br>
            <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/doonerror.html">doOnError/tapOnError</a><br>
            <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/dooncompleted.html">doOnCompleted/tapOnCompleted</a></td>
    </tr>
    <tr>
        <td rowspan="6">我想包含值</td>
        <td colspan="2">基于自定义逻辑</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/where.html">filter/where</a></td>
    </tr>
    <tr>
        <td rowspan="2">从序列开头</td>
        <td></td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/take.html">take</a></td>
    </tr>
    <tr>
        <td>基于自定义逻辑</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/takewhile.html">takeWhile</a></td>
    </tr>
    <tr>
    </tr>
    <tr>
        <td colspan="2">从序列的末尾</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/takelast.html">takeLast</a></td>
    </tr>
    <tr>
        <td colspan="2">直到另一个序列发射一个值或完成</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/takeuntil.html">takeUntil</a></td>
    </tr>
    <tr>
        <td rowspan="7">我想忽略值</td>
        <td colspan="2">全部</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/ignoreelements.html">ignoreElements</a></td>
    </tr>
    <tr>
        <td rowspan="2">从序列的开头</td>
        <td></td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/skip.html">skip</a></td>
    </tr>
    <tr>
        <td>基于自定义逻辑</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/skipwhile.html">skipWhile</a></td>
    </tr>
    <tr>
        <td colspan="2">从序列的末尾</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/skiplast.html">skipLast</a></td>
    </tr>
    <tr>
        <td colspan="2">直到另一个序列发出一个值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/skipuntil.html">skipUntil</a></td>
    </tr>
    <tr>
        <td colspan="2">与以前的值相同</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/distinctuntilchanged.html">distinctUntilChanged</a></td>
    </tr>
    <tr>
        <td colspan="2">这（触发）太频繁</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/throttle.html">throttle</a></td>
    </tr>
    <tr>
        <td rowspan="4">我想计算</td>
        <td>总和</td>
        <td rowspan="2">这些值的</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/sum.html">sum</a></td>
    </tr>
    <tr>
        <td>平均值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/average.html">average</a></td>
    </tr>
    <tr>
        <td rowspan="2">使用自定义逻辑</td>
        <td>并且只输出最终值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/aggregate.html">aggregate</a><br>
            <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/reduce.html">reduce</a>
        </td>
    </tr>
    <tr>
        <td>并在计算出值时输出（每一步的）值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/scan.html">scan</a></td>
    </tr>
    <tr>
        <td rowspan="3">我想用元数据包装它的消息</td>
        <td colspan="2">描述每个消息</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/materialize.html">materialize</a></td>
    </tr>
    <tr>
        <td colspan="2">包括从最后一个价值以来的时间</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/timeinterval.html">timeInterval</a></td>
    </tr>
    <tr>
        <td colspan="2">包括时间戳</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/timestamp.html">timestamp</a></td>
    </tr>
    <tr>
        <td rowspan="2">经过一段时间的不活动</td>
        <td colspan="2">我想抛出一个错误</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/timeout.html">timeout</a></td>
    </tr>
    <tr>
        <td colspan="2">我想切换到另一个序列</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/timeout.html">timeout</a></td>
    </tr>
    <tr>
        <td rowspan="2">我想确保只有一个值</td>
        <td colspan="2">并且如果存在多于或少于一个值则抛出错误</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/single.html">single</a></td>
    </tr>
    <tr>
        <td colspan="2">并且如果没有值，则使用默认值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/singleordefault.html">singleOrDefault</a></td>
    </tr>
    <tr>
        <td rowspan="3">我只想取第一个值</td>
        <td colspan="2">并且如果没有值，则抛出错误</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/first.html">first</a></td>
    </tr>
    <tr>
        <td colspan="2">并且如果没有值，则使用默认值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/firstordefault.html">firstOrDefault</a></td>
    </tr>
    <tr>
        <td colspan="2">在一段时间内</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/sample.html">sample</a></td>
    </tr>
    <tr>
        <td rowspan="2">我只想取最后的值</td>
        <td colspan="2">如果没有值，则报错</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/last.html">last</a></td>
    </tr>
    <tr>
        <td colspan="2">并且如果没有值，则使用默认值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/lastordefault.html">lastOrDefault</a></td>
    </tr>
    <tr>
        <td colspan="3">我想知道它包含多少值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/count.html">count</a></td>
    </tr>
    <tr>
        <td colspan="3">我想知道它是否包含一个指定的值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/includes.html">contains</a></td>
    </tr>
    <tr>
        <td rowspan="2">我想知道条件是否满足</td>
        <td colspan="2">只需要任一值满足</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/any.html">any/some</a></td>
    </tr>
    <tr>
        <td colspan="2">需要所有值都满足</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/every.html">all/every</a></td>
    </tr>
    <tr>
        <td rowspan="2" colspan="2">我想把消息延迟一段特定的时间</td>
        <td></td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/delay.html">delay</a></td>
    </tr>
    <tr>
        <td>基于自定义逻辑</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/delaywithselector.html">delayWithSelector</a></td>
    </tr>
    <tr>
        <td rowspan="11">我想给值分组</td>
        <td colspan="2">直到序列完成</td>
        <td>
          <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/toarray.html">toArray</a><br>
          <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/tomap.html">toMap</a><br>
          <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/toset.html">toSet</a>
        </td>
    </tr>
    <tr>
        <td rowspan="2">使用自定义逻辑</td>
        <td>作为数组</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/buffer.html">buffer</a></td>
    </tr>
    <tr>
        <td>作为序列</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/window.html">window</a></td>
    </tr>
    <tr>
        <td rowspan="2">根据特定大小分批</td>
        <td>作为数组</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/bufferwithcount.html">bufferWithCount</a></td>
    </tr>
    <tr>
        <td>作为序列</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/windowwithcount.html">windowWithCount</a></td>
    </tr>
    <tr>
        <td rowspan="2">基于时间</td>
        <td>作为数组</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/bufferwithtime.html">bufferWithTime</a></td>
    </tr>
    <tr>
        <td>作为序列</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/windowwithtime.html">windowWithTime</a></td>
    </tr>
    <tr>
        <td rowspan="2">基于时间或计数，以先发生者为准</td>
        <td>作为数组</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/bufferwithtimeorcount.html">bufferWithTimeOrCount</a></td>
    </tr>
    <tr>
        <td>作为序列</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/windowwithtimeorcount.html">windowWithTimeOrCount</a></td>
    </tr>
    <tr>
        <td rowspan="2">基于一个指定的key</td>
        <td>直到序列完成</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/groupby.html">groupBy</a></td>
    </tr>
    <tr>
        <td>并控制每组的生命周期</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/groupbyuntil.html">groupByUntil</a></td>
    </tr>
    <tr>
        <td rowspan="6">我想为每个值开始一个新的序列</td>
        <td colspan="2">并且并行地从所有序列中发出值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/selectmany.html">flatMap/selectMany</a></td>
    </tr>
    <tr>
        <td colspan="2">并按顺序从每个序列中输出值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/concatmap.html">concatMap/selectConcat</a></td>
    </tr>
    <tr>
        <td colspan="2">并在新值到达时取消先前的序列</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/flatmaplatest.html">flatMapLatest/selectSwitch</a></td>
    </tr>
    <tr>
        <td colspan="2">并递归地为每个新值启动一个新的序列</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/expand.html">expand</a></td>
    </tr>
    <tr>
        <td colspan="2">并根据onNext，onError和onCompleted并行地从所有序列发出值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/flatmapobserver.html">flatMapObserver/selectManyObserver</a></td>
    </tr>
    <tr>
        <td colspan="2">并根据onNext，onError和onCompleted顺序地从所有序列发出值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/flatmapobserver.html">concatMapObserver/selectConcatObserver</a></td>
    </tr>
    <tr>
        <td>我想把它与另一个结合起来</td>
        <td colspan="2">两者都完成时发出通知</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/forkjoin.html">forkJoin</a></td>
    </tr>
    <tr>
        <td colspan="3">我想执行复杂的操作，而不会打破流畅的调用</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/let.html">let</a></td>
    </tr>
    <tr>
        <td rowspan="5">我想在多个订阅者之间共享订阅</td>
        <td colspan="2">使用特定的<code>subject</code>实现</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/multicast.html">multicast</a></td>
    </tr>
    <tr>
        <td colspan="2"></td>
        <td>
          <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/publish.html">publish</a><br>
          <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/share.html">share</a>
        </td>
    </tr>
    <tr>
        <td colspan="2">并向未来订阅者提供最后的值</td>
        <td>
          <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/publishlast.html">publishLast</a><br>
          <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/sharelast.html">shareLast</a>
        </td>
    </tr>
    <tr>
        <td colspan="2">并向未来订阅者重播默认值或最新值</td>
        <td>
          <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/publishvalue.html">publishValue</a><br>
          <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/sharevalue.html">shareValue</a>
        </td>
    </tr>
    <tr>
        <td colspan="2">并向未来的订阅者重播n个值</td>
        <td>
          <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/publish.html">replay</a><br>
          <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/share.html">shareReplay</a>
        </td>
    </tr>
    <tr>
        <td rowspan="3">发生错误时</td>
        <td colspan="2">我想重新订阅</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/retry.html">retry</a></td>
    </tr>
    <tr>
        <td rowspan="2">我想开始一个新序列</td>
        <td></td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/catch.html">catch</a></td>
    </tr>
    <tr>
        <td>取决于错误</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/catch.html">catch</a></td>
    </tr>
    <tr>
        <td rowspan="2">当完成时</td>
        <td colspan="2">我想重新订阅</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/repeat.html">repeat</a></td>
    </tr>
    <tr>
        <td colspan="2">我想开始一个新序列</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/concat.html">concat</a></td>
    </tr>
    <tr>
        <td>当完成或抛出错误时</td>
        <td colspan="2">我想开始一个新序列</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/onerrorresumenext.html">onErrorResumeNext</a></td>
    </tr>
    <tr>
        <td>当完成，抛出错误或退订时</td>
        <td colspan="2">我想执行一个函数</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/finally.html">finally</a></td>
    </tr>
    <tr>
        <td rowspan="2">我想改变路由的调度程序</td>
        <td colspan="2">调用<code>subscribe</code>（订阅）</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/subscribeon.html">subscribeOn</a></td>
    </tr>
    <tr>
        <td colspan="2">消息</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/observeon.html">observeOn</a></td>
    </tr>
    <tr>
        <td rowspan="9">使用两个序列</td>
        <td>我想决定从哪个接收值</td>
        <td colspan="2">取决于哪个序列先发出值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/amb.html">amb</a></td>
    </tr>
    <tr>
        <td colspan="3">我想确定它们的值是否相等</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/sequenceequal.html">sequenceEqual</a></td>
    </tr>
    <tr>
        <td rowspan="5">我想合并它们的值</td>
        <td colspan="2">只有当第一个序列发射时，使用每个序列的最新值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/withlatestfrom.html">withLatestFrom</a></td>
    </tr>
    <tr>
        <td rowspan="2">为了</td>
        <td>不改变时重复使用最新值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/combinelatest.html">combineLatest</a></td>
    </tr>
    <tr>
        <td>每个值只使用一次</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/zip.html">zip</a></td>
    </tr>
    <tr>
        <td rowspan="2">重复分享我选择的“生命周期”</td>
        <td>并通知每个组合</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/join.html">join</a></td>
    </tr>
    <tr>
        <td>并给每个“左”的序列的值给“右”的序列</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/groupjoin.html">groupJoin</a></td>
    </tr>
    <tr>
        <td colspan="3">我想包含两者的值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/merge.html">merge</a></td>
    </tr>
</tbody></table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RXJS比较强大，操作符众多，想熟悉需要比较长时间的运用，所以大部分新手都比较疑惑应该使用哪些操作符去实现自己的数据流的操作。&lt;/p&gt;
&lt;p&gt;更多详情请翻阅 &lt;a href=&quot;https://robin-front.github.io/RxJS-doc-chinese&quot;&gt;RXJS中文翻译文档&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;我该选用哪个操作符-实例操作符&quot;&gt;&lt;a href=&quot;#我该选用哪个操作符-实例操作符&quot; class=&quot;headerlink&quot; title=&quot;我该选用哪个操作符? - 实例操作符&quot;&gt;&lt;/a&gt;我该选用哪个操作符? - 实例操作符&lt;/h1&gt;&lt;p&gt;使用此页面通过类型查找&lt;a href=&quot;https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;Observable&lt;/code&gt;&lt;/a&gt; 适合您需要的实例运算符：
    
    </summary>
    
      <category term="RXJS" scheme="http://robin-front.github.io/categories/RXJS/"/>
    
    
      <category term="RXJS" scheme="http://robin-front.github.io/tags/RXJS/"/>
    
  </entry>
  
  <entry>
    <title>Marko和react,preact,vue相比快在哪里</title>
    <link href="http://robin-front.github.io/2017/06/01/Marko%E5%92%8Creact-preact-vue%E7%9B%B8%E6%AF%94%E5%BF%AB%E5%9C%A8%E5%93%AA%E9%87%8C/"/>
    <id>http://robin-front.github.io/2017/06/01/Marko和react-preact-vue相比快在哪里/</id>
    <published>2017-06-01T02:48:00.000Z</published>
    <updated>2017-06-01T02:48:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://hackernoon.com/why-is-marko-fast-a20796cb8ae3" target="_blank" rel="external">译文：why-is-marko-fast</a></p>
<p>在eBay，我们正在使用<code>[Marko](http://markojs.com/)</code>每天处理超过十亿的请求，这就要求我们精简我们的开源UI库Marko。我们大大优化了Marko ，以实现快速渲染，<a href="http://www.ebaytechblog.com/2014/12/08/async-fragments-rediscovering-progressive-html-rendering-with-marko/" target="_blank" rel="external">高级性能技术</a>，并实现了最小的页面重量（〜10kb gzipped）。性能只是一个方面，因为我们还必须扩展Marko以支持数百个团队的开发，从而允许开发人员有效地创建可维护和强大的Web应用程序。</p>
<p>我们已经创建了我们自己的<a href="https://github.com/marko-js/isomorphic-ui-benchmarks" target="_blank" rel="external">benchMarks</a>进行比较，也已经将Marko添加到<a href="https://github.com/raxjs/server-side-rendering-comparison/pull/11" target="_blank" rel="external">其他基准测试</a>中，但是基准测试并不总是值得信赖的。尽管我们尽可能公平地对待我们的基准，但最重要的是在现实世界的应用中的表现，而不是专注于微观基准。这就是V8团队转而采用新的方法来衡量和理解现实JavaScript性能的一个原因。</p>
<p>同样，我们已经观察过我们的开发人员实际开发中如何编写他们的Marko组件，并且发现了可以进一步优化的模式。而不是关注本文中的基准测试，我想关注我们应用于Marko的优化细节。
<a id="more"></a></p>
<h2 id="多个编译输出"><a href="#多个编译输出" class="headerlink" title="多个编译输出"></a>多个编译输出</h2><p>Marko是一个在服务器和浏览器中运行的同构UI库。正如<a href="https://medium.com/@mlrawlings" target="_blank" rel="external">Michael Rawlings</a>在“ <a href="https://hackernoon.com/server-side-rendering-shootout-with-marko-preact-rax-react-and-vue-25e1ae17800f" target="_blank" rel="external">服务器端渲染染</a> ”中提到的，当在服务器上呈现时，Marko直接呈现可以作为HTTP响应发送的文档（HTML）的字符串表示形式。</p>
<p>在浏览器中呈现时，必须解析HTML字符串才能更新DOM。因此，Marko通过程序将视图编译为直接呈现到虚拟文档（VDOM）树，这可以针对浏览器有效地更新真实的DOM。</p>
<p>给出以下模板：</p>
<p><a href="https://gist.github.com/anonymous/5ccdaadcb42dc0f5a4b2e6a956111562/raw/fa23a13e458bf8bb79dfbdc659f1248c012a799a/template.marko" target="_blank" rel="external"></a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;Hello $&#123;input.name&#125;!<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div></pre></td></tr></table></figure>
<h3 id="编译为服务器"><a href="#编译为服务器" class="headerlink" title="编译为服务器"></a>编译为服务器</h3><p>编译输出针对服务器上的HTML输出进行了优化：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> marko_template = <span class="built_in">require</span>(<span class="string">"marko/html"</span>).t(__filename),</div><div class="line">    marko_helpers = <span class="built_in">require</span>(<span class="string">"marko/runtime/html/helpers"</span>),</div><div class="line">    marko_escapeXml = marko_helpers.x;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">input, out</span>) </span>&#123;</div><div class="line">  out.w(<span class="string">"&lt;div&gt;Hello "</span> +</div><div class="line">    marko_escapeXml(input.name) +</div><div class="line">    <span class="string">"!&lt;/div&gt;"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="编译为浏览器"><a href="#编译为浏览器" class="headerlink" title="编译为浏览器"></a>编译为浏览器</h3><p>编译输出针对浏览器中的虚拟DOM渲染进行了优化：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> marko_template = <span class="built_in">require</span>(<span class="string">"marko/vdom"</span>).t(__filename);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">input, out</span>) </span>&#123;</div><div class="line">  out.e(<span class="string">"DIV"</span>, <span class="literal">null</span>, <span class="number">3</span>)</div><div class="line">    .t(<span class="string">"Hello "</span>)</div><div class="line">    .t(input.name)</div><div class="line">    .t(<span class="string">"!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="模块化运行时"><a href="#模块化运行时" class="headerlink" title="模块化运行时"></a>模块化运行时</h3><p>Marko运行时并不作为单个JavaScript文件分发。相反，Marko编译器会生成一个JavaScript模块，该模块仅导入实际需要的运行时部分。这允许我们向Marko添加新功能，而不会使现有应用程序膨胀。例如，给出以下模板：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">var</span> color = <span class="string">'red'</span>;</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;backgroundColor:</span> <span class="attr">color</span>&#125;&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>在上面的示例中，需要额外的运行时代码来根据所提供<code>style</code>的JavaScript对象呈现属性。导入<code>styleAttr</code>助手的编译代码如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> marko_styleAttr = <span class="built_in">require</span>(<span class="string">"marko/runtime/vdom/helper-styleAttr"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">input, out</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> color = <span class="string">'red'</span>;</div><div class="line">  out.e(<span class="string">"DIV"</span>, &#123;</div><div class="line">      <span class="attr">style</span>: marko_styleAttr(&#123;</div><div class="line">          <span class="attr">backgroundColor</span>: color</div><div class="line">        &#125;)</div><div class="line">    &#125;, <span class="number">0</span>, <span class="number">4</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="高性能的服务器端渲染"><a href="#高性能的服务器端渲染" class="headerlink" title="高性能的服务器端渲染"></a>高性能的服务器端渲染</h3><p>与基于专门进行虚拟DOM渲染的JSX的解决方案相比，Marko在服务器端渲染方面具有巨大的优势。当渲染到服务器上的虚拟DOM树时，它是一个两步的过程来呈现HTML：</p>
<ul>
<li>首先在内存中生成一个完整的虚拟DOM树</li>
<li>第二遍将虚拟DOM树序列化为可以通过线路发送的HTML字符串（这需要遍历整个树结构）</li>
</ul>
<p>相比之下，Marko直接一次性渲染一整个HTML流。没有中间树数据结构。</p>
<h3 id="静态子树的编译时优化"><a href="#静态子树的编译时优化" class="headerlink" title="静态子树的编译时优化"></a>静态子树的编译时优化</h3><p>给出以下模板：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;This is a &lt;strong&gt;<span class="keyword">static</span>&lt;<span class="regexp">/strong&gt; node&lt;/</span>div&gt;</div></pre></td></tr></table></figure>
<p>Marko将会认识到，模板片段每次都会产生相同的输出，因此会像以下编译输出一样创建一个虚拟DOM节点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> marko_node0 = marko_createElement(<span class="string">"DIV"</span>, <span class="literal">null</span>, <span class="number">3</span>, ...)</div><div class="line">  .t(<span class="string">"This is a "</span>)</div><div class="line">  .e(<span class="string">"STRONG"</span>, <span class="literal">null</span>, <span class="number">1</span>)</div><div class="line">    .t(<span class="string">"static"</span>)</div><div class="line">  .t(<span class="string">" node"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">input, out</span>) </span>&#123;</div><div class="line">  out.n(marko_node0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>渲染静态子树几乎是零成本。此外，Marko将跳过对比/修补静态子树。</p>
<p>同样，在服务器上，Marko会将模板的静态部分合并成一个字符串：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">input, out</span>) </span>&#123;</div><div class="line">  out.w(<span class="string">"&lt;div&gt;This is a &lt;strong&gt;static&lt;/strong&gt; node&lt;/div&gt;"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="静态属性的编译时优化"><a href="#静态属性的编译时优化" class="headerlink" title="静态属性的编译时优化"></a>静态属性的编译时优化</h3><p>Marko还将优化动态元素的静态属性。</p>
<p>给出以下模板：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div.hello&gt;Hello $&#123;input.name&#125;!<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>Marko将产生以下编译输出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> marko_attrs0 = &#123;</div><div class="line">        <span class="string">"class"</span>: <span class="string">"hello"</span></div><div class="line">      &#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">input, out</span>) </span>&#123;</div><div class="line">  out.e(<span class="string">"DIV"</span>, marko_attrs0, <span class="number">3</span>)</div><div class="line">    .t(<span class="string">"Hello "</span>)</div><div class="line">    .t(input.name)</div><div class="line">    .t(<span class="string">"!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>请注意，属性对象只创建一次，它用于每个渲染。另外，静态属性不会发生 <code>diffing</code>/<code>patching</code>。</p>
<h3 id="智能编译器"><a href="#智能编译器" class="headerlink" title="智能编译器"></a>智能编译器</h3><p>使用Marko，我们倾向于在编译时尽可能多地执行。这使我们的编译器更加复杂，但它在运行时给我们带来了很大的收获。我们有〜90％的代码覆盖率和超过2000个测试，以确保编译器正常工作。此外，在许多情况下，Marko编译器为给定的模板提供运行时提示，以便运行时可以针对特定模式进行优化。例如，识别的Marko如果HTML元素仅具有<code>class</code>/<code>id</code>/<code>style</code>定义和做版本比较时/修补运行时优化了这些虚拟DOM节点（Marko编译器生成的代码，标记简单的虚拟DOM节点用于针对 <code>diffing</code>/<code>patching</code> 逻辑）。</p>
<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>如果你正在建立一个UI组件，您将很可能需要编写代码来处理不同的DOM事件（<code>click</code>，<code>submit</code>，等）。开发人员常常编写使用<code>el.addEventListener(...)</code>或使用诸如jQuery的库来添加DOM事件监听器的代码。当您使用Marko构建UI组件时，您仍然可以执行此操作，但是在初始化大量组件时，在附加侦听器时会出现开销。相反，Marko建议使用声明式事件绑定，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;button type=<span class="string">"button"</span> on-click(<span class="string">"handleClick"</span>)&gt;</div><div class="line">  Click Me</div><div class="line">&lt;<span class="regexp">/button&gt;</span></div></pre></td></tr></table></figure>
<p>当使用声明性事件绑定时，事实上没有附加任何DOM事件侦听器。相反，Marko会为每个DOM事件（在启动时完成）为页面的根DOM元素附加一个监听器。当Marko在根节点处收到事件时，它将把事件委托给该事件的相应组件。这是通过查看<code>event.target</code>属性来查看事件发生的位置，然后向上遍历树来查找需要通知的组件。因此，当根目录捕获DOM事件时，会做更多的工作，但这种方法使用的内存少得多，并减少了初始化时需要完成的。将事件委派给组件的额外开销并不明显，因此这是一个非常有益的优化。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://hackernoon.com/why-is-marko-fast-a20796cb8ae3&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;译文：why-is-marko-fast&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在eBay，我们正在使用&lt;code&gt;[Marko](http://markojs.com/)&lt;/code&gt;每天处理超过十亿的请求，这就要求我们精简我们的开源UI库Marko。我们大大优化了Marko ，以实现快速渲染，&lt;a href=&quot;http://www.ebaytechblog.com/2014/12/08/async-fragments-rediscovering-progressive-html-rendering-with-marko/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;高级性能技术&lt;/a&gt;，并实现了最小的页面重量（〜10kb gzipped）。性能只是一个方面，因为我们还必须扩展Marko以支持数百个团队的开发，从而允许开发人员有效地创建可维护和强大的Web应用程序。&lt;/p&gt;
&lt;p&gt;我们已经创建了我们自己的&lt;a href=&quot;https://github.com/marko-js/isomorphic-ui-benchmarks&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;benchMarks&lt;/a&gt;进行比较，也已经将Marko添加到&lt;a href=&quot;https://github.com/raxjs/server-side-rendering-comparison/pull/11&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;其他基准测试&lt;/a&gt;中，但是基准测试并不总是值得信赖的。尽管我们尽可能公平地对待我们的基准，但最重要的是在现实世界的应用中的表现，而不是专注于微观基准。这就是V8团队转而采用新的方法来衡量和理解现实JavaScript性能的一个原因。&lt;/p&gt;
&lt;p&gt;同样，我们已经观察过我们的开发人员实际开发中如何编写他们的Marko组件，并且发现了可以进一步优化的模式。而不是关注本文中的基准测试，我想关注我们应用于Marko的优化细节。
    
    </summary>
    
      <category term="Marko" scheme="http://robin-front.github.io/categories/Marko/"/>
    
    
      <category term="Marko" scheme="http://robin-front.github.io/tags/Marko/"/>
    
  </entry>
  
  <entry>
    <title>npm@5发布有哪些改进</title>
    <link href="http://robin-front.github.io/2017/06/01/npm-5%E5%8F%91%E5%B8%83%E6%9C%89%E5%93%AA%E4%BA%9B%E6%94%B9%E8%BF%9B/"/>
    <id>http://robin-front.github.io/2017/06/01/npm-5发布有哪些改进/</id>
    <published>2017-06-01T02:15:45.000Z</published>
    <updated>2017-06-01T02:15:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn-images-1.medium.com/max/800/1*9nI6dL1Z-8cqFpCX96zVFA.gif" alt="npm@5 is now latest"></p>
<p>从今天开始，如果您输入“<code>npm install npm@latest -g</code>”，那么您将被更新为npm版本5。另外，在所有<a href="https://medium.com/@nodejs/node-js-8-big-improvements-for-the-debugging-and-native-module-ecosystem-58454861f2fc" target="_blank" rel="external">Node.js 8</a>的新安装中都捆绑了<code>npm@5</code> ，它已经替代了<code>Node.js 7</code>在Node Project的当前版本中。</p>
<p>在过去一年半的时间里，我们一直在努力解决大量的痛点，其中有些是创建npm以来就已经存在的。今天的发布是对npm速度，一致性和用户体验的最大改进。</p>
<p>发布说明中有什么新内容和更改内容的明确列表，但这里有一些亮点：
<a id="more"></a></p>
<h2 id="速度很快"><a href="#速度很快" class="headerlink" title="速度很快"></a>速度很快</h2><p>重新编排了包元数据，软件包下载和软件包缓存，这大大加快了工作。一般来说，期望性能提升20-100％; 我们还看到一些安装和版本冲突的运行速度提高了5倍。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/0*K1Wb1ERhtAHLRG0m." alt="speed improvements in npm@5"></p>
<p>由于npm最初的设计，开发人员已经改变了他们如何使用npm。npm生态系统不仅呈指数级增长，而且从2014年起，平均npm软件包中的依赖关系数量增加了250％。现在，更多的开发人员现在可以在本地安装Babel，Webpack和Tap等有用工具，而不是全局。这是一个最佳实践，但这意味着“<code>npm install</code>”可以做更多的工作。</p>
<p>鉴于我们社区的规模，任何速度上升都会为数百万用户带来巨大的节省，更不用说我们的所有组织和npm企业客户。使npm @ 5变快成为一个很显然的目标。</p>
<h2 id="目标一致"><a href="#目标一致" class="headerlink" title="目标一致"></a>目标一致</h2><h3 id="默认锁文件"><a href="#默认锁文件" class="headerlink" title="默认锁文件"></a>默认锁文件</h3><p><code>Shrinkwrap</code>很早就已经是npm的一部分，但<code>npm@5</code>使<code>lockfiles</code>成为默认，所以所有的npm安装现在都是可重现的。在安装给定版本的软件包时，每次安装它您获得的文件将是相同的。</p>
<p>我们发现无数常见且耗时的问题可能与不同开发人员环境利用不同软件包版本时发生的“漂移”相关。使用默认锁文件，这不再是问题。你不会浪费时间，试图找出一个错误，只是为了了解它来自运行不同版本的图书馆的人。</p>
<h3 id="SHA-512哈希"><a href="#SHA-512哈希" class="headerlink" title="SHA-512哈希"></a>SHA-512哈希</h3><p><code>npm@5</code>增加了对<code>Node.js</code>支持的任何tarball Hash功能的支持，并以SHA-512 hash发布。通过检查所有下载的软件包，您可以防止数据损坏和恶意攻击，并且您可以相信您从npm下载的代码是一致和安全的。</p>
<h3 id="自愈缓存"><a href="#自愈缓存" class="headerlink" title="自愈缓存"></a>自愈缓存</h3><p>我们的新缓存很容易损坏，但也更具弹性。多个npm进程不会破坏共享缓存，<code>npm@5</code>将检查插入和提取的数据，以防止安装损坏的数据。如果缓存项失败完整性检查，<code>npm@5</code>将自动删除它并重新获取。</p>
<h3 id="更易使用"><a href="#更易使用" class="headerlink" title="更易使用"></a>更易使用</h3><p>根据您的反馈，我们通过<code>npm @ 5</code>中的优化改进了用户体验。其中很大一部分是输出更多的有用的提示信息。最好的例子是，npm不再显示<code>package</code>上的整个树; 相反，您将看到有关安装内容的摘要报告。由于平均每个<code>package</code>中的依赖关系较大，因此我们进行了此更改。逐个文件读出结果是超过一定数量就会显得非常笨重。</p>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>有一个项目使用 <code>benchmark</code> 比较了 <code>yarn</code>, <code>pnpm</code>, <code>npm</code> 的效率, <a href="https://github.com/JamieMason/npm-cache-benchmark" target="_blank" rel="external">传送门</a></p>
<p>下面是比较结果：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Installer</th>
<th style="text-align:right">Average over 5 runs</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">yarn –offline</td>
<td style="text-align:right">5.88</td>
</tr>
<tr>
<td style="text-align:left">pnpm –offline</td>
<td style="text-align:right">6.72</td>
</tr>
<tr>
<td style="text-align:left">pnpm (cached)</td>
<td style="text-align:right">6.86</td>
</tr>
<tr>
<td style="text-align:left">npm 5.x (shrinkpacked, compressed)</td>
<td style="text-align:right">8.35</td>
</tr>
<tr>
<td style="text-align:left">npm 5.x (shrinkpacked)</td>
<td style="text-align:right">8.94</td>
</tr>
<tr>
<td style="text-align:left">npm 5.x (cached)</td>
<td style="text-align:right">11.36</td>
</tr>
<tr>
<td style="text-align:left">npm 4.x (cached)</td>
<td style="text-align:right">13.47</td>
</tr>
<tr>
<td style="text-align:left">yarn</td>
<td style="text-align:right">13.71</td>
</tr>
<tr>
<td style="text-align:left">npm 5.x</td>
<td style="text-align:right">14.93</td>
</tr>
<tr>
<td style="text-align:left">pnpm</td>
<td style="text-align:right">17.57</td>
</tr>
<tr>
<td style="text-align:left">npm 4.x (shrinkpacked, compressed)</td>
<td style="text-align:right">18.73</td>
</tr>
<tr>
<td style="text-align:left">npm 4.x (shrinkpacked)</td>
<td style="text-align:right">18.78</td>
</tr>
<tr>
<td style="text-align:left">npm 4.x</td>
<td style="text-align:right">29.73</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*9nI6dL1Z-8cqFpCX96zVFA.gif&quot; alt=&quot;npm@5 is now latest&quot;&gt;&lt;/p&gt;
&lt;p&gt;从今天开始，如果您输入“&lt;code&gt;npm install npm@latest -g&lt;/code&gt;”，那么您将被更新为npm版本5。另外，在所有&lt;a href=&quot;https://medium.com/@nodejs/node-js-8-big-improvements-for-the-debugging-and-native-module-ecosystem-58454861f2fc&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Node.js 8&lt;/a&gt;的新安装中都捆绑了&lt;code&gt;npm@5&lt;/code&gt; ，它已经替代了&lt;code&gt;Node.js 7&lt;/code&gt;在Node Project的当前版本中。&lt;/p&gt;
&lt;p&gt;在过去一年半的时间里，我们一直在努力解决大量的痛点，其中有些是创建npm以来就已经存在的。今天的发布是对npm速度，一致性和用户体验的最大改进。&lt;/p&gt;
&lt;p&gt;发布说明中有什么新内容和更改内容的明确列表，但这里有一些亮点：
    
    </summary>
    
      <category term="npm" scheme="http://robin-front.github.io/categories/npm/"/>
    
    
      <category term="npm" scheme="http://robin-front.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>JSX是什么鬼(WTF is JSX)</title>
    <link href="http://robin-front.github.io/2017/05/30/JSX%E6%98%AF%E4%BB%80%E4%B9%88%E9%AC%BC/"/>
    <id>http://robin-front.github.io/2017/05/30/JSX是什么鬼/</id>
    <published>2017-05-30T01:52:45.000Z</published>
    <updated>2017-05-30T01:52:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>JSX实际上很简单：只需要花1分钟阅读这个，你会明白有关这个有趣的替代模板的一切。
<a id="more"></a></p>
<p>替换标题：“融入JSX”</p>
<h2 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h2><p>您可以声明每个文件或每个函数来告诉您的<code>transpiler</code>（例如：<code>Babel</code>）每个节点在运行时应调用的函数的名称（请参阅“<a href="https://jasonformat.com/wtf-is-jsx/#Transpilation" target="_blank" rel="external">Transpilation</a>”）。</p>
<p>在下面的例子中，我们说的是“ <code>h()</code>为每个节点注入一个函数”：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** @jsx h */</span></div></pre></td></tr></table></figure>
<h2 id="Transpilation"><a href="#Transpilation" class="headerlink" title="Transpilation"></a>Transpilation</h2><p>如果你还没有使用解析器，你应该是尝试一下。使用ES6 / ES2015 编写，调试，测试和运行JavaScript时更为高效。<code>Babel</code>是最受欢迎和推荐的透析器，所以我会假设你正在使用它。</p>
<p>除了将ES6 / ES7 +语法转换为 ES5 以外，Babel还包括对JSX 开箱即用的转换支持。您不需要添加或更改任何内容以使用此功能。</p>
<p>通过查看一个非常简单的例子来了解它的工作原理是最简单的：</p>
<p><em>转换前</em> :( 你写的代码）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** @jsx h */</span></div><div class="line"><span class="keyword">let</span> foo = <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"foo"</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div></pre></td></tr></table></figure>
<p><em>转换后</em> :(你运行的代码）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = h(<span class="string">'div'</span>, &#123;<span class="attr">id</span>:<span class="string">"foo"</span>&#125;, <span class="string">'Hello!'</span>);</div></pre></td></tr></table></figure>
<p>你可能看第二个代码片段的时候，认为使用函数构建UI不会那么糟糕</p>
<p>这就是为什么我坐上了 <code>JSX</code> 的车：如果它从地球上消失了，用手写的输出依然会很舒服。</p>
<blockquote>
<p>JSX只是一种已经相当不错的语法的糖。</p>
</blockquote>
<p>人们甚至把它用于整个项目：<a href="https://github.com/dominictarr/hyperscript" target="_blank" rel="external">hyperscript</a></p>
<h2 id="我们来构建一个JSX渲染器"><a href="#我们来构建一个JSX渲染器" class="headerlink" title="我们来构建一个JSX渲染器"></a>我们来构建一个JSX渲染器</h2><p>首先，我们需要定义转换代码后调用的 <code>h()</code> 函数。</p>
<p>你调用任何你想要的，我使用<code>h()</code>，因为这种类型的“构建器”功能的原始想法被称为hyperscript (“hyper<del>text</del>“ + “<del>java</del>script”).。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">nodeName, attributes, ...args</span>) </span>&#123;  </div><div class="line">      <span class="keyword">let</span> children = args.length ? [].concat(...args) : <span class="literal">null</span>;</div><div class="line">      <span class="keyword">return</span> &#123; nodeName, attributes, children &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好的，这看起来很简单（ps: 只处理了 children）</p>
<blockquote>
<p>不熟悉ES6 / ES2015？</p>
<ul>
<li>这…在参数列表是一个rest param。它将“其余”的参数收集到数组中。</li>
<li>该concat(…args)位是一个扩展运算符：它需要该数组并将其扩展为参数concat()。这里使用的concat()是将子节点推入数组。</li>
</ul>
</blockquote>
<p>现在我们有这些嵌套的JSON对象我们的<code>h()</code>函数吐出来，所以我们最终得到一个这样的“树”：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">nodeName</span>: <span class="string">"div"</span>,</div><div class="line">  <span class="attr">attributes</span>: &#123;</div><div class="line">    <span class="string">"id"</span>: <span class="string">"foo"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">children</span>: [<span class="string">"Hello!"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以我们只需要一个接受该格式并抛出实际DOM节点的函数：(即沉染vdom)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode</span>) </span>&#123;  </div><div class="line">    <span class="comment">// 字符串只转换成 文本节点：</span></div><div class="line">    <span class="keyword">if</span> (vnode.split) <span class="keyword">return</span> <span class="built_in">document</span>.createTextNode(vnode);</div><div class="line"></div><div class="line">    <span class="comment">// 使用 VDOM 的 nodeName 创建一个DOM 标签</span></div><div class="line">    <span class="keyword">let</span> n = <span class="built_in">document</span>.createElement(vnode.nodeName);</div><div class="line"></div><div class="line">    <span class="comment">// 拷贝所有属性到新节点上</span></div><div class="line">    <span class="keyword">let</span> a = vnode.attributes || &#123;&#125;;</div><div class="line">    <span class="built_in">Object</span>.keys(a).forEach( <span class="function"><span class="params">k</span> =&gt;</span> n.setAttribute(k, a[k]) );</div><div class="line"></div><div class="line">    <span class="comment">// 渲染并添加子节点</span></div><div class="line">    (vnode.children || []).forEach( <span class="function"><span class="params">c</span> =&gt;</span> n.appendChild(render(c)) );</div><div class="line"></div><div class="line">    <span class="keyword">return</span> n;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>：） 不难理解这是如何工作的。
如果有帮助，您可以将“虚拟DOM”视为一个非常简单的配置，用于构建给定的DOM结构。</p>
<blockquote>
<p>虚拟DOM的好处是它非常轻巧。小对象引用其他小对象，一个由易于优化的应用程序逻辑构成的结构。</p>
<p>这也意味着它不受任何渲染逻辑或缓慢的DOM方法的束缚。</p>
</blockquote>
<h2 id="使用JSX"><a href="#使用JSX" class="headerlink" title="使用JSX"></a>使用JSX</h2><p>我们知道<code>JSX</code>被转换成<code>h()</code>函数调用。
那些函数调用创建一个简单的“虚拟”DOM树。
我们可以使用该<code>render()</code>函数来制作一个匹配的“真实”DOM树。
这就是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// JSX -&gt; VDOM:</span></div><div class="line"><span class="keyword">let</span> vdom = <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"foo"</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// VDOM -&gt; DOM:</span></div><div class="line"><span class="keyword">let</span> dom = render(vdom);</div><div class="line"></div><div class="line"><span class="comment">// add the tree to &lt;body&gt;:</span></div><div class="line"><span class="built_in">document</span>.body.appendChild(dom);</div></pre></td></tr></table></figure>
<h4 id="Partials，迭代与逻辑：没有新的语法"><a href="#Partials，迭代与逻辑：没有新的语法" class="headerlink" title="Partials，迭代与逻辑：没有新的语法"></a>Partials，迭代与逻辑：没有新的语法</h4><blockquote>
<p>我们拥有所有的JavaScript语法，而不是模板语言引入的有限概念。（PS:这是JSX胜过模板语言的地方）</p>
</blockquote>
<p>“Partials”是由无逻辑/有限逻辑模板引擎引入的概念，用于在不同的上下文中重复使用视图块。</p>
<p>迭代似乎是每个新的模板语言都重新发明的东西（我和任何人一样有罪）。使用JSX，没有新的语法来学习：迭代您在JavaScript程序中的其他任何地方。您选择最适合给定任务迭代式的：<code>[].forEach()</code>，<code>[].map()</code>，<code>for</code>和<code>while</code>循环等</p>
<p>逻辑，像迭代，是模板语言喜欢重新发明的东西。一方面，无逻辑模板在将逻辑嵌入到视图方法非常弱：有限的结构，如<code>\{\{ \#if value}}</code>将逻辑推入控制器层，鼓励膨胀。这规避了构建语言来描述更复杂的逻辑，避免可预见性和安全隐患。</p>
<p>在另一方面，使用代码生成（一种从粗略到不可原谅的技术）的引擎通常具有执行逻辑或甚至迭代任意JavaScript表达式的能力。这是一个很好的理由，不惜一切代价避免这种情况：您的代码被从原始位置（也许是一个模块，闭包或标记内）中剥离出来，并对“别的地方”评估。这对我来说是不可预测的或足够安全的。</p>
<blockquote>
<p>JSX允许所有 JavaScript的语言功能，而不依赖于在构建步骤中生成奇怪的代码，没有eval()和扩展。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将数组中的字符串以列表的形式展示</span></div><div class="line"><span class="keyword">let</span> items = [<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>];</div><div class="line"></div><div class="line"><span class="comment">// 创建列表li</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">item</span>(<span class="params">text</span>) </span>&#123;  </div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;text&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 一个使用迭代和复用的视图</span></div><div class="line"><span class="keyword">let</span> list = render(  </div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></div><div class="line">    &#123; items.map(item) &#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">);</div></pre></td></tr></table></figure>
<p><code>render()</code>返回一个DOM节点（在上述情况下是返回<ul>列表），所以我们只需要把它放到DOM中：</ul></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.body.appendChild(list);</div></pre></td></tr></table></figure>
<h2 id="把它放在一起"><a href="#把它放在一起" class="headerlink" title="把它放在一起"></a>把它放在一起</h2><p>以下是小型虚拟DOM渲染器和使用它的视图的完整源码。
具有一些样式的CodePen可在下面获得。</p>
<blockquote>
<p>同样，我也写了一个例子：<a href="https://github.com/Robin-front/code-code-hut/tree/master/jsx" target="_blank" rel="external">在任何地方使用JSX渲染DOM</a></p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">const ITEMS = 'hello there people'.split(' ');</div><div class="line"></div><div class="line">// turn an Array into list items:</div><div class="line">let list = items =&gt; items.map( p =&gt; &lt;li&gt; &#123;p&#125; &lt;/li&gt; );</div><div class="line"></div><div class="line">// view with a call out ("partial") to generate a list from an Array:</div><div class="line">let vdom = (  </div><div class="line">    &lt;div id="foo"&gt;</div><div class="line">        &lt;p&gt;Look, a simple JSX DOM renderer!&lt;/p&gt;</div><div class="line">        &lt;ul&gt;&#123; list(ITEMS) &#125;&lt;/ul&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">);</div><div class="line"></div><div class="line">// render() converts our "virtual DOM" (see below) to a real DOM tree:</div><div class="line">let dom = render(vdom);</div><div class="line"></div><div class="line">// append the new nodes somewhere:</div><div class="line">document.body.appendChild(dom);</div><div class="line"></div><div class="line">// Remember that "virtual DOM"? It's just JSON - each "VNode" is an object with 3 properties.</div><div class="line">let json = JSON.stringify(vdom, null, '  ');</div><div class="line"></div><div class="line">// The whole process (JSX -&gt; VDOM -&gt; DOM) in one step:</div><div class="line">document.body.appendChild(  </div><div class="line">    render( &lt;pre id="vdom"&gt;&#123; json &#125;&lt;/pre&gt; )</div><div class="line">);</div></pre></td></tr></table></figure>
<h2 id="Codepen演示"><a href="#Codepen演示" class="headerlink" title="Codepen演示"></a><a href="https://codepen.io/developit/embed/aOYywe/" target="_blank" rel="external">Codepen演示</a></h2><iframe src="https://codepen.io/developit/embed/aOYywe/?height=600&theme-id=16424&default-tab=result" frameborder="no" crolling="no" width="100%" height="600"></iframe>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JSX实际上很简单：只需要花1分钟阅读这个，你会明白有关这个有趣的替代模板的一切。
    
    </summary>
    
      <category term="JSX" scheme="http://robin-front.github.io/categories/JSX/"/>
    
      <category term="react" scheme="http://robin-front.github.io/categories/JSX/react/"/>
    
    
      <category term="JSX" scheme="http://robin-front.github.io/tags/JSX/"/>
    
      <category term="react" scheme="http://robin-front.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>RxJS事件桥接</title>
    <link href="http://robin-front.github.io/2017/05/05/RxJS%E4%BA%8B%E4%BB%B6%E6%A1%A5%E6%8E%A5/"/>
    <id>http://robin-front.github.io/2017/05/05/RxJS事件桥接/</id>
    <published>2017-05-05T08:51:51.000Z</published>
    <updated>2017-05-05T08:51:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事件桥接"><a href="#事件桥接" class="headerlink" title="事件桥接"></a>事件桥接</h1><p>RxJS 提供工厂方法来桥接 DOM 或 Node.js 中已存在的异步数据源，所以，你可以使用丰富的创作、过滤和资源管理功能对RxJS提供的任何类型的数据流进行操作。这篇文章探讨 <a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/fromevent.md" target="_blank" rel="external"><code>fromEvent</code></a> 和 <a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/fromeventpattern.md" target="_blank" rel="external"><code>fromEventPattern</code></a>操作符，它允许导入一个 DOM 或者普通事件到 RxJS 的数据流。每次引发事件时，一个 <code>OnNext</code> 消息将传递到数据流。然后，可以像其他任何数据流一样操作事件数据流。</p>
<p>RxJS 不打算取代现有的异步编程模型如 <code>Promises</code> 或 <code>callbacks</code>。但是，当你尝试组合事件， RxJS的工厂方法会提供简便的方法给你，你完全感受不到当前使用了何种编程模式。这真的很方便维护（比如取消订阅）和筛选（比如选择合适的数据）数据源。在本节和下节中，你可以尝试 RxJS 的这些特性如何协助你完成异步编程。</p>
<p>自然，RxJS 支持一批库和他们的勾子函数去使用他们的事件系统，比如 <a href="http://jquery.com/" target="_blank" rel="external">jQuery</a>, <a href="http://zeptojs.com/" target="_blank" rel="external">Zepto.js</a>, <a href="https://angularjs.org/" target="_blank" rel="external">AngularJS</a>, <a href="http://emberjs.com/" target="_blank" rel="external">Ember.js</a> 和 <a href="http://backbonejs.org" target="_blank" rel="external">Backbone.js</a>。这种行为，不管怎样只能重写本地绑定。默认情况下， RxJS 也支持 <a href="http://nodejs.org" target="_blank" rel="external">Node.js</a> <code>EventEmitter</code> 的事件勾子。
<a id="more"></a></p>
<h2 id="将一个-DOM-事件转换成-RxJS-数据流"><a href="#将一个-DOM-事件转换成-RxJS-数据流" class="headerlink" title="将一个 DOM 事件转换成 RxJS 数据流"></a>将一个 DOM 事件转换成 RxJS 数据流</h2><p>接下来这个例子为鼠标移动事件创建了一个 DOM 事件操作，并且在页面上打印出鼠标的坐标。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = <span class="built_in">document</span>.getElementById(<span class="string">'result'</span>);</div><div class="line"></div><div class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'mousemove'</span>, e =&gt; result.innerHTML = e.clientX + <span class="string">', '</span> + e.clientY, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<p>导入一个事件到 RxJS, 你可以使用 <a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/fromevent.md" target="_blank" rel="external"><code>fromEvent</code></a> 操作符，并且传入被桥接的事件参数。然后它会将事件转换成数据流。</p>
<p>下面这个例子，我们将 DOM 的 <code>mousemove</code> 事件流转换成事件流（可观察对象）。每次鼠标移动事件被触发时，订阅都会接收到一个 <code>onNext</code> 事件。然后我们可以检查这种通知的事件参数并获得鼠标的坐标。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = <span class="built_in">document</span>.getElementById(<span class="string">'result'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'mousemove'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(<span class="function"><span class="params">e</span> =&gt;</span> result.innerHTML = e.clientX + <span class="string">', '</span> + e.clientY);</div></pre></td></tr></table></figure>
<p>在这个例子中要注意，（鼠标）移动变成一个数据流以便我们进一步操作。 <a href="querying.md">Querying Observable Sequences</a> 这篇文章将会展示如何将该序列投射到点类型集合中并筛选其内容，以便应用程序只接收满足一定条件的值。</p>
<p>事件处理程序的销毁由 <code>subscribe</code> 方法返回的 <code>Disposable</code> 对象处理。调用 <code>dispose</code> 将会释放由该序列所使用的所有资源，包括底层事件处理程序。这本质上是取消订阅事件。</p>
<p><code>fromEvent</code> 方法还支持向多个项目添加事件处理程序，比如一整个 DOM 节点列表。下面这个例子将会给列表中的每个元素添加 ‘click’ 事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = <span class="built_in">document</span>.getElementById(<span class="string">'result'</span>);</div><div class="line"><span class="keyword">var</span> sources = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.fromEvent(sources, <span class="string">'click'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(<span class="function"><span class="params">e</span> =&gt;</span> result.innerHTML = e.clientX + <span class="string">', '</span> + e.clientY);</div></pre></td></tr></table></figure>
<p>另外，<code>fromEvent</code> 也支持类库，像 <a href="http://jquery.com/" target="_blank" rel="external">jQuery</a>, <a href="http://zeptojs.com/" target="_blank" rel="external">Zepto.js</a>, <a href="https://angularjs.org/" target="_blank" rel="external">AngularJS</a>, <a href="http://emberjs.com/" target="_blank" rel="external">Ember.js</a> and <a href="http://backbonejs.org" target="_blank" rel="external">Backbone.js</a>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $result = $(<span class="string">'#result'</span>);</div><div class="line"><span class="keyword">var</span> $sources = $(<span class="string">'div'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.fromEvent($sources, <span class="string">'click'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(<span class="function"><span class="params">e</span> =&gt;</span> $result.html(e.clientX + <span class="string">', '</span> + e.clientY));</div></pre></td></tr></table></figure>
<p>如果表现不如预期，你可以通过设置 <code>Rx.config.useNativeEvents</code> 为 <code>true</code> 去重写它，这会无视任何类库。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 只使用原生事件，尽管引用了 jQuery</span></div><div class="line">Rx.config.useNativeEvents = <span class="literal">true</span>;</div><div class="line"></div><div class="line"><span class="comment">// 只使用原生事件</span></div><div class="line"><span class="keyword">var</span> result = <span class="built_in">document</span>.getElementById(<span class="string">'result'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'mousemove'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(<span class="function"><span class="params">e</span> =&gt;</span> result.innerHTML = e.clientX + <span class="string">', '</span> + e.clientY);</div></pre></td></tr></table></figure>
<p>另外，您可以轻松地给事件系统的事件添加许多快捷方式，比如 <code>mousemove</code>， 甚至是 <a href="http://www.w3.org/TR/pointerevents/" target="_blank" rel="external">Pointer</a> and <a href="http://www.w3.org/TR/touch-events/" target="_blank" rel="external">Touch</a> 事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Rx.dom = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> events = <span class="string">"blur focus focusin focusout load resize scroll unload click dblclick "</span> +</div><div class="line">  <span class="string">"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave "</span> +</div><div class="line">  <span class="string">"change select submit keydown keypress keyup error contextmenu"</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (root.PointerEvent) &#123;</div><div class="line">  events += <span class="string">" pointerdown pointerup pointermove pointerover pointerout pointerenter pointerleave"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (root.TouchEvent) &#123;</div><div class="line">  events += <span class="string">" touchstart touchend touchmove touchcancel"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">events.split(<span class="string">' '</span>).forEach(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</div><div class="line">  Rx.dom[e] = <span class="function">(<span class="params">element, selector</span>) =&gt;</span> Rx.Observable.fromEvent(element, e, selector)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>现在我们可以重写单个鼠标拖拽事件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> draggable = <span class="built_in">document</span>.getElementById(<span class="string">'draggable'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> mousedrag = Rx.dom.mousedown(draggable).flatMap(<span class="function"><span class="params">md</span> =&gt;</span> &#123;</div><div class="line">  md.preventDefault();</div><div class="line"></div><div class="line">  <span class="keyword">var</span> start = getLocation(md);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> Rx.dom.mousemove(<span class="built_in">document</span>)</div><div class="line">    .map(<span class="function"><span class="params">mm</span> =&gt;</span> getDelta(start, mm))</div><div class="line">    .takeUntil(Rx.dom.mouseup(draggable));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>注意这在 <a href="https://github.com/Reactive-Extensions/RxJS-DOM" target="_blank" rel="external">RxJS-DOM</a> 项目中已经可用，但你自己实现也只需要很少量的代码。</p>
<h2 id="将-Node-js-事件转换成-RxJS-数据流"><a href="#将-Node-js-事件转换成-RxJS-数据流" class="headerlink" title="将 Node.js 事件转换成 RxJS 数据流"></a>将 Node.js 事件转换成 RxJS 数据流</h2><p>Node.js 也支持类似 <a href="http://nodejs.org/api/events.html#events_class_events_eventemitter" target="_blank" rel="external"><code>EventEmitter</code></a>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Rx = <span class="built_in">require</span>(<span class="string">'rx'</span>),</div><div class="line">  EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter;</div><div class="line"></div><div class="line"><span class="keyword">var</span> eventEmitter = <span class="keyword">new</span> EventEmitter();</div><div class="line"></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.fromEvent(eventEmitter, <span class="string">'data'</span>)</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'data: '</span> + data));</div><div class="line"></div><div class="line">eventEmitter.emit(<span class="string">'data'</span>, <span class="string">'foo'</span>);</div><div class="line"><span class="comment">// =&gt; data: foo</span></div></pre></td></tr></table></figure>
<h2 id="使用-FromEventPattern-桥接自定义事件"><a href="#使用-FromEventPattern-桥接自定义事件" class="headerlink" title="使用 FromEventPattern 桥接自定义事件"></a>使用 FromEventPattern 桥接自定义事件</h2><p>下面有一个使用类库实现事件订阅和退订的实例。<a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/fromeventpattern.md" target="_blank" rel="external"><code>fromEventPattern</code></a> 方法就是为了这个目的而创建的，用来桥接这些自定义事件。</p>
<p>举个例子，你可以想使用 jQuery <a href="http://api.jquery.com/on/" target="_blank" rel="external"><code>on</code></a> 方法去桥接。我们可以将下列代码转换为基于表格行单击的 alert。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$( <span class="string">"#dataTable tbody"</span> ).on(<span class="string">'click'</span>, <span class="string">'tr'</span>, e =&gt; alert($( e.target ).text()));</div></pre></td></tr></table></figure>
<p>使用 <code>fromEventPattern</code> 方法转换后的代码看起来像下面这样。每个函数在处理函数中传递，允许您调用 <code>on</code> 和 <code>off</code> 方法来正确处理事件的处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $tbody = $(<span class="string">'#dataTable tbody'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.fromEventPattern(</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">addHandler</span> (<span class="params">h</span>) </span>&#123; $tbody.on(<span class="string">'click'</span>, <span class="string">'tr'</span>, h); &#125;,</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">delHandler</span> (<span class="params">h</span>) </span>&#123; $tbody.off(<span class="string">'click'</span>, <span class="string">'tr'</span>, h); &#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(<span class="function"><span class="params">e</span> =&gt;</span> alert($( e.target ).text()));</div></pre></td></tr></table></figure>
<p>除了这种常用的支持外，我们也支持 <code>addHandler</code> 返回一个对象，它可以通过 <code>removeHandler</code> 去完全退订。在这个例子中，我们将使用 <a href="http://dojotoolkit.org" target="_blank" rel="external">Dojo Toolkit</a> 和 <a href="http://dojotoolkit.org/api/1.9/dojo/on.html" target="_blank" rel="external"><code>on</code></a> 模块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">'dojo/on'</span>, <span class="string">'dojo/dom'</span>, <span class="string">'rx'</span>, <span class="string">'rx.async'</span>, <span class="string">'rx.binding'</span>], (on, dom, rx) =&gt; &#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> input = dom.byId(<span class="string">'input'</span>);</div><div class="line"></div><div class="line">    <span class="keyword">var</span> source = Rx.Observable.fromEventPattern(</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">addHandler</span> (<span class="params">h</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> on(input, <span class="string">'click'</span>, h);</div><div class="line">        &#125;,</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">delHandler</span> (<span class="params">_, signal</span>) </span>&#123;</div><div class="line">            signal.remove();</div><div class="line">        &#125;</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="keyword">var</span> subscription = source.subscribe(</div><div class="line">        <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Next: Clicked!'</span>),</div><div class="line">        err =&gt; <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + err),</div><div class="line">        () =&gt; <span class="built_in">console</span>.log(<span class="string">'Completed'</span>));</div><div class="line"></div><div class="line">    on.emit(input, <span class="string">'click'</span>);</div><div class="line">    <span class="comment">// =&gt; Next: Clicked!</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h2><p>概念</p>
<ul>
<li><a href="querying_observable_sequences.md">Querying Observable Sequences</a></li>
</ul>
<p><a href="https://robin-front.github.io/RxJS-doc-chinese/content/getting_started_with_rxjs/creating_and_querying_observable_sequences/bridging_to_events.html">本文翻译在: RxJS中文文档</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;事件桥接&quot;&gt;&lt;a href=&quot;#事件桥接&quot; class=&quot;headerlink&quot; title=&quot;事件桥接&quot;&gt;&lt;/a&gt;事件桥接&lt;/h1&gt;&lt;p&gt;RxJS 提供工厂方法来桥接 DOM 或 Node.js 中已存在的异步数据源，所以，你可以使用丰富的创作、过滤和资源管理功能对RxJS提供的任何类型的数据流进行操作。这篇文章探讨 &lt;a href=&quot;https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/fromevent.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;fromEvent&lt;/code&gt;&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/fromeventpattern.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;fromEventPattern&lt;/code&gt;&lt;/a&gt;操作符，它允许导入一个 DOM 或者普通事件到 RxJS 的数据流。每次引发事件时，一个 &lt;code&gt;OnNext&lt;/code&gt; 消息将传递到数据流。然后，可以像其他任何数据流一样操作事件数据流。&lt;/p&gt;
&lt;p&gt;RxJS 不打算取代现有的异步编程模型如 &lt;code&gt;Promises&lt;/code&gt; 或 &lt;code&gt;callbacks&lt;/code&gt;。但是，当你尝试组合事件， RxJS的工厂方法会提供简便的方法给你，你完全感受不到当前使用了何种编程模式。这真的很方便维护（比如取消订阅）和筛选（比如选择合适的数据）数据源。在本节和下节中，你可以尝试 RxJS 的这些特性如何协助你完成异步编程。&lt;/p&gt;
&lt;p&gt;自然，RxJS 支持一批库和他们的勾子函数去使用他们的事件系统，比如 &lt;a href=&quot;http://jquery.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;jQuery&lt;/a&gt;, &lt;a href=&quot;http://zeptojs.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Zepto.js&lt;/a&gt;, &lt;a href=&quot;https://angularjs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AngularJS&lt;/a&gt;, &lt;a href=&quot;http://emberjs.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Ember.js&lt;/a&gt; 和 &lt;a href=&quot;http://backbonejs.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Backbone.js&lt;/a&gt;。这种行为，不管怎样只能重写本地绑定。默认情况下， RxJS 也支持 &lt;a href=&quot;http://nodejs.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Node.js&lt;/a&gt; &lt;code&gt;EventEmitter&lt;/code&gt; 的事件勾子。
    
    </summary>
    
      <category term="RxJS" scheme="http://robin-front.github.io/categories/RxJS/"/>
    
    
      <category term="RxJS" scheme="http://robin-front.github.io/tags/RxJS/"/>
    
      <category term="bridging" scheme="http://robin-front.github.io/tags/bridging/"/>
    
      <category term="event" scheme="http://robin-front.github.io/tags/event/"/>
    
  </entry>
  
  <entry>
    <title>使用RxJS创建和订阅单一数据流</title>
    <link href="http://robin-front.github.io/2017/05/04/%E5%88%9B%E5%BB%BA%E5%92%8C%E8%AE%A2%E9%98%85%E5%8D%95%E4%B8%80%E6%95%B0%E6%8D%AE%E6%B5%81/"/>
    <id>http://robin-front.github.io/2017/05/04/创建和订阅单一数据流/</id>
    <published>2017-05-04T10:06:14.000Z</published>
    <updated>2017-05-04T10:06:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://robin-front.gitbooks.io/rxjs-doc-chinese/content/content/getting_started_with_rxjs/creating_and_querying_observable_sequences/creating_and_subscribing_to_simple_observable_sequences.html" target="_blank" rel="external">来自</a></p>
<h1 id="创建和订阅单一可观察序列"><a href="#创建和订阅单一可观察序列" class="headerlink" title="创建和订阅单一可观察序列"></a>创建和订阅单一可观察序列</h1><p>你不需要去实现 <code>Observable</code> 类去创建一个可观察序列。 同样的，你也不需要去实现 <code>Observer</code> 去订阅数据流。通过安装 Rx 库，你可以利用 <code>Observable</code>类型，它提供了许多操作符来根据零个，一个或多个元素去创建一个数据流。另外， RxJS 还提供 <code>subscribe</code> 方法允许你使用 <code>onNext</code>, <code>onError</code> 和 <code>onCompleted</code> 函数。</p>
<a id="more"></a>
<h2 id="从零创建一个数据流"><a href="#从零创建一个数据流" class="headerlink" title="从零创建一个数据流"></a>从零创建一个数据流</h2><p>在使用操作符之前，让我们看一看怎样使用 <a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/create.md" target="_blank" rel="external"><code>Rx.Observable.create</code></a> 方法从零创建 <code>Observable</code> 。</p>
<p>首先， 我们需要确认引用了 <code>rx.js</code> 核心文件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"rx.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如果我们使用 <a href="http://node.js" target="_blank" rel="external">Node.js</a>， 我们可以这样引入:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Rx = <span class="built_in">require</span>(<span class="string">'rx'</span>);</div></pre></td></tr></table></figure>
<p>在这个例子中， 我们将只产生一个单一值42，然后标记为完成。 如果不需要清除，返回值是完全可选的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> source = Rx.Observable.create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// 产生一个单一值然后完成。</span></div><div class="line">  observer.onNext(<span class="number">42</span>);</div><div class="line">  observer.onCompleted();</div><div class="line"></div><div class="line">  <span class="comment">// 任何清除的逻辑写在这里</span></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'disposed'</span>)</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onNext: %s'</span>, x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'onError: %s'</span>, e),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; onNext: 42</span></div><div class="line"><span class="comment">// =&gt; onCompleted</span></div><div class="line"></div><div class="line">subscription.dispose();</div><div class="line"><span class="comment">// =&gt; disposed</span></div></pre></td></tr></table></figure>
<p>对于大多数操作， 这完全是多余的，但这展示了非常基础的大部分 RxJS 操作符是如何工作的。</p>
<h2 id="创建及订阅单一数据流"><a href="#创建及订阅单一数据流" class="headerlink" title="创建及订阅单一数据流"></a>创建及订阅单一数据流</h2><p>接下来的例子使用 <code>Observable</code> 类的 <a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/range.md" target="_blank" rel="external"><code>range</code></a> 操作符来创建一个包含一些数字的单一数据流。观察者使用 <code>Observable</code> 类的 <code>Subscribe</code> 订阅这个数据流集合， 并且处理回调 <code>onNext</code>, <code>onError</code> and <code>onCompleted</code>。在我们的例子中，创建了一个从 x 开始的整数序列，然后接下来产生 y 个。</p>
<p>只要订阅了数据流，数据就会发送给观察者。<code>onNext</code>函数会打印出这个值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个从 1 开始，包含 5 个整数的数据流</span></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.range(<span class="number">1</span>, <span class="number">5</span>);</div><div class="line"></div><div class="line"><span class="comment">// 打印每个值</span></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onNext: %s'</span>, x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'onError: %s'</span>, e),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; onNext: 1</span></div><div class="line"><span class="comment">// =&gt; onNext: 2</span></div><div class="line"><span class="comment">// =&gt; onNext: 3</span></div><div class="line"><span class="comment">// =&gt; onNext: 4</span></div><div class="line"><span class="comment">// =&gt; onNext: 5</span></div><div class="line"><span class="comment">// =&gt; onCompleted</span></div></pre></td></tr></table></figure>
<p>当一个观察者订阅了一个数据流， <code>subscribe</code> 方法背后使用的异步操作取决于操作符。因些， <code>subscribe</code> 的调用是异步的，因为调用者在完成序列观察之前不会被阻塞。这篇文章 <a href="schedulers.md">Using Schedulers</a> 提供了更多信息。</p>
<p>注意 <a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/susbcribe.md" target="_blank" rel="external"><code>subscribe</code></a> 方法返回一个 <code>Disposable</code>，所以你可以很容易地退订和销毁它。当你在可观察对象上调用 <code>dispose</code> 方法时，观察者将会停止监听数据流。正常来说，你不需要精确地调用 <code>dispose</code> 除非你需要提前退订，或者当数据流的生命周期比观察者的还长。 Rx 的订阅被设计成 <code>触发-丢弃</code> 的场景，并不需要终结者。注意到，可观察对象的操作符的默认表现是 只要有可能（比如，<code>onCompleted</code> 或 <code>onError</code> 消息被发送时），订阅就会被销毁。举个例子，下面的代码将会订阅 a 和 b 两个数据流。如果 a 抛出一个错误， x 会立即退订 b 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = Rx.Observable.zip(a, b, (a1, b1) =&gt; a1 + b1).subscribe();</div></pre></td></tr></table></figure>
<p>还可以调整代码示例以使用观察者的 <code>Create</code> 运算符，创建并从指定的 <code>OnNext</code>, <code>OnError</code>, 和 <code>OnCompleted</code> 回调返回一个观察者。然后你可以传递 <code>observer</code> 给 <code>observable</code> 的 <code>subscribe</code> 方法。下面的例子展示了这种写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建包含 5个整数的数据流，从 1 开始</span></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.range(<span class="number">1</span>, <span class="number">5</span>);</div><div class="line"></div><div class="line"><span class="comment">// 创建观察者</span></div><div class="line"><span class="keyword">var</span> observer = Rx.Observer.create(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onNext: %s'</span>, x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'onError: %s'</span>, e),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="comment">// 打印每个结果</span></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(observer);</div><div class="line"></div><div class="line"><span class="comment">// =&gt; onNext: 1</span></div><div class="line"><span class="comment">// =&gt; onNext: 2</span></div><div class="line"><span class="comment">// =&gt; onNext: 3</span></div><div class="line"><span class="comment">// =&gt; onNext: 4</span></div><div class="line"><span class="comment">// =&gt; onNext: 5</span></div><div class="line"><span class="comment">// =&gt; onCompleted</span></div></pre></td></tr></table></figure>
<p>另外，从零创建一个数据流，你也可以将已存在的 数据， 事件，回调以及 <code>promise</code> 转换成数据流。下一节的主题将会教你怎么做。</p>
<p>注意，这一节只展示了可以从零创建数据流的很少一部分操作符。学习更多其他的  <code>LINQ</code> 操作符， 可以查看 <a href="querying_observable_squences.md">Querying Observable Sequences</a>.</p>
<h2 id="使用定时器"><a href="#使用定时器" class="headerlink" title="使用定时器"></a>使用定时器</h2><p>接下来的例子使用 <a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/timer.md" target="_blank" rel="external"><code>timer</code></a> 操作符去创建一个数据流。 这个数据流将在5秒后输出第一个值，接着每1秒输出后面的值。为了说明， 我们配合 <a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/timestamp.md" target="_blank" rel="external"><code>timestamp</code></a> 操作符去查询，使每一个被推出来的值将在发布时追加时间戳。这样，当我们订阅这个数据源时，我们可以接收到值和时间戳。</p>
<p>首先，我们需要确认我们是否在浏览器引入了相关的文件。注意 RxJS NPM 包已经默认包含了所有操作符。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"rx.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"rx.time.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>下面是我们的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'Current time: '</span> + <span class="built_in">Date</span>.now());</div><div class="line"></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.timer(</div><div class="line">  <span class="number">5000</span>, <span class="comment">/* 5 秒 */</span></div><div class="line">  <span class="number">1000</span> <span class="comment">/* 1 秒 */</span>)</div><div class="line">   .timestamp();</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x.value + <span class="string">': '</span> + x.timestamp));</div><div class="line"></div><div class="line"><span class="comment">/* 输出可能像这样子 */</span></div><div class="line"><span class="comment">// Current time: 1382560697820</span></div><div class="line"><span class="comment">// 0: 1382560702820</span></div><div class="line"><span class="comment">// 1: 1382560703820</span></div><div class="line"><span class="comment">// 2: 1382560704820</span></div></pre></td></tr></table></figure>
<p>通过使用 <code>timestamp</code> 操作符，我们可以证实，第一个值确实是开始5秒后输出，然后每1秒输出一个值。</p>
<h2 id="将数组和可迭代对象转换为数据流"><a href="#将数组和可迭代对象转换为数据流" class="headerlink" title="将数组和可迭代对象转换为数据流"></a>将数组和可迭代对象转换为数据流</h2><p>使用 <a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/from.md" target="_blank" rel="external"><code>Rx.Observable.from</code></a> 操作符，你可以将一个数组转换为数据流。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"></div><div class="line"><span class="comment">// 将数组转换为数据流</span></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.from(array);</div><div class="line"></div><div class="line"><span class="comment">// 输出每个值</span></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onNext: %s'</span>, x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'onError: %s'</span>, e),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; onNext: 1</span></div><div class="line"><span class="comment">// =&gt; onNext: 2</span></div><div class="line"><span class="comment">// =&gt; onNext: 3</span></div><div class="line"><span class="comment">// =&gt; onNext: 4</span></div><div class="line"><span class="comment">// =&gt; onNext: 5</span></div><div class="line"><span class="comment">// =&gt; onCompleted</span></div></pre></td></tr></table></figure>
<p>你也可以转换类数组结构，比如包含 <code>length</code> 属性和数字索引的对象。这种情况下，我们只简单有一个包含长度为5的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arrayLike = &#123; <span class="attr">length</span>: <span class="number">5</span> &#125;;</div><div class="line"></div><div class="line"><span class="comment">// 转换数组为数据流</span></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.from(arrayLike, (v, k) =&gt; k);</div><div class="line"></div><div class="line"><span class="comment">// 输出每个值</span></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onNext: %s'</span>, x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'onError: %s'</span>, e),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; onNext: 1</span></div><div class="line"><span class="comment">// =&gt; onNext: 2</span></div><div class="line"><span class="comment">// =&gt; onNext: 3</span></div><div class="line"><span class="comment">// =&gt; onNext: 4</span></div><div class="line"><span class="comment">// =&gt; onNext: 5</span></div><div class="line"><span class="comment">// =&gt; onCompleted</span></div></pre></td></tr></table></figure>
<p>另外，我们也可以使用 ES6 可迭代对象，如 <code>Map</code> 和 <code>Set</code> 使用 <code>from</code> 转换成数据流。下面这个例子，我们将获取一个 <code>Set</code> 对象，并且将它转换成数据流。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</div><div class="line"></div><div class="line"><span class="comment">// 转换 Set 为数据流</span></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.from(set);</div><div class="line"></div><div class="line"><span class="comment">// 转出每个值</span></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onNext: %s'</span>, x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'onError: %s'</span>, e),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; onNext: 1</span></div><div class="line"><span class="comment">// =&gt; onNext: 2</span></div><div class="line"><span class="comment">// =&gt; onNext: 3</span></div><div class="line"><span class="comment">// =&gt; onNext: 4</span></div><div class="line"><span class="comment">// =&gt; onNext: 5</span></div><div class="line"><span class="comment">// =&gt; onCompleted</span></div></pre></td></tr></table></figure>
<p>我们也可以将它应用在 <code>Map</code> 对象上面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'key1'</span>, <span class="number">1</span>], [<span class="string">'key2'</span>, <span class="number">2</span>]]);</div><div class="line"></div><div class="line"><span class="comment">// 将 Map 转换成数据流</span></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.from(map);</div><div class="line"></div><div class="line"><span class="comment">// 打印每个值</span></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onNext: %s'</span>, x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'onError: %s'</span>, e),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; onNext: key1, 1</span></div><div class="line"><span class="comment">// =&gt; onNext: key2, 2</span></div><div class="line"><span class="comment">// =&gt; onCompleted</span></div></pre></td></tr></table></figure>
<p><code>from</code> 方法也支持 ES6 generators，可以你的浏览器已经支持，或将要支持。这允许我们实现一些像 <code>斐波那契序列</code> 等，并将它们转换成数据流。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibonacci</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> fn1 = <span class="number">1</span>;</div><div class="line">  <span class="keyword">var</span> fn2 = <span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span> (<span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">var</span> current = fn2;</div><div class="line">    fn2 = fn1;</div><div class="line">    fn1 = fn1 + current;</div><div class="line">    <span class="keyword">yield</span> current;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 将 generator 转换成数据流</span></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.from(fibonacci()).take(<span class="number">5</span>);</div><div class="line"></div><div class="line"><span class="comment">// 打印每个值</span></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onNext: %s'</span>, x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'onError: %s'</span>, e),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; onNext: 1</span></div><div class="line"><span class="comment">// =&gt; onNext: 1</span></div><div class="line"><span class="comment">// =&gt; onNext: 2</span></div><div class="line"><span class="comment">// =&gt; onNext: 3</span></div><div class="line"><span class="comment">// =&gt; onNext: 5</span></div><div class="line"><span class="comment">// =&gt; onCompleted</span></div></pre></td></tr></table></figure>
<h2 id="冷（惰性）-vs-热（非惰性）-数据流"><a href="#冷（惰性）-vs-热（非惰性）-数据流" class="headerlink" title="冷（惰性） vs. 热（非惰性） 数据流"></a>冷（惰性） vs. 热（非惰性） 数据流</h2><p>冷数据流的开始运行取决于订阅，比如，数据流只有当 <code>subscribe</code> 调用的时候才开始输出值。用户之间也没有共享值。这些是与热数据流的不同之处，热数据像流鼠标移动事件或股票代码这样的订阅时就已经不断输出值。当观察者订阅热数据流时，它将会获取流的实时值。热数据流是与所有订阅者共享的，每个订阅者按顺序推送下一个值。举个例子，就算没有人订阅一个特定的股票，股票市场也将继续根据市场动向更新其价值。当有注册者对这支股票感兴趣时，它会自动获得股票的最新值。</p>
<p>下面的示例演示了一个冷数据流。这个例子中，我们使用了 <code>Interval</code> 操作符去创建一个单一数据流并在特定的时间间隔输出值，这个例子中是间隔1秒。</p>
<p>两个观察者订阅这个数据流并打印输出值。你会注意到数据流会为每个订阅者重置，第二个订阅者也是从第1个值开始的。</p>
<p>首先，我们需要确保在浏览器中引入了相关文件。注意 RxJS NPM 包已经默认包含了所有操作符。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"rx.lite.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后是例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">1000</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription1 = source.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Observer 1: onNext: '</span> + x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'Observer 1: onError: '</span> + e.message),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'Observer 1: onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription2 = source.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Observer 2: onNext: '</span> + x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'Observer 2: onError: '</span> + e.message),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'Observer 2: onCompleted'</span>));</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  subscription1.dispose();</div><div class="line">  subscription2.dispose();</div><div class="line">&#125;, <span class="number">5000</span>);</div><div class="line"></div><div class="line"><span class="comment">// =&gt; Observer 1: onNext: 0</span></div><div class="line"><span class="comment">// =&gt; Observer 2: onNext: 0</span></div><div class="line"><span class="comment">// =&gt; Observer 1: onNext: 1</span></div><div class="line"><span class="comment">// =&gt; Observer 2: onNext: 1</span></div><div class="line"><span class="comment">// =&gt; Observer 1: onNext: 2</span></div><div class="line"><span class="comment">// =&gt; Observer 2: onNext: 2</span></div><div class="line"><span class="comment">// =&gt; Observer 1: onNext: 3</span></div><div class="line"><span class="comment">// =&gt; Observer 2: onNext: 3</span></div></pre></td></tr></table></figure>
<p>接下来的例子中，我们使用 <a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/publish.md" target="_blank" rel="external"><code>publish</code></a> 操作符将前面的冷数据源转换成热数据源，返回一个 <code>ConnectableObservable</code> 实例，我们称为 <code>hot</code>。<a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/publish.md" target="_blank" rel="external"><code>publish</code></a> 操作符通过向多个订阅服务器广播单个订阅来提供共享订阅的机制。<code>hot</code>变量作为代理订阅 <code>source</code>，因为它从 <code>source</code> 接收值，推到自己的用户. 我们使用 <a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/connect.md" target="_blank" rel="external"><code>ConnectableObservable.prototype.connect</code></a> 建立订阅的备份源，并开始接收值。因为 <code>ConnectableObservable</code> 继承自 <code>Observable</code>， 我们可以在它运行之前使用 <code>subscribe</code> 去订阅这个热数据流。 在这个例子中要注意，当 <code>subscription1</code>订阅它的时候热数据流还没有开始。因些，没有值输出给订阅者。只有调用 <code>Connect</code> 之后，输出值才会推送给 <code>subscription1</code>。3秒的延迟之后，<code>subscription2</code> 订阅了热数据流，并且立即开始接收当前输出值（当前值是3），一直到最后。输出结果看起来像这样：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// =&gt; Current <span class="built_in">time</span>: <span class="number">1382562433256</span></div><div class="line">// =&gt; Current <span class="keyword">Time</span> <span class="built_in">after</span> <span class="number">1</span>st subscription: <span class="number">1382562433260</span></div><div class="line">// =&gt; Current <span class="keyword">Time</span> <span class="built_in">after</span> connect: <span class="number">1382562436261</span></div><div class="line">// =&gt; Observer <span class="number">1</span>: onNext: <span class="number">0</span></div><div class="line">// =&gt; Observer <span class="number">1</span>: onNext: <span class="number">1</span></div><div class="line">// =&gt; Current <span class="keyword">Time</span> <span class="built_in">after</span> <span class="number">2</span>nd subscription: <span class="number">1382562439262</span></div><div class="line">// =&gt; Observer <span class="number">1</span>: onNext: <span class="number">2</span></div><div class="line">// =&gt; Observer <span class="number">2</span>: onNext: <span class="number">2</span></div><div class="line">// =&gt; Observer <span class="number">1</span>: onNext: <span class="number">3</span></div><div class="line">// =&gt; Observer <span class="number">2</span>: onNext: <span class="number">3</span></div><div class="line">// =&gt; Observer <span class="number">1</span>: onNext: <span class="number">4</span></div><div class="line">// =&gt; Observer <span class="number">2</span>: onNext: <span class="number">4</span></div></pre></td></tr></table></figure>
<p>首先，我们需要确认我们引入了相关文件。注意 RxJS NPM包已经默认包含了所有操作符。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"rx.lite.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>接下来是例子！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'Current time: '</span> + <span class="built_in">Date</span>.now());</div><div class="line"></div><div class="line"><span class="comment">// 创建一个数据流</span></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">1000</span>);</div><div class="line"></div><div class="line"><span class="comment">// 将数据流转换成热数据流</span></div><div class="line"><span class="keyword">var</span> hot = source.publish();</div><div class="line"></div><div class="line"><span class="comment">// 第一个订阅时没有值输出</span></div><div class="line"><span class="keyword">var</span> subscription1 = hot.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Observer 1: onNext: %s'</span>, x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'Observer 1: onError: %s'</span>, e),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'Observer 1: onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Current Time after 1st subscription: '</span> + <span class="built_in">Date</span>.now());</div><div class="line"></div><div class="line"><span class="comment">// 空闲 3 秒</span></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line"></div><div class="line">  <span class="comment">// 热数据源连接并开始输出值给订阅者</span></div><div class="line">  hot.connect();</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Current Time after connect: '</span> + <span class="built_in">Date</span>.now());</div><div class="line"></div><div class="line">  <span class="comment">// 又空闲 3 秒</span></div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Current Time after 2nd subscription: '</span> + <span class="built_in">Date</span>.now());</div><div class="line"></div><div class="line">    <span class="keyword">var</span> subscription2 = hot.subscribe(</div><div class="line">      <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Observer 2: onNext: %s'</span>, x),</div><div class="line">      e =&gt; <span class="built_in">console</span>.log(<span class="string">'Observer 2: onError: %s'</span>, e),</div><div class="line">      () =&gt; <span class="built_in">console</span>.log(<span class="string">'Observer 2: onCompleted'</span>));</div><div class="line"></div><div class="line">  &#125;, <span class="number">3000</span>);</div><div class="line">&#125;, <span class="number">3000</span>);</div><div class="line"></div><div class="line"><span class="comment">// =&gt; Current Time after connect: 1431197578426</span></div><div class="line"><span class="comment">// =&gt; Observer 1: onNext: 0</span></div><div class="line"><span class="comment">// =&gt; Observer 1: onNext: 1</span></div><div class="line"><span class="comment">// =&gt; Observer 1: onNext: 2</span></div><div class="line"><span class="comment">// =&gt; Current Time after 2nd subscription: 1431197581434</span></div><div class="line"><span class="comment">// =&gt; Observer 1: onNext: 3</span></div><div class="line"><span class="comment">// =&gt; Observer 2: onNext: 3</span></div><div class="line"><span class="comment">// =&gt; Observer 1: onNext: 4</span></div><div class="line"><span class="comment">// =&gt; Observer 2: onNext: 4</span></div><div class="line"><span class="comment">// =&gt; Observer 1: onNext: 5</span></div><div class="line"><span class="comment">// =&gt; Observer 2: onNext: 5</span></div><div class="line"><span class="comment">// =&gt; ...</span></div></pre></td></tr></table></figure>
<p><strong>类推</strong></p>
<p>这有助于思考冷热数据源的关系，就像一个人看（<code>subscribe</code>）电影和表演。</p>
<ul>
<li>冷数据流：电影。</li>
<li>热数据流：现场演出</li>
<li>重播热数据流：录播现场演出</li>
</ul>
<p>你管你何时观看电影，你看电影和别人看都是独立的，尽管所有观看者看的都是相同的内容。另一方面，一个表演是与多个观看都一起分享的。如果你迟到了，你将会错过一部分。不管怎样，如果记录下来了（在 RxJS中可以使用 <code>BehaviorSubject</code> 或 <code>ReplaySubject</code>），你也可像看电影一样看现场演出。<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/refcount.md" target="_blank" rel="external"><code>.publish().refCount()</code></a> 现场表演是艺术家在没有人观看的情况下退出比赛，当观众中至少有一人出现时，他会重新开始演奏。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://robin-front.gitbooks.io/rxjs-doc-chinese/content/content/getting_started_with_rxjs/creating_and_querying_observable_sequences/creating_and_subscribing_to_simple_observable_sequences.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;来自&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;创建和订阅单一可观察序列&quot;&gt;&lt;a href=&quot;#创建和订阅单一可观察序列&quot; class=&quot;headerlink&quot; title=&quot;创建和订阅单一可观察序列&quot;&gt;&lt;/a&gt;创建和订阅单一可观察序列&lt;/h1&gt;&lt;p&gt;你不需要去实现 &lt;code&gt;Observable&lt;/code&gt; 类去创建一个可观察序列。 同样的，你也不需要去实现 &lt;code&gt;Observer&lt;/code&gt; 去订阅数据流。通过安装 Rx 库，你可以利用 &lt;code&gt;Observable&lt;/code&gt;类型，它提供了许多操作符来根据零个，一个或多个元素去创建一个数据流。另外， RxJS 还提供 &lt;code&gt;subscribe&lt;/code&gt; 方法允许你使用 &lt;code&gt;onNext&lt;/code&gt;, &lt;code&gt;onError&lt;/code&gt; 和 &lt;code&gt;onCompleted&lt;/code&gt; 函数。&lt;/p&gt;
    
    </summary>
    
      <category term="RxJS" scheme="http://robin-front.github.io/categories/RxJS/"/>
    
    
      <category term="RxJS" scheme="http://robin-front.github.io/tags/RxJS/"/>
    
      <category term="Observable" scheme="http://robin-front.github.io/tags/Observable/"/>
    
  </entry>
  
  <entry>
    <title>Coverage针对js和css的代码覆盖检测-Chrome_devtools的新功能</title>
    <link href="http://robin-front.github.io/2017/04/06/Coverage%E9%92%88%E5%AF%B9js%E5%92%8Ccss%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E6%A3%80%E6%B5%8B-Chrome-devtools%E7%9A%84%E6%96%B0%E5%8A%9F%E8%83%BD/"/>
    <id>http://robin-front.github.io/2017/04/06/Coverage针对js和css的代码覆盖检测-Chrome-devtools的新功能/</id>
    <published>2017-04-06T03:21:26.000Z</published>
    <updated>2017-04-06T03:21:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>也许你之前用过一些像 <code>css usage</code>、<code>css used</code> 这样的浏览器插件去检测代码覆盖率。但现在，Chrome的实验版本<a href="https://www.google.com/chrome/browser/canary.html" target="_blank" rel="external">Canary</a>终于实现了代码覆盖率检测，这意味着它将很快普及到正式版本。这是一个令人兴奋的功能，在使用JavaScript和CSS时非常有用，所以我会做一个快速的演示，并探索它如何使用。</p>
<a id="more"></a>
<h2 id="它做了些什么事情"><a href="#它做了些什么事情" class="headerlink" title="它做了些什么事情"></a>它做了些什么事情</h2><p>代码覆盖可以在您运行您的Web应用程序的时候，遍历每个JS / CSS文件，看看哪些代码行运行，哪些代码没有运行。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*gD8lX40PSemDOZgvT695Mg.png" alt="coverage"></p>
<p>在这里，我做了一个简单的静态网页，Chrome生成了页面上存在的CSS和JS文件的问题汇总。右侧的栏显示每个文件的相对大小，红色表示未使用的代码，绿色显示运行的代码。</p>
<p>记录代码覆盖范围与devtools时间轴类似，您点击开始记录，然后在您的站点进行正常的交互。完成后，Chrome会进行一些计算并生成读数。在这里，我很好奇网站上有多少未使用的CSS，所以我导航到各个子页面，以确保我触及到每个css。果然，这里有很多改进的空间，因为我的网站上的css的97％没有使用！</p>
<p><img src="https://cdn-images-1.medium.com/max/1200/1*1SUTeKlhRee3MyKdxkUGtQ.png" alt="coverage"></p>
<p>Chrome还可让您深入研究单个文件的代码范围。在这里，左边的红色/绿色条显示哪一行执行了，哪一行没有。请注意，当检查最小化的文件时，可以按文件左下角的按钮来“<code>prettify</code>”代码。</p>
<h2 id="这有什么用"><a href="#这有什么用" class="headerlink" title="这有什么用"></a>这有什么用</h2><p>在一个复杂的或长期的项目上工作时，很容易积累冗余代码。如果你使用 <code>webpack</code> 或另一个JS构建系统，可以防止大多数无用的JS代码。但是对于CSS来说，这样做可能会有点棘手。有了这个覆盖工具，在Chrome是一个伟大的方式来快速了解多少冗余的代码在运行，哪些文件需要优化。</p>
<h2 id="如何才能使用它"><a href="#如何才能使用它" class="headerlink" title="如何才能使用它"></a>如何才能使用它</h2><p>下载Chrome的实验版本<a href="https://www.google.com/chrome/browser/canary.html" target="_blank" rel="external">Canary</a>或等待此功能更新到正式版本。</p>
<p>【译文参考】：<a href="https://blog.logrocket.com/using-the-chrome-devtools-new-code-coverage-feature-ca96c3dddcaf" target="_blank" rel="external">https://blog.logrocket.com/using-the-chrome-devtools-new-code-coverage-feature-ca96c3dddcaf</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;也许你之前用过一些像 &lt;code&gt;css usage&lt;/code&gt;、&lt;code&gt;css used&lt;/code&gt; 这样的浏览器插件去检测代码覆盖率。但现在，Chrome的实验版本&lt;a href=&quot;https://www.google.com/chrome/browser/canary.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Canary&lt;/a&gt;终于实现了代码覆盖率检测，这意味着它将很快普及到正式版本。这是一个令人兴奋的功能，在使用JavaScript和CSS时非常有用，所以我会做一个快速的演示，并探索它如何使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Chrome_devtools" scheme="http://robin-front.github.io/categories/Chrome-devtools/"/>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/Chrome-devtools/javascript/"/>
    
    
      <category term="coverage" scheme="http://robin-front.github.io/tags/coverage/"/>
    
      <category term="Chrome_devtools" scheme="http://robin-front.github.io/tags/Chrome-devtools/"/>
    
  </entry>
  
  <entry>
    <title>学习RxJS需要知道的奇淫技巧</title>
    <link href="http://robin-front.github.io/2017/04/05/%E5%AD%A6%E4%B9%A0RxJS%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7/"/>
    <id>http://robin-front.github.io/2017/04/05/学习RxJS需要知道的奇淫技巧/</id>
    <published>2017-04-05T09:06:03.000Z</published>
    <updated>2017-04-05T09:06:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-Rx-的奇淫技巧"><a href="#使用-Rx-的奇淫技巧" class="headerlink" title="使用 Rx 的奇淫技巧"></a>使用 Rx 的奇淫技巧</h1><h3 id="尝试画珠宝图"><a href="#尝试画珠宝图" class="headerlink" title="尝试画珠宝图"></a>尝试画珠宝图</h3><p>为你想创建的流画一个珠宝图。 通过画珠宝图，你将会很清楚你应该使用哪些操作符。</p>
<p>珠宝图就是每个珠宝表示当前的一个事件或状态。珠宝图需要包含输入和输出流。</p>
<p><img src="https://raw.githubusercontent.com/Reactive-Extensions/RxJS/master/doc/designguidelines/images/throttleWithTimeout.png" alt="throttleWithSelector"></p>
<a id="more"></a>
<p>通过画珠宝图，我们可以看到，我们在异步调用事件回调之前，需要延迟检测用户的输入。在这个例图里展示的是<code>throttle</code>操作符的延迟。从一个流创建另一个流，我们会使用 <code>flatMap</code> 或 <code>selectMany</code> 操作符。然后就有了下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dictionarySuggest = userInput.throttle(<span class="number">250</span>).flatMap(<span class="function"><span class="params">input</span> =&gt;</span> serverCall(input));</div></pre></td></tr></table></figure>
<h4 id="何时忽略这条指南"><a href="#何时忽略这条指南" class="headerlink" title="何时忽略这条指南"></a>何时忽略这条指南</h4><p>如果你感觉你已经可以很熟练地编写出你想要的流，你可以省去画珠宝图这一步。不管怎样，就算是 Rx 团队的成员在写代码的时候也仍然会先画一画珠宝图。</p>
<h3 id="调用-subscribe-时传递多个参数"><a href="#调用-subscribe-时传递多个参数" class="headerlink" title="调用 subscribe 时传递多个参数"></a>调用 <code>subscribe</code> 时传递多个参数</h3><p>为了方便， Rx 提供一个<code>subscribe</code>方法来加载观察者的回调函数。</p>
<p>观察者只需要实现这三个方法（<code>onNext</code>, <code>onError</code> &amp; <code>onCompleted</code>）。 <code>subscribe</code>方法的扩展允许开发人员使用这些方法的默认选项。</p>
<p>比如： 当调用<code>subscribe</code>方法时只有一个<code>onNext</code>参数，<code>onError</code>将捕获来自事件流的异常。<code>onCompleted</code>在这里什么也不会做。</p>
<p>大部分情况下，处理异常是很重要的（不管是对于恢复还是中断应用程序）。</p>
<p>知道事件流是否完成也经常是很重要的。举个例子，告诉用户他的操作是否完成了。</p>
<p>所以，最好提供完整的三个参数给 <code>subscribe</code> 操作符。</p>
<p>RxJS还提供了三种方便的方法，其仅订阅所期望的序列的一部分。其他的处理程序会默认为原来的行为。有三个这样的功能：</p>
<ul>
<li><code>subscribeOnNext</code>: 只对应 <code>onNext</code> 消息</li>
<li><code>subscribeOnError</code>: 只对应 <code>onError</code> 消息</li>
<li><code>subscribeOnCompleted</code>: 只对应 <code>onCompleted</code> 消息.</li>
</ul>
<h4 id="何时忽略这条指南-1"><a href="#何时忽略这条指南-1" class="headerlink" title="何时忽略这条指南"></a>何时忽略这条指南</h4><ul>
<li>当流确定不会有完成状态，比如 <code>keyup</code>事件。</li>
<li>当流确定不会抛出异常，比如一个事件，一个完全确定的流。</li>
<li>当默认行为是符合预期的时候。</li>
</ul>
<h3 id="考虑通过特定的调度程序并发引入操作符"><a href="#考虑通过特定的调度程序并发引入操作符" class="headerlink" title="考虑通过特定的调度程序并发引入操作符"></a>考虑通过特定的调度程序并发引入操作符</h3><p>相比使用<code>observeon</code>操作符来改变可观察序列产生消息的执行上下文，更好的做法是在正确的地方开始创建并发。 通过正确的调度器将会减少 <code>ObserveOn</code>操作符的使用。</p>
<h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Rx.Observable.range(<span class="number">0</span>, <span class="number">90000</span>, Rx.Scheduler.requestAnimationFrame).subscribe(draw);</div></pre></td></tr></table></figure>
<p>在这个例子中，来自<code>range</code>操作符的回调将会通过<code>window.requestAnimationFrame</code>传递。在这个例子中， <code>range</code>操作符的回调将被调用。默认情况下，当递归调用立即执行时，<code>range</code>过载将会代替 <code>onNext</code>在<code>Rx.Scheduler.currentThread</code>上的调用。 通过提供<code>Rx.Scheduler.requestAnimationFrame</code>调度程序， 所有来自observable的消息都将会在 <code>window.requestAnimationFrame</code>回调中产生。</p>
<h4 id="何时忽略这条指南-2"><a href="#何时忽略这条指南-2" class="headerlink" title="何时忽略这条指南"></a>何时忽略这条指南</h4><p>当结合来自不同执行上下文的几个事件时，使用指南4.4将所有消息尽可能晚地放在特定的执行上下文。</p>
<h3 id="尽可能少且尽可能迟地调用observeOn-操作符"><a href="#尽可能少且尽可能迟地调用observeOn-操作符" class="headerlink" title="尽可能少且尽可能迟地调用observeOn 操作符"></a>尽可能少且尽可能迟地调用<code>observeOn</code> 操作符</h3><p>通过使用 <code>observeOn</code> 操作符， 一个预定的功能是通过原始的消息流来获取信息。这可能会改变时序信息以及对系统施加额外的压力。在查询中延迟使用这个操作符可以改善这两个问题。</p>
<h4 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = xs.throttle(<span class="number">1000</span>)</div><div class="line">  .flatMap(<span class="function"><span class="params">x</span> =&gt;</span> ys.takeUntil(zs).sample(<span class="number">250</span>).map(<span class="function"><span class="params">y</span> =&gt;</span> x + y))</div><div class="line">  .merge(ws)</div><div class="line">  .filter(<span class="function"><span class="params">x</span> =&gt;</span> x &lt; <span class="number">10</span>)</div><div class="line">  .observeOn(Rx.Scheduler.requestAnimationFrame);</div></pre></td></tr></table></figure>
<p>这个例子合并了多个 运行在不同上下文的 observable 。这个查询筛选掉了大部分信息。将<code>observeOn</code>操作符放在查询中的前面会对筛选出来的消息做额外的工作。最后才调用 <code>observeOn</code> 将会最大限度地提高性能。</p>
<h4 id="何时忽略这条指南-3"><a href="#何时忽略这条指南-3" class="headerlink" title="何时忽略这条指南"></a>何时忽略这条指南</h4><p>如果你使用的 observable 并没有指定不同的上下文环境。这种情况下可以不必使用 <code>observeOn</code> 操作符。</p>
<h3 id="关注内存限制"><a href="#关注内存限制" class="headerlink" title="关注内存限制"></a>关注内存限制</h3><p>RxJS 有很多操作符和类可以在内存中创建 observable, 比如：<code>replay</code> 操作符。当这些内存存储着 observable 时，这些缓存的大小将取决于 observable 的操作。如果缓存过大，将会造成内存溢出。有许多缓冲操作符提供策略来限制缓冲区，不管是从时间方面还是大小。提供这个限制将解决内存压力问题。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = xs.replay(<span class="literal">null</span>, <span class="number">10000</span>, <span class="number">1000</span> * <span class="number">60</span> <span class="comment">/* 1 hr */</span>).refCount();</div></pre></td></tr></table></figure>
<p>这个例子中，<code>replay</code> 操作符创建了一个 buffer. 我们有限制这个 buffer 最多包含 10,000 条信息以及最多保留这些信息1小时。</p>
<h4 id="何时忽略这条指南-4"><a href="#何时忽略这条指南-4" class="headerlink" title="何时忽略这条指南"></a>何时忽略这条指南</h4><p>当 observable 创建了大量的信息只填充了一小块 buffer， 或者当 buffer本身有大小限制。</p>
<h3 id="使用-do-tap-操作符的副作用很明显"><a href="#使用-do-tap-操作符的副作用很明显" class="headerlink" title="使用 do/tap 操作符的副作用很明显"></a>使用 <code>do</code>/<code>tap</code> 操作符的副作用很明显</h3><p>有很多 Rx 操作符使用函数作为参数，这可以在这些参数中传递任何有效的用户代码。这些代码可以改变全局状态（比如改变全局变量，读写硬盘等等）。</p>
<p>Rx 是通过每个操作符组合起来运行的（除了共享操作符，例如“publish”）。这将使副作用发生在每个订阅。</p>
<p>如果这种表现是期望的行为，最好弄清楚在 <code>do</code>/<code>tap</code> 操作符中有副作用的这部分代码。这些方法会过载，只能调用指定的方法，比如 <code>doOnNext</code>/<code>tapOnNext</code>，<code>doOnError</code>/<code>tapOnError</code>,<code>doOnCompleted</code>/<code>tapOnCompleted</code></p>
<h4 id="例-1"><a href="#例-1" class="headerlink" title="例"></a>例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = xs.filter(<span class="function"><span class="params">x</span> =&gt;</span> x.failed).tap(<span class="function"><span class="params">x</span> =&gt;</span> log(x));</div></pre></td></tr></table></figure>
<p>这个例子中，过滤失败的消息。将它们分发到订阅observable的代码之前记录该消息。此记录有一个副作用（比如：将消息放置在计算机的事件日志中）并明确地通过调用<code>do</code>/<code>tap</code>操作符。</p>
<h3 id="假设消息可以传达，直到退订完成"><a href="#假设消息可以传达，直到退订完成" class="headerlink" title="假设消息可以传达，直到退订完成"></a>假设消息可以传达，直到退订完成</h3><p>由于RxJS 使用推模式，消息可以通过不同的上下文环境发送。 当退订的时候，消息可能还在路上。当退订还没有完成的时候，这些消息仍然可以被传达。当控制权被返回时，消息将不能再传达。退订过程可以是在一个不同的上下文环境中进行。</p>
<h4 id="何时忽略这条指南-5"><a href="#何时忽略这条指南-5" class="headerlink" title="何时忽略这条指南"></a>何时忽略这条指南</h4><p>一旦 <code>onCompleted</code> 或 <code>onError</code> 方法被调用，RxJS语法可以保证订阅已结束。</p>
<h3 id="使用-publish-操作符分享副作用"><a href="#使用-publish-操作符分享副作用" class="headerlink" title="使用 publish 操作符分享副作用"></a>使用 <code>publish</code> 操作符分享副作用</h3><p>因为许多 observable是冷门的<a href="http://channel9.msdn.com/Blogs/J.Van.Gogh/Rx-API-in-depth-Hot-and-Cold-observables" target="_blank" rel="external">(see cold vs. hot on Channel 9)</a>, 每个订阅都有单独的副作用。 某些情况下，这些副作用只发生一次。<code>publish</code> 操作符通过向多个用户广播单个订阅来提供共享订阅的机制。</p>
<p>有几个过载<code>publish</code>运算符。最方便的过载是那些提供了一个函数封装 observable 共享的副作用的参数。</p>
<h4 id="例-2"><a href="#例-2" class="headerlink" title="例"></a>例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xs = Rx.Observable.create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Side effect'</span>);</div><div class="line">  observer.onNext(<span class="string">'hi!'</span>);</div><div class="line">  observer.onCompleted();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">xs.publish(<span class="function"><span class="params">sharedXs</span> =&gt;</span> &#123;</div><div class="line">  sharedXs.subscribe(<span class="built_in">console</span>.log);</div><div class="line">  sharedXs.subscribe(<span class="built_in">console</span>.log);</div><div class="line">  <span class="keyword">return</span> sharedXs;</div><div class="line">&#125;).subscribe();</div></pre></td></tr></table></figure>
<p>这个例子中，<code>xs</code> 是一个有副作用的（写入console） observable。正常情况下，每个单独的订阅都会触发这些副作用。 <code>publish</code> 操作符使用<code>xs</code>单独给所有订阅者 <code>sharedXs</code> 变量去订阅。</p>
<h4 id="何时忽略这条指南-6"><a href="#何时忽略这条指南-6" class="headerlink" title="何时忽略这条指南"></a>何时忽略这条指南</h4><p>只有当 <code>publish</code> 操作符需要共享副作用时才使用这条指南。在大多数情况下，您可以创建单独的订阅，没有任何问题：不管是订阅没有副作用的或是副作用可以执行多次没有任何问题的。</p>
<p><a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/designguidelines#4-using-rx" target="_blank" rel="external">参考</a>
<a href="https://robin-front.gitbooks.io/rxjs-doc-chinese/content/content/guidelines/using.html" target="_blank" rel="external">同步翻译至RxJS中文文档</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用-Rx-的奇淫技巧&quot;&gt;&lt;a href=&quot;#使用-Rx-的奇淫技巧&quot; class=&quot;headerlink&quot; title=&quot;使用 Rx 的奇淫技巧&quot;&gt;&lt;/a&gt;使用 Rx 的奇淫技巧&lt;/h1&gt;&lt;h3 id=&quot;尝试画珠宝图&quot;&gt;&lt;a href=&quot;#尝试画珠宝图&quot; class=&quot;headerlink&quot; title=&quot;尝试画珠宝图&quot;&gt;&lt;/a&gt;尝试画珠宝图&lt;/h3&gt;&lt;p&gt;为你想创建的流画一个珠宝图。 通过画珠宝图，你将会很清楚你应该使用哪些操作符。&lt;/p&gt;
&lt;p&gt;珠宝图就是每个珠宝表示当前的一个事件或状态。珠宝图需要包含输入和输出流。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Reactive-Extensions/RxJS/master/doc/designguidelines/images/throttleWithTimeout.png&quot; alt=&quot;throttleWithSelector&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="RxJS" scheme="http://robin-front.github.io/categories/RxJS/"/>
    
    
      <category term="RxJS" scheme="http://robin-front.github.io/tags/RxJS/"/>
    
  </entry>
  
  <entry>
    <title>为什么选择 RxJS?</title>
    <link href="http://robin-front.github.io/2017/04/04/why-rxjs/"/>
    <id>http://robin-front.github.io/2017/04/04/why-rxjs/</id>
    <published>2017-04-04T09:48:15.000Z</published>
    <updated>2017-04-04T09:48:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Why-RxJS"><a href="#Why-RxJS" class="headerlink" title="Why RxJS?"></a>Why RxJS?</h2><p>你可能会问，为什么选择 RxJS?  为什么不是 Promises? Promises 可以很好地解决异步操作，像使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" target="_blank" rel="external">XMLHttpRequest</a> 去查询服务器, 它预期会返回值并且最终完成请求。  <code>The Reactive Extensions</code> 统一了 <code>JavaScript</code> 中的 <code>Promises</code>, <code>callbacks</code> 以及事件数据，比如 DOM输入, <code>Web Workers</code>, <code>Web Sockets</code>. 一旦我们统一了这些概念，就可以进行各种各样的组合.</p>
<a id="more"></a>
<p>为了让您了解丰富的组合，我们可以创建一个自动完成功能，它从文本输入中接收用户输入，然后查询服务，确保不会对每个键盘输入的进行泛滥地调用，而是以一种更自然的方式调用。</p>
<p>首先，我们将引用JavaScript文件，包括jQuery，尽管RxJS没有依赖于jQuery …
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://code.jquery.com/jquery.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"rx.lite.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>接下来，我们将从输入框获取用户输入，使用<a href="content/observable/observable_methods/fromevent.html"><code>Rx.Observable.fromEvent</code></a> 方法监听 <code>keyup</code> 事件.  如果 <a href="http://jquery.com" target="_blank" rel="external">jQuery</a>, <a href="http://zeptojs.com/" target="_blank" rel="external">Zepto</a>, <a href="https://angularjs.org/" target="_blank" rel="external">AngularJS</a> and <a href="http://emberjs.com/" target="_blank" rel="external">Ember.js</a> 可用，将会使用它们来绑定事件, 否则将使用原生事件绑定. 这跟您的框架思考事件的一致方式，因此没有任何惊喜。
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $input = $(<span class="string">'#input'</span>),</div><div class="line">    $results = $(<span class="string">'#results'</span>);</div><div class="line"></div><div class="line"><span class="comment">/* 只从 keyup 事件获得输入值 */</span></div><div class="line"><span class="keyword">var</span> keyups = Rx.Observable.fromEvent($input, <span class="string">'keyup'</span>)</div><div class="line">    .map(<span class="function"><span class="params">e</span> =&gt;</span> e.target.value)</div><div class="line">    .filter(<span class="function"><span class="params">text</span> =&gt;</span> text.length &gt; <span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="comment">/* 函数节流输出设置为 500ms */</span></div><div class="line"><span class="keyword">var</span> throttled = keyups.throttle(<span class="number">500</span> <span class="comment">/* ms */</span>);</div><div class="line"></div><div class="line"><span class="comment">/* 现在判断值是否有改变，只获取不同的值 */</span></div><div class="line"><span class="keyword">var</span> distinct = throttled.distinctUntilChanged();</div></pre></td></tr></table></figure></p>
<p>现在，让我们来查询维基百科！在RxJS中，我们可以立即通过<code>Rx.Observable.fromPromise</code>方法绑定到任何<a href="https://github.com/promises-aplus/promises-spec" target="_blank" rel="external">Promises A+</a>的实现上，或者直接返回它，并将其封装。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">searchWikipedia</span> (<span class="params">term</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> $.ajax(&#123;</div><div class="line">        <span class="attr">url</span>: <span class="string">'http://en.wikipedia.org/w/api.php'</span>,</div><div class="line">        <span class="attr">dataType</span>: <span class="string">'jsonp'</span>,</div><div class="line">        <span class="attr">data</span>: &#123;</div><div class="line">            <span class="attr">action</span>: <span class="string">'opensearch'</span>,</div><div class="line">            <span class="attr">format</span>: <span class="string">'json'</span>,</div><div class="line">            <span class="attr">search</span>: term</div><div class="line">        &#125;</div><div class="line">    &#125;).promise();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一旦创建，现在我们可以将不同的节流输入绑定在一起，然后查询服务。在这种情况下，我们将调用<code>flatMapLatest</code>获取该值，并确保我们不会有任何混乱的调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> suggestions = distinct.flatMapLatest(searchWikipedia);</div></pre></td></tr></table></figure>
<p>最后，我们将在可观察对象上调用<code>subscribe</code>方法开始拉数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">suggestions.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">var</span> res = data[<span class="number">1</span>];</div><div class="line"></div><div class="line">    <span class="comment">/* Do something 像数据绑定 */</span></div><div class="line">    $results.empty();</div><div class="line"></div><div class="line">    $.each(res, (_, value) =&gt; $(<span class="string">'&lt;li&gt;'</span> + value + <span class="string">'&lt;/li&gt;'</span>).appendTo($results));</div><div class="line">&#125;, error =&gt; &#123;</div><div class="line">    <span class="comment">/* handle any errors */</span></div><div class="line">    $results.empty();</div><div class="line"></div><div class="line">    $(<span class="string">'&lt;li&gt;Error: '</span> + error + <span class="string">'&lt;/li&gt;'</span>).appendTo($results);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><a href="https://github.com/Reactive-Extensions/RxJS#why-rxjs" target="_blank" rel="external">翻译参考</a>
<a href="https://robin-front.gitbooks.io/rxjs-doc-chinese/content/why_rxjs.html" target="_blank" rel="external">同步发布RxJS中文文档</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Why-RxJS&quot;&gt;&lt;a href=&quot;#Why-RxJS&quot; class=&quot;headerlink&quot; title=&quot;Why RxJS?&quot;&gt;&lt;/a&gt;Why RxJS?&lt;/h2&gt;&lt;p&gt;你可能会问，为什么选择 RxJS?  为什么不是 Promises? Promises 可以很好地解决异步操作，像使用 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;XMLHttpRequest&lt;/a&gt; 去查询服务器, 它预期会返回值并且最终完成请求。  &lt;code&gt;The Reactive Extensions&lt;/code&gt; 统一了 &lt;code&gt;JavaScript&lt;/code&gt; 中的 &lt;code&gt;Promises&lt;/code&gt;, &lt;code&gt;callbacks&lt;/code&gt; 以及事件数据，比如 DOM输入, &lt;code&gt;Web Workers&lt;/code&gt;, &lt;code&gt;Web Sockets&lt;/code&gt;. 一旦我们统一了这些概念，就可以进行各种各样的组合.&lt;/p&gt;
    
    </summary>
    
      <category term="RxJS" scheme="http://robin-front.github.io/categories/RxJS/"/>
    
    
      <category term="RxJS" scheme="http://robin-front.github.io/tags/RxJS/"/>
    
  </entry>
  
  <entry>
    <title>Lerp的应用-利用简单线性插值来平滑动画效果</title>
    <link href="http://robin-front.github.io/2017/03/20/Lerp%E7%9A%84%E5%BA%94%E7%94%A8-%E5%88%A9%E7%94%A8%E7%AE%80%E5%8D%95%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC%E6%9D%A5%E5%B9%B3%E6%BB%91%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C/"/>
    <id>http://robin-front.github.io/2017/03/20/Lerp的应用-利用简单线性插值来平滑动画效果/</id>
    <published>2017-03-20T03:04:39.000Z</published>
    <updated>2017-03-20T03:04:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇的 <a href="http://robin-front.github.io/2017/03/19/RxJS%E7%9A%84%E5%8A%A8%E7%94%BB%E7%AE%80%E4%BB%8B/">RxJS的动画简介</a> 里提到一个动画平滑的小技巧, 这里展示几个例子，它真的很简单却很有用。</p>
<p><code>Lerp</code>是两点之间的线性插值的别称。这是一个实现起来相当简单的效果，但可以真正改善你的动画的外观，如果你将一个对象从点A移动到点B.
<a id="more"></a></p>
<h1 id="它是如何工作的？"><a href="#它是如何工作的？" class="headerlink" title="它是如何工作的？"></a>它是如何工作的？</h1><p>如果您有一个对象的当前位置和目标的位置，您可以线性内插这些点之间的距离的百分比，并在每个动画帧上更新该位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">lerp</span>(<span class="params">position, targetPosition</span>) </span>&#123;</div><div class="line"><span class="comment">// 计算当前位置与目标位置差值的 20%</span></div><div class="line">  position.x += (targetPosition.x - position.x)*<span class="number">0.2</span>;</div><div class="line">  position.y += (targetPosition.y - position.y)*<span class="number">0.2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过这样做，对象移动的量随着位置和目标之间的距离减小而变小。这意味着对象将越来越接近它的目标，速度将减慢，这创造一个很好的缓和效果。</p>
<h1 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h1><p>这里有一个球跟随用户的鼠标或触摸运动的例子。如果我们使球移动到鼠标移动的地方，球的移动可以非常快但看起来有点脱节。如果我们快速移动鼠标，我们也可以看到单独的“球影”。</p>
<iframe width="100%" height="300" src="//codepen.io/anon/embed/avXmyV?slug-hash=avXmyV&default-tab=result&height=300&theme-id=1970&user=anon"></iframe>

<p>这里是同样的演示，除了这次我们使用lerp。不是将球立即向右移动到鼠标位置，我们每次将它移动10％的距离。</p>
<iframe width="100%" height="300" src="//codepen.io/anon/embed/yYZapV?slug-hash=yYZapV&default-tab=result&height=300&theme-id=1970&user=anon"></iframe>

<p>注意球的运动很平滑，整体更令人愉快的效果。</p>
<p>这里是使用lerp的另一个例子。这次我们有一个滚动指示器，当您向下滚动“页面”时更新。</p>
<iframe width="100%" height="300" src="//codepen.io/anon/embed/rOPMvz?slug-hash=rOPMvz&default-tab=result&height=300&theme-id=1970&user=anon"></iframe>

<iframe width="100%" height="300" src="//codepen.io/anon/embed/epxdxe?slug-hash=epxdxe&default-tab=result&height=300&theme-id=1970&user=anon"></iframe>

<p>所以，lerp“把戏”是一个伟大的工具，我们的网络动画套路，以对抗线性或锯齿状的运动。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇的 &lt;a href=&quot;http://robin-front.github.io/2017/03/19/RxJS%E7%9A%84%E5%8A%A8%E7%94%BB%E7%AE%80%E4%BB%8B/&quot;&gt;RxJS的动画简介&lt;/a&gt; 里提到一个动画平滑的小技巧, 这里展示几个例子，它真的很简单却很有用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Lerp&lt;/code&gt;是两点之间的线性插值的别称。这是一个实现起来相当简单的效果，但可以真正改善你的动画的外观，如果你将一个对象从点A移动到点B.
    
    </summary>
    
      <category term="animate" scheme="http://robin-front.github.io/categories/animate/"/>
    
    
      <category term="animate" scheme="http://robin-front.github.io/tags/animate/"/>
    
  </entry>
  
  <entry>
    <title>RxJS的动画简介</title>
    <link href="http://robin-front.github.io/2017/03/19/RxJS%E7%9A%84%E5%8A%A8%E7%94%BB%E7%AE%80%E4%BB%8B/"/>
    <id>http://robin-front.github.io/2017/03/19/RxJS的动画简介/</id>
    <published>2017-03-19T06:40:21.000Z</published>
    <updated>2017-03-19T06:40:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文译自 <a href="https://css-tricks.com/animated-intro-rxjs/" target="_blank" rel="external">An Animated Intro to RxJS</a></p>
<p>你可能听说过RxJS，ReactiveX，或反应式编程，或者甚至只听过函数式编程。这些术语在谈论最新和最前沿的前端技术时变得越来越突出。如果你像我一样，当你第一次尝试学习它时，你感到很困惑。
<a id="more"></a></p>
<p>根据<a href="http://reactivex.io/" target="_blank" rel="external">ReactiveX.io</a>：</p>
<blockquote>
<p>ReactiveX是一个库，用于通过使用可观察序列来组成异步和基于事件的程序。</p>
</blockquote>
<p>这句话包含了很多要消化的内容。在本文中，我们将采用一种不同的方法来学习RxJS（ReactiveX的JavaScript实现）和<code>Observables</code>，通过创建反应式动画。</p>
<h1 id="理解Observable"><a href="#理解Observable" class="headerlink" title="理解Observable"></a>理解Observable</h1><p>数组是元素的集合，例如[1, 2, 3, 4, 5]。你可以立即得到所有的元素，你可以做的事情像<code>map</code>，<code>filter</code>和映射他们。这允许你以任何你想要的方式转换元素的集合。</p>
<p>现在假设阵列中的每个元素随时间发生; 也就是说，你不是立即得到所有的元素，而是一次一个。你可能得到第一个元素在第1秒，下一个在第3秒，依此类推。以下是如何表示：</p>
<p><img src="https://cdn.css-tricks.com/wp-content/uploads/2017/02/rx-article-1.svg" alt="a steam of values"></p>
<p>这可以被描述为值的流，或事件序列，或更确切地，称为<code>observable</code>。</p>
<blockquote>
<p><code>observable</code>是随时间的值的集合。</p>
</blockquote>
<p>就像使用数组一样，您可以对这些值进行映射，过滤等操作，以创建和组合新的<code>observable</code>。最后，你可以订阅这些<code>observable</code>，并在<code>steam</code>的值之后执行你想要做的事。这是RxJS的源。</p>
<h1 id="RxJS起步"><a href="#RxJS起步" class="headerlink" title="RxJS起步"></a>RxJS起步</h1><p>开始使用RxJS的最简单的方法是使用CDN，虽然有<a href="http://reactivex.io/rxjs/manual/installation.html" target="_blank" rel="external">很多方法可以安装</a>，这取决于项目的需要。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- the latest, minified version of RxJS --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/@reactivex/rxjs@latest/dist/global/Rx.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>一旦你的项目中有RxJS，你可以从任何东西中创建一个observable ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> aboutAnything = <span class="number">42</span>;</div><div class="line"></div><div class="line"><span class="comment">// 从变量创建</span></div><div class="line"><span class="comment">// The observable emits that value, then completes.</span></div><div class="line"><span class="keyword">const</span> meaningOfLife$ = Rx.Observable.just(aboutAnything);</div><div class="line"></div><div class="line"><span class="comment">// 从数组或可遍历的结构中创建</span></div><div class="line"><span class="comment">// The observable emits each item from the array, then completes.</span></div><div class="line"><span class="keyword">const</span> myNumber$ = Rx.Observable.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</div><div class="line"></div><div class="line"><span class="comment">// From a promise.</span></div><div class="line"><span class="comment">// The observable emits the result eventually, then completes (or errors).</span></div><div class="line"><span class="keyword">const</span> myData$ = Rx.Observable.fromPromise(fetch(<span class="string">'http://example.com/users'</span>));</div><div class="line"></div><div class="line"><span class="comment">// 从事件中创建</span></div><div class="line"><span class="comment">// The observable continuously emits events from the event listener.</span></div><div class="line"><span class="keyword">const</span> mouseMove$ = Rx.Observable</div><div class="line">  .fromEvent(<span class="built_in">document</span>.documentElement, <span class="string">'mousemove'</span>);</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：变量末尾的美元符号<code>$</code>是一个约定，表示该变量是一个可观察者。<code>Observable</code>可以用来对任何可以表示为随时间变化的值的流进行建模，例如事件，Promises，计时器，间隔和动画。</p>
</blockquote>
<p>因为，这些可观察的东西不做任何事情，至少直到你实际观察他们。一个简单的订阅将做到这一点，使用创建<code>.subscribe()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">myNumber$.subscribe(<span class="function"><span class="params">number</span> =&gt;</span> <span class="built_in">console</span>.log(number));</div><div class="line"></div><div class="line"><span class="comment">// Result:</span></div><div class="line"><span class="comment">// &gt; 1</span></div><div class="line"><span class="comment">// &gt; 2</span></div><div class="line"><span class="comment">// &gt; 3</span></div><div class="line"><span class="comment">// &gt; 4</span></div><div class="line"><span class="comment">// &gt; 5</span></div></pre></td></tr></table></figure>
<p>让我们实践看看：</p>
<iframe height="400" width="100%" src="//codepen.io/davidkpiano/embed/d6f5fa72a9b7b6c2c9141de6fa1ab93f?height=400&theme-id=1&slug-hash=d6f5fa72a9b7b6c2c9141de6fa1ab93f&default-tab=js%2Cresult&user=davidkpiano&embed-version=2&pen-title="></iframe>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> docElm = <span class="built_in">document</span>.documentElement;</div><div class="line"><span class="keyword">const</span> cardElm = <span class="built_in">document</span>.querySelector(<span class="string">'#card'</span>);</div><div class="line"><span class="keyword">const</span> titleElm = <span class="built_in">document</span>.querySelector(<span class="string">'#title'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> mouseMove$ = Rx.Observable</div><div class="line">  .fromEvent(docElm, <span class="string">'mousemove'</span>);</div><div class="line"></div><div class="line">mouseMove$.subscribe(<span class="function"><span class="params">event</span> =&gt;</span> &#123;</div><div class="line">  titleElm.innerHTML = <span class="string">`<span class="subst">$&#123;event.clientX&#125;</span>, <span class="subst">$&#123;event.clientY&#125;</span>`</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>从<code>mouseMove$</code>观察到的，每次<code>mousemove</code>事件发生时，订阅改变<code>titleElm</code>的<code>.innerHTML</code>的鼠标的位置。该<a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-map" target="_blank" rel="external"><code>.map</code></a>操作（据工作原理类似<code>Array.prototype.map</code>方法）可帮助简化事情：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Produces e.g., &#123;x: 42, y: 100&#125; instead of the entire event</span></div><div class="line"><span class="keyword">const</span> mouseMove$ = Rx.Observable</div><div class="line">  .fromEvent(docElm, <span class="string">'mousemove'</span>)</div><div class="line">  .map(<span class="function"><span class="params">event</span> =&gt;</span> (&#123; <span class="attr">x</span>: event.clientX, <span class="attr">y</span>: event.clientY &#125;));</div></pre></td></tr></table></figure>
<p>使用一些数学和内联样式，您可以使卡片朝向鼠标旋转。<code>pos.y / clientHeight</code>和<code>pos.x / clientWidth</code>计算为0和1之间的值，所以乘以由50减去一半（25）产生的值从-25到25，这正是我们需要为我们的旋转值：</p>
<iframe width="100%" height="500" src="//codepen.io/davidkpiano/embed/55cb38a26b9166c41017c6512ea00209?height=500&theme-id=1&slug-hash=55cb38a26b9166c41017c6512ea00209&default-tab=js%2Cresult&user=davidkpiano&embed-version=2&pen-title="></iframe>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> docElm = <span class="built_in">document</span>.documentElement;</div><div class="line"><span class="keyword">const</span> cardElm = <span class="built_in">document</span>.querySelector(<span class="string">'#card'</span>);</div><div class="line"><span class="keyword">const</span> titleElm = <span class="built_in">document</span>.querySelector(<span class="string">'#title'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> &#123; clientWidth, clientHeight &#125; = docElm;</div><div class="line"></div><div class="line"><span class="keyword">const</span> mouseMove$ = Rx.Observable</div><div class="line">  .fromEvent(docElm, <span class="string">'mousemove'</span>)</div><div class="line">  .map(<span class="function"><span class="params">event</span> =&gt;</span> (&#123; <span class="attr">x</span>: event.clientX, <span class="attr">y</span>: event.clientY &#125;))</div><div class="line"></div><div class="line">mouseMove$.subscribe(<span class="function"><span class="params">pos</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> rotX = (pos.y / clientHeight * <span class="number">-50</span>) - <span class="number">25</span>;</div><div class="line">  <span class="keyword">const</span> rotY = (pos.x / clientWidth * <span class="number">50</span>) - <span class="number">25</span>;</div><div class="line"></div><div class="line">  cardElm.style = <span class="string">`</span></div><div class="line">    transform: rotateX(<span class="subst">$&#123;rotX&#125;</span>deg) rotateY(<span class="subst">$&#123;rotY&#125;</span>deg);</div><div class="line">  `;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h1 id="使用-merge-合并"><a href="#使用-merge-合并" class="headerlink" title="使用 .merge 合并"></a>使用 <code>.merge</code> 合并</h1><p>现在让我们假设你想让这个适应触摸设备，不管是鼠标事件或是触摸动作。没有任何混乱的回调，你可以通过RxJS使用很多方法来结合<code>Observable</code>。在这个例子中，可以使用<code>.merge</code>实现。就像交通多条车道合并成一个单一的车道，这将返回一个包含所有数据的<code>Observable</code>通过合并多个<code>Observable</code>.</p>
<p><img src="https://cdn.css-tricks.com/wp-content/uploads/2017/02/merge.png" alt="来源：http://rxmarbles.com/#merge"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> touchMove$ = Rx.Observable</div><div class="line">  .fromEvent(docElm, <span class="string">'touchmove'</span>)</div><div class="line">  .map(<span class="function"><span class="params">event</span> =&gt;</span> (&#123;</div><div class="line">    <span class="attr">x</span>: event.touches[<span class="number">0</span>].clientX,</div><div class="line">    <span class="attr">y</span>: event.touches[<span class="number">0</span>].clientY</div><div class="line">  &#125;));</div><div class="line"></div><div class="line"><span class="keyword">const</span> move$ = Rx.Observable.merge(mouseMove$, touchMove$);</div><div class="line"></div><div class="line">move$.subscribe(<span class="function"><span class="params">pos</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>继续，尝试在触摸屏设备上平移左右：</p>
<iframe width="100%" height="500" src="//codepen.io/davidkpiano/embed/4a430c13f4faae099e5a34cb2a82ce6d?height=500&theme-id=1&slug-hash=4a430c13f4faae099e5a34cb2a82ce6d&default-tab=js%2Cresult&user=davidkpiano&embed-version=2&pen-title="></iframe>

<p>还有很多其他有用的<code>Observable</code><a href="http://reactivex.io/documentation/operators.html#combining" target="_blank" rel="external">合并方法</a>，如<code>.switch()</code>，<code>.combineLatest()</code>和<code>.withLatestFrom()</code>，我们继续关注下一个点。</p>
<h1 id="添加平滑的运动"><a href="#添加平滑的运动" class="headerlink" title="添加平滑的运动"></a>添加平滑的运动</h1><p>旋转卡动作有点太死板。只要鼠标（或手指）停止，旋转即刻停止。为了解决这个问题，线性内插（线性插值）都可以使用。一般技术中描述这个<a href="https://codepen.io/rachsmith/post/animation-tip-lerp" target="_blank" rel="external">伟大的教程由雷切尔·史密斯</a>。本质上，而不是从A点跳到B，线性插值会在每一个动画运行一小部分。这将产生一个平滑的过渡，甚至当鼠标/触摸移动已停止。</p>
<p>让我们创建一个函数实现这个功能：计算给定初始值和终值下一个值，采用线性插值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">lerp</span>(<span class="params">start, end</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> dx = end.x - start.x;</div><div class="line">  <span class="keyword">const</span> dy = end.y - start.y;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">x</span>: start.x + dx * <span class="number">0.1</span>,</div><div class="line">    <span class="attr">y</span>: start.y + dy * <span class="number">0.1</span>,</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>非常简约。我们有一个纯函数每次返回一个新的，线性内插的位置值，通过移动当前的（开始）接近每个动画帧上的下一个（完）位置10％的位置。</p>
<h1 id="调度和-interval"><a href="#调度和-interval" class="headerlink" title="调度和.interval"></a>调度和.interval</h1><p>问题是，我们如何在RxJS中表示动画帧？原来，RxJS有一个叫做<code>Schedulers</code>的东西，它控制什么时候从一个<code>observable</code>发出数据，当订阅都开始接收值。</p>
<p>使用<a href="http://reactivex.io/documentation/operators/interval.html" target="_blank" rel="external"><code>Rx.Observable.interval()</code></a>，您可以创建一个<code>observable</code>，它在固定的时间间隔发出值，例如每隔一秒（Rx.Observable.interval(1000)）。如果创建一个非常微小的时间间隔，例如<code>Rx.Observable.interval(0)</code>，并希望它只在每个动画帧上发出值，那么在动画帧内<code>Rx.Scheduler.animationFrame</code>每隔16到17ms就会发出一个值，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> animationFrame$ = Rx.Observable.interval(<span class="number">0</span>, Rx.Scheduler.animationFrame);</div></pre></td></tr></table></figure>
<h1 id="结合-withLatestFrom"><a href="#结合-withLatestFrom" class="headerlink" title="结合.withLatestFrom"></a>结合<code>.withLatestFrom</code></h1><p>要创建平滑线性插值，您只需要关心每个动画帧的最新鼠标或触摸位置。要做到这一点，有一个操作符叫<code>.withLatestFrom()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> smoothMove$ = animationFrame$</div><div class="line">  .withLatestFrom(move$, (frame, move) =&gt; move);</div></pre></td></tr></table></figure>
<p>现在，<code>smoothMove$</code>是一个新的<code>observable</code>，<code>move$</code> 只有当<code>animationFrame$</code>发出一个值时，才会发出最新的值。这是必须的 - 你并不想要的动画帧外发出的值（除非你真的喜欢jank）。第二个参数是描述当组合来自每个可观察的最新值时要做什么的函数。在这种情况下，唯一重要的值是<code>move</code>值，这是所有返回的值。</p>
<p><img src="https://cdn.css-tricks.com/wp-content/uploads/2017/02/with-latest-from.png" alt="withLatestFrom"></p>
<h1 id="与过渡-scan"><a href="#与过渡-scan" class="headerlink" title="与过渡.scan"></a>与过渡<code>.scan</code></h1><p>现在你有一个<code>observable</code>从<code>move$</code>每个动画帧发出最新的值，是时候添加线性插值了。<a href="http://reactivex.io/documentation/operators/scan.html" target="_blank" rel="external"><code>.scan()</code></a>运算符“积累”从可观察到的当前值和下一个值，提供给需要这些值的函数。</p>
<p><img src="https://cdn.css-tricks.com/wp-content/uploads/2017/02/scan.png" alt="#scan"></p>
<p>这对于我们的线性插值用例是完美的。记住，我们的<code>lerp(start, end)</code>函数有两个参数：<code>start（current）</code>值和<code>end（next）</code>值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> smoothMove$ = animationFrame$</div><div class="line">  .withLatestFrom(move$, (frame, move) =&gt; move)</div><div class="line">  .scan(<span class="function">(<span class="params">current, next</span>) =&gt;</span> lerp(current, next));</div><div class="line">  <span class="comment">// or simplified: .scan(lerp)</span></div></pre></td></tr></table></figure>
<p>现在，您可以订阅<code>smoothMove$</code>代替<code>move$</code>在操作中查看线性插值：</p>
<iframe width="100%" height="500" src="//codepen.io/davidkpiano/embed/127ee82ad742b4dddd657703e2259852?height=500&theme-id=1&slug-hash=127ee82ad742b4dddd657703e2259852&default-tab=js%2Cresult&user=davidkpiano&embed-version=2&pen-title="></iframe>

<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p><code>RxJS</code> 不是一个动画库，当然，但对于处理随时间变化的值，它的可组合以及声明性的方式是<code>ReactiveX</code>演示动画的核心概念。反应式编程是考虑编程的另类方式，具有许多优点：</p>
<ul>
<li>它是声明性的，可组合的和不可变的，避免回调地狱，并使你的代码更简洁，可重用和模块化。</li>
<li>它在处理所有类型的异步数据时非常有用，无论是获取数据，通过<code>WebSockets</code>进行通信，监听来自多个源的外部事件，甚至是动画。</li>
<li>“关注的分离” - 您使用<code>Observable</code>和运算符声明性地表示您期望的数据，然后在一个单独的上下文环境中处理<code>.subscribe()</code>，而不会在您的原代码上产生副作用。</li>
<li>有这么多语言的实现了它 - <code>Java</code>，<code>PHP</code>，<code>Python</code>，<code>Ruby</code>，<code>C＃</code>，<code>Swift</code>和其他你可能没有听说过的。</li>
<li>它不是一个框架，它与许多流行的框架（如React，Angular和Vue）可以非常好地融合在一起。</li>
<li>你可以得到行家指点，如果你想要，但<code>ReactiveX</code>从被提出到现在实施了近十年前（2009年），由创意所产生的<a href="http://conal.net/papers/icfp97/" target="_blank" rel="external"><code>Conal Elliott</code>和保罗·胡达克</a> 2年前（1997年），在描述功能性反应的动画（惊喜惊喜）。不用说，它经过了足够的测试。</li>
</ul>
<p>本文探讨了一些有用的部分和<code>RxJS</code>的概念-创建与订阅<code>.fromEvent()</code>和<code>.interval()</code>，对订阅操作<code>.map()</code>和<code>.scan()</code>，多个订阅相结合<code>.merge()</code>和<code>.withLatestFrom()</code>，并与引入调度<code>Rx.Scheduler.animationFrame</code>。有很多其他有用的资源学习RxJS：</p>
<ul>
<li><a href="http://reactivex.io/rxjs/" target="_blank" rel="external">ReactiveX：RxJS</a> - 官方文档</li>
<li><a href="http://rxmarbles.com/" target="_blank" rel="external">RxMarbles</a> - 用于可视化观察</li>
<li><a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754" target="_blank" rel="external">Reactive编程的介绍</a></li>
</ul>
<p>如果你想进一步深入<code>RxJS动画</code>（和使用更多的CSS变量），请查看<a href="http://slides.com/davidkhourshid/reactanim#/" target="_blank" rel="external">我的幻灯片从<code>CSS Dev Conf 2016</code></a>和<a href="https://www.youtube.com/watch?v=lTCukb6Zn3g" target="_blank" rel="external">我2016年的演讲从JSConf冰岛</a>关于反应式动画与CSS变量。这里有一些使用RxJS创建的动画可能对触发灵感有帮助：</p>
<ul>
<li><a href="http://codepen.io/davidkpiano/pen/Vmyyzd" target="_blank" rel="external">3D数字时钟</a></li>
<li><a href="http://codepen.io/davidkpiano/pen/mAoaxP" target="_blank" rel="external">心脏app概念</a></li>
<li><a href="http://codepen.io/Enki/pen/eBwKgO" target="_blank" rel="external">透视使用RxJS拖动</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文译自 &lt;a href=&quot;https://css-tricks.com/animated-intro-rxjs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;An Animated Intro to RxJS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;你可能听说过RxJS，ReactiveX，或反应式编程，或者甚至只听过函数式编程。这些术语在谈论最新和最前沿的前端技术时变得越来越突出。如果你像我一样，当你第一次尝试学习它时，你感到很困惑。
    
    </summary>
    
      <category term="RxJS" scheme="http://robin-front.github.io/categories/RxJS/"/>
    
    
      <category term="RxJS" scheme="http://robin-front.github.io/tags/RxJS/"/>
    
  </entry>
  
  <entry>
    <title>通过动图简单通俗地了解Flexbox的工作原理</title>
    <link href="http://robin-front.github.io/2017/03/13/%E9%80%9A%E8%BF%87%E5%8A%A8%E5%9B%BE%E7%AE%80%E5%8D%95%E9%80%9A%E4%BF%97%E5%9C%B0%E4%BA%86%E8%A7%A3Flexbox%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://robin-front.github.io/2017/03/13/通过动图简单通俗地了解Flexbox的工作原理/</id>
    <published>2017-03-13T03:31:42.000Z</published>
    <updated>2017-03-13T03:31:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文译自 <a href="https://medium.freecodecamp.com/even-more-about-how-flexbox-works-explained-in-big-colorful-animated-gifs-a5a74812b053#.iwqlenuqq" target="_blank" rel="external">Scott Domes</a></p>
<p>Flex属性是一个复合属性，而大部分教程中都只设置一个值，但其实它包含了 <code>flex-basis</code>、<code>flex-grow</code>、<code>flex-shrink</code>.
让我们深入了解Flexbox - 以及如何利用它来构建适应性强和漂亮的布局.
<a id="more"></a></p>
<h3 id="属性一：-Flex-Basis"><a href="#属性一：-Flex-Basis" class="headerlink" title="属性一： Flex-Basis"></a>属性一： Flex-Basis</h3><p>在<a href="https://medium.freecodecamp.com/an-animated-guide-to-flexbox-d280cf6afc35#.s7qtdlnbf" target="_blank" rel="external">上一篇文章</a>中，我们主要把它用于外部容器中。这一次，我们试着把它用在容器内的子元素中。</p>
<p>这是一个很不起眼的属性，但也很直接。</p>
<p><code>Flex-basis</code> 控制着一个元素的默认大小，在其他 flex 属性应用之前。</p>
<p>在下面的 GIF 看来，它的作用和 <code>width</code> 的作用一样：</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*S3LKFr_BICUtAWA5LOFxVw.gif" alt="flex-basis"></p>
<p>是什么让 <code>flex-basis</code> 表现得和 <code>width</code> 一样？事实上，它对应着 flex 的坐标轴。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*_Ruy6jFG7gUpSf76IUcJTQ.png" alt="flex axes"></p>
<blockquote>
<p>flex-basis 影响无素在主轴上的大小</p>
</blockquote>
<p>让我们看看保持 <code>flex-basis</code> 的值不变，但是改变主轴方向会有什么变化：</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*W4QU1Fw9kDLEH2m-J9VGyw.gif" alt="flex direction"></p>
<p>注意到，我从手动设置高度变成手动设置宽度。 <code>Flex-basis</code> 影响宽度还是高度取决于 <code>flex-direction</code> 的值。</p>
<h3 id="属性二：Flex-Grow"><a href="#属性二：Flex-Grow" class="headerlink" title="属性二：Flex Grow"></a>属性二：Flex Grow</h3><p>现在，我们来点更复杂的。</p>
<p>首先，让我们设置给所有方块设置相同的宽度，120px:</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*dON3-0RooiPyfDr0DBEOmA.png" alt="same width"></p>
<p>现在，当它加上属性 <code>flex-grow</code>（默认值为0）.这意味着，不允许方块自动充满容器。</p>
<p>没理解？现在给每个方块的 <code>flex-grow</code> 属性设置为 <code>1</code>：</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*cK-yB4z_L6bmEqoG5qDoRA.png" alt="flex-grow"></p>
<p>所有方块共同充满了容器的整个宽度，并且是平均分。 <code>flex-grow</code> 属性覆盖了 <code>width</code> 属性。</p>
<p>让人困惑的是 <code>flex-grow</code> 的值到底是什么意思？ <code>flex-grow: 1</code> 意味着什么？</p>
<p>好吧，下图是给每个方块设置 <code>flex-grow</code> 值为 <code>999</code> 的表现：</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*p2fLcy13xFU9GjtM4cbHEw.png" alt="flex-grow:999"></p>
<p>这真是。。完全一样。</p>
<p>那是因为 <code>flex-grow</code> 不是一个绝对的值，而是一个相对的值。</p>
<p>重要的不是一个方块 <code>flex-grow</code> 值的本身，而是这个值和其他方块的值的关系。</p>
<p>如果给每个方块设置 <code>flex-grow: 1</code>， 然后调整第3个方块的 <code>flex-grow</code> 属性，可以看到如下变化：</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*gHyLHG52cySgLmy0x-edZA.gif" alt="flex-grow change"></p>
<p>想要真正明白这里发生了什么，让我们快速略过一个简单的数学计算。</p>
<p>每个正方形都以flex-grow为1开始。如果我们将每个正方形的flex-grow相加，则总和为6。因此，容器被分成6个单独的部分。<em>每个正方形增长到可用空间的1/6以填满容器。</em></p>
<p>当设置第3个方块的<code>flex-grow</code> 为 2， 现在容器被分成7份，因为 <code>flex-grow</code> 属性的值的总和为 <code>1+1+2+1+1+1</code>.</p>
<p>方块3获得 2/7 的宽度，剩下的获得 1/7。</p>
<p>当设置第3个方块为 <code>flex-grow: 3</code>， 容器被分成8份（1+1+3+1+1+1）, 方块3占 3/8, 剩下的占 1/8.</p>
<p>以此类推。</p>
<p><code>flex-grow</code>是占所有值总和的比例。如果给所有方块设置<code>flex-grow: 4</code>, 方块3设置 <code>flex-grow: 12</code>, 效果和给它们分别设置 1 和 3 是一样的。</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*JnjR4ULs8de0so1bdUPogw.png" alt="flex-grow"></p>
<p>最后一点，<code>flex-grow</code> 和 <code>flex-basis</code> 都和主轴对应。我们的方块只会增长宽度，除非设置 <code>flex-direction</code> 为 <code>column</code>.</p>
<h3 id="属性三：-Flex-Shrink"><a href="#属性三：-Flex-Shrink" class="headerlink" title="属性三： Flex Shrink"></a>属性三： Flex Shrink</h3><p><code>flex-shrink</code> 和 <code>flex-grow</code>正好相反，决定每个方块可以收缩多少。</p>
<p>它只有在元素必须收缩以适应其容器时才起作用 - 即当容器太小时。</p>
<p>它的主要用途是指定哪些元素要缩小，哪些元素不用缩小。默认情况下，每个方块的 <code>flex-shrink</code> 值为1 - 这意味着它会随着容器的收缩而收缩。</p>
<p>让我们看看它的表现。在下面的GIFS中，正方形的<code>flex-grow</code>为1，因此它们填充了容器，并且<code>flex-shrink</code>为1，因此它们被允许收缩.</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*FVO9kX3wwqakhcT9JWS2Ww.gif" alt="flex-shrink"></p>
<p>现在让我们将方块3的<code>flex-shrink</code>设置为0.它禁止收缩，所以它会增长以适应容器，但它拒绝收缩到其设置的120px宽度以下。</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*GrLzJ4jH3v2Z5Va_TMOXkQ.gif" alt="flex-shrink"></p>
<p><code>flex-shrink</code>的默认值是1 - 这意味着你的元素会收缩，除非设置为0去禁止它。</p>
<p>同样，<code>flex-shrink</code> 是按比例的。如果一个盒子的<code>flex-shrink</code>为6，其余的<code>flex-shrink</code>为2，一个盒子将以3倍的速度缩减，当空间被压缩。</p>
<p>注意这里说的是：具有3x弹性收缩的方块将比其他方块缩短3倍。<em>这并不意味着它将收缩1/3的宽度。</em></p>
<p>稍后，我们会深入了解这到底会收缩或增长多少，在此之前，先来看一下最后一个属性，并把所有混在一起。</p>
<h3 id="属性四：-Flex"><a href="#属性四：-Flex" class="headerlink" title="属性四： Flex"></a>属性四： Flex</h3><p>flex 是 grow, shrink 以及 basis 的缩写，复合属性。</p>
<p>它的默认值是 0(grow) 1（shrink）auto(basis).</p>
<p>最后一个例子，让我们简化到两个 boxs</p>
<p>这是它们的属性：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.square</span><span class="selector-id">#one</span> &#123;</div><div class="line">  <span class="attribute">flex</span>: <span class="number">2</span> <span class="number">1</span> <span class="number">300px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.square</span><span class="selector-id">#two</span> &#123;</div><div class="line">  <span class="attribute">flex</span>: <span class="number">1</span> <span class="number">2</span> <span class="number">300px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>两者都有相同的 <code>flex-basis</code>属性。这意味着如果它们都有足够的空间（容器是600px加上边距和填充空间），它们都将是300px宽度。</p>
<p>但随着容器的增长，Square 1（具有更高的flex-grow）将增长两倍。随着盒子的收缩，Square 2（具有更高的flex-shrink）将缩短两倍。</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*BKZt7AT5eFee4KRhe82gew.gif" alt="all together"></p>
<h4 id="它是如何增长和收缩的"><a href="#它是如何增长和收缩的" class="headerlink" title="它是如何增长和收缩的"></a>它是如何增长和收缩的</h4><p>这里有可能会混淆：当Square 1增长时，它不会增长到Square 2的两倍。同样，当Square 2缩小时，它不会缩小到Square 1的一半大小 - 即使比率的收缩率为2比1。</p>
<blockquote>
<p>这不是他们的大小 2比1或1比2.这是他们的收缩和增长的速度的比例。</p>
</blockquote>
<h4 id="一点数学计算"><a href="#一点数学计算" class="headerlink" title="一点数学计算"></a>一点数学计算</h4><p>容器的起始大小为640像素。在容器的每一边占用20px的填充后，这留下了足够的空间，两个方块恢复到它们的<code>flex-basis</code>的300px.</p>
<p>当容器设置为430px时，我们丢失了210px的空间。正方形1，flex-shrink:1，失去70px。方形2，flex-shrink: 2，失去140px。</p>
<p>当容器缩小到340px时，我们现在已经失去了300像素的空间。方块1损失100像素，方块2损失200像素.</p>
<p>损失的空间根据它们各自的收缩率（2:1）的比率来分割。</p>
<p><code>flex-grow</code>同样。当容器增长到940px，我们获得了300px的空间，Square 1获得了额外的200px，Square 2获得了额外的100px。</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*70-KTWYpA2LnLjqi0xDrJA.gif" alt="grow and shrink"></p>
<p>在上面的GIF中，您可以看到宽度如何根据比率进行调整，增量（Δ）显示与基于<code>flex-basis</code>的差异。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文译自 &lt;a href=&quot;https://medium.freecodecamp.com/even-more-about-how-flexbox-works-explained-in-big-colorful-animated-gifs-a5a74812b053#.iwqlenuqq&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Scott Domes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Flex属性是一个复合属性，而大部分教程中都只设置一个值，但其实它包含了 &lt;code&gt;flex-basis&lt;/code&gt;、&lt;code&gt;flex-grow&lt;/code&gt;、&lt;code&gt;flex-shrink&lt;/code&gt;.
让我们深入了解Flexbox - 以及如何利用它来构建适应性强和漂亮的布局.
    
    </summary>
    
      <category term="Flexbox" scheme="http://robin-front.github.io/categories/Flexbox/"/>
    
    
      <category term="Flexbox" scheme="http://robin-front.github.io/tags/Flexbox/"/>
    
  </entry>
  
  <entry>
    <title>js遍历Object对象可枚举属性、不可枚举属性、原型链属性和自身属性</title>
    <link href="http://robin-front.github.io/2017/01/13/js%E9%81%8D%E5%8E%86Object%E5%8F%AF%E6%9E%9A%E4%B8%BE%E5%B1%9E%E6%80%A7%E3%80%81%E4%B8%8D%E5%8F%AF%E6%9E%9A%E4%B8%BE%E5%B1%9E%E6%80%A7%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%B1%9E%E6%80%A7%E5%92%8C%E8%87%AA%E8%BA%AB%E5%B1%9E%E6%80%A7/"/>
    <id>http://robin-front.github.io/2017/01/13/js遍历Object可枚举属性、不可枚举属性、原型链属性和自身属性/</id>
    <published>2017-01-13T02:19:27.000Z</published>
    <updated>2017-01-13T02:19:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>利用hasOwnProperty、getOwnPropertyNames、Object.keys、for…in遍历对象的可枚举属性、不可枚举属性、原型链上的属性和自身属性。
<a id="more"></a></p>
<p>首先来看看各种方法的用法及兼容性。</p>
<h3 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty"></a>hasOwnProperty</h3><p>Object.prototype.hasOwnProperty(name) 方法用来判断某个对象是否含有指定的自身属性，它本身是对象原型链上的默认方法。</p>
<p>hasOwnProperty 方法是 ES3 就标准化了，所以不用担心兼容性问题。</p>
<p>但由于 hasOwnProperty 是原型链上的方法，所以有可能被对象的自身方法所屏蔽。如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;</div><div class="line">    <span class="attr">hasOwnProperty</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">bar</span>: <span class="string">'Here be dragons'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">foo.hasOwnProperty(<span class="string">'bar'</span>); <span class="comment">// 始终返回 false</span></div><div class="line"></div><div class="line"><span class="comment">// 如果担心这种情况，可以直接使用原型链上真正的 hasOwnProperty 方法</span></div><div class="line">(&#123;&#125;).hasOwnProperty.call(foo, <span class="string">'bar'</span>); <span class="comment">// true</span></div><div class="line"><span class="built_in">Object</span>.prototype.hasOwnProperty.call(foo, <span class="string">'bar'</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="getOwnPropertyNames"><a href="#getOwnPropertyNames" class="headerlink" title="getOwnPropertyNames"></a>getOwnPropertyNames</h3><p>Object.getOwnPropertyNames(obj)方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组, 该方法不会获取到原型链上的属性。如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 父类构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ParentClass</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">ParentClass.prototype.inheritedMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 继承</span></div><div class="line"><span class="keyword">var</span> ChildClass = <span class="built_in">Object</span>.create(ParentClass.prototype, &#123;</div><div class="line">  <span class="comment">// 不可枚举属性</span></div><div class="line">  getFoo: &#123;</div><div class="line">    <span class="attr">value</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.foo; &#125;,</div><div class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 自身可枚举属性</span></div><div class="line">ChildClass.foo = <span class="number">1</span>;</div><div class="line"><span class="comment">// 再定义一个原型链属性</span></div><div class="line">ChildClass.prototype.prototypeMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(my_obj).sort()); <span class="comment">// ["foo", "getFoo"]</span></div></pre></td></tr></table></figure>
<p>兼容性到 IE9, es 5标准。</p>
<h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><p>返回该对象的所有可枚举自身属性的属性名。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">//</span>具有随机键排序的数组类对象</div><div class="line">var an_obj = &#123; <span class="number">100</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">7</span>: <span class="string">'c'</span> &#125;;</div><div class="line">console.log(Object.keys(an_obj)); <span class="regexp">//</span> console: [<span class="string">'2'</span>, <span class="string">'7'</span>, <span class="string">'100'</span>]</div></pre></td></tr></table></figure>
<p>这些属性的顺序与手动遍历（如for..in）该对象属性时的一致。</p>
<blockquote>
<p>注意：Object.keys 和 getOwnPropertyNames ，在ES5，如果此方法的参数不是一个对象（原始的），那么它会造成 TypeError。在ES6，非对象的参数将被强制转换为一个对象。</p>
</blockquote>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Object.keys(<span class="string">"foo"</span>);</div><div class="line">Object.getOwnPropertyNames(<span class="string">"foo"</span>);</div><div class="line"><span class="regexp">//</span> <span class="symbol">TypeError:</span> <span class="string">"foo"</span> is <span class="keyword">not</span> an object (ES5 code)</div><div class="line"></div><div class="line">Object.keys(<span class="string">"foo"</span>);</div><div class="line"><span class="regexp">//</span> [<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>]                   (ES6 code)</div><div class="line">Object.getOwnPropertyNames(<span class="string">"foo"</span>);</div><div class="line"><span class="regexp">//</span> [<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"length"</span>]                   (ES6 code)</div></pre></td></tr></table></figure>
<p>兼容性到 IE9, es 5标准。</p>
<h3 id="for-in"><a href="#for-in" class="headerlink" title="for..in"></a>for..in</h3><p>手动遍历，可以遍历到自身和原型链上所有可枚举的属性。</p>
<h3 id="只获取自身可枚举属性"><a href="#只获取自身可枚举属性" class="headerlink" title="只获取自身可枚举属性"></a>只获取自身可枚举属性</h3><ul>
<li>直接用 <code>Object.keys()</code></li>
<li>IE9 以下可以通过<code>hasOwnProperty</code>实现：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!<span class="built_in">Object</span>.keys) <span class="built_in">Object</span>.keys = <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (o !== <span class="built_in">Object</span>(o))</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Object.keys called on a non-object'</span>);</div><div class="line">  <span class="keyword">var</span> k=[],p;</div><div class="line">  <span class="keyword">for</span> (p <span class="keyword">in</span> o) <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(o,p)) k.push(p);</div><div class="line">  <span class="keyword">return</span> k;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="只获取自身不可枚举属性"><a href="#只获取自身不可枚举属性" class="headerlink" title="只获取自身不可枚举属性"></a>只获取自身不可枚举属性</h3><ul>
<li>通过 <code>Object.keys()</code> 排除可枚举属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> target = myObject;</div><div class="line"><span class="keyword">var</span> enum_and_nonenum = <span class="built_in">Object</span>.getOwnPropertyNames(target);</div><div class="line"><span class="comment">// 排除可枚举属性</span></div><div class="line"><span class="keyword">var</span> enum_only = <span class="built_in">Object</span>.keys(target);</div><div class="line"><span class="keyword">var</span> nonenum_only = enum_and_nonenum.filter(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> indexInEnum = enum_only.indexOf(key);</div><div class="line">    <span class="keyword">if</span> (indexInEnum == <span class="number">-1</span>) &#123;</div><div class="line">        <span class="comment">// not found in enum_only keys mean the key is non-enumerable,</span></div><div class="line">        <span class="comment">// so return true so we keep this in the filter</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(nonenum_only);</div></pre></td></tr></table></figure>
<ul>
<li>通过<code>propertyIsEnumerable</code>判断，该方法返回Boolean值，不可枚举返回false。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> target = myObject;</div><div class="line"><span class="keyword">var</span> enum_and_nonenum = <span class="built_in">Object</span>.getOwnPropertyNames(target);</div><div class="line"><span class="keyword">var</span> enum_only = <span class="built_in">Object</span>.keys(target);</div><div class="line"><span class="keyword">var</span> nonenum_only = enum_and_nonenum.filter(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">    <span class="comment">// 筛选不可枚举属性</span></div><div class="line">    <span class="keyword">return</span> !target.propertyIsEnumerable(key)</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(nonenum_only);</div></pre></td></tr></table></figure>
<h3 id="只获取原型链上的可枚举属性"><a href="#只获取原型链上的可枚举属性" class="headerlink" title="只获取原型链上的可枚举属性"></a>只获取原型链上的可枚举属性</h3><ul>
<li>直接用 for..in</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.getPrototypeOf(targetObj); <span class="comment">// 跳过遍历自身属性，直接从原型上开始</span></div><div class="line"><span class="keyword">var</span> k=[],p;</div><div class="line"><span class="keyword">for</span> (p <span class="keyword">in</span> o) <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(o,p)) k.push(p);</div><div class="line"><span class="keyword">return</span> k;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意，这样遍历出来的属性也不一定能访问， 因为自身属性可能会屏蔽掉原型上的属性。</p>
</blockquote>
<h3 id="只获取原型链上的不可枚举属性"><a href="#只获取原型链上的不可枚举属性" class="headerlink" title="只获取原型链上的不可枚举属性"></a>只获取原型链上的不可枚举属性</h3><p>比较麻烦，如果使用 getOwnPropertyNames，只能单独获取一层原型链，必须一级一级遍历往上找，而且这也不一定有场景，因为原型链上的方法重名是会被屏蔽的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;利用hasOwnProperty、getOwnPropertyNames、Object.keys、for…in遍历对象的可枚举属性、不可枚举属性、原型链上的属性和自身属性。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="getOwnPropertyNames" scheme="http://robin-front.github.io/tags/getOwnPropertyNames/"/>
    
      <category term="hasOwnProperty" scheme="http://robin-front.github.io/tags/hasOwnProperty/"/>
    
      <category term="Object.keys" scheme="http://robin-front.github.io/tags/Object-keys/"/>
    
  </entry>
  
  <entry>
    <title>比较instanceof与isPrototypeOf</title>
    <link href="http://robin-front.github.io/2017/01/12/%E6%AF%94%E8%BE%83instanceof%E4%B8%8EisPrototypeof/"/>
    <id>http://robin-front.github.io/2017/01/12/比较instanceof与isPrototypeof/</id>
    <published>2017-01-12T09:49:14.000Z</published>
    <updated>2017-01-12T09:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>在javascript中，instanceof 和 isPrototypeOf 都可以判断一个原型是否在另一个实例的原型链中，那他们有什么区别呢，为什么说 isPrototypeOf 可以替代 instanceof 。
<a id="more"></a></p>
<h3 id="instanceof-用法"><a href="#instanceof-用法" class="headerlink" title="instanceof 用法"></a>instanceof 用法</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="comment">// init code</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span><span class="params">()</span> </span>&#123;</div><div class="line">      Super.call(<span class="keyword">this</span>);</div><div class="line">      <span class="comment">// other init code</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">Sub.prototype = <span class="keyword">new</span> Super();</div><div class="line"></div><div class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> Sub();</div></pre></td></tr></table></figure>
<p>对于上面的代码，用 instanceof 可以像这样确定他们的关系：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">instanceof</span> <span class="title">Super</span></span>; // true</div></pre></td></tr></table></figure>
<h3 id="isPrototypeOf-用法"><a href="#isPrototypeOf-用法" class="headerlink" title="isPrototypeOf 用法"></a>isPrototypeOf 用法</h3><p>复用上面的代码，用 isPrototypeOf 可以这样写：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Super.prototype.isPrototypeOf(<span class="function"><span class="keyword">sub</span>)</span>; // true</div></pre></td></tr></table></figure>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>乍一看，都可以用，但某种情况下是有区别的，例如：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var super = &#123;</div><div class="line">    <span class="regexp">//</span> some super properties</div><div class="line">&#125;</div><div class="line"></div><div class="line">var <span class="function"><span class="keyword">sub</span> = <span class="title">Object</span>.<span class="title">create</span></span>(super);</div><div class="line"><span class="function"><span class="keyword">sub</span>.<span class="title">someProp</span> = 5</span>;</div><div class="line"></div><div class="line">var <span class="function"><span class="keyword">sub</span> = <span class="title">Object</span>.<span class="title">create</span></span>(sub);</div><div class="line"></div><div class="line">console.log(super.isPrototypeOf(<span class="function"><span class="keyword">sub</span>))</span>;  // true</div><div class="line">console.log(<span class="function"><span class="keyword">sub</span> <span class="title">instanceof</span> <span class="title">super</span>)</span>;      // TypeError</div></pre></td></tr></table></figure>
<p>这时候 super 并不是构造函数，无法使用 instanceof, 只能使用 isPrototypeOf.</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>结论就是 isPrototypeOf 能使用的场景更广，完全可以替代 instanceof， 只是写起来没那么简洁。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在javascript中，instanceof 和 isPrototypeOf 都可以判断一个原型是否在另一个实例的原型链中，那他们有什么区别呢，为什么说 isPrototypeOf 可以替代 instanceof 。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="instanceof" scheme="http://robin-front.github.io/tags/instanceof/"/>
    
      <category term="isPrototypeOf" scheme="http://robin-front.github.io/tags/isPrototypeOf/"/>
    
  </entry>
  
  <entry>
    <title>javascript通过Vibration API实现手机振动反馈提高用户体验</title>
    <link href="http://robin-front.github.io/2017/01/10/javascript%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E6%8C%AF%E5%8A%A8%E5%8F%8D%E9%A6%88%E6%8F%90%E9%AB%98%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C/"/>
    <id>http://robin-front.github.io/2017/01/10/javascript实现手机振动反馈提高用户体验/</id>
    <published>2017-01-10T05:35:00.000Z</published>
    <updated>2017-01-11T01:13:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>目前大多数的移动设备均具备硬件能力支持振动，让软件代码通过使设备摇晃来向用户提供物理反馈。Vibration API 为 Web应用程序提供访问此硬件的能力。如果设备不支持，则不会产生任何效果。
<a id="more"></a></p>
<h3 id="振动描述"><a href="#振动描述" class="headerlink" title="振动描述"></a>振动描述</h3><p>振动被抽象成【开-关】脉冲的模式，且可以具有变化的长度。参数可以是单个整数，表示持续振动的毫秒数 (ms)；或可由多个整数组成的数组，达到振动和暂停循环的效果。只要单一 window.navigator.vibrate() 函式即可控制振动。</p>
<h3 id="单次振动"><a href="#单次振动" class="headerlink" title="单次振动"></a>单次振动</h3><p>你可指定单一数值，或用只有一个数值成员的数组，让设备振动 1 次：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">window</span><span class="selector-class">.navigator</span><span class="selector-class">.vibrate</span>(200);</div><div class="line"><span class="selector-tag">window</span><span class="selector-class">.navigator</span><span class="selector-class">.vibrate</span>(<span class="selector-attr">[200]</span>);</div></pre></td></tr></table></figure>
<p>以上两个例子都可以使设备振动 200 ms.</p>
<h3 id="多次振动"><a href="#多次振动" class="headerlink" title="多次振动"></a>多次振动</h3><p>一个数组的值描述了装置振动与不振动的交替时间段。数组中的每个值都转换为整数，然后交替解释为设备应该振动的毫秒数和不振动的毫秒数。例如:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">window</span><span class="selector-class">.navigator</span><span class="selector-class">.vibrate</span>(<span class="selector-attr">[200, 100, 200]</span>);</div></pre></td></tr></table></figure>
<p>这会使设备振动200 ms，然后暂停100 ms，然后再次振动设备200 ms。</p>
<p>您可以根据需要设定多个振动/暂停对，数组的值可以是偶数或奇数个； 值得注意的是，由于振动在每个振动周期结束时自动停止，因此您不必提供最后一个值去暂停，换句话说，数组长度只需要设置奇数个。</p>
<h3 id="停止振动"><a href="#停止振动" class="headerlink" title="停止振动"></a>停止振动</h3><p>当调用 window.navigator.vibrate() 的参数为「0」、空白数组，或数组全为「0」时，即可取消目前进行中的振动。</p>
<h3 id="持续振动"><a href="#持续振动" class="headerlink" title="持续振动"></a>持续振动</h3><p>一些基于setInterval和clearInterval操作将允许您创建持续的振动：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> vibrateInterval;</div><div class="line"></div><div class="line"><span class="comment">// Starts vibration at passed in level</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">startVibrate</span><span class="params">(duration)</span> </span>&#123;</div><div class="line">    navigator.vibrate(duration);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Stops vibration</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopVibrate</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// Clear interval and stop persistent vibrating</span></div><div class="line">    <span class="keyword">if</span>(vibrateInterval) clearInterval(vibrateInterval);</div><div class="line">    navigator.vibrate(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Start persistent vibration at given duration and interval</span></div><div class="line"><span class="comment">// Assumes a number value is given</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">startPeristentVibrate</span><span class="params">(duration, interval)</span> </span>&#123;</div><div class="line">    vibrateInterval = setInterval(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">        startVibrate(duration);</div><div class="line">    &#125;, interval);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然上面的代码片段没有考虑到振动参数为数组情况; 基于阵列的持久性振动将需要计算数组项的和，并基于该数量创建周期（可能具有额外的延迟）。</p>
<h3 id="生成振动节奏"><a href="#生成振动节奏" class="headerlink" title="生成振动节奏"></a>生成振动节奏</h3><p>可以通过<a href="https://naschq.github.io/vibe.js/" target="_blank" rel="external">vibe.js tool</a>这个工具来生成你需要的振动频率，然后复制它到你的代码里。</p>
<h3 id="lib"><a href="#lib" class="headerlink" title="lib"></a>lib</h3><p>我写了一个小lib，方便使用<a href="https://github.com/Robin-front/vibrate.js" target="_blank" rel="external">vibrate.js</a></p>
<p>demo: <a href="https://robin-front.github.io/vibrate.js/example/demo.html">DEMO</a></p>
<p>译自： <a href="https://developer.mozilla.org/en-US/docs/Web/API/Vibration_API" target="_blank" rel="external">MDN Vibration API</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前大多数的移动设备均具备硬件能力支持振动，让软件代码通过使设备摇晃来向用户提供物理反馈。Vibration API 为 Web应用程序提供访问此硬件的能力。如果设备不支持，则不会产生任何效果。
    
    </summary>
    
      <category term="Vibration" scheme="http://robin-front.github.io/categories/Vibration/"/>
    
      <category term="html5" scheme="http://robin-front.github.io/categories/Vibration/html5/"/>
    
    
      <category term="Vibration" scheme="http://robin-front.github.io/tags/Vibration/"/>
    
  </entry>
  
  <entry>
    <title>由lodash引出数组Array的slice方法性能探究</title>
    <link href="http://robin-front.github.io/2016/11/25/%E7%94%B1lodash%E5%BC%95%E5%87%BA%E6%95%B0%E7%BB%84Array%E7%9A%84slice%E6%96%B9%E6%B3%95%E6%80%A7%E8%83%BD%E6%8E%A2%E7%A9%B6/"/>
    <id>http://robin-front.github.io/2016/11/25/由lodash引出数组Array的slice方法性能探究/</id>
    <published>2016-11-25T03:05:19.000Z</published>
    <updated>2016-11-25T03:05:19.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>lodash</code> 源码中，发现数组截取操作并没有直接使用<code>array</code>的<code>slice</code>方法，而是写了个 <code>baseSlice</code> 方法，更重要的是 <code>baseSlice</code> 方法里，也并没有使用 <code>slice</code> 方法，而是使用循环索引的方式去实现。这让我陷入思考，难道原生Array的<code>slice</code>方法还不如循环快？</p>
<a id="more"></a>
<p><code>lodash</code> 源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseSlice</span>(<span class="params">array, start, end</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> index = <span class="number">-1</span>,</div><div class="line">      length = array.length;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (start &lt; <span class="number">0</span>) &#123;</div><div class="line">    start = -start &gt; length ? <span class="number">0</span> : (length + start);</div><div class="line">  &#125;</div><div class="line">  end = end &gt; length ? length : end;</div><div class="line">  <span class="keyword">if</span> (end &lt; <span class="number">0</span>) &#123;</div><div class="line">    end += length;</div><div class="line">  &#125;</div><div class="line">  length = start &gt; end ? <span class="number">0</span> : ((end - start) &gt;&gt;&gt; <span class="number">0</span>);</div><div class="line">  start &gt;&gt;&gt;= <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> result = <span class="built_in">Array</span>(length);</div><div class="line">  <span class="keyword">while</span> (++index &lt; length) &#123;</div><div class="line">    result[index] = array[index + start];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>于是就开始写代码比较：</p>
<p>  操作长度为100的数组，执行10000次：
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> baseArray = [];</div><div class="line"><span class="keyword">var</span> i = <span class="number">-1</span>;</div><div class="line"><span class="keyword">while</span> (++ i &lt; <span class="number">100</span>) &#123; <span class="comment">// 定义一个10000长度的数组以供使用</span></div><div class="line">  baseArray[i] = i;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.time(<span class="string">'slice with no args'</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</div><div class="line">  baseArray.slice();</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'slice with no args'</span>);</div><div class="line"><span class="built_in">console</span>.time(<span class="string">'slice with args'</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</div><div class="line">  baseArray.slice(<span class="number">20</span>, <span class="number">40</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'slice with args'</span>);</div><div class="line"><span class="built_in">console</span>.time(<span class="string">'index'</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</div><div class="line">  <span class="keyword">var</span> result = <span class="built_in">Array</span>(<span class="number">100</span>);</div><div class="line">  <span class="keyword">var</span> index = <span class="number">-1</span>;</div><div class="line">  <span class="keyword">var</span> length = baseArray.length;</div><div class="line">  <span class="keyword">while</span> (++index &lt; length) &#123;</div><div class="line">    result[index] = baseArray[index];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'index'</span>);</div><div class="line"><span class="built_in">console</span>.time(<span class="string">'index with no init array'</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</div><div class="line">  <span class="keyword">var</span> result = [];</div><div class="line">  <span class="keyword">var</span> index = <span class="number">-1</span>;</div><div class="line">  <span class="keyword">var</span> length = baseArray.length;</div><div class="line">  <span class="keyword">while</span> (++index &lt; <span class="number">20</span>) &#123;</div><div class="line">    result[index] = baseArray[index];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'index with no init array'</span>);</div></pre></td></tr></table></figure></p>
<p>对比结果：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="string">//</span> <span class="string">chrome</span> <span class="string">版本</span> <span class="number">54.0</span><span class="number">.2840</span><span class="number">.98</span> <span class="string">(64-bit)</span></div><div class="line"><span class="string">slice</span> <span class="string">with</span> <span class="literal">no</span> <span class="attr">args:</span> <span class="number">93.3</span><span class="string">ms</span></div><div class="line"><span class="string">slice</span> <span class="string">with</span> <span class="attr">args:</span> <span class="number">175</span><span class="string">ms</span></div><div class="line"><span class="attr">index:</span> <span class="number">365</span><span class="string">ms</span></div><div class="line"><span class="string">index</span> <span class="string">with</span> <span class="literal">no</span> <span class="string">init</span> <span class="attr">array:</span> <span class="number">546</span><span class="string">ms</span></div><div class="line"><span class="string">//</span> <span class="string">safari</span> <span class="string">版本</span> <span class="number">9.0</span><span class="number">.2</span> <span class="string">(11601.3.9)</span></div><div class="line"><span class="string">slice</span> <span class="string">with</span> <span class="literal">no</span> <span class="attr">args:</span> <span class="number">122.152</span><span class="string">ms</span></div><div class="line"><span class="string">slice</span> <span class="string">with</span> <span class="attr">args:</span> <span class="number">117.181</span><span class="string">ms</span></div><div class="line"><span class="attr">index:</span> <span class="number">60076.301</span><span class="string">ms</span></div><div class="line"><span class="string">index</span> <span class="string">with</span> <span class="literal">no</span> <span class="string">init</span> <span class="attr">array:</span> <span class="number">62055.406</span><span class="string">ms</span></div><div class="line"><span class="string">//firefox</span> <span class="number">50.0</span></div><div class="line"><span class="string">slice</span> <span class="string">with</span> <span class="literal">no</span> <span class="attr">args:</span> <span class="number">462.07</span><span class="string">ms</span></div><div class="line"><span class="string">slice</span> <span class="string">with</span> <span class="attr">args:</span> <span class="number">442.25</span><span class="string">ms</span></div><div class="line"><span class="attr">index:</span> <span class="number">194206.08</span><span class="string">ms</span></div><div class="line"><span class="string">index</span> <span class="string">with</span> <span class="literal">no</span> <span class="string">init</span> <span class="attr">array:</span> <span class="number">184714.59</span><span class="string">ms</span></div></pre></td></tr></table></figure>
<p>由于mac ox无法测试IE,
可以看出，chrome总体要比safafi、firefox快很多；
slice方法上，safari和chrome差不多， chrome下slice有参数比无参数慢；
新建数组Array()和 []性能差不多；</p>
<p>这么看来，那用原生 slice 明显会更好，为什么 lodash 要用循环索引呢？难道是因为一般应用数组都不会这么大，那改成长度为100的数组进行操作；
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="string">//</span> <span class="string">chrome</span></div><div class="line"><span class="string">slice</span> <span class="string">with</span> <span class="literal">no</span> <span class="attr">args:</span> <span class="number">6</span><span class="string">ms</span></div><div class="line"><span class="string">slice</span> <span class="string">with</span> <span class="attr">args:</span> <span class="number">4.12</span><span class="string">ms</span></div><div class="line"><span class="attr">index:</span> <span class="number">5.82</span><span class="string">ms</span></div><div class="line"><span class="string">index</span> <span class="string">with</span> <span class="literal">no</span> <span class="string">init</span> <span class="attr">array:</span> <span class="number">7.96</span><span class="string">ms</span></div><div class="line"><span class="string">//</span> <span class="string">safari</span></div><div class="line"><span class="string">slice</span> <span class="string">with</span> <span class="literal">no</span> <span class="attr">args:</span> <span class="number">9.158</span><span class="string">ms</span></div><div class="line"><span class="string">slice</span> <span class="string">with</span> <span class="attr">args:</span> <span class="number">8.432</span><span class="string">ms</span></div><div class="line"><span class="attr">index:</span> <span class="number">640.311</span><span class="string">ms</span></div><div class="line"><span class="string">index</span> <span class="string">with</span> <span class="literal">no</span> <span class="string">init</span> <span class="attr">array:</span> <span class="number">643.174</span><span class="string">ms</span></div><div class="line"><span class="string">//firefox</span></div><div class="line"><span class="string">slice</span> <span class="string">with</span> <span class="literal">no</span> <span class="attr">args:</span> <span class="number">17.56</span><span class="string">ms</span></div><div class="line"><span class="string">slice</span> <span class="string">with</span> <span class="attr">args:</span> <span class="number">17.53</span><span class="string">ms</span></div><div class="line"><span class="attr">index:</span> <span class="number">2174.15</span><span class="string">ms</span></div><div class="line"><span class="string">index</span> <span class="string">with</span> <span class="literal">no</span> <span class="string">init</span> <span class="attr">array:</span> <span class="number">2198.15</span><span class="string">ms</span></div></pre></td></tr></table></figure></p>
<p>发现结论并没有改变。
然后就向lodash提了question, 回复是：</p>
<blockquote>
<p>The perf wins of Array#slice vs. baseSlice depends on the size of the array. That is a minor point though as the perf of that method is not likely to be an issue. The reason we use baseSlice is because we treat arrays as dense while Array#slice will respect sparse arrays.</p>
</blockquote>
<p>大概意思是，他觉得性能没有太大的差别，Array#slice和baseSlice性能强弱取决于数组的大小。这里采用baseSlice是因为他们要视所有为密集数据，而Array#slice会处理稀疏数组。</p>
<p>然后就有下面的测试：</p>
<p>使用 Array#slice和baseSlice 分别截取数组其中一段，循环1000000次：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> baseArray = [];</div><div class="line"><span class="keyword">var</span> i = <span class="number">-1</span>;</div><div class="line"><span class="keyword">while</span> (++ i &lt; <span class="number">100000</span>) &#123; <span class="comment">// 定义一个10000长度的数组以供使用,这里数组长度并不影响性能，性能影响主要在于截取的长度。</span></div><div class="line">  baseArray[i] = i;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.time(<span class="string">'slice with args'</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)&#123;</div><div class="line">  baseArray.slice(<span class="number">0</span>, <span class="number">20</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'slice with args'</span>);</div><div class="line"><span class="built_in">console</span>.time(<span class="string">'index'</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)&#123;</div><div class="line">  <span class="keyword">var</span> result = <span class="built_in">Array</span>(<span class="number">20</span>);</div><div class="line">  <span class="keyword">var</span> index = <span class="number">-1</span>;</div><div class="line">  <span class="keyword">while</span> (++index &lt; <span class="number">20</span>) &#123;</div><div class="line">    result[index] = baseArray[index];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'index'</span>);</div></pre></td></tr></table></figure>
<p>不同截取长度在chrome下的效果：
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 截取长度 20</span></div><div class="line">slice <span class="keyword">with</span> args: <span class="number">110</span>ms</div><div class="line"><span class="keyword">index</span>: <span class="number">78.9</span>ms</div><div class="line"><span class="comment">// 截取长度 30</span></div><div class="line">slice <span class="keyword">with</span> args: <span class="number">114</span>ms</div><div class="line"><span class="keyword">index</span>: <span class="number">112</span>ms</div><div class="line"><span class="comment">// 截取长度 30</span></div><div class="line">slice <span class="keyword">with</span> args: <span class="number">132</span>ms</div><div class="line"><span class="keyword">index</span>: <span class="number">146</span>ms</div></pre></td></tr></table></figure></p>
<p>由此看出，截取长度为30左右时，Array#slice和loop方式性能基本一样，而 Array#slice 基本不受截取长度的影响。
所以结论是，当长度为30以下时，lodash的方法是比较高效的，当然，这影响微乎其微。像_.chunk方法，一般场景分组都不会太长。</p>
<p>疑惑是，对我的回复的后半句我没怎么看懂，密集数据和稀疏数据对这有什么影响呢？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;lodash&lt;/code&gt; 源码中，发现数组截取操作并没有直接使用&lt;code&gt;array&lt;/code&gt;的&lt;code&gt;slice&lt;/code&gt;方法，而是写了个 &lt;code&gt;baseSlice&lt;/code&gt; 方法，更重要的是 &lt;code&gt;baseSlice&lt;/code&gt; 方法里，也并没有使用 &lt;code&gt;slice&lt;/code&gt; 方法，而是使用循环索引的方式去实现。这让我陷入思考，难道原生Array的&lt;code&gt;slice&lt;/code&gt;方法还不如循环快？&lt;/p&gt;
    
    </summary>
    
      <category term="lodash" scheme="http://robin-front.github.io/categories/lodash/"/>
    
      <category term="array" scheme="http://robin-front.github.io/categories/lodash/array/"/>
    
      <category term="slice" scheme="http://robin-front.github.io/categories/lodash/array/slice/"/>
    
    
      <category term="lodash" scheme="http://robin-front.github.io/tags/lodash/"/>
    
      <category term="array" scheme="http://robin-front.github.io/tags/array/"/>
    
      <category term="slice" scheme="http://robin-front.github.io/tags/slice/"/>
    
  </entry>
  
</feed>
