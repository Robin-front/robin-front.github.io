<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>三寸稚笔</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://robin-front.github.io/"/>
  <updated>2017-07-28T01:17:36.000Z</updated>
  <id>http://robin-front.github.io/</id>
  
  <author>
    <name>robin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>你可能不知道的JSON用法及误区</title>
    <link href="http://robin-front.github.io/2017/07/28/you-may-dont-know-JSON/"/>
    <id>http://robin-front.github.io/2017/07/28/you-may-dont-know-JSON/</id>
    <published>2017-07-28T01:17:36.000Z</published>
    <updated>2017-07-28T01:17:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="再谈-JSON-你可能不知道的一些-JSON-用法及误区"><a href="#再谈-JSON-你可能不知道的一些-JSON-用法及误区" class="headerlink" title="再谈 JSON, 你可能不知道的一些 JSON 用法及误区"></a>再谈 JSON, 你可能不知道的一些 JSON 用法及误区</h1><p>最近也是看到很多人在讨论 <code>JSON</code>, 但有些点说得不太准确，翻翻犀牛书，再次复习一下。</p><h2 id="JSON-stringify-value-replacer-space"><a href="#JSON-stringify-value-replacer-space" class="headerlink" title="JSON.stringify(value [, replacer [, space]])"></a>JSON.stringify(value [, replacer [, space]])</h2><p>第一个参数一般是对象（Object）或数组（Array），或 <code>javascript</code> 基本值。</p><h3 id="误区：不支持的值都会被忽略"><a href="#误区：不支持的值都会被忽略" class="headerlink" title="误区：不支持的值都会被忽略"></a>误区：不支持的值都会被忽略</h3><p><strong>首先 JSON 只能序列化可枚举的值，其次 <code>undefined</code>，<code>NaN</code>，<code>Infinity</code>，<code>function</code>, <code>Date</code>, <code>RegExp</code>, <code>Error</code> 这些值或对象都是不支持的，但并不是这些值都会被忽略。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="built_in">Symbol</span>(), <span class="comment">// 新增的 ES6 基本值</span></div><div class="line">  b: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</div><div class="line">  <span class="attr">c</span>: <span class="literal">undefined</span>,</div><div class="line">  <span class="attr">d</span>: <span class="literal">NaN</span>,</div><div class="line">  <span class="attr">e</span>: <span class="literal">Infinity</span>,</div><div class="line">  <span class="attr">f</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">1</span>;&#125;,</div><div class="line">  <span class="attr">g</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(),</div><div class="line">  <span class="attr">h</span>: <span class="regexp">/^\d$/gi</span>,</div><div class="line">  <span class="attr">i</span>: <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'err'</span>),</div><div class="line">  <span class="attr">j</span>: &#123;&#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">JSON</span>.stringify(o);</div><div class="line"></div><div class="line"><span class="comment">// output: '&#123;"b":[1,2,3],"d":null,"e":null,"g":"2017-07-28T02:56:37.102Z","h":&#123;&#125;,"i":&#123;&#125;,"j":&#123;&#125;&#125;'</span></div></pre></td></tr></table></figure><p>由上可以看出：</p><ul><li><code>Symbol</code>, <code>undefined</code>, <code>function</code> 会直接被忽略</li><li><code>NaN</code>, <code>Infinity</code> 被转换成了 <code>null</code></li><li><code>RegExp</code>, <code>Error</code> 则被转成了空对象 {}</li></ul><h3 id="replacer"><a href="#replacer" class="headerlink" title="replacer"></a>replacer</h3><p>因为 <code>JSON.stringify()</code> 序列化不支持部分值，所以不能简单地使用 <code>JSON</code> 的两个方法进行深拷贝。但可以利用 <code>JSON.stringify()</code> 的第二个参数进行正确序列化。</p><p><strong>但这并不推荐，因为 JSON.parse() 仍然无法还原不被支持的值。只有对象字面量 Object 和 数组 Array 可以被正确还原，其他都变成字符串</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 沿用上一例子的代码</span></div><div class="line"><span class="keyword">var</span> replacer = <span class="function"><span class="keyword">function</span>(<span class="params">k ,v</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> type = <span class="keyword">typeof</span> v;</div><div class="line">  <span class="keyword">if</span>(type === <span class="string">'function'</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Function</span>.prototype.toString.call(v)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (type === <span class="string">'undefined'</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'undefined'</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (type === <span class="string">'number'</span>)&#123;</div><div class="line">    <span class="keyword">if</span> (v !== v)&#123;</div><div class="line">      <span class="keyword">return</span> <span class="string">'NaN'</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (v === <span class="literal">Infinity</span>)&#123;</div><div class="line">      <span class="keyword">return</span> <span class="string">'Infinity'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (type === <span class="string">'symbol'</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Symbol</span>.prototype.toString.call(v)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (v <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">RegExp</span>.prototype.toString.call(v)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (v <span class="keyword">instanceof</span> <span class="built_in">Error</span> &amp;&amp; v.name !== <span class="string">''</span> &amp;&amp; v.message !== <span class="string">''</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'new '</span> + v.name + <span class="string">'('</span>+ v.message +<span class="string">')'</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> v</div><div class="line">&#125;</div><div class="line"><span class="built_in">JSON</span>.stringify(o, replacer);</div><div class="line"></div><div class="line"><span class="comment">//  output: '&#123;"a":"Symbol()","b":[1,2,3],"c":"undefined","d":"NaN","e":"Infinity","f":"function ()&#123; return 1;&#125;","g":"2017-07-28T02:56:37.102Z","h":"/^\\d$/gi","i":"new Error(err)","j":&#123;&#125;&#125;'</span></div></pre></td></tr></table></figure><p>另外一个用法就是传入数组，指定需要序列化的key.这个在提取部分属性的时候也是很有用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 沿用上面的代码</span></div><div class="line"><span class="built_in">JSON</span>.stringify(o, [<span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>]);</div><div class="line"></div><div class="line"><span class="comment">// output: '&#123;"b":[1,2,3],"d":null&#125;'</span></div></pre></td></tr></table></figure><h3 id="space"><a href="#space" class="headerlink" title="space"></a>space</h3><p>是一个可选的美化属性，序列化时是没有换行和空格的，此参数可指定一个数值（大于10则限制为10）或一组字符（长度最长为10个字符), 此参数不为空会自动插入换行。</p><p><strong>但是设置为字符时，无法使用 parse 复原</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">JSON</span>.stringify(o, <span class="literal">null</span>, <span class="string">'-'</span>);</div><div class="line"><span class="comment">// '&#123;</span></div><div class="line"><span class="comment">// -"b": [</span></div><div class="line"><span class="comment">// --1,</span></div><div class="line"><span class="comment">// --2,</span></div><div class="line"><span class="comment">// --3</span></div><div class="line"><span class="comment">// -],</span></div><div class="line"><span class="comment">// -"d": null,</span></div><div class="line"><span class="comment">// -"e": null,</span></div><div class="line"><span class="comment">// -"g": "2017-07-28T02:56:37.102Z",</span></div><div class="line"><span class="comment">// -"h": &#123;&#125;,</span></div><div class="line"><span class="comment">// -"i": &#123;&#125;,</span></div><div class="line"><span class="comment">// -"j": &#123;&#125;</span></div><div class="line"><span class="comment">// &#125;'</span></div></pre></td></tr></table></figure><h2 id="JSON-parse-value-reviver"><a href="#JSON-parse-value-reviver" class="headerlink" title="JSON.parse(value[, reviver])"></a>JSON.parse(value[, reviver])</h2><p><code>JSON.parse</code> 与 <code>JSON.stringify</code> 操作正好相反，但 <code>value</code> 必须严格符合 <code>JSON</code> 格式，否则报错。</p><p>第二个参数可传入一个函数，用以转换解析出来的值。</p><p>比如 <code>Date</code> 对象在序列化之后无法逆转成一个 <code>Date</code> 对象，此时可写一个函数去转换：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reviver = <span class="function"><span class="keyword">function</span> (<span class="params">name, value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="regexp">/^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\d.\d\d\dZ$/</span>.test(value));</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'string'</span> &amp;&amp; <span class="regexp">/^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\d.\d\d\dZ$/</span>.test(value))&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(value)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> value</div><div class="line">&#125;</div><div class="line"><span class="comment">// 沿用前个例子的代码</span></div><div class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(o.g), reviver)</div><div class="line"><span class="comment">// output: Fri Jul 28 2017 10:56:37 GMT+0800 (+08)</span></div></pre></td></tr></table></figure><h2 id="toJSON"><a href="#toJSON" class="headerlink" title="toJSON()"></a>toJSON()</h2><p>有些文章会说 <code>Object.toJSON()</code> ，这是不对的，<code>Object</code> 原型上并没有定义 <code>toJSON</code> 方法，该方法只被定义在 <code>Date</code> 对象上。<code>JSON.stringify()</code> 在序列化的时候会首先查找该方法，如果有则直接返回 <code>toJSON</code> 的调用结果。这个一开始是让 <code>Date</code> 正确序列化成 <code>JSON</code> 时设计的。但我们也可以利用 <code>toJSON</code> 的屏蔽功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.toJSON = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Function</span>.prototype.toString.call(<span class="keyword">this</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 沿用上面的例子</span></div><div class="line"><span class="built_in">JSON</span>.stringify(o);</div><div class="line"><span class="comment">// &#123;"b":[1,2,3],"d":null,"e":null,"f":"function ()&#123; return 1;&#125;","g":"2017-07-28T02:56:37.102Z","h":&#123;&#125;,"i":&#123;&#125;,"j":&#123;&#125;&#125;</span></div></pre></td></tr></table></figure><p>会发现，<code>function</code> 没有被忽略，但此方法要慎用，在原型上添加方法可能产生副作用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;再谈-JSON-你可能不知道的一些-JSON-用法及误区&quot;&gt;&lt;a href=&quot;#再谈-JSON-你可能不知道的一些-JSON-用法及误区&quot; class=&quot;headerlink&quot; title=&quot;再谈 JSON, 你可能不知道的一些 JSON 用法及误区&quot;&gt;&lt;/a&gt;再
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="JSON" scheme="http://robin-front.github.io/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>像 google 一样通过缩短 css 类名和作用域隔离来压缩优化 css 包的大小</title>
    <link href="http://robin-front.github.io/2017/07/24/reducing-css-bundle-size-by-cutting-the-class-names-and-using-scope-isolation/"/>
    <id>http://robin-front.github.io/2017/07/24/reducing-css-bundle-size-by-cutting-the-class-names-and-using-scope-isolation/</id>
    <published>2017-07-24T09:05:01.000Z</published>
    <updated>2017-07-24T09:05:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="像-google-一样通过缩短-css-类名和作用域隔离来压缩优化-css-包的大小"><a href="#像-google-一样通过缩短-css-类名和作用域隔离来压缩优化-css-包的大小" class="headerlink" title="像 google 一样通过缩短 css 类名和作用域隔离来压缩优化 css 包的大小"></a>像 google 一样通过缩短 css 类名和作用域隔离来压缩优化 css 包的大小</h1><blockquote><h2 id="就像-google-的做法一样"><a href="#就像-google-的做法一样" class="headerlink" title="就像 google 的做法一样"></a>就像 google 的做法一样</h2></blockquote><p>今年年初，我已经退出咨询公司并开始构建 <a href="https://go2cinema.com/" target="_blank" rel="external">GO2CINEMA</a> - 一个 <em>快速，简单和安全</em> 的方式来预订英国的电影票的网站。我做了一个辉煌的工作，使其快速，简单和安全。在其中某个阶段，我一直痴迷于关键渲染路径的优化。⚡️</p><p>我已经使用 <a href="https://github.com/gajus/usus" target="_blank" rel="external">ūsus</a> 解决了 HTML 的预渲染。ūsus 渲染单页应用程序（SPA）的 HTML，并<a href="https://medium.com/@gajus/pre-rendering-spa-for-seo-and-improved-perceived-page-loading-speed-47075aa16d24" target="_blank" rel="external">内嵌了用于呈现页面的 CSS</a>。但是，我并不喜欢在每个 HTML 文档内嵌 70 KB 的 css，特别是其中大部分是 CSS 类名。</p><a id="more"></a><h2 id="就像Google一样"><a href="#就像Google一样" class="headerlink" title="就像Google一样"></a>就像Google一样</h2><p>你有没有看过 <a href="https://www.google.com/" target="_blank" rel="external">https://www.google.com/</a> 的源代码？如果看过，您注意到的第一件事是会是，CSS 类名称没有超过几个字符。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*mGuDYFM56iyLi1MgZPC8bw.png" alt="https://cdn-images-1.medium.com/max/800/1*mGuDYFM56iyLi1MgZPC8bw.png"></p><p>但是怎么样做到的呢？</p><h2 id="CSS-minifiers-的缺点"><a href="#CSS-minifiers-的缺点" class="headerlink" title="CSS minifiers 的缺点"></a>CSS minifiers 的缺点</h2><p>有一件事，<code>minifier</code> 不能做 - 改变选择器名称。这是因为 <code>CSS minifier</code> 不能控制 HTML 输出。同时，CSS 名称可以很长。</p><p>如果您使用 <code>CSS modules</code>，您的 CSS modules 可能会包含样式表文件名，本地标识名和随机哈希。使用 <a href="https://github.com/webpack-contrib/css-loader" target="_blank" rel="external">css-loader</a> <a href="https://github.com/webpack-contrib/css-loader" target="_blank" rel="external">localIdentName</a> 配置描述类名模板，例如<code>[name]___[local]___[hash:base64:5]</code>。因此，生成的类名称将如下所示 <code>.MovieView___movie-title___yvKVV</code> ; 如果你喜欢描述性的名字，它可能更长，例如 <code>.MovieView___movie-description-with-summary-paragraph___yvKVV</code> 。</p><h2 id="在编译时重命名-CSS-类名"><a href="#在编译时重命名-CSS-类名" class="headerlink" title="在编译时重命名 CSS 类名"></a>在编译时重命名 CSS 类名</h2><p>但是，如果您使用的是 <a href="https://webpack.js.org/" target="_blank" rel="external"><code>webpack</code></a> 和 <a href="https://github.com/gajus/babel-plugin-react-css-modules" target="_blank" rel="external"><code>babel-plugin-react-css-modules</code></a>，那么您很幸运 🍀 - 您可以使用 <code>css-loader</code> 的 <code>getLocalIdent</code> 配置项或者等效的 <code>babel-plugin-react-css-modules</code> 中的 <code>generateScopedName</code> 配置项来达到在编译时重命名类名的目的。</p><script src="https://gist.github.com/gajus/a70df30613ebd848ab1ce27f3e33aac2.js"></script><p><code>generateScopedName</code> 中很酷的是，同样的功能实例可以用于 <code>Babel</code> 和 <code>webpack</code> 的构建过程：</p><script src="https://gist.github.com/gajus/acc6684de7ef310e9fdcbfa502307e50.js"></script><h2 id="让名字变短"><a href="#让名字变短" class="headerlink" title="让名字变短"></a>让名字变短</h2><p>感谢 <code>babel-plugin-react-css-modules</code> 和 <code>css-loader</code> 共享相同的逻辑来生成 CSS 类名称，我们可以将类名改为任何我们喜欢的，甚至是随机哈希。然而，我想要最短的类名，而不是随机哈希。</p><p>为了生成最短的类名，我创建了类名索引，并使用该 <code>incstr</code> 模块为索引中的每个条目生成增量ID。</p><script src="https://gist.github.com/gajus/b61ab58c4243f189722c0c13e59cdd24.js"></script><p>这保证了类名简短并且唯一。现在，<code>.MovieView___movie-title___yvKVV</code> 和 <code>.MovieView___movie-description-with-summary-paragraph___yvKVV</code> 的类名都成了 <code>.a_a</code>, <code>.b_a</code>等。</p><p>这将 <code>GO2CINEMA</code> CSS 压缩包的大小从 140 KB 降低到 53KB。</p><h2 id="使用作用域隔离来进一步减少包的大小"><a href="#使用作用域隔离来进一步减少包的大小" class="headerlink" title="使用作用域隔离来进一步减少包的大小"></a>使用作用域隔离来进一步减少包的大小</h2><p>分离组件名称和本地标识符名称是一个很好的理由让我添加 <code>_</code> 到 CSS 类名 - 对于缩小文件大小特别有用。</p><p><a href="https://github.com/css/csso" target="_blank" rel="external">csso</a>（CSS minifier）具有<a href="https://github.com/css/csso#scopes" target="_blank" rel="external">作用域</a>配置。作用域定义了在某些标记上专门使用的类名列表，即来自不同作用域的选择器不会匹配同一个元素。这一条让优化规则更进一步。</p><p>要利用此功能，请使用 <a href="https://github.com/zoobestik/csso-webpack-plugin" target="_blank" rel="external"><code>csso-webpack-plugin</code></a> 来后处理 CSS 包：</p><script src="https://gist.github.com/gajus/720ece26d03ea901b515c9b80b6ac4c8.js"></script><p>这使 GO2CINEMA CSS 捆绑包的大小从 53 KB 降至 47 KB。</p><h2 id="这值得么？"><a href="#这值得么？" class="headerlink" title="这值得么？"></a>这值得么？</h2><p>这种压缩的第一个争议是觉得压缩算法本来就可以做到。使用 <a href="https://en.wikipedia.org/wiki/Brotli" target="_blank" rel="external">Brotli</a> 算法压缩的 GO2CINEMA CSS 包与长类名的原始包相比只压缩了 1 KB。</p><p>另一方面，设置这个缩小是一次性投入，它减少了需要解析的文档的大小。它还具有其他好处，例如阻止依赖 CSS类名称的扫描仪导航或意外匹配广告拦截器<a href="https://gist.github.com/spyesx/42fe84c0ef757d1c38a4" target="_blank" rel="external">黑名单</a>的 CSS选择器。</p><p>同时，您可以看到在 GO2CINEMA 和 venue 页面上使用的这种压缩的演示，例如</p><ul><li><a href="https://go2cinema.com/movies/wonder-woman-2017-1305237" target="_blank" rel="external">https://go2cinema.com/movies/wonder-woman-2017-1305237</a></li><li><a href="https://go2cinema.com/venues/odeon-oxford-magdalen-st-1001053" target="_blank" rel="external">https://go2cinema.com/venues/odeon-oxford-magdalen-st-1001053</a></li></ul><p>【翻译原文】：<a href="https://medium.freecodecamp.org/reducing-css-bundle-size-70-by-cutting-the-class-names-and-using-scope-isolation-625440de600b" target="_blank" rel="external">https://medium.freecodecamp.org/reducing-css-bundle-size-70-by-cutting-the-class-names-and-using-scope-isolation-625440de600b</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;像-google-一样通过缩短-css-类名和作用域隔离来压缩优化-css-包的大小&quot;&gt;&lt;a href=&quot;#像-google-一样通过缩短-css-类名和作用域隔离来压缩优化-css-包的大小&quot; class=&quot;headerlink&quot; title=&quot;像 google 一样通过缩短 css 类名和作用域隔离来压缩优化 css 包的大小&quot;&gt;&lt;/a&gt;像 google 一样通过缩短 css 类名和作用域隔离来压缩优化 css 包的大小&lt;/h1&gt;&lt;blockquote&gt;&lt;h2 id=&quot;就像-google-的做法一样&quot;&gt;&lt;a href=&quot;#就像-google-的做法一样&quot; class=&quot;headerlink&quot; title=&quot;就像 google 的做法一样&quot;&gt;&lt;/a&gt;就像 google 的做法一样&lt;/h2&gt;&lt;/blockquote&gt;&lt;p&gt;今年年初，我已经退出咨询公司并开始构建 &lt;a href=&quot;https://go2cinema.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GO2CINEMA&lt;/a&gt; - 一个 &lt;em&gt;快速，简单和安全&lt;/em&gt; 的方式来预订英国的电影票的网站。我做了一个辉煌的工作，使其快速，简单和安全。在其中某个阶段，我一直痴迷于关键渲染路径的优化。⚡️&lt;/p&gt;&lt;p&gt;我已经使用 &lt;a href=&quot;https://github.com/gajus/usus&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ūsus&lt;/a&gt; 解决了 HTML 的预渲染。ūsus 渲染单页应用程序（SPA）的 HTML，并&lt;a href=&quot;https://medium.com/@gajus/pre-rendering-spa-for-seo-and-improved-perceived-page-loading-speed-47075aa16d24&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;内嵌了用于呈现页面的 CSS&lt;/a&gt;。但是，我并不喜欢在每个 HTML 文档内嵌 70 KB 的 css，特别是其中大部分是 CSS 类名。&lt;/p&gt;
    
    </summary>
    
      <category term="css" scheme="http://robin-front.github.io/categories/css/"/>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/css/javascript/"/>
    
    
      <category term="react" scheme="http://robin-front.github.io/tags/react/"/>
    
      <category term="webpack" scheme="http://robin-front.github.io/tags/webpack/"/>
    
      <category term="css" scheme="http://robin-front.github.io/tags/css/"/>
    
      <category term="minifier" scheme="http://robin-front.github.io/tags/minifier/"/>
    
  </entry>
  
  <entry>
    <title>桂林山水最强徒步攻略-大圩古镇-奇峰镇-会仙镇-葡萄镇至兴坪古镇20公里经典徒步路线</title>
    <link href="http://robin-front.github.io/2017/07/23/Daxu-village-Huixian-wetland-Putao-Xingping-of-Guilin/"/>
    <id>http://robin-front.github.io/2017/07/23/Daxu-village-Huixian-wetland-Putao-Xingping-of-Guilin/</id>
    <published>2017-07-23T02:42:17.000Z</published>
    <updated>2017-07-23T02:42:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我可不是一个酒店享受者，我的玩法是 don’t stop, keep your step.</p></blockquote><h1 id="桂林山水最强徒步攻略-大圩古镇-奇峰镇-会仙镇-葡萄镇至兴坪古镇20公里经典徒步路线"><a href="#桂林山水最强徒步攻略-大圩古镇-奇峰镇-会仙镇-葡萄镇至兴坪古镇20公里经典徒步路线" class="headerlink" title="桂林山水最强徒步攻略-大圩古镇-奇峰镇-会仙镇-葡萄镇至兴坪古镇20公里经典徒步路线"></a>桂林山水最强徒步攻略-大圩古镇-奇峰镇-会仙镇-葡萄镇至兴坪古镇20公里经典徒步路线</h1><p>对于每个地方并不打算去两次的人来说（除了一些体验特别好的地方），一次性打包看完一个地方所有感兴趣的地点是最合适的。所以，每次去完，总是把一个市，甚至一个省的攻略都做完了。或许也是一种强迫症吧。</p><p>其实国内很多景点都是坑，网上照片基本都不是原片。写攻略是为了方便别人，也是为坑了别人一起，哈哈，顺便记录。<a id="more"></a></p><h2 id="路线规划"><a href="#路线规划" class="headerlink" title="路线规划"></a>路线规划</h2><p>下面先简要看看总体路线规划：</p><p>Day 1: 火车 ——&gt; 桂林市 ——&gt; 大圩古镇（+熊村） Day 2: 大圩古镇 ——&gt; 奇峰镇（遇到不可抗因素）——&gt; 会仙镇 Day 3: 会仙湿地 ——&gt; 玻璃田 ——&gt; 葡萄镇 Day 4: 葡萄镇 至 兴坪古镇 经典徒步路线 20 公里 ——&gt; 相公山（日落） Day 5: 相公山（日出）——&gt; 相公山至兴坪古镇 ——&gt; 老寨山（日落）——&gt; 阳朔高铁最后一班回（8pm）</p><p>补充几张线路图：</p><p><img src="/images/guilin/tubu.jpeg" alt="/images/guilin/tubu.jpeg"> <img src="/images/guilin/tubu2.jpeg" alt="/images/guilin/tubu2.jpeg"> 葡萄镇至兴坪古镇 徒步路线图</p><p><img src="/images/guilin/huixian.jpeg" alt="/images/guilin/huixian.jpeg"> 会仙玻璃田路线图</p><h2 id="大圩古镇（大墟）"><a href="#大圩古镇（大墟）" class="headerlink" title="大圩古镇（大墟）"></a>大圩古镇（大墟）</h2><p>“明清时期繁华一时的大圩古镇”。</p><p>在桂林火车站旁边的桂林长途汽车总站坐开往冠岩的专线车，40分钟左右即可到达大圩，票价5元左右。</p><p>古镇不大，1小时足以游完，距大圩镇8公里（在大圩路口能看到指路牌）的熊村（大圩县城搭公交过去3元）。</p><p>村上保留着完整的旧时村落格局，有上百栋明清建筑，现存有湖南会馆、江西会馆、财神殿等，村子的老建筑上保留了许多文革标语。</p><p>小吃：姜汁桂花凉粉</p><p>“大圩江上芦田寺，百尺深潭万竹围。柳店积薪晨爨后，僮人荷叶裹盐归”</p><h2 id="奇峰镇（李家村）"><a href="#奇峰镇（李家村）" class="headerlink" title="奇峰镇（李家村）"></a>奇峰镇（李家村）</h2><p>在桂林火车站对面搭乘4路车，开往奇峰镇方向，在 <strong>东山村</strong> 下车。每趟运行单程时间大约是40分钟。（我是大圩直接坐摩的30元抄小路到奇峰镇）</p><p>奇峰镇外看奇峰，万点尖峰锁碧空。</p><p><strong>事实上，里面是军事管制区，只有本村村民才能进。公交车到村口就被强制下车。请不要来这里，没有开放</strong></p><h2 id="会仙镇"><a href="#会仙镇" class="headerlink" title="会仙镇"></a>会仙镇</h2><p>桂林汽车站，乘坐桂林—会仙的班车，每隔15分钟一趟，票价8元（直达），也可在雁中路口，师大侧门坐车。</p><blockquote><p>秋天去看一片金黄，或田地放水时，一片天镜。</p></blockquote><ul><li><p>会仙湿地： 正在开发中，酒店食宿全没有，一年后应该会有。到睦洞村委路口，然后乘坐前往毛家村的三轮车每人2元钱（实际上有时会坑你10元）。也可从路口步行至毛家村，大概40分钟左右，路边一大片农田，湿地公园有一大片荷花。一般摄影人会去龙山，售票口的人会建议你坐船过去上龙山。票价不菲。觉得值可以坐。如果是穷学生，那就买门票，走过去，船是走近路直接到山脚，走路就要十八弯，40分钟左右。再不济，往回走有条岔路，是通向刚刚入口方向，人少时没人守，免票进入，这是我出来的时候发现的。</p></li><li><p>玻璃田： 湿地是后开发的，最开始出名的是玻璃田这一块。山也不难找，就是下图的 D 点，上山点在村口医院前。</p></li></ul><p><img src="/images/guilin/huixian.jpeg" alt="/images/guilin/huixian.jpeg"></p><h2 id="葡萄镇"><a href="#葡萄镇" class="headerlink" title="葡萄镇"></a>葡萄镇</h2><p>这是个中转休息点，是经典徒步路线的起点。从会仙过来的话，先坐车到 雁中路口，师大侧门，然后在南下的大路上拦去阳朔的车，在葡萄镇下车。</p><p>《石头城到兴坪徒步 - 居高临下欣赏山水画卷》（总长度22.5公里）: 这条徒步线路清幽古朴，游人罕至，途中每一次登高俯视，都将为您展开一幅不同的阳朔山水画卷。阳朔的经典摄影主题，葡萄田园风光(地处阳朔葡萄镇乌龙村，拍摄葡萄田园风光多为逆光拍摄，应选择有太阳的天气下午4-5时到达山顶等候拍摄)、相公山日出以及老寨山日落，都在这条线路上。途径古朴的石头城以及兴坪老街，又给这条线路增加了人文风情。线路最好分两天完成，这样可以夜宿相公山以便第二天观看日出。全程难度不大，两三人轻装便可出发，沿途村庄可以补给，也可带少量食物和水以防万一</p><p>当然，这条路线可以反着来走，但我是从会仙过来的，这样走更顺路，最后阳朔高铁回。</p><p>【徒步线路A：小耀门村–石头寨–大岩头村–小冲崴村–大坪村–水岩门村–相公山–黄泥田村–镰刀湾村–大河背村–渔村村–兴坪镇。（全程约19公里） 徒步线路B：小耀门村—石头寨—大岩头村—小冲崴村—大坪村–水岩门村–相公山–荷苞山村–冷水村–画山村–兴坪镇。（全程约18公里）】 (PS: 其实应该有25公里，我在石头城迷路，走得太累，后来还搭了一段顺风车到相公山)</p><h2 id="兴坪古镇"><a href="#兴坪古镇" class="headerlink" title="兴坪古镇"></a>兴坪古镇</h2><p>相公山到冷水村路不太好走，比想象中远，但其实应该有近路，因为在路上有岔路，但地图上没有标。去冷水村需要渡河，10元。本地人免费。冷水村到兴坪古镇一路是风景，也可坐三轮车过去。下车点就是20元人民币上的图。之后在老寨山看日落。下山在汽车站坐小面包 5元到阳朔高铁站回。</p><h2 id="详细影摄"><a href="#详细影摄" class="headerlink" title="详细影摄"></a>详细影摄</h2><p>上面都是交通简要，下面是影摄：</p><blockquote><p>（待更。。）</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;我可不是一个酒店享受者，我的玩法是 don’t stop, keep your step.&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 id=&quot;桂林山水最强徒步攻略-大圩古镇-奇峰镇-会仙镇-葡萄镇至兴坪古镇20公里经典徒步路线&quot;&gt;&lt;a href=&quot;#桂林山水最强徒步攻略-大圩古镇-奇峰镇-会仙镇-葡萄镇至兴坪古镇20公里经典徒步路线&quot; class=&quot;headerlink&quot; title=&quot;桂林山水最强徒步攻略-大圩古镇-奇峰镇-会仙镇-葡萄镇至兴坪古镇20公里经典徒步路线&quot;&gt;&lt;/a&gt;桂林山水最强徒步攻略-大圩古镇-奇峰镇-会仙镇-葡萄镇至兴坪古镇20公里经典徒步路线&lt;/h1&gt;&lt;p&gt;对于每个地方并不打算去两次的人来说（除了一些体验特别好的地方），一次性打包看完一个地方所有感兴趣的地点是最合适的。所以，每次去完，总是把一个市，甚至一个省的攻略都做完了。或许也是一种强迫症吧。&lt;/p&gt;&lt;p&gt;其实国内很多景点都是坑，网上照片基本都不是原片。写攻略是为了方便别人，也是为坑了别人一起，哈哈，顺便记录。
    
    </summary>
    
      <category term="travel" scheme="http://robin-front.github.io/categories/travel/"/>
    
    
      <category term="travel" scheme="http://robin-front.github.io/tags/travel/"/>
    
  </entry>
  
  <entry>
    <title>马萨萨海滩(masasa beach) 旅行预算指南</title>
    <link href="http://robin-front.github.io/2017/07/22/masasa-beach-travel-guide/"/>
    <id>http://robin-front.github.io/2017/07/22/masasa-beach-travel-guide/</id>
    <published>2017-07-22T03:29:35.000Z</published>
    <updated>2017-07-22T03:29:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="假期旅行之菲律宾系列之二-——-马萨萨海滩-masasa-beach"><a href="#假期旅行之菲律宾系列之二-——-马萨萨海滩-masasa-beach" class="headerlink" title="假期旅行之菲律宾系列之二 —— 马萨萨海滩(masasa beach)"></a>假期旅行之菲律宾系列之二 —— 马萨萨海滩(masasa beach)</h1><p>马萨沙滩可以说是 Tingloy 最好的海滩，这是 Batangas 唯一不在大陆吕宋岛上。它的主要岛屿是鱼形马里卡班（Maricaban），位于 Calumpang 半岛的一角，将巴拉扬湾（Balayan Bay）与八打雁湾（Batangas Bay）分开。</p><p>事实是，这里的沙滩不像你在长滩岛或巴拉望岛所期望的那样像白色珍珠，但是马萨沙滩在缺乏亮度的沙滩中展现出波浪的气息。它的水晶般清澈，浅水散发出美丽的绿松石闪光，即使远距离也能吸引您的注意。<a id="more"></a></p><p>来这里主要是玩水，如果你喜欢游泳，来这里吧。我是在这学会狗爬式的。哈哈。。 先来看看一些照片。</p><p><img src="http://www.thepoortraveler.net/wp-content/uploads/2017/03/Masasa-Beach-Batangas-1.jpg" alt="http://www.thepoortraveler.net/wp-content/uploads/2017/03/Masasa-Beach-Batangas-1.jpg"></p><p><img src="http://www.thepoortraveler.net/wp-content/uploads/2014/02/Mabini-Tingloy-Map.png" alt="http://www.thepoortraveler.net/wp-content/uploads/2014/02/Mabini-Tingloy-Map.png"> 小岛是一个小鱼形状，很可爱</p><p><img src="/images/masasa/IMG_1398.JPG" alt="/images/masasa/IMG_1398.JPG"> 在 Anilao Port 坐公共船只</p><p><img src="/images/masasa/IMG_1419.JPG" alt="/images/masasa/IMG_1419.JPG"> 到达 小鱼岛 ，准备浮潜，小哥很卖力！</p><p><img src="/images/masasa/IMG_1429.JPG" alt="/images/masasa/IMG_1429.JPG"> 没错，螃蟹船很好看，他们喜欢涂成各种颜色，艺术细胞不错。以及。。真正蓝色的大海，而不是灰色的。</p><p>浮潜只需100p !!超便宜，一定要尝试一下，虽然只是带着你转一圈，但是可以看到各种海龟，珊瑚，长带鱼等。怪不得很多本地大学生来！经济漂亮！但是我没有拍到好的海底照片。。</p><p><img src="/images/masasa/IMG_1439.JPG" alt="/images/masasa/IMG_1439.JPG"> 沙子确实不怎么样，但是水还是不错</p><p><img src="/images/masasa/IMG_1477.JPG" alt="/images/masasa/IMG_1477.JPG"> 水清见底</p><p><img src="/images/masasa/IMG_1478.JPG" alt="/images/masasa/IMG_1478.JPG"> 全貌</p><p><img src="/images/masasa/IMG_1539.JPG" alt="/images/masasa/IMG_1539.JPG"> 家庭出行非常多</p><p><img src="/images/masasa/IMG_1588.JPG" alt="/images/masasa/IMG_1588.JPG"> 香蕉船</p><p><img src="/images/masasa/IMG_1643.JPG" alt="/images/masasa/IMG_1643.JPG"> 附近村庄的小卖部的老人</p><p><img src="/images/masasa/IMG_1692.JPG" alt="/images/masasa/IMG_1692.JPG"> 这是什么，谁能告诉我</p><p><img src="/images/masasa/IMG_1702.JPG" alt="/images/masasa/IMG_1702.JPG"> 其实来到这里再找住宿也可以，因为很多，到处都是</p><p><img src="/images/masasa/IMG_1732.JPG" alt="/images/masasa/IMG_1732.JPG"> 菲菲 <img src="/images/masasa/IMG_1741.JPG" alt="/images/masasa/IMG_1741.JPG"></p><h2 id="交通"><a href="#交通" class="headerlink" title="交通"></a>交通</h2><ul><li><p>bus,在八打雁市区 Batangas Grand Terminal下车（3-4 小时）（<strong>同样的，半夜出发，早上到达，不然会塞车</strong>） 在LRT- Gil Puyat 车站旁边有公共汽车站（DLTB liner 或 JAM liner）。（注意，越早越好。如果您选择一辆带有 CALABARZON 标志的公共汽车，旅行时间将会更短）P120-P180。</p></li><li><p>转吉普尼（1小时） 40 minutes. Fare: PhP 37. 终点站是 Mabini Multi-purpose port.（又名 Anilao Port）(在habagat season季节，终点站是 Talaga Port )</p></li><li><p>a. 在 Anilao Port 坐船(<strong>推荐</strong>)（45min） 如果要在岛上住一晚，就选择公共船只，最便宜，P80。旅行时间：45分钟 - 1小时。 直接坐船到 masasa beach。但是直达的船更少，不可预测，P100 （注意，最后一艘返回 Anilao的船是上午九点，所以不得不住一晚,有些船在较小的码头在中午12点可以接乘客回,具体可以咨询当地人上船地点）</p></li><li><p>b. 如果是一日游，租船P4500，可坐10人，可以讲价。如果租船，可以要求中途登陆 Sombrero岛，上岛费 P200，有些要P500.（算是跳岛游，比较贵）</p></li></ul><h2 id="住宿"><a href="#住宿" class="headerlink" title="住宿"></a>住宿</h2><p>我当时是在 facebook 上搜索 masasa 然后联系的住宿，P300 每人！没有酒店。其实那里旁边有村子，有很多过夜的地方。以前可以在沙滩露营过夜，但后来不允许了。</p><h2 id="其他项目"><a href="#其他项目" class="headerlink" title="其他项目"></a>其他项目</h2><ul><li>环岛游： 标准费率：P1500，岛上可以联系当地船只。</li><li>浮潜：P100 !!我是当时住宿的人帮我安排联系的，30min,时间不长</li></ul><h2 id="费用清单"><a href="#费用清单" class="headerlink" title="费用清单"></a>费用清单</h2><ul><li>到八打雁的票价车票：票价：P157 从LRT-Buendia 出发，P127 从阿拉邦出发。</li><li>吉隆尼到阿尼洛的吉普尼票价：P37</li><li>从Anilao出发的小船出租（岛屿游览）：每船P4500（最大10人）Masasa</li><li>海滩的小船出租（岛屿游览）：每船P1500（3pax最大）</li><li>公共小船到 Tingloy：P80（推荐）</li><li>三轮车到马萨沙滩：P120/辆</li><li>环境费：P30</li><li>马萨沙滩：免费</li><li>Sombrero Island 上岛费：P200</li><li>租帐篷 P200</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>masasa beach只有一个洗手间，收费，P10 每次；</li><li>过夜可能没有电，带好充电宝；</li><li>看好天气，晴天比阴天更漂亮，水更清；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;假期旅行之菲律宾系列之二-——-马萨萨海滩-masasa-beach&quot;&gt;&lt;a href=&quot;#假期旅行之菲律宾系列之二-——-马萨萨海滩-masasa-beach&quot; class=&quot;headerlink&quot; title=&quot;假期旅行之菲律宾系列之二 —— 马萨萨海滩(masasa beach)&quot;&gt;&lt;/a&gt;假期旅行之菲律宾系列之二 —— 马萨萨海滩(masasa beach)&lt;/h1&gt;&lt;p&gt;马萨沙滩可以说是 Tingloy 最好的海滩，这是 Batangas 唯一不在大陆吕宋岛上。它的主要岛屿是鱼形马里卡班（Maricaban），位于 Calumpang 半岛的一角，将巴拉扬湾（Balayan Bay）与八打雁湾（Batangas Bay）分开。&lt;/p&gt;&lt;p&gt;事实是，这里的沙滩不像你在长滩岛或巴拉望岛所期望的那样像白色珍珠，但是马萨沙滩在缺乏亮度的沙滩中展现出波浪的气息。它的水晶般清澈，浅水散发出美丽的绿松石闪光，即使远距离也能吸引您的注意。
    
    </summary>
    
      <category term="travel" scheme="http://robin-front.github.io/categories/travel/"/>
    
    
      <category term="travel" scheme="http://robin-front.github.io/tags/travel/"/>
    
      <category term="philippine" scheme="http://robin-front.github.io/tags/philippine/"/>
    
  </entry>
  
  <entry>
    <title>Borawan island、Pagbilao Beach 和 Dampalitan island旅行预算指南——一个周末三个沙滩</title>
    <link href="http://robin-front.github.io/2017/07/22/borawan-island-Pagbilao-beach-and-Dampalitan-island/"/>
    <id>http://robin-front.github.io/2017/07/22/borawan-island-Pagbilao-beach-and-Dampalitan-island/</id>
    <published>2017-07-22T00:30:22.000Z</published>
    <updated>2017-07-22T00:30:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一个孩子的冒险故事 ————讲故事的人</p></blockquote><h1 id="假期旅行之菲律宾系列之一-————-Borawan岛、Pagbilao岛、Dampalitan岛"><a href="#假期旅行之菲律宾系列之一-————-Borawan岛、Pagbilao岛、Dampalitan岛" class="headerlink" title="假期旅行之菲律宾系列之一 ———— Borawan岛、Pagbilao岛、Dampalitan岛"></a>假期旅行之菲律宾系列之一 ———— Borawan岛、Pagbilao岛、Dampalitan岛</h1><p>坐落在奎松南部的边缘，布尔戈斯（Padre Burgos）和帕格比洛（Pagbilao）的城镇面向泰巴巴斯湾（Tayabas Bay），这是分离大陆吕宋岛和马林杜克岛（Marinduque）的通道。马尼拉市区的这一边只有四到五个小时的路程，甚至远远近于 Pangasinan和碧瑶（Baguio）。<a id="more"></a></p><p><img src="/images/20170722/IMG_4158.JPG" alt="/images/20170722/IMG_4158.JPG"> 这是Puting Buhangin，Pagbilao（也叫Kuwebang Lampas）最推荐，请在这里规划最长的时间</p><p><img src="/images/20170722/IMG_4157.JPG" alt="/images/20170722/IMG_4157.JPG"></p><p><img src="/images/20170722/IMG_4139.JPG" alt="/images/20170722/IMG_4139.JPG"></p><p><img src="/images/20170722/IMG_3918.JPG" alt="/images/20170722/IMG_3918.JPG"> <img src="/images/20170722/IMG_3904.JPG" alt="/images/20170722/IMG_3904.JPG"> Borawan，背靠山，是另一种风景，和岩石拍照特别好看。这是 Borawan 的日落。</p><p><img src="/images/20170722/IMG_3979.JPG" alt="/images/20170722/IMG_3979.JPG"> 水面很平静，没有浪，很适合游泳</p><p><img src="/images/20170722/IMG_3383.JPG" alt="/images/20170722/IMG_3383.JPG"> Dampalitan， 水很清！ <img src="/images/20170722/IMG_3613.JPG" alt="/images/20170722/IMG_3613.JPG"> <img src="/images/20170722/IMG_3654.JPG" alt="/images/20170722/IMG_3654.JPG"> 天气很好！</p><h2 id="公共交通如何到达"><a href="#公共交通如何到达" class="headerlink" title="公共交通如何到达"></a>公共交通如何到达</h2><ul><li>公共汽车站：JAM liner, DLTB liner, JAC liner. 位于 Taft Ave.</li><li>乘公共汽车到卢塞纳市（Lucena）。马尼拉大都会有许多终点站到卢塞纳。票价介于P250-260之间。旅行时间：3-4小时。</li><li>在卢塞纳站下车（Lucena Grand Terminal）。</li><li>a. 从终点站乘坐另一辆巴士到 Unisan。公共汽车没有空调，票价在P35-40左右。旅行时间：1个半小时。 b. 也有小面包车 （Vans），有招客牌写着 Unisan，说去 QCRB Bank 下车，大概 60p 每人</li><li>在QCRB银行（Padre Burgos）下车，或者 <strong>提前告诉司机让你这里下车</strong>。</li><li>乘坐三轮车到 Aplaya。告诉司机你打算去Borawan， 只需 20p。</li><li>在 Aplaya 有小船出租。这些船只可以带您前往 Puting Buhangin（Pagbilao），Dampalitan岛和Borawan岛的一个岛屿游览。P1500 - P2000，适合10人以下。</li></ul><h2 id="行程参考时间表"><a href="#行程参考时间表" class="headerlink" title="行程参考时间表"></a>行程参考时间表</h2><p>半夜出发是最合适的，早上就到。如果早上出发，你会在路上塞车并浪费一整天。不要把白天玩的时间浪费在车上。</p><ol><li>2:00 - Buendia Bus Terminal(DLTB liner or JAM liner)坐车 (P227-P250, 4h)【凌晨两点出发，早上六点到】 目的地：Lucena Grand Terminal</li><li>6:00 - Lucena Grand Terminal换乘去 Unisan 的公交bus（P35 - P40）【1.5h, 预计七点半到】</li><li>7:00 - 在 QCRB BANK下车。换tricycle三轮车（10min），去Aplaya (和司机说要去 Borawan)</li><li>在Aplaya租船 8:00 出发。</li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>该地区有水母（jerryfish），请一定注意，Borawan沙滩尤其多，所以建了水网区域游泳，不要在非安全区域游泳。被水母蛰了也不要惊慌，提前了解处理方法，使用碱性溶液（如肥皂水等）清洗。Pagbilao岛、Dampalitan岛比较安全，下水前可以询问岛上工作人员能否下水，或与其他人一同下水，勿单独游泳。</p><h2 id="露营或酒店或租船"><a href="#露营或酒店或租船" class="headerlink" title="露营或酒店或租船"></a>露营或酒店或租船</h2><p>Borawan 和 Dampalitan Islands 没有度假村或酒店，但允许露营过夜。如果你不是野营的类型，那么大陆有几个度假村，你可以选择留下来。以下是我收集的简短列表：</p><ul><li>Silangang Nayon餐厅和度假村。位于Pagbilao，它是Bicol绑定的路途跋涉者之间的共同点，他们渴望品尝到他们美味的Pinoy海鲜菜肴。他们只有少量的房间，所以如果你要在旺季，提前预订。联系电话：（042）7160077，0922 8867677</li></ul><p>但，如果你认为你是一个野营旅行，为什么不露营呢？露营不仅降低了成本，还使您更好地欣赏岛屿，从而使您更接近自然。所有你需要的是一个帐篷和一些易于准备的食品。如果有冲泡食品，沙滩小卖部有热水出售，20p。</p><p>租船（完全可以去到再租，如果不放心，可以提前询问）： 09501928546，09094819703</p><p>大部分人会在 Borawan 沙滩 和 Pagbilao 沙滩过夜，这两个地方有冲凉房和公厕，免费使用。我建议在 Puthang Buhangin, Pagbilao 过夜，那里水最清。</p><h2 id="备用物品提示"><a href="#备用物品提示" class="headerlink" title="备用物品提示"></a>备用物品提示</h2><ul><li>化妆品和防晒霜 - 通常。在岛上有商店，但预计价格有点过高，所以更好地带上洗发水，肥皂，牙膏，卫生纸和湿巾。Dampalitan 岛上有公厕，但水有点稀少。</li><li>防蚊洗剂 - 很多人会忘记带来。岛上有蚊子。</li><li>手电筒 - 那里偶尔会停电</li><li>打火机和很多故事 - 你会被诱惑开始篝火，你将需要打火机点火和对话，以保持燃烧。</li><li>急救包 - 你永远不会知道意外什么时候发生。</li><li>浮潜装置 - 我们没有看到活珊瑚，但有很多鱼。特别是在 Dampalitan和Pagbilao，这两个沙滩水更清。</li><li>防水相机 - Kuwebang Lampas（在Puthang Buhangin, Pagbilao）是非常棒的，但去那里的水很深。如果您想要在洞穴内的图片，防水相机非常有用。</li></ul><h2 id="预算详细条目"><a href="#预算详细条目" class="headerlink" title="预算详细条目"></a>预算详细条目</h2><p>以下是您期望的费用和其他费用清单。</p><p>乘船游览费（8人乘车）： P800 - Borawan海滩（往返） P1800 - Borawan + Dampalitan + Puting Buhangin（三岛两天一夜，这是总船费，不是每次）</p><p>Borawan海滩 上岛费：P80 帐篷租金：P500(买一个帐篷去最好，便宜的才1000p左右，还能带回去) 小屋出租：P700-P850 过夜费： P220每人 帐篷占地费用：P200-P250(分占地大小)</p><p>Puting Buhangin，Pagbilao 上岛费：P80 帐篷出租：P300-400</p><p>Dampalitan 岛 上岛费：P80 帐篷占地费：P100 小屋出租：P850-P1000 水：P40/5L，P400/大桶</p><p>以上费用可能会涨价，但不会偏离太多。最重要是带好食物和饮用水。过夜请拿好票据，以免其他员工再次来收钱。</p><h2 id="一般顺序："><a href="#一般顺序：" class="headerlink" title="一般顺序："></a>一般顺序：</h2><ul><li><strong>推荐：Borawan（9：00-午餐） ==&gt; Puting buhangin（14：00-过夜） ===&gt; Dampalitan (10：00 - 14:00回程)</strong></li><li>Puting buhangin（9：00） ==&gt; Dampalitan（11：30-午餐） ===&gt; Borawan (14：00 - 过夜)</li><li>Puting buhangin（9：00-午餐）===&gt; Borawan（14：00-过夜）===&gt; Dampalitan(10:00- 14:00回程)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;一个孩子的冒险故事 ————讲故事的人&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 id=&quot;假期旅行之菲律宾系列之一-————-Borawan岛、Pagbilao岛、Dampalitan岛&quot;&gt;&lt;a href=&quot;#假期旅行之菲律宾系列之一-————-Borawan岛、Pagbilao岛、Dampalitan岛&quot; class=&quot;headerlink&quot; title=&quot;假期旅行之菲律宾系列之一 ———— Borawan岛、Pagbilao岛、Dampalitan岛&quot;&gt;&lt;/a&gt;假期旅行之菲律宾系列之一 ———— Borawan岛、Pagbilao岛、Dampalitan岛&lt;/h1&gt;&lt;p&gt;坐落在奎松南部的边缘，布尔戈斯（Padre Burgos）和帕格比洛（Pagbilao）的城镇面向泰巴巴斯湾（Tayabas Bay），这是分离大陆吕宋岛和马林杜克岛（Marinduque）的通道。马尼拉市区的这一边只有四到五个小时的路程，甚至远远近于 Pangasinan和碧瑶（Baguio）。
    
    </summary>
    
      <category term="travel" scheme="http://robin-front.github.io/categories/travel/"/>
    
    
      <category term="travel" scheme="http://robin-front.github.io/tags/travel/"/>
    
      <category term="philippine" scheme="http://robin-front.github.io/tags/philippine/"/>
    
  </entry>
  
  <entry>
    <title>高性能 react：3种加快应用程序的新工具</title>
    <link href="http://robin-front.github.io/2017/07/18/make-react-fast-again-tools-and-techniques-for-speeding-up-your-react-app/"/>
    <id>http://robin-front.github.io/2017/07/18/make-react-fast-again-tools-and-techniques-for-speeding-up-your-react-app/</id>
    <published>2017-07-18T07:25:02.000Z</published>
    <updated>2017-07-18T07:25:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高性能-react：3种加快应用程序的新工具"><a href="#高性能-react：3种加快应用程序的新工具" class="headerlink" title="高性能 react：3种加快应用程序的新工具"></a>高性能 react：3种加快应用程序的新工具</h1><p><img src="https://cdn-images-1.medium.com/max/2000/1*mJFYp7LKVzZM3PPjFb0QXQ.png" alt="https://cdn-images-1.medium.com/max/2000/1*mJFYp7LKVzZM3PPjFb0QXQ.png"></p><p>react 通常很快，但很容易造成导致性能问题的小错误。缓慢的组件安装，深层组件树和不必要的渲染循环可以快速添加到一个感觉缓慢的应用程序。</p><p>幸运的是，有很多工具，有些甚至内置于 React，这有助于诊断性能问题。在这篇文章中，我将强调使 React 应用程序更快速的工具和技术。每个部分还有一个互动，（希望）有趣的演示！<a id="more"></a></p><h2 id="工具＃1：性能时间表"><a href="#工具＃1：性能时间表" class="headerlink" title="工具＃1：性能时间表"></a>工具＃1：性能时间表</h2><p>React 15.4.0引入了一个新的性能时间轴功能，可让您准确了解组件的挂载，更新和卸载。它还可以让您可视化相关的组件生命周期。</p><p>注意：现在，此功能仅适用于Chrome，Edge和IE，因为它利用了尚未在所有浏览器中实现的用户时间轴API（User Timing API）。</p><h3 id="怎么运行的"><a href="#怎么运行的" class="headerlink" title="怎么运行的"></a>怎么运行的</h3><ul><li>打开你的应用程序并附加查询参数：<code>react_perf</code>。例如，<code>http://localhost:3000?react_perf</code></li><li>打开Chrome DevTools 性能选项卡，然后按 <strong>记录（Record）</strong>。</li><li>执行您要分析的操作。</li><li>停止记录</li><li>在 <code>User Timing</code> 下检查可视化。</li></ul><p><img src="https://cdn-images-1.medium.com/max/1000/1*cOO5vUnbkdDUcqMW8ebJqA.png" alt="https://cdn-images-1.medium.com/max/1000/1*cOO5vUnbkdDUcqMW8ebJqA.png"></p><h3 id="了解输出"><a href="#了解输出" class="headerlink" title="了解输出"></a>了解输出</h3><p>每个彩色条显示组件正在做“工作”的时间。由于JavaScript是单线程的，每当组件正在加载或呈现时，它会阻止主线程，并阻止其他代码运行。</p><p>方括号中的文字<code>[update]</code>描述了组件生命周期的哪个部分正在发生。时间轴会分解每个步骤，因此您可以在<code>[componentDidMount]</code> <code>[componentWillReceiveProps]</code> <code>[ctor]</code>（构造函数）和 <code>[render]</code> 方法上看到细粒度的时序.</p><p>堆叠的条表示组件树。虽然在React中具有相当深的组件树是典型的，但如果要优化经常安装的组件，则可以帮助减少封装组件的数量，因为每个组件都会增加小的性能和内存损失。</p><p>这里有一点值得注意的是，时间表中的时间序列是用于开发构建React的，它比生产环境更慢。事实上，甚至性能时间表本身会减慢您的应用程序。虽然这些数字不应该被认为是真实表现的性能，但是不同组件之间的相对定时是准确的。此外，组件是否更新完全不依赖于生产环境上的构建。</p><h3 id="演示＃1"><a href="#演示＃1" class="headerlink" title="演示＃1"></a>演示＃1</h3><p>为了乐趣，我操纵了TodoMVC应用程序，出现一些严重的性能问题。你可以在<a href="https://perf-demo.firebaseapp.com/?react_perf" target="_blank" rel="external">这里试试看</a>。</p><p>要查看时间轴，请打开Chrome开发工具，转到“性能”选项卡，然后单击记录。然后在应用程序中添加一些TODO，停止录制并检查时间轴。看看是否可以发现哪些组件导致性能问题:)</p><h2 id="工具＃2：为什么更新"><a href="#工具＃2：为什么更新" class="headerlink" title="工具＃2：为什么更新"></a>工具＃2：为什么更新</h2><p>影响 React 中性能的最常见问题之一是不必要的渲染循环。默认情况下，即使他们的 props 没有改变，React 组件将在父级 render 时重新 render。</p><p>例如，如果我有一个这样的简单组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DumbComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> &#123;this.props.value&#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>加上父组件:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">      <span class="tag">&lt;<span class="name">DumbComponent</span> <span class="attr">value</span>=<span class="string">&#123;3&#125;</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>无论何时父组件 render，<code>DumbComponent</code> 都会重新 render，尽管其 <code>props</code> 没有改变。</p><p>通常，如果 render 运行，并且没有对虚拟DOM进行任何更改，则这是一个浪费的渲染循环，因为该 render 方法应该是纯的，并且没有任何副作用。在大规模的 React 应用程序中，检测发生这种情况的地方可能很棘手，但幸运的是，有一个可以帮助的工具！</p><h3 id="使用-why-did-you-update"><a href="#使用-why-did-you-update" class="headerlink" title="使用 why-did-you-update"></a>使用 why-did-you-update</h3><p><img src="https://cdn-images-1.medium.com/max/1000/1*Lb4nr_WLwnLt63jUoszrnQ.png" alt="https://cdn-images-1.medium.com/max/1000/1*Lb4nr_WLwnLt63jUoszrnQ.png"></p><p><code>why-did-you-update</code> 是一个挂接到 React 的库，并检测潜在的不必要的组件渲染。它检测组件的render方法何时被调用，尽管它的 <code>props</code> 没有改变。</p><h3 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h3><p>安装 <code>npm： npm i --save-dev why-did-you-update</code></p><p>在您的应用程序的任何地方添加此代码段：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">  <span class="keyword">const</span> &#123;whyDidYouUpdate&#125; = <span class="built_in">require</span>(<span class="string">'why-did-you-update'</span>)</div><div class="line">  whyDidYouUpdate(React)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>请注意，此工具在本地开发中非常出色，但确保在生产中已被禁用，因为它会减慢您的应用程序。</p><h3 id="了解输出-1"><a href="#了解输出-1" class="headerlink" title="了解输出"></a>了解输出</h3><p><code>why-did-you-update</code> 监视您的应用程序运行并记录可能会不必要地更改的组件。它允许您在渲染循环之前和之后看到 <code>props</code>，确定它可能是不必要的。</p><h3 id="演示＃2"><a href="#演示＃2" class="headerlink" title="演示＃2"></a>演示＃2</h3><p>为了演示<code>why-did-you-update</code>，我将库安装在 TodoMVC 应用程序的 Code Sandbox 上，这是一个在线 React 游戏场。打开浏览器控制台并添加一些 TODO 以查看输出。</p><p><a href="https://codesandbox.io/s/xGJP4QExn" target="_blank" rel="external">这是演示</a></p><blockquote><p>请注意，应用程序中的几个组件不必要地 render。尝试实现上述技术来防止不必要的渲染。如果正确完成，则<code>why-did-you-update</code>控制台中不应有输出。</p></blockquote><h2 id="工具＃3：反应开发工具"><a href="#工具＃3：反应开发工具" class="headerlink" title="工具＃3：反应开发工具"></a>工具＃3：反应开发工具</h2><p><img src="https://cdn-images-1.medium.com/max/1000/1*1Ih6h8djFyH13tfFK3D1sw.png" alt="https://cdn-images-1.medium.com/max/1000/1*1Ih6h8djFyH13tfFK3D1sw.png"></p><p>React 开发者工具 Chrome 扩展程序具有可视化组件更新的内置功能。这有助于检测不必要的渲染循环。要使用它，首先请确保在<a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=zh-CN" target="_blank" rel="external">此处安装扩展</a>。</p><p>然后，点击Chrome DevTools中的“React”标签打开扩展程序，然后选中“Highlight Updates”。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*GP4vXvW3WO0vTbggDfus4Q.png" alt="https://cdn-images-1.medium.com/max/800/1*GP4vXvW3WO0vTbggDfus4Q.png"></p><p>然后，只需使用你的应用程序。与各种组件交互，并观看 DevTools 工作的魔力。</p><h3 id="了解输出-2"><a href="#了解输出-2" class="headerlink" title="了解输出"></a>了解输出</h3><p>“react 开发人员工具”突出显示在给定时间点重新呈现的组件。根据更新的频率，使用不同的颜色。对于频繁更新的组件，蓝色显示不频繁更新，按更新频率依次为绿色，黄色和红色。</p><p>看到黄色或红色不一定是坏事。当调整滑块或触发频繁更新的其他UI元素时，可以预期。但是，如果您点击一个简单的按钮并看到红色，这可能意味着某些东西是错误的。该工具的目的是发现不必要的更新的组件。作为应用程序开发人员，您应该有一个一般的想法，哪些组件应该在给定的时间更新。</p><h3 id="演示＃3"><a href="#演示＃3" class="headerlink" title="演示＃3"></a>演示＃3</h3><p>为了演示组件突出显示，我安装了 TodoMVC 应用程序来不必要地更新某些组件。</p><p><a href="https://highlight-demo.firebaseapp.com/" target="_blank" rel="external">这是演示</a></p><p>打开上面的链接，然后打开 React Developer Tools 并启用更新突出显示。当您输入顶部文本输入时，您将看到所有 TODO 都不必要地突出显示。当您输入更快时，您将看到颜色更改以指示更频繁的更新。</p><h2 id="修复不必要的渲染"><a href="#修复不必要的渲染" class="headerlink" title="修复不必要的渲染"></a>修复不必要的渲染</h2><p>一旦识别出应用程序中不必要的重新渲染的组件，就会有一些简单的修复。</p><h3 id="使用PureComponent"><a href="#使用PureComponent" class="headerlink" title="使用PureComponent"></a>使用PureComponent</h3><p>在上面的例子中，<code>DumbComponent</code> 是它 props 的纯函数。也就是说，该组件只有在其 <code>props</code> 更改时才需要重新 render。React 有一种内置的特殊类型的组件，<code>PureComponent</code> 这个类型是为这个用例准备的。</p><p>而不是继承自 <code>React.Component</code>，请使用 <code>React.PureComponent</code>，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DumbComponent</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> &#123;this.props.value&#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后，该组件只有在其 <code>props</code> 实际更改时才会重新 render。而已！</p><p>请注意，<code>PureComponent</code>做一个 <code>props</code> 的浅比较，所以如果你使用复杂的数据结构，它可能会错过一些 <code>props</code> 更改，而不是更新您的组件。</p><h3 id="实现-shouldComponentUpdate"><a href="#实现-shouldComponentUpdate" class="headerlink" title="实现 shouldComponentUpdate"></a>实现 shouldComponentUpdate</h3><p><code>shouldComponentUpdate</code> 是 render 任何一个 <code>props</code> 或 <code>state</code> 更改之前调用的组件方法。如果 <code>shouldComponentUpdate</code> 返回 <code>true</code>，render 将被调用，如果它返回 <code>false</code>，没有任何反应。</p><p>通过实现此方法，您可以指示 React 避免重新渲染给定的组件，当其 <code>props</code> 不更改的时候。</p><p>例如，我们可以像下面这样，在一个组件中实现一个 <code>shouldComponentUpdate</code> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DumbComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  shouldComponentUpdate(nextProps) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.value !== nextProps.value) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">render() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="调试生产中的性能问题"><a href="#调试生产中的性能问题" class="headerlink" title="调试生产中的性能问题"></a>调试生产中的性能问题</h2><p>如果您在自己的机器上运行应用程序，“React Developer Tools”才能起作用。如果您有兴趣了解用户在生产中看到的性能问题，请尝试使用<a href="https://logrocket.com/" target="_blank" rel="external">LogRocket</a>。</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*s_rMyo6NbrAsP-XtvBaXFg.png" alt="https://cdn-images-1.medium.com/max/1000/1*s_rMyo6NbrAsP-XtvBaXFg.png"></p><p><a href="https://logrocket.com/" target="_blank" rel="external">LogRocket</a> 就像是网络应用程序，记录 DVR 字面上 的一切，您网站上发生的。您可以使用错误或性能问题重播会话，而不是猜测为什么会出现问题，以快速了解根本原因。</p><p>LogRocket 为您的应用程序记录性能数据，Redux actions/state，日志，错误，网络请求/响应与标题+主体和浏览器元数据。它还在页面上记录HTML和CSS，重新创建即使是最复杂的单页应用程序的像素视频。</p><blockquote><p>【翻译原文链接】：<a href="https://medium.freecodecamp.org/make-react-fast-again-tools-and-techniques-for-speeding-up-your-react-app-7ad39d3c1b82" target="_blank" rel="external">https://medium.freecodecamp.org/make-react-fast-again-tools-and-techniques-for-speeding-up-your-react-app-7ad39d3c1b82</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;高性能-react：3种加快应用程序的新工具&quot;&gt;&lt;a href=&quot;#高性能-react：3种加快应用程序的新工具&quot; class=&quot;headerlink&quot; title=&quot;高性能 react：3种加快应用程序的新工具&quot;&gt;&lt;/a&gt;高性能 react：3种加快应用程序的新工具&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*mJFYp7LKVzZM3PPjFb0QXQ.png&quot; alt=&quot;https://cdn-images-1.medium.com/max/2000/1*mJFYp7LKVzZM3PPjFb0QXQ.png&quot;&gt;&lt;/p&gt;&lt;p&gt;react 通常很快，但很容易造成导致性能问题的小错误。缓慢的组件安装，深层组件树和不必要的渲染循环可以快速添加到一个感觉缓慢的应用程序。&lt;/p&gt;&lt;p&gt;幸运的是，有很多工具，有些甚至内置于 React，这有助于诊断性能问题。在这篇文章中，我将强调使 React 应用程序更快速的工具和技术。每个部分还有一个互动，（希望）有趣的演示！
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="react" scheme="http://robin-front.github.io/tags/react/"/>
    
      <category term="tools" scheme="http://robin-front.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>Redux 并不慢，只是你使用姿势不对 —— 一份优化指南</title>
    <link href="http://robin-front.github.io/2017/07/17/react-redux-optimization/"/>
    <id>http://robin-front.github.io/2017/07/17/react-redux-optimization/</id>
    <published>2017-07-17T09:12:02.000Z</published>
    <updated>2017-07-17T09:12:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redux-并不慢，只是你使用姿势不对-——-一份优化指南"><a href="#Redux-并不慢，只是你使用姿势不对-——-一份优化指南" class="headerlink" title="Redux 并不慢，只是你使用姿势不对 —— 一份优化指南"></a>Redux 并不慢，只是你使用姿势不对 —— 一份优化指南</h1><p><em>如何优化使用了 Redux 的 react 应用程序并不是显而易见的。但实际上相当简单。这是一个简短的指南，以及一些例子。</em></p><p>当优化使用 Redux 的 react 应用程序时，我经常听到有人说 Redux 缓慢。在99％的情况下，性能不佳的原因（适用于任何其他框架）与不必要的渲染相关联，因为 DOM 更新是昂贵的！在本文中，您将学习如何在使用 Redux 绑定 react 时避免不必要的 <code>render</code>。</p><p>通常，我们使用<a href="https://github.com/reactjs/react-redux" target="_blank" rel="external">官方 react 绑定的 Redux</a> 的 <a href="https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options" target="_blank" rel="external">connect</a> 高阶组件， 当您的 Redux <code>store</code> 更新时，react 组件就会更新。这是一个将组件包装在另一个组件中的函数，该组件订阅了 Redux <code>store</code> 中的更改，并渲染 <code>store</code>，这就是它的子节点更新的原因。<a id="more"></a></p><h2 id="快速入坑-react-redux，官方-react-绑定-Redux"><a href="#快速入坑-react-redux，官方-react-绑定-Redux" class="headerlink" title="快速入坑 react-redux，官方 react 绑定 Redux"></a>快速入坑 react-redux，官方 react 绑定 Redux</h2><p>该 <code>connect</code> 高阶组件实际上是已经过优化。要了解如何最好地使用它，最好了解先它是如何工作的！</p><p>Redux 以及 react-redux 实际上是相当小的库，所以源代码并不费解。我鼓励大家阅读源代码，或至少其中的一些。如果你想进一步，编写自己的实现，它将让你深入了解为什么库的设计方式是这样的。</p><p>不用多说，我们来看看 react 绑定的工作原理。正如我们公认的那样，react 绑定的核心部分就是 <code>connect</code> 高阶组件，这是它的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"></span></span></div><div class="line">  mapStateToProps,</div><div class="line">  mapDispatchToProps,</div><div class="line">  mergeProps,</div><div class="line">  &#123;</div><div class="line">    pure = true,</div><div class="line">    areStatesEqual = strictEqual,</div><div class="line">    areOwnPropsEqual = shallowEqual,</div><div class="line">    areStatePropsEqual = shallowEqual,</div><div class="line">    areMergedPropsEqual = shallowEqual,</div><div class="line">    ...extraOptions</div><div class="line">  &#125; = &#123;&#125;</div><div class="line">) &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>作为附注 - 唯一的强制性参数是 <code>mapStateToProps</code>，在大多数情况下，您只需要前两个参数。但是，我在这里使用完整的写法来说明 <code>react bindings</code> 是如何工作的。</p><p>传递给 <code>connect</code> 函数的所有参数都用于生成一个对象，该对象作为 <code>props</code> 传递到封装的组件上。<code>mapStateToProps</code> 用于将状态从 Redux store 映射到一个对象，<code>mapDispatchToProps</code> 用于生成包含函数的对象 - 通常这些函数是 <code>actions</code> 创建者。最后，<code>mergeProps</code> 有三个参数 <code>stateProps</code>，<code>dispatchProps</code> 和 <code>ownProps</code>。第一个是 <code>mapStateToProps</code> 的结果，第二个参数是 <code>mapDispatchToProps</code> 的结果，第三个参数是从组件本身继承的 <code>props</code> 对象。默认情况下，<code>mergeProps</code> 将这些参数简单地组合到一个对象中，但是如果您传递一个函数作为 <code>mergeProps</code> 参数，<code>connect</code> 则将使用该函数生成封装组件的 <code>props</code>。</p><p><code>connect</code> 函数的第四个参数是一个 <code>options</code> 对象。这包含5个选项：<code>pure</code> 可以是 <code>true</code> 或 <code>false</code>，以及确定是否重新渲染组件的4个函数（应该返回一个布尔值）。<code>pure</code> 默认设置为<code>true</code>。如果设置为<code>false</code>，则<code>connect</code> 将跳过任何优化，并且<code>options</code>对象中的4个函数将不生效。我个人不能想到一个用例，但是如果您希望关闭优化，则将其设置为<code>false</code>。</p><p>我们的 <code>mergeProps</code> 函数产生的对象与最后一个 <code>props</code> 对象进行比较。如果我们的 <code>connect</code> 认为 <code>props</code> 对象已经改变了，那么这个组件就会重新渲染。要了解库如何决定是否有变更，我们可以查看该 <code>shallowEqual</code> 功能。如果函数返回 <code>true</code>，组件将不会重新渲染，如果返回 <code>false</code>，它将重新渲染。<code>shallowEqual</code> 执行此比较。下面你会看到 <code>shallowEqual</code> 方法的一部分，它告诉你所有你需要知道的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keysA.length; i++) &#123;</div><div class="line">  <span class="keyword">if</span> (!hasOwn.call(objB, keysA[i]) ||</div><div class="line">      !is(objA[keysA[i]], objB[keysA[i]])) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>总而言之，这是上面的代码：</p><p>它在 object a 中的 key 上循环，并检查 object B 是否拥有相同的属性。然后它检查 object A中的属性（具有相同名称）是否等于对象B的属性。如果只有一个比较返回false，那么对象将被视为不相等，并且会发生重新渲染。</p><p>这导致我们一个黄金法则：</p><h2 id="只给您的组件它需要呈现的数据"><a href="#只给您的组件它需要呈现的数据" class="headerlink" title="只给您的组件它需要呈现的数据"></a>只给您的组件它需要呈现的数据</h2><p>这说得很含糊，所以让我们用一些实际的例子来阐述。</p><h3 id="拆分连接的组件"><a href="#拆分连接的组件" class="headerlink" title="拆分连接的组件"></a>拆分连接的组件</h3><p>我看到人们这样做 订阅容器组件一系列状态，并通过 <code>props</code> 传递所有东西。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> BigComponent = <span class="function">(<span class="params">&#123; a, b, c, d &#125;</span>) =&gt;</span> (</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;CompA a=&#123;a&#125; /&gt;</div><div class="line">    &lt;CompB b=&#123;b&#125; /&gt;</div><div class="line">    &lt;CompC c=&#123;c&#125; /&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">);</div><div class="line"></div><div class="line">const ConnectedBigComponent = connect(</div><div class="line">  (&#123; a, b, c &#125;) =&gt; (&#123; a, b, c &#125;)</div><div class="line">);</div></pre></td></tr></table></figure><p>现在，每次要么a，b或c变化，BigComponent包括CompA，CompB并且CompC将重新呈现。</p><p>相反，拆分您的组件，不要害怕更多地使用 connect：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ConnectedA = connect(CompA, (&#123; a &#125;) =&gt; (&#123; a &#125;));</div><div class="line"><span class="keyword">const</span> ConnectedB = connect(CompB, (&#123; b &#125;) =&gt; (&#123; b &#125;));</div><div class="line"><span class="keyword">const</span> ConnectedC = connect(CompC, (&#123; c &#125;) =&gt; (&#123; c &#125;));</div><div class="line"></div><div class="line"><span class="keyword">const</span> BigComponent = <span class="function"><span class="params">()</span> =&gt;</span> (</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;ConnectedA a=&#123;a&#125; /&gt;</div><div class="line">    &lt;ConnectedB b=&#123;b&#125; /&gt;</div><div class="line">    &lt;ConnectedC c=&#123;c&#125; /&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">);</div></pre></td></tr></table></figure><p>通过此次更新，<code>CompA</code> 将只有当<code>a</code>已经改变才会重新渲染，<code>CompB</code>当<code>b</code>改变等。考虑这样一个场景，每一个值<code>a</code>，<code>b</code>并<code>c</code>分别经常更新。对于每次更新，我们现在重新渲染一个，而不是所有组件。这几乎没有什么明显的三个组件，但如果你有更多！</p><h3 id="改变你的状态，使其尽可能的最小"><a href="#改变你的状态，使其尽可能的最小" class="headerlink" title="改变你的状态，使其尽可能的最小"></a>改变你的状态，使其尽可能的最小</h3><p>这是一个假设（稍微设计过）的例子：</p><p>你有一个大的项目列表，我们假设有300或更多。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;List&gt;</div><div class="line">  &#123;<span class="keyword">this</span>.props.items.map(<span class="function">(<span class="params">&#123; content, itemId &#125;</span>) =&gt;</span> (</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ListItem</span></span></span></div><div class="line">      <span class="attr">onClick</span>=<span class="string">&#123;selectItem&#125;</span></div><div class="line">      <span class="attr">content</span>=<span class="string">&#123;content&#125;</span></div><div class="line">      <span class="attr">itemId</span>=<span class="string">&#123;itemId&#125;</span></div><div class="line">      <span class="attr">key</span>=<span class="string">&#123;itemId&#125;</span></div><div class="line">    /&gt;</div><div class="line">  ))&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">List</span>&gt;</span></div></pre></td></tr></table></figure><p>当我们点击一​​个列表项时，一个动作被触发，更新一个存储值 - <code>selectedItem</code>。每个列表项连接到 Redux 并获取<code>selectedItem</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ListItem = connect(</div><div class="line">  <span class="function">(<span class="params">&#123; selectedItem &#125;</span>) =&gt;</span> (&#123; selectedItem &#125;)</div><div class="line">)(SimpleListItem);</div></pre></td></tr></table></figure><p>我们正在做正确的事情，我们仅将组件连接到所需的状态。但是，当<code>selectedItem</code>更新时，所有<code>ListItem</code>组件都将重新渲染，因为我们返回的对象<code>selectedItem</code>已经更改。在此之前 <code>{ selectedItem: 123 }</code>，现在是 <code>{ selectedItem: 120 }</code>。</p><p>请记住，我们正在使用该 <code>selectedItem</code> 值来检查当前项目是否被选中。所以我们的组件真正需要知道的是它是否被选择 - 实质上是一个<code>Boolean</code>。<code>Boolean</code> 是伟大的，因为只有两个可能的值，<code>true</code> 或者 <code>false</code>。所以如果我们返回一个布尔值，而不是 <code>selectedItem</code> ，仅 <code>Boolean</code> 更改的两个项目将会重新渲染，这就是我们需要的。<code>mapStateToProps</code> 实际上 <code>props</code> 它是组件的第二个参数，我们可以用它来检查这是否实际上是选定的项目。以下是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ListItem = connect(</div><div class="line">  <span class="function">(<span class="params">&#123; selectedItem &#125;, &#123; itemId &#125;</span>) =&gt;</span> (&#123; <span class="attr">isSelected</span>: selectedItem === itemId &#125;)</div><div class="line">)(SimpleListItem);</div></pre></td></tr></table></figure><p>现在，只要我们的 <code>selectedItem</code> 值发生变化，只有两个组件重新呈现 - <code>ListItem</code> 现在已经被选择了，而且原来那个已经被取消选择了。</p><h3 id="保持数据扁平化"><a href="#保持数据扁平化" class="headerlink" title="保持数据扁平化"></a>保持数据扁平化</h3><p>在 <a href="http://redux.js.org/docs/recipes/reducers/NormalizingStateShape.html" target="_blank" rel="external">Redux文档提到</a> 这是一种最佳实践。保持您的store 扁平化是有益的一些原因。但是对于本文的主旨，嵌套会造成问题，因为为了让我们的应用程序尽可能的快，我们希望我们的更新尽可能的细微。假设我们有一个这样的嵌套形状：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">articles</span>: [&#123;</div><div class="line">    <span class="attr">comments</span>: [&#123;</div><div class="line">      <span class="attr">users</span>: [&#123;</div><div class="line">      &#125;]</div><div class="line">    &#125;]</div><div class="line">  &#125;],</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>为了优化我们的 <code>Article</code>，<code>Comment</code> 和 <code>User</code> 组件，我们现在需要所有的人订阅 <code>articles</code>，然后深深伸入这种结构只返回他们所需要的状态。相反地​​，如此设计你的形状更有意义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">articles</span>: [&#123;</div><div class="line">    ...</div><div class="line">  &#125;],</div><div class="line">  <span class="attr">comments</span>: [&#123;</div><div class="line">    <span class="attr">articleId</span>: ..,</div><div class="line">    <span class="attr">userId</span>: ...,</div><div class="line">    ...</div><div class="line">  &#125;],</div><div class="line">  <span class="attr">users</span>: [&#123;</div><div class="line">    ...</div><div class="line">  &#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后使用映射函数选择注释和用户信息。关于这一点的更多信息可以在 <a href="http://redux.js.org/docs/recipes/reducers/NormalizingStateShape.html" target="_blank" rel="external">Redux文档中阅读关于规范化状态的信息</a>。</p><h2 id="彩蛋：用于选择-Redux-state-的库"><a href="#彩蛋：用于选择-Redux-state-的库" class="headerlink" title="彩蛋：用于选择 Redux state 的库"></a>彩蛋：用于选择 Redux state 的库</h2><p>这是完全可选的，取决于您。通常所有以上的建议都足够深入地让你写出快速的 react 和 Redux 应用程序。但是有两个优秀的库使得选择状态更容易一些：</p><p><a href="https://github.com/reactjs/reselect" target="_blank" rel="external">Reselect</a> 是 <code>selectors</code> 为您的 Redux 应用程序编写的引人注目的工具。从重新选择文档：</p><ul><li>选择器可以计算派生数据，允许 Redux 存储尽可能小的状态。</li><li>选择器效率高。除非其中一个参数发生变化，否则不会重新计算选择器。</li><li>选择器是可组合的。它们可以用作其他选择器的输入。</li></ul><p>对于具有复杂接口，复杂状态 和/或 频繁更新的应用程序，重新选择可以帮助您轻松使您的应用程序更快！</p><p><a href="http://ramdajs.com/" target="_blank" rel="external">Ramda</a> 是一个功能强大的库，具有更高阶的函数。换句话说 - 用函数创建函数。由于我们的映射函数只是这个函数，所以我们可以很方便地使用 <code>Ramda</code> 创建我们的选择器。<code>Ramda</code> 可以有选择器的所有功能并做的更多。查看 <a href="https://github.com/ramda/ramda/wiki/Cookbook" target="_blank" rel="external">Ramda 食谱</a>的一些例子，您可以使用 Ramda 做什么。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redux-并不慢，只是你使用姿势不对-——-一份优化指南&quot;&gt;&lt;a href=&quot;#Redux-并不慢，只是你使用姿势不对-——-一份优化指南&quot; class=&quot;headerlink&quot; title=&quot;Redux 并不慢，只是你使用姿势不对 —— 一份优化指南&quot;&gt;&lt;/a&gt;Redux 并不慢，只是你使用姿势不对 —— 一份优化指南&lt;/h1&gt;&lt;p&gt;&lt;em&gt;如何优化使用了 Redux 的 react 应用程序并不是显而易见的。但实际上相当简单。这是一个简短的指南，以及一些例子。&lt;/em&gt;&lt;/p&gt;&lt;p&gt;当优化使用 Redux 的 react 应用程序时，我经常听到有人说 Redux 缓慢。在99％的情况下，性能不佳的原因（适用于任何其他框架）与不必要的渲染相关联，因为 DOM 更新是昂贵的！在本文中，您将学习如何在使用 Redux 绑定 react 时避免不必要的 &lt;code&gt;render&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;通常，我们使用&lt;a href=&quot;https://github.com/reactjs/react-redux&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方 react 绑定的 Redux&lt;/a&gt; 的 &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;connect&lt;/a&gt; 高阶组件， 当您的 Redux &lt;code&gt;store&lt;/code&gt; 更新时，react 组件就会更新。这是一个将组件包装在另一个组件中的函数，该组件订阅了 Redux &lt;code&gt;store&lt;/code&gt; 中的更改，并渲染 &lt;code&gt;store&lt;/code&gt;，这就是它的子节点更新的原因。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="react" scheme="http://robin-front.github.io/tags/react/"/>
    
      <category term="redux" scheme="http://robin-front.github.io/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>优化 react 让它快如闪电——你是电，你是光，你是唯一的神话</title>
    <link href="http://robin-front.github.io/2017/07/17/react-at-light-speed/"/>
    <id>http://robin-front.github.io/2017/07/17/react-at-light-speed/</id>
    <published>2017-07-17T07:23:17.000Z</published>
    <updated>2017-07-17T07:23:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="光速-React"><a href="#光速-React" class="headerlink" title="光速 React"></a>光速 React</h1><h2 id="Vixlet-团队优化性能的经验教训"><a href="#Vixlet-团队优化性能的经验教训" class="headerlink" title="Vixlet 团队优化性能的经验教训"></a>Vixlet 团队优化性能的经验教训</h2><p><img src="https://cdn-images-1.medium.com/max/1000/1*SJzLm3SW2IegLw0GzlaG-w.jpeg" alt=""></p><p>在过去一年多，我们 <a href="http://www.vixlet.com" target="_blank" rel="external">Vixlet</a> 的 web 团队已经着手于一个激动人心的项目：将我们的整个 web 应用迁移到 <code>React</code> + <code>Redux</code> 架构。对于整个团队来说，这是不断成长中的机会，在整个过程中，我们在这方面面临一些挑战。</p><p>因为我们的 web-app 可能有非常大的 feed 视图，包括成百上千的媒体、文本、视频、链接元素，我们花了相当多的时间寻找能充分利用 <code>React</code> 性能的方法。在这里，我们将分享我们这一路学到的一些经验教训。</p><p><strong>声明</strong>：<strong>下面讲的做法和方法更适用于我们具体应用的性能需求。然而，像所有的开发者建议的那样，最重要的是要考虑到你的应用程序和团队的实际需求。React 是一个开箱即用的框架，所以你可能不需要像我们一样细致地优化性能。话虽如此，我们还是希望你能在这篇文章里找到一些有用的信息。</strong><a id="more"></a></p><h3 id="基本优化"><a href="#基本优化" class="headerlink" title="基本优化"></a>基本优化</h3><p><img src="https://cdn-images-1.medium.com/max/800/1*UOGdUM1V_rGUbxLS-eaWdQ.gif" alt=""></p><p>向更大的世界迈出第一步。</p><h4 id="render-函数"><a href="#render-函数" class="headerlink" title="render() 函数"></a>render() 函数</h4><p>一般来说，要尽可能少地在 <code>render</code> 函数中做操作。如果非要做一些复杂操作或者计算，也许你可以考虑使用一个 <a href="https://en.wikipedia.org/wiki/Memoization" target="_blank" rel="external">memoized</a> 函数以便于缓存那些重复的结果。可以看看 <a href="https://lodash.com/docs#memoize" target="_blank" rel="external">Lodash.memoize</a>，这是一个开箱即用的记忆函数。</p><p>反过来讲，避免在组件的 <code>state</code> 上存储一些容易计算的值也很重要。举个例子，如果 <code>props</code> 同时包含 <code>firstName</code> 和 <code>lastName</code>，没必要在 <code>state</code> 上存一个 <code>fullName</code>，因为它可以很容易通过提供的 <code>props</code> 来获取。如果一个值可以通过简单的字符串拼接或基本的算数运算从 <code>props</code> 派生出来，那么没理由将这些值包含在组件的 <code>state</code> 上。</p><h4 id="Prop-和-Reconciliation"><a href="#Prop-和-Reconciliation" class="headerlink" title="Prop 和 Reconciliation"></a>Prop 和 Reconciliation</h4><p>重要的是要记住，只要 <code>props</code>（或 <code>state</code>）的值不等于之前的值，<code>React</code> 就会触发重新渲染。如果 <code>props</code> 或者 <code>state</code> 包含一个对象或者数组，嵌套值中的任何改变也会触发重新渲染。考虑到这一点，你需要注意在每次渲染的生命周期中，创建一个新的 <code>props</code> 或者 <code>state</code> 都可能无意中导致了性能下降。</p><p><strong>例子: 函数绑定的问题</strong></p><script src="https://gist.github.com/jacob-beltran/638dcc9978b498c82d68a19593266999.js"></script><p><strong>例子:</strong> <strong>对象或数组字面量</strong></p><script src="https://gist.github.com/jacob-beltran/7777a477942cbb2c9db65a1e3c312e88.js"></script><p><strong>例子</strong> <strong>: 注意字面量的回退值</strong></p><script src="https://gist.github.com/jacob-beltran/ae63069d95831fb49e59e74eb7ddbd11.js"></script><h4 id="尽可能的保持-Props（和-State）简单和精简"><a href="#尽可能的保持-Props（和-State）简单和精简" class="headerlink" title="尽可能的保持 Props（和 State）简单和精简"></a>尽可能的保持 Props（和 State）简单和精简</h4><p>理想情况下，传递给组件的 <code>props</code> 应该是它直接需要的。为了将值传给子组件而将一个大的、复杂的对象或者很多独立的 <code>props</code> 传递给一个组件会导致很多不必要的组件渲染（并且会增加开发复杂性）。</p><p>在 Vixlet，我们使用 Redux 作为状态容器，所以在我们看来，最理想的是方案在组件层次结构的每一个层级中使用 <a href="https://www.npmjs.com/package/react-redux" target="_blank" rel="external">react-redux</a> 的 <a href="https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options" target="_blank" rel="external">connect()</a> 函数直接从 <code>store</code> 上获取数据。<code>connect</code> 函数的性能很好，并且使用它的开销也非常小。</p><h4 id="组件方法"><a href="#组件方法" class="headerlink" title="组件方法"></a>组件方法</h4><p>由于组件方法是为组件的每个实例创建的，如果可能的话，使用 <code>helper/util</code> 模块的纯函数或者<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="external">静态类方法</a>。尤其在渲染大量组件的应用中会有明显的区别。</p><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p><img src="https://cdn-images-1.medium.com/max/800/1*9n2fdJB1gPYLFJAj5D5RqA.gif" alt=""></p><p>在我看来视图的变化是邪恶的！</p><h4 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate()"></a>shouldComponentUpdate()</h4><p>React 有一个生命周期函数 <a href="https://facebook.github.io/react/docs/react-component.html#shouldcomponentupdate" target="_blank" rel="external">shouldComponentUpdate()</a>。这个方法可以根据当前的和下一次的 <code>props</code> 和 <code>state</code> 来通知这个 React 组件是否应该被重新渲染。</p><p>然而使用这个方法有一个问题，开发者必须考虑到需要触发重新渲染的每一种情况。这会导致逻辑复杂，一般来说，会非常痛苦。如果非常需要，你可以使用一个自定义的 <code>shouldComponentUpdate()</code> 方法，但是很多情况下有更好的选择。</p><h4 id="React-PureComponent"><a href="#React-PureComponent" class="headerlink" title="React.PureComponent"></a>React.PureComponent</h4><p>React 从 <code>v15</code> 开始会包含一个 <code>PureComponent</code> 类，它可以被用来构建组件。<code>React.PureComponent</code> 声明了它自己的 <code>shouldComponentUpdate()</code> 方法，它自动对当前的和下一次的 <code>props</code> 和 <code>state</code> 做一次浅对比。有关浅对比的更多信息，请参考这个 Stack Overflow：</p><p><a href="http://stackoverflow.com/questions/36084515/how-does-shallow-compare-work-in-react" target="_blank" rel="external">http://stackoverflow.com/questions/36084515/how-does-shallow-compare-work-in-react</a></p><p>在大多数情况下，<code>React.PureComponent</code> 是比 <code>React.Component</code> 更好的选择。在创建新组件时，首先尝试将其构建为纯组件，只有组件需要更多功能时才使用 <code>React.Component</code>。</p><p>更多信息，请查阅相关文档 <a href="https://facebook.github.io/react/docs/react-api.html#react.purecomponent" target="_blank" rel="external">React.PureComponent</a>。</p><h4 id="组件性能分析（在-Chrome-里）"><a href="#组件性能分析（在-Chrome-里）" class="headerlink" title="组件性能分析（在 Chrome 里）"></a>组件性能分析（在 Chrome 里）</h4><p>在新版本的 Chrome <code>里，timeline</code> 工具里有一个额外的内置功能可以显示哪些 React 组件正在渲染以及他们花费的时间。要启用此功能，将 <code>?react_perf</code> 作为要测试的 URL 的查询字符串。React 渲染时间轴数据将位于 User Timing 部分。</p><p>更多相关信息，请查阅官方文档：<a href="https://facebook.github.io/react/docs/optimizing-performance.html#profiling-components-with-chrome-timeline" target="_blank" rel="external">Profiling Components with Chrome Timeline</a> 。</p><h4 id="有用的工具-why-did-you-update"><a href="#有用的工具-why-did-you-update" class="headerlink" title="有用的工具: why-did-you-update"></a>有用的工具: <a href="https://www.npmjs.com/package/why-did-you-update" target="_blank" rel="external">why-did-you-update</a></h4><p>这是一个很棒的 NPM 包，他们给 React 添加补丁，当一个组件触发了不必要的重新渲染时，它会在控制台输出一个 <code>console</code> 提示。</p><p><strong>注意</strong>: 这个模块在初始化时可以通过一个过滤器匹配特定的想要优化的组件，否则你的命令行可能会被垃圾信息填满，并且可能你的浏览器会因此而挂起或者崩溃，查阅 <a href="https://www.npmjs.com/package/why-did-you-update" target="_blank" rel="external">why-did-you-update 文档</a> 获取更多详细信息。</p><h3 id="常见性能陷阱"><a href="#常见性能陷阱" class="headerlink" title="常见性能陷阱"></a>常见性能陷阱</h3><p><img src="https://cdn-images-1.medium.com/max/800/1*GVteDSQnhXZCSui8JRp10A.gif" alt=""></p><h4 id="setTimeout-和-setInterval"><a href="#setTimeout-和-setInterval" class="headerlink" title="setTimeout() 和 setInterval()"></a>setTimeout() 和 setInterval()</h4><p>在 React 组件中使用 <code>setTimeout()</code> 或者 <code>setInterval()</code> 要十分小心。几乎总是有更好的选择，例如 ‘resize’ 和 ‘scroll’ 事件（注意：有关注意事项请参阅下一节）。</p><p>如果你需要使用 <code>setTimeout()</code> 和 <code>setInterval()</code>，你必须 <strong>遵守下面两条建议</strong></p><blockquote><p>不要设置过短的时间间隔。</p></blockquote><p>当心那些小于 100 ms 的定时器，他们很可能是没意义的。如果确实需要一个更短的时间，可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" target="_blank" rel="external">window.requestAnimationFrame()</a> 替代。</p><blockquote><p>保留对这些函数的引用，并且在 unmount 时取消或者销毁他们。</p></blockquote><p><code>setTimeout()</code> 和 <code>setInterval()</code> 都返回一个延迟函数的引用，并且需要的时候可以取消它们。由于这些函数是在全局作用域执行的，他们不在乎你的组件是否存在，这会导致报错甚至程序卡死。</p><p><strong>注意</strong>: 对 <code>window.requestAnimationFrame()</code> 来说也是如此</p><p>解决这个问题最简答的方法是使用 <a href="https://www.npmjs.com/package/react-timeout" target="_blank" rel="external">react-timeout</a> 这个 NPM 包，它提供了一个可以自动处理上述内容的高阶组件。它将 setTimeout/setInterval 等功能添加到包装组建的 <code>props</code> 上。(<strong>特别感谢 Vixlet 的开发人员 <a href="https://twitter.com/@carlpillot" target="_blank" rel="external"><em>Carl Pillot</em></a> 提供这个方法</strong>)</p><p>如果你不想引入这个依赖，并且希望自行解决此问题，你可以使用以下的方法：</p><script src="https://gist.github.com/jacob-beltran/910bd1d7ede863cd8178c0ecb40a075f.js"></script><p>如果你使用 requestAnimationFrame() 执行的一个动画循环，可以使用一个非常相似的解决方案，当前代码要有一点小的修改：</p><script src="https://gist.github.com/jacob-beltran/aa114af1b6fd5de866aa365e3763a90b.js"></script><h4 id="未-去抖-频繁触发的事件"><a href="#未-去抖-频繁触发的事件" class="headerlink" title="未 去抖 频繁触发的事件"></a>未 去抖 频繁触发的事件</h4><p>某些常见的事件可能会非常频繁的触发，例如 <code>scroll</code>，<code>resize</code>。去抖这些事件是明智的，特别是如果事件处理程序执行的不仅仅是基本功能。</p><p><code>Lodash</code> 有 <a href="https://lodash.com/docs/#debounce" target="_blank" rel="external">_.debounce</a> 方法。在 NPM 上还有一个独立的 <a href="https://www.npmjs.com/package/debounce" target="_blank" rel="external">debounce</a> 包.</p><blockquote><p>“但是我真的需要立即反馈 scroll/resize 或者别的事件”</p></blockquote><p>我发现一种可以处理这些事件并且以高性能的方式进行响应的方法，那就是在第一次事件触发时启动 <code>requestAnimationFrame()</code> 循环。然后可以使用 <code>[debounce()](https://lodash.com/docs#debounce)</code> 方法并且将 <code>trailing</code> 这个配置项设为 <code>true</code>（<strong>这意味着该功能只在频繁触发的事件流结束后触发</strong>）来取消对值的监听，看看下面这个例子。</p><script src="https://gist.github.com/jacob-beltran/84bd0aea2c1023743dda09172d30bc16.js"></script><h4 id="密集CPU任务线程阻塞"><a href="#密集CPU任务线程阻塞" class="headerlink" title="密集CPU任务线程阻塞"></a>密集CPU任务线程阻塞</h4><p>某些任务一直是 CPU 密集型的，因此可能会导致主渲染线程的阻塞。举几个例子，比如非常复杂的数学计算，迭代非常大的数组，使用 <code>File</code> api 进行文件读写，利用 <code>&lt;canvas&gt;</code> 对图片进行编码解码。</p><p>在这些情况下，如果有可能最好使用 <code>Web Worker</code> 将这些功能移到另一个线程上，这样我们的主渲染线程可以保持顺滑。</p><p><strong>相关阅读</strong></p><p>MDN 文章: <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="external">Using Web Workers</a></p><p>MDN 文档: <a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker" target="_blank" rel="external">Worker API</a></p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>我们希望上述建议对您能有所帮助。如果没有 Vixlet 团队的伟大工作和研究，上述的提示和编程技巧是不可能产出的。他们真的是我曾经合作过的最棒的团队之一。</p><p>在你的 React 的征途中保持学习和练习，愿原力与你同在！</p><blockquote><p>原文地址：<a href="https://blog.vixlet.com/react-at-light-speed-78cd172a6411" target="_blank" rel="external">React at Light Speed</a> <a href="https://blog.vixlet.com/@jacob_beltran" target="_blank" rel="external">@Jacob Beltran</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;光速-React&quot;&gt;&lt;a href=&quot;#光速-React&quot; class=&quot;headerlink&quot; title=&quot;光速 React&quot;&gt;&lt;/a&gt;光速 React&lt;/h1&gt;&lt;h2 id=&quot;Vixlet-团队优化性能的经验教训&quot;&gt;&lt;a href=&quot;#Vixlet-团队优化性能的经验教训&quot; class=&quot;headerlink&quot; title=&quot;Vixlet 团队优化性能的经验教训&quot;&gt;&lt;/a&gt;Vixlet 团队优化性能的经验教训&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1000/1*SJzLm3SW2IegLw0GzlaG-w.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;在过去一年多，我们 &lt;a href=&quot;http://www.vixlet.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Vixlet&lt;/a&gt; 的 web 团队已经着手于一个激动人心的项目：将我们的整个 web 应用迁移到 &lt;code&gt;React&lt;/code&gt; + &lt;code&gt;Redux&lt;/code&gt; 架构。对于整个团队来说，这是不断成长中的机会，在整个过程中，我们在这方面面临一些挑战。&lt;/p&gt;&lt;p&gt;因为我们的 web-app 可能有非常大的 feed 视图，包括成百上千的媒体、文本、视频、链接元素，我们花了相当多的时间寻找能充分利用 &lt;code&gt;React&lt;/code&gt; 性能的方法。在这里，我们将分享我们这一路学到的一些经验教训。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;声明&lt;/strong&gt;：&lt;strong&gt;下面讲的做法和方法更适用于我们具体应用的性能需求。然而，像所有的开发者建议的那样，最重要的是要考虑到你的应用程序和团队的实际需求。React 是一个开箱即用的框架，所以你可能不需要像我们一样细致地优化性能。话虽如此，我们还是希望你能在这篇文章里找到一些有用的信息。&lt;/strong&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="react" scheme="http://robin-front.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>npx是什么，为什么需要npx?</title>
    <link href="http://robin-front.github.io/2017/07/14/introducing-npx-an-npm-package-runner/"/>
    <id>http://robin-front.github.io/2017/07/14/introducing-npx-an-npm-package-runner/</id>
    <published>2017-07-14T09:31:57.000Z</published>
    <updated>2017-07-14T09:31:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍npx：一个npm包运行"><a href="#介绍npx：一个npm包运行" class="headerlink" title="介绍npx：一个npm包运行"></a>介绍npx：一个npm包运行</h1><p>NPM升级到最新版本，<a href="https://github.com/npm/npm/releases/tag/v5.2.0" target="_blank" rel="external">npm@5.2.0</a>，你可能会发现，它会安装一个新的二进制包跟着 <code>npm</code>：<a href="https://npm.im/npx" target="_blank" rel="external">npx</a>。</p><p><code>npx</code> 是一个工具，旨在帮助整理从npm注册软件包的体验 - 和 使得npm非常容易地安装和管理托管在注册表上的依赖关系是 同样的方式，<code>npx</code>使 npm 很方便使用CLI工具和其他被托管的可执行文件。它大大简化了一些事情，到目前为止，需要一些与普通的npm有关的步骤：</p><a id="more"></a><h1 id="使用本地化的安装工具而不用-npm-run-script"><a href="#使用本地化的安装工具而不用-npm-run-script" class="headerlink" title="使用本地化的安装工具而不用 npm run-script"></a>使用本地化的安装工具而不用 npm run-script</h1><p><img src="https://cdn-images-1.medium.com/max/800/1*A4HJT1FHQA_1_z3aMBc5mg.gif" alt="https://cdn-images-1.medium.com/max/800/1*A4HJT1FHQA_1_z3aMBc5mg.gif"></p><center><small>将cowsay作为本地devDependency进行安装，并以“$ npx cowsay”运行</small></center><p>在过去几年中，npm生态系统越来越多地将安装工具作为项目本地化<code>devDependencies</code>，而不是要求用户在全局安装。这意味着，像工具<code>mocha</code>，<code>grunt</code>和<code>bower</code>，曾经被要求安装在系统的全局目录上，现在可以在每个项目的基础上管理自己的版本。这也意味着，所有你需要做的就是基于NPM的项目运行起来，以确保您有<code>node + NPM</code>您的系统上，克隆github项目，并运行<code>npm it</code>去运行<code>install</code>和<code>test</code>。由于<code>npm run-script</code>添加本地二进制文件到路径，这个工作很好！</p><p>不利之处在于，它不会快速/方便地以交互方式调用本地二进制文件。有几种方法可以做到这一点，他们都对他们有一些烦恼：你可以添加这些工具到你<code>scripts</code>，但是你需要记住通过使用传递参数<code>--</code>，你可以通过<code>shell</code>技巧<code>alias npmx=PATH=$(npm bin):$PATH</code> 做到，或者你可以手动路径他们，使用 <code>./node_modules/.bin/mocha</code>。这些都是工作，但没有一个是非常理想的。</p><p><code>npx</code>给你我认为是最好的解决方案：您需要做的是使用<code>$ npx mocha</code>进行本地安装。如果你再进行一个额外的步骤并<a href="https://www.npmjs.com/package/npx#shell-auto-fallback" target="_blank" rel="external">配置shell自动回退</a>（更多内容在下面会提到），那么在一个项目目录中运行<code>$ mocha</code>将会成为你的技巧！</p><p>作为彩蛋，如果调用已经安装的二进制文件，<a href="https://twitter.com/maybekatz/status/877444832494596096" target="_blank" rel="external">npx基本上没有开销</a> - 这足以将该工具的代码直接加载到当前运行的node进程中！这种事情就像读取文件一样快，并且使它成为一个完全可以接受的脚本编写工具。</p><h1 id="执行一次性命令"><a href="#执行一次性命令" class="headerlink" title="执行一次性命令"></a>执行一次性命令</h1><p><img src="https://cdn-images-1.medium.com/max/800/1*OlIRsvVO5aK7ja9HmwXz_Q.gif" alt="https://cdn-images-1.medium.com/max/800/1*OlIRsvVO5aK7ja9HmwXz_Q.gif"></p><center><small><code>$ npx create-react-app my-cool-new-app</code>安装一个临时的创建应答程序并调用它，而不会污染全局安装或需要多个步骤！</small></center><p>你有没有遇到过 想要尝试一些CLI工具的情况，但是要安装一个全局只是为了运行一次，这很烦人？<code>npx</code>对这种情况也是很有用。调用的<code>npx &lt;command&gt;</code>当<code>&lt;command&gt;</code>不在你的<code>$PATH</code>意愿列表中，会自动从你的npm注册表中安装一个包含该名称的包，然后调用它。完成后，安装的软件包将不会储存在全球范围内任何地方，所以您不用担心长期的污染。</p><p>此功能也适用于<code>generators</code>等。像<code>yeoman</code>或<code>create-react-app</code>这样的工具只被调用一次。<strong>当你再次运行它们时，他们已经过时了，所以你最终不得不在每次想要使用它们时再次安装更新</strong>。</p><p>作为一种工具的维护者，我很喜欢这个功能，因为这意味着我可以把<code>$ npx my-tool</code>写进<code>README.md</code>的指令，而不是试图让人们在实际安装它的障碍。坦白说，说“哦，只需复制粘贴这一个命令，这是零成本的”更贴切，对于不确定是否使用这个工具的用户来说。</p><p>这里，你可能想用尝试一些其他有趣的包<code>npx</code>：<a href="https://npm.im/happy-birthday" target="_blank" rel="external">happy-birthday</a>，<a href="https://npm.im/benny-hill" target="_blank" rel="external">benny-hill</a>，<a href="https://npm.im/workin-hard" target="_blank" rel="external">workin-hard</a>，<a href="https://npm.im/cowsay" target="_blank" rel="external">cowsay</a>，<a href="https://npm.im/yo" target="_blank" rel="external">yo</a>，<a href="https://npm.im/create-react-app" target="_blank" rel="external">create-react-app</a>，<a href="https://npm.im/npm-check" target="_blank" rel="external">npm-check</a>。甚至有一个完整的<a href="https://github.com/js-n/awesome-npx" target="_blank" rel="external">awesome-npx</a><a href="https://github.com/js-n/awesome-npx" target="_blank" rel="external">入门</a>项目！来吧！获取一个<a href="https://twitter.com/maybekatz/status/878926190064668672" target="_blank" rel="external">足够小的完整的本地REST服务器运行的命令</a>以适应一个推文。</p><h1 id="使用不同Node-js版本运行命令"><a href="#使用不同Node-js版本运行命令" class="headerlink" title="使用不同Node.js版本运行命令"></a>使用不同Node.js版本运行命令</h1><p><img src="https://cdn-images-1.medium.com/max/800/1*cfjXl2hTKW7czetTfNGYbA.png" alt="https://cdn-images-1.medium.com/max/800/1*cfjXl2hTKW7czetTfNGYbA.png"></p><center><small><code>npx -p node-bin @ &lt;version&gt; node -v</code>可用于执行节点版本的一次性运行。</small></center><p>事实证明，在npm注册表中有一个很酷的包叫 <code>node-bin</code>。这意味着你可以使用不同的<code>node</code>版本，而不必使用node版本管理器,像<code>nvm</code>，<code>nave</code>或<code>n</code>。所有你需要的只是安装<code>npm@5.2.0</code>！</p><p><code>-pnpx</code> 选项允许您指定要安装并添加到正在运行的软件包<code>$PATH</code>，这意味着您可以进行有趣的操作，例如：<code>$ npx -p node-bin@6 npm it</code>安装并测试当前的npm软件包，就像在<code>node@6</code>全局运行一样。我一直使用这个 - 我甚至最近不得不在一个项目中经常使用它，由于我的一个测试库在<code>node@8</code>环境下无法运行。这是一个真正的救世主，我发现使用这种类型的用例比版本管理器更容易，我总是以某种方式找到<code>break</code>或错误配置的方法。</p><p>注意：<code>node-bin</code>仅适用于<code>* nix</code>平台。这是<a href="https://medium.com/@aredridel" target="_blank" rel="external">Aria Stewart</a>的出色工作。在将来，同样的软件包将可以简单地使用<code>node</code>，所以您可以<code>$ npx node@6 ...</code>直接执行，包括在Windows上。</p><h1 id="与-npm-run-script-互动发展"><a href="#与-npm-run-script-互动发展" class="headerlink" title="与 npm run-script 互动发展"></a>与 npm run-script 互动发展</h1><p><img src="https://cdn-images-1.medium.com/max/800/1*JqCC1irC-XxXAWiThpOUiw.gif" alt="https://cdn-images-1.medium.com/max/800/1*JqCC1irC-XxXAWiThpOUiw.gif"></p><center><small><code>$ npx -p cowsay -p lolcatjs -c&#39;echo“$ npm_package_name @ $ npm_package_version”| cowsay | lolcatjs&#39;s</code>将安装cowsay和lolcatjs，并使脚本从运行脚本访问一堆“$ npm_”变量。</small></center><p>很多<code>npm</code>的用户现在可以利用这个非常酷的<code>run-script</code>功能。他们不仅让您的<code>$PATH</code>本地二进制文件可访问，而且还添加了一大堆环境变量，您可以在这些脚本中访问。你可以看到这些额外的变量是什么<code>$ npm run env | grep npm_</code>。</p><p>这可以使开发和测试运行脚本变得棘手 - 这意味着即使使用诸如此类的技巧<code>$(npm bin)/some-bin</code>，在交互式工作的同时仍然无法访问这些神奇的<code>env var</code>。</p><p>可是等等！<code>npx</code>还有一个技巧：当你使用这个<code>-c</code>选项时，写入<code>string</code>参数内的脚本将能够像普通的运行脚本一样完全访问相同的<code>env</code>变量！您甚至可以使用管道和多个命令进行单次<code>npx</code>调用！</p><h1 id="与朋友以及你想要的任何人分享基于gist的脚本！"><a href="#与朋友以及你想要的任何人分享基于gist的脚本！" class="headerlink" title="与朋友以及你想要的任何人分享基于gist的脚本！"></a>与朋友以及你想要的任何人分享基于gist的脚本！</h1><p><img src="https://cdn-images-1.medium.com/max/800/1*Hdk5w080acQjABK3CQWh4Q.gif" alt="https://cdn-images-1.medium.com/max/800/1*Hdk5w080acQjABK3CQWh4Q.gif"></p><p>使用<code>gist.github.com</code>分享各种实用程序脚本变得很常见，而不是设置整个<code>git repos</code>，发布新工具等。</p><p>使用<code>npx</code>，您可以进一步：因为<code>npx</code>接受<code>npm</code>本身所做的任何说明符，您可以创建一个人们可以直接使用单个命令调用的要点！</p><p>尝试使用<a href="https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32" target="_blank" rel="external">https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32</a>！</p><blockquote><p>注意：保持安全！在执行这些时，始终确保通过 <code>gists</code> 网站读取和执行代码，就像运行 <code>.sh</code> 脚本时一样谨慎！</p></blockquote><h1 id="彩蛋：shell自动回退"><a href="#彩蛋：shell自动回退" class="headerlink" title="彩蛋：shell自动回退"></a>彩蛋：shell自动回退</h1><p><img src="https://cdn-images-1.medium.com/max/600/1*MXY3EyWrnjdrv6gjDLgznw.png" alt="https://cdn-images-1.medium.com/max/600/1*MXY3EyWrnjdrv6gjDLgznw.png"></p><center><small>将.zshrc中的npx自动回退意味着你可以在没有引用npx的情况下执行<code>$ ember-cli @ latest ...</code></small></center><p><code>FélixSaparelli</code>补充说，这个令人敬畏的功能意味着对于许多这些用例，您甚至不需要直接调用<code>npx</code>！常规的<code>npx</code>使用和回退之间的主要区别是，回退不会安装新软件包，除非您使用<code>pkg@version</code>语法：安全网来防止潜在的危险排序。</p><p>设置自动回退是很简单的：在<code>npx</code>文档中查看用于当前<code>shell</code>的命令，将其添加到 <code>.bashrc</code> / <code>.zshrc</code> / <code>.fishrc</code>，然后重新启动<code>shell</code>（或使用<code>source</code>或其他机制来刷新<code>shell</code>）。</p><p>现在，您可以做一些<code>$ standard@8 --version</code>尝试不同版本的东西，如果您在一个<code>npm</code>项目中，<code>$ mocha</code>则会自动回到本地安装的<code>mocha</code>版本，前提是它尚未在全局安装。</p><h1 id="现在就试试吧"><a href="#现在就试试吧" class="headerlink" title="现在就试试吧"></a>现在就试试吧</h1><p>你现在可以通过安装<code>npm@5.2.0</code>或更新来获得<code>npx</code> ，或者如果你不想使用<code>npm</code>，你可以安装独立版本的<code>npx</code>！它与其他软件包管理器完全兼容，因为任何<code>npm</code>使用仅适用于内部操作。哦，它有10种不同的语言，感谢来自世界各地的一大批早期采用者的贡献，<code>--help</code>以及所有的系统消息翻译，并可以根据系统区域设置自动提供！还有一个<code>awesome-npx</code><a href="https://github.com/js-n/awesome-npx" target="_blank" rel="external">repo</a>与<code>npx</code>工作地很好的例子！</p><p>你有最喜欢的功能吗？你有没有使用过？如果你有一些很酷炫的事，我没有在这里列出，请在评论中分享！我很想听听别人的意见！</p><p>PS人们不断地问这个，所以我只是会弹出它在这里：在这些GIF文件，我使用<a href="https://www.npmjs.com/package/hyperterm-monokai" target="_blank" rel="external">monokai</a>主题的<a href="https://hyper.is/" target="_blank" rel="external">Hyper</a>运行 <code>oh-my-zsh</code>中的<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes#spaceship" target="_blank" rel="external">spaceship主题</a>，再加上<a href="https://github.com/tonsky/FiraCode" target="_blank" rel="external">FiraCode</a>字体。</p><p>【翻译原文】: <a href="https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b" target="_blank" rel="external">https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍npx：一个npm包运行&quot;&gt;&lt;a href=&quot;#介绍npx：一个npm包运行&quot; class=&quot;headerlink&quot; title=&quot;介绍npx：一个npm包运行&quot;&gt;&lt;/a&gt;介绍npx：一个npm包运行&lt;/h1&gt;&lt;p&gt;NPM升级到最新版本，&lt;a href=&quot;https://github.com/npm/npm/releases/tag/v5.2.0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;npm@5.2.0&lt;/a&gt;，你可能会发现，它会安装一个新的二进制包跟着 &lt;code&gt;npm&lt;/code&gt;：&lt;a href=&quot;https://npm.im/npx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;npx&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;code&gt;npx&lt;/code&gt; 是一个工具，旨在帮助整理从npm注册软件包的体验 - 和 使得npm非常容易地安装和管理托管在注册表上的依赖关系是 同样的方式，&lt;code&gt;npx&lt;/code&gt;使 npm 很方便使用CLI工具和其他被托管的可执行文件。它大大简化了一些事情，到目前为止，需要一些与普通的npm有关的步骤：&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="npm" scheme="http://robin-front.github.io/tags/npm/"/>
    
      <category term="npx" scheme="http://robin-front.github.io/tags/npx/"/>
    
  </entry>
  
  <entry>
    <title>为什么我停止使用多个显示器</title>
    <link href="http://robin-front.github.io/2017/07/11/why-should-stopped-using-multiple-monitors/"/>
    <id>http://robin-front.github.io/2017/07/11/why-should-stopped-using-multiple-monitors/</id>
    <published>2017-07-11T08:02:47.000Z</published>
    <updated>2017-07-11T08:02:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>许多开发人员认为多个显示器可以提高生产力。研究证明是这样，对吧？那么，请记住，许多这些研究是由戴尔和NEC等监控制造商委托进行的。🤔</p><p>尽管多个显示器使您看起来像一个重度的计算机使用者，但我在几年前卖了我的多显示器，并切换到一个监视器。而且我并不是一个人。</p><p>下面就是为什么。<a id="more"></a></p><h1 id="专注"><a href="#专注" class="headerlink" title="专注"></a>专注</h1><p>人类一次只能关注一件事情。那么为什么我们花钱来同时显示多个东西呢？如果我的电子邮件或社交媒体资讯提供一目了然，我会经常检查。这不仅不是不必要的，反而是有效的。在一个无休止的分心的世界中，能够长期专注于单一任务是一项非常有价值的技能。</p><blockquote><p>深刻的工作在我们分心充实的经济中变得越来越困难，但也变得越来越重要和罕见。少数能够在深度工作上度过的日子将变得非常市场化和成功。</p><ul><li>Cal Newport在“ 深加工 ”</li></ul></blockquote><p>一个监视器意味着我的工作 - 只有我的工作 - 显示在前面和中央。分心停留在视线之外，所以眼不见，心不烦。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*gRNCnSRrV5JUxbMagFV0CA.jpeg" alt="这看起来像是专注一项任务吗"></p><center>这看起来像是专注一项任务吗</center><p>我们每天做的最有价值的工作之一就是要长期专注于一个单一的应用程序：<strong>阅读和写作</strong>。阅读和写作都受益于来自于屏幕上唯一的重点。一本带有移动微博的小本本在旁边将是一场灾难。但是很多人都愿意做这个。额外的显示经常导致潜在的持续分心。如果您的电子邮件，社交媒体等不可见，您更有可能继续工作。</p><p>作为开发人员，我每天都在编写代码。所以我经常阅读文档。但是我很少需要在读文档的 <strong>同时</strong> 编写代码。我读完相关的文档，然后再编码。我的工作流是模态的。</p><h1 id="减少窗口管理"><a href="#减少窗口管理" class="headerlink" title="减少窗口管理"></a>减少窗口管理</h1><p>我使用一个月的 34“LG超宽屏显示器，起初，我喜欢它。</p><p>不过，过了几天，我很惊讶地发现我出了个馊主意。我的桌面最大化，太宽了，所以我发现自己花了太多的时间摆弄桌面。“今天应该放在左边呢？”“现在有什么重要的事情呢？”</p><p>当然，屏幕足够宽，可以并排显示多个窗口，但是它非常宽，边缘感到不舒服。所以，我发现自己不断把我的工作转移到屏幕的中心，从而违背了买一个巨大的显示器的整个目的！Jeff Atwood很久以前在“<a href="https://blog.codinghorror.com/the-large-display-paradox/" target="_blank" rel="external">大型显示悖论</a>”中讨论了这个问题。他的解决方案，使用软件移动和调整大小的窗口更容易。我的解决方案，<strong>只需使用一个合理尺寸的显示器</strong>。</p><p>即使使用方便的窗口管理软件，多个显示器也会出现问题：如果我有两个显示器，内容不会直接在我的前面。我必须向右或向左转动我的头（特别烦在跑步机上行走的人，就像我经常看到的那样）。我可以把一个监视器直接放在我面前，但是第二个监视器甚至更远一些，这使得它显然是一个二等公民。这再次导致我从正在工作的中间屏幕移动。</p><p>正如巴里·施瓦茨（Barry Schwartz）在“<a href="https://www.amazon.com/Paradox-Choice-Why-More-Less/dp/0060005696" target="_blank" rel="external">选择的悖论</a>”中所探讨的那样，决策疲劳是一个真正的问题。有时候，少即是多。</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fembed.ted.com%2Ftalks%2Fbarry_schwartz_on_the_paradox_of_choice&amp;url=https%3A%2F%2Fwww.ted.com%2Ftalks%2Fbarry_schwartz_on_the_paradox_of_choice&amp;image=https%3A%2F%2Fpe.tedcdn.com%2Fimages%2Fted%2F8bdfbadbf8c620bfe3c5209c223a0f7b4316092a_240x180.jpg%3Flang%3Den&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=ted" allowfullscreen frameborder="0" scrolling="no"></iframe><blockquote><p>“选择使我们不是更自由，更瘫痪，不快乐，但更不满意。”</p></blockquote><p>只通过一个屏幕，我决定。我不会浪费时间决定在哪里拖曳窗口或摆放在给定窗口的位置。我最大化我正在使用的应用程序，以阻止所有其他分心…在上班的时候。</p><h1 id="虚拟桌面为赢"><a href="#虚拟桌面为赢" class="headerlink" title="虚拟桌面为赢"></a>虚拟桌面为赢</h1><p>Mac和Windows现在都支持虚拟桌面。在我的Mac上，我可以通过3个手指快速切换多个虚拟桌面。这需要不到一秒钟的时间，它不需要我转过头来重新聚焦我的眼睛在不同的地方的内容。我也不用浪费时间安排。最左边的虚拟桌面总是我的浏览器，右边是我的编辑器。<strong>所以我将虚拟桌面视为可靠呈现相同内容的物理屏幕</strong>。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*BLoFtdzKsyuBaysiMNMaBA.png" alt="顶部的三个框架表示三个虚拟桌面。三手指滑动可立即在它们之间切换 - 无需再花时间旋转我的头，看一个单独的显示器。"></p><center>顶部的三个框架表示三个虚拟桌面。三手指滑动可立即在它们之间切换 - 无需再花时间旋转我的头，看一个单独的显示器。</center><h1 id="我用于完成工作的首选监视器"><a href="#我用于完成工作的首选监视器" class="headerlink" title="我用于完成工作的首选监视器"></a>我用于完成工作的首选监视器</h1><p>我更喜欢使用一个24“4K，为什么24”？因为如果你想完成实际的工作，更大的不一定更好。24“足够大，可以全屏显示单个应用程序，它足够大，可以在罕见的情况下并排显示两个应用程序，我真的需要同时看到两件事情（我在Mac上使用BetterTouchTool，只需击中Win +箭头在Windows），但是24“足够小，您可以最大限度地利用所有应用程序，而无需移动您的头部或眼睛很多看到屏幕边缘。记住，最大化所有的事情。最大化=集中。</p><p>为什么是4K？高DPI降低疲劳。文字更加清晰。价格也慢慢合理了，所以如果你还没有高DPI显示器，买一个。而24“4K每4K英寸的点数要大于4K屏幕，所以它更加清晰。过去几年内建成的任何MacBook Pro都可以在DisplayPort上以60hz的速度推出4K显示器，许多最近的Windows笔记本电脑也可以这样做。</p><p>那么为什么这么多工作者需要多台显示器呢？我相信这是极端不合逻辑的诱惑。</p><blockquote><p>太多的东西变得相反。 - 蒂姆·弗里斯</p></blockquote><p>显示器太多会变得分心。所以说到监视器，我拥抱这些想法：</p><ul><li>少即是多</li><li>质量而不是数量</li><li>定力，定力，定力（Location, Location, Location）</li></ul><p>【翻译原文】:（有删减） <a href="https://hackernoon.com/why-i-stopped-using-multiple-monitors-bfd87efa2e5b" target="_blank" rel="external">https://hackernoon.com/why-i-stopped-using-multiple-monitors-bfd87efa2e5b</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;许多开发人员认为多个显示器可以提高生产力。研究证明是这样，对吧？那么，请记住，许多这些研究是由戴尔和NEC等监控制造商委托进行的。🤔&lt;/p&gt;&lt;p&gt;尽管多个显示器使您看起来像一个重度的计算机使用者，但我在几年前卖了我的多显示器，并切换到一个监视器。而且我并不是一个人。&lt;/p&gt;&lt;p&gt;下面就是为什么。
    
    </summary>
    
      <category term="workflow" scheme="http://robin-front.github.io/categories/workflow/"/>
    
    
      <category term="performance" scheme="http://robin-front.github.io/tags/performance/"/>
    
  </entry>
  
  <entry>
    <title>不要混用 import 和 require</title>
    <link href="http://robin-front.github.io/2017/07/10/dont-mixin-import-and-require/"/>
    <id>http://robin-front.github.io/2017/07/10/dont-mixin-import-and-require/</id>
    <published>2017-07-10T08:30:11.000Z</published>
    <updated>2017-07-10T08:30:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>import 是 ES6 规范语法之一。而 require 属于CommonJS规范的一部分。</p><p>目前来说，使用现代浏览器还无法支持 import，一般都会搭配 babel 使用，而 babel 会把 import 转换成 CommonJS 的 require.</p><p>但是，我们不能混用 import 和 require。有时候会看下如下代码：<a id="more"></a></p><p><img src="https://pbs.twimg.com/media/DESmTTXUMAAJcIW.jpg:large" alt="https://pbs.twimg.com/media/DESmTTXUMAAJcIW.jpg:large"></p><p>但实际执行顺序并不是你想象或看到的那样。import 具有声明提升效果，会首先执行。所以最好 <strong>不要混用</strong>。 import 是 ES6 标准，如果可能，首先使用 import, 如果不行，就用 require。</p><h2 id="ES6-import"><a href="#ES6-import" class="headerlink" title="ES6 import"></a>ES6 import</h2><ul><li>具有声明提升效果</li><li>您可以使用命名导入来选择性地加载所需的部分。这样可以节省内存， 如：<code>import { render } from react</code></li><li>导入可以是异步的</li><li>ES6 标准</li></ul><h2 id="require"><a href="#require" class="headerlink" title="require"></a>require</h2><ul><li>您可以在加载的模块名称不是预定义/静态的情况下进行动态加载，或者只有在真正需要的情况下才有条件地加载模块（取决于某些代码流）</li><li>CommonJS 规范加载是同步的。这意味着如果你有多个require，它们将逐个加载和处理（AMD规范是可以异步的）</li><li>只是约定的规范</li></ul><p>参考：<a href="https://twitter.com/dan_abramov/status/883375646357041152" target="_blank" rel="external">https://twitter.com/dan_abramov/status/883375646357041152</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;import 是 ES6 规范语法之一。而 require 属于CommonJS规范的一部分。&lt;/p&gt;&lt;p&gt;目前来说，使用现代浏览器还无法支持 import，一般都会搭配 babel 使用，而 babel 会把 import 转换成 CommonJS 的 require.&lt;/p&gt;&lt;p&gt;但是，我们不能混用 import 和 require。有时候会看下如下代码：
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="import" scheme="http://robin-front.github.io/tags/import/"/>
    
      <category term="require" scheme="http://robin-front.github.io/tags/require/"/>
    
  </entry>
  
  <entry>
    <title>react性能优化：提取子组件中额外的事件绑定</title>
    <link href="http://robin-front.github.io/2017/07/06/react-pattern-extract-child-components-to-avoid-binding/"/>
    <id>http://robin-front.github.io/2017/07/06/react-pattern-extract-child-components-to-avoid-binding/</id>
    <published>2017-07-06T08:24:53.000Z</published>
    <updated>2017-07-06T08:24:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn-images-1.medium.com/max/800/1*zISOb74W7PriWKX0y7biKg.jpeg" alt=""></p><p>我们经常在快要完成一个<code>react</code>中型应用时，发现页面并没有想象中那么流畅。 react 理论性能是不错的，但是对开发者要求也很高，一些不易注意的点很容易造成性能问题。正所谓“烂泥扶不上墙”。</p><p>下面看看子组件的事件绑定写法对性能的影响。<a id="more"></a></p><p>这是React中的常见情况：您正在映射数组，您需要每个项目调用点击处理程序和一些相关数据。</p><p>这是一个例子。我正在迭代一个用户列表，并将<code>userId</code>传递给第29行的<code>deleteUser</code>函数。</p><script src="https://gist.github.com/coryhouse/01339ce21024cfd7f5cd4c64d1fd26c4.js"></script><p>这是<a href="https://codesandbox.io/" target="_blank" rel="external">Codeandbox</a>上的一个<a href="https://codesandbox.io/s/0OP2Yq87" target="_blank" rel="external">工作示例</a>。（真棒）</p><h1 id="所以-有什么问题？"><a href="#所以-有什么问题？" class="headerlink" title="所以, 有什么问题？"></a>所以, 有什么问题？</h1><p>我在点击处理程序中使用箭头函数。这意味着每次渲染运行时，都会分配一个新函数。在许多情况下，这不是一件多大的事。但是，如果您有子组件，即使数据没有更改，它们也将重新渲染，因为每个渲染分配一个新的函数。</p><p>底线：避免在渲染中声明箭头函数或绑定以获得最佳性能。我的团队使用这个<a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-no-bind.md" target="_blank" rel="external">ESLint规则</a>帮助提醒我们这个问题。</p><h1 id="解决方案是什么？"><a href="#解决方案是什么？" class="headerlink" title="解决方案是什么？"></a>解决方案是什么？</h1><p>那么你如何在渲染中避免绑定和箭头函数呢？一个选项是提取一个子组件。在这里，我将列表项提取到<code>UserListItem.js</code>：</p><script src="https://gist.github.com/coryhouse/a002111d01fb7ee1862af55d4a26abfa.js"></script><p>然后，父组件的渲染变得更简单，不再需要包含箭头函数。它只是通过<code>props</code>传递每个列表项的相关上下文：</p><script src="https://gist.github.com/coryhouse/f5758f5355da5280fc0e3350453fef31.js"></script><p>这是一个<a href="https://codesandbox.io/s/Q1Jo3zB79" target="_blank" rel="external">重构的工作实例</a>。</p><h1 id="Yay-or-Yuck"><a href="#Yay-or-Yuck" class="headerlink" title="Yay or Yuck?"></a>Yay or Yuck?</h1><p>此模式通过消除冗余的函数分配来提高性能。所以当这种情况适用于您的组件时，它是最有用的：</p><ul><li>渲染频繁被调用</li><li>渲染子组件非常耗时</li></ul><p>诚然，我提取子组件也是我提到的一个额外的工作。它需要更多的移动部件和更多的代码。所以如果你没有出现性能问题，可以说这是一个过早的优化。</p><p>所以你有两个选择：允许箭头和绑定到任何地方（如果有性能问题再处理），或禁止他们获得最佳性能和一致性。</p><p>底线：我建议禁止箭头函数并在<code>render</code>中绑定。下面就是为什么：</p><ul><li>你必须禁用我上面建议的有用的<a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-no-bind.md" target="_blank" rel="external">ESLint规则</a>来允许它。</li><li>禁用linting规则后，人们可能会复制此模式，并开始禁用其他linting规则。一个处例外可以很快成为规范…</li></ul><p></p><blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">General rule for code reviews:<br><br>Each line of code should be worthy of copying.<br><br>Because people will.<a href="https://twitter.com/hashtag/cleancode?src=hash" target="_blank" rel="external">#cleancode</a></p>&mdash; Cory House 🏠 (@housecor) <a href="https://twitter.com/housecor/status/839511073279598594" target="_blank" rel="external">March 8, 2017</a></blockquote><p></p><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script><p>所以我发现提取子组件是一个有用的模式，以避免在渲染中绑定。</p><h1 id="其他的反例"><a href="#其他的反例" class="headerlink" title="其他的反例"></a>其他的反例</h1><p>还有些人会想要这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">deleteUser = id=<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line"> <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> &#123;</div><div class="line"> <span class="keyword">return</span> &#123; <span class="attr">users</span>: prevState.users.filter( <span class="function"><span class="params">user</span> =&gt;</span> user.id !== id)&#125;</div><div class="line"> &#125;)</div><div class="line">&#125;</div><div class="line"><span class="comment">// …</span></div><div class="line">onClick=&#123;<span class="keyword">this</span>.deleteUser(user.id)&#125;</div></pre></td></tr></table></figure><p>他们认为传递参数会比其他方式更加方便。但这和第一个糟糕的例子并无太大区别，子组件同样会再次渲染。</p><p>如果有相当多类似的输入框，像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;form&gt;</div><div class="line">Render = <span class="function"><span class="params">()</span> =&gt;</span></div><div class="line">Input1 value=<span class="keyword">this</span>.state.input1 onChange= update state <span class="keyword">for</span> field1</div><div class="line">Input2….</div><div class="line">Input3….</div></pre></td></tr></table></figure><p><a href="https://facebook.github.io/react/docs/forms.html#handling-multiple-inputs" target="_blank" rel="external">官方给出的方法</a>是给每个 input 添加 name 属性，进而获取参数。</p><p>当然也有人会想要在 html 上动文章，比如添加自定义属性 <code>data-id=${userId}</code>。这当然也能实现，但是 html不应该是数据源，这应该避免。</p><p>【翻译原文】:(有改动)<a href="https://medium.freecodecamp.org/react-pattern-extract-child-components-to-avoid-binding-e3ad8310725e" target="_blank" rel="external">https://medium.freecodecamp.org/react-pattern-extract-child-components-to-avoid-binding-e3ad8310725e</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*zISOb74W7PriWKX0y7biKg.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;我们经常在快要完成一个&lt;code&gt;react&lt;/code&gt;中型应用时，发现页面并没有想象中那么流畅。 react 理论性能是不错的，但是对开发者要求也很高，一些不易注意的点很容易造成性能问题。正所谓“烂泥扶不上墙”。&lt;/p&gt;&lt;p&gt;下面看看子组件的事件绑定写法对性能的影响。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="react" scheme="http://robin-front.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>如何使用Memoize来缓存JavaScript函数结果并加快代码的速度</title>
    <link href="http://robin-front.github.io/2017/07/04/understanding-memoize-in-javascript/"/>
    <id>http://robin-front.github.io/2017/07/04/understanding-memoize-in-javascript/</id>
    <published>2017-07-04T09:57:51.000Z</published>
    <updated>2017-07-04T09:57:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Function</code> 是编程的组成部分。它们有助于为我们的代码增加模块化和可重用性。</p><p>将程序划分为大块是很常见的功能，我们稍后可以使用这些功能来执行一些有用的操作。</p><p>有时，多次调用功能可能会变得昂贵（比如，计算一个数字的阶乘的函数）。但是有一种方法可以优化这些功能，使它们执行得更快：<strong>缓存</strong>。<a id="more"></a></p><p>例如，假设我们<code>function</code>要返回一个数字的阶乘：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">    <span class="comment">// Calculations: n * (n-1) * (n-2) * ... (2) * (1)</span></div><div class="line">    <span class="keyword">return</span> factorial</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>非常好，现在我们来看看<code>factorial(50)</code>。计算机会执行计算，并返回给我们最后的答案，不错！</p><p>完成后，让我们来看看<code>factorial(51)</code>。计算机再次执行一些计算并获得结果，但是您可能已经注意到我们已经重复了可以避免的一些步骤。优化的方式是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">factorial(<span class="number">51</span>) = factorial(<span class="number">50</span>) * <span class="number">51</span>;</div></pre></td></tr></table></figure><p>但是我们<code>function</code>每次调用时都会从头开始执行计算：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">factorial(<span class="number">51</span>) = <span class="number">51</span> * <span class="number">50</span> * <span class="number">49</span> * ... * <span class="number">2</span> * <span class="number">1</span></div></pre></td></tr></table></figure><p>如果我们的函数<code>factorial</code>能记住它之前运算的结果并用它来提交运行效率，那不是很酷吗？</p><p>谈到<code>Memoization</code>，一种让我们的<code>function</code>记住（缓存）结果的方式。既然您对我们要实现的目标有一个基本的了解，这里是一个正式的定义：</p><blockquote><p><a href="https://en.wikipedia.org/wiki/Memoization" target="_blank" rel="external">Memoization</a>是一种优化技术，主要用于通过 <strong>存储昂贵的函数调用的结果</strong> 来加速计算机程序，并在相同的输入再次发生时返回缓存的结果.</p></blockquote><p>记住简单的东西意味着记忆或存储在内存中。记忆函数通常更快，因为如果随后使用先前的值调用该函数，我们将从缓存中获取结果来代替执行该函数，。</p><p>这看起来像一个简单的记忆函数（如果你想进行测试它，这里是一个<a href="https://codepen.io/divyanshu013/pen/xdQPvp?editors=0011" target="_blank" rel="external">CodePen</a>）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a simple function to add something</span></div><div class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">n</span>) =&gt;</span> (n + <span class="number">10</span>);</div><div class="line">add(<span class="number">9</span>);</div><div class="line"><span class="comment">// a simple memoized function to add something</span></div><div class="line"><span class="keyword">const</span> memoizedAdd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">let</span> cache = &#123;&#125;;</div><div class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (n <span class="keyword">in</span> cache) &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'Fetching from cache'</span>);</div><div class="line">      <span class="keyword">return</span> cache[n];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'Calculating result'</span>);</div><div class="line">      <span class="keyword">let</span> result = n + <span class="number">10</span>;</div><div class="line">      cache[n] = result;</div><div class="line">      <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// returned function from memoizedAdd</span></div><div class="line"><span class="keyword">const</span> newAdd = memoizedAdd();</div><div class="line"><span class="built_in">console</span>.log(newAdd(<span class="number">9</span>)); <span class="comment">// calculated</span></div><div class="line"><span class="built_in">console</span>.log(newAdd(<span class="number">9</span>)); <span class="comment">// cached</span></div></pre></td></tr></table></figure><h1 id="Memoization-要点"><a href="#Memoization-要点" class="headerlink" title="Memoization 要点"></a>Memoization 要点</h1><p>以上代码的一些要点是：</p><p><code>memoizedAdd</code>返回一个<code>function</code>以便稍后调用的。这是可能的，因为在JavaScript中，函数是一等公民，它们可以将它们用作<a href="http://eloquentjavascript.net/05_higher_order.html#h_xxCc98lOBK" target="_blank" rel="external">高阶的函数</a>并返回另一个函数。</p><p><code>cache</code>可以记住它的值，因为返回的函数被<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Closures" target="_blank" rel="external">闭包</a>封装了。</p><p><code>memoized</code>功能纯粹<a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976" target="_blank" rel="external">(Pure)</a>是至关重要的。纯函数将为特定输入返回相同的输出，而不需要调用多少次，这使得<code>cache</code>按预期的工作。</p><h1 id="编写自己的-memoize-功能"><a href="#编写自己的-memoize-功能" class="headerlink" title="编写自己的 memoize 功能"></a>编写自己的 memoize 功能</h1><p>以前的代码工作正常，但如果我们想将任何函数转换为记忆函数呢？</p><p>以下是如何编写自己的<code>memoize</code>函数（<a href="https://codepen.io/divyanshu013/pen/zwMPdK?editors=0011#code-area" target="_blank" rel="external">codepen</a>）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a simple pure function to get a value adding 10</span></div><div class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">n</span>) =&gt;</span> (n + <span class="number">10</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Simple call'</span>, add(<span class="number">3</span>));</div><div class="line"><span class="comment">// a simple memoize function that takes in a function</span></div><div class="line"><span class="comment">// and returns a memoized function</span></div><div class="line"><span class="keyword">const</span> memoize = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">let</span> cache = &#123;&#125;;</div><div class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> n = args[<span class="number">0</span>];  <span class="comment">// just taking one argument here</span></div><div class="line">    <span class="keyword">if</span> (n <span class="keyword">in</span> cache) &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'Fetching from cache'</span>);</div><div class="line">      <span class="keyword">return</span> cache[n];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'Calculating result'</span>);</div><div class="line">      <span class="keyword">let</span> result = fn(n);</div><div class="line">      cache[n] = result;</div><div class="line">      <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// creating a memoized function for the 'add' pure function</span></div><div class="line"><span class="keyword">const</span> memoizedAdd = memoize(add);</div><div class="line"><span class="built_in">console</span>.log(memoizedAdd(<span class="number">3</span>));  <span class="comment">// calculated</span></div><div class="line"><span class="built_in">console</span>.log(memoizedAdd(<span class="number">3</span>));  <span class="comment">// cached</span></div><div class="line"><span class="built_in">console</span>.log(memoizedAdd(<span class="number">4</span>));  <span class="comment">// calculated</span></div><div class="line"><span class="built_in">console</span>.log(memoizedAdd(<span class="number">4</span>));  <span class="comment">// cached</span></div></pre></td></tr></table></figure><p>这很棒！这个简单的<code>memoize</code>功能将任何简单的<code>function</code>封装成一个有记忆性的等价物。该代码适用于简单的功能，可以根据您的需要轻松调整处理任意数量的<code>arguments</code>代码。另一个选择是利用一些的类库，如：</p><p><a href="https://lodash.com/docs/4.17.4#memoize" target="_blank" rel="external">Lodash</a>的<code>_.memoize(func, [resolver])</code></p><p>来自<a href="https://github.com/developit/decko#memoize" target="_blank" rel="external">decko</a>的 ES7 <code>@memoize</code> <a href="https://babeljs.io/docs/plugins/transform-decorators/" target="_blank" rel="external">装饰器</a></p><h1 id="记忆递归函数"><a href="#记忆递归函数" class="headerlink" title="记忆递归函数"></a>记忆递归函数</h1><p>如果您尝试将递归函数传递到<code>memoize</code>上面的函数或Lodash的<code>_.memoize</code>函数，结果将不会如预期的那样，因为其后续调用的递归函数将最终调用自身而不是记忆函数，从而不再使用<code>cache</code>。</p><p>只需确保递归函数调用记忆函数。这里是你如何调整教科书<a href="https://en.wikipedia.org/wiki/Factorial" target="_blank" rel="external">阶乘</a>例子（<a href="https://codepen.io/divyanshu013/pen/JNevOm" target="_blank" rel="external">codepen</a>）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// same memoize function from before</span></div><div class="line"><span class="keyword">const</span> memoize = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">let</span> cache = &#123;&#125;;</div><div class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> n = args[<span class="number">0</span>];</div><div class="line">    <span class="keyword">if</span> (n <span class="keyword">in</span> cache) &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'Fetching from cache'</span>, n);</div><div class="line">      <span class="keyword">return</span> cache[n];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'Calculating result'</span>, n);</div><div class="line">      <span class="keyword">let</span> result = fn(n);</div><div class="line">      cache[n] = result;</div><div class="line">      <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> factorial = memoize(</div><div class="line">  <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (x === <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> x * factorial(x - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">);</div><div class="line"><span class="built_in">console</span>.log(factorial(<span class="number">5</span>)); <span class="comment">// calculated</span></div><div class="line"><span class="built_in">console</span>.log(factorial(<span class="number">6</span>)); <span class="comment">// calculated for 6 and cached for 5</span></div></pre></td></tr></table></figure><p>从这段代码注意几点：</p><p>该<code>factorial</code>函数递归地调用自己的记忆版本。</p><p>记忆功能是缓存先前阶乘的值，从而可以重复使用，从而显着改善了计算 <code>factorial(6) = 6 * factorial(5)</code></p><h1 id="memoization-是否与-caching-相同？"><a href="#memoization-是否与-caching-相同？" class="headerlink" title="memoization 是否与 caching 相同？"></a>memoization 是否与 caching 相同？</h1><p>是的，有点。<code>Memoization</code>实际上是一种特定类型的缓存。虽然缓存通常可以引用任何存储技术（如HTTP缓存）以供将来使用，但是<code>memoizing</code>特指调用缓存的<code>function</code>返回值。</p><h1 id="什么时候记录你的-functions"><a href="#什么时候记录你的-functions" class="headerlink" title="什么时候记录你的 functions"></a>什么时候记录你的 functions</h1><p>虽然可能看起来 <code>memoize</code> 可以与所有函数一起使用，但它实际上有限制的用例：</p><ul><li>为了记忆一个函数，它应该是纯粹的（pure），所以每次返回值对于相同的输入是相同的</li><li>记忆是增加的空间和增加的速度之间的权衡，因此对于具有有限的输入范围的功能而言是重要的，以便可以更频繁地使用缓存的值</li><li>它可能看起来像您记住您的API调用，但这并不是必需的，因为浏览器会为您自动缓存它们。有关详细信息，请参阅<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching" target="_blank" rel="external">HTTP缓存</a></li><li>我发现用于记忆功能的最佳用例是 <strong>重度计算功能</strong>，可以显着提高性能（阶乘和斐波那契不是真正现实世界的例子）</li><li>如果您进入React / Redux，您可以检查重新选择哪个使用记忆选择器，以确保仅在状态树的相关部分发生更改时进行计算。</li></ul><h1 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h1><p>如果您想更详细地了解本文中的一些主题，以下链接可能很有用：</p><ul><li>JavaScript中的<a href="http://eloquentjavascript.net/05_higher_order.html#h_xxCc98lOBK" target="_blank" rel="external">高阶函数</a></li><li>JavaScript<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Closures" target="_blank" rel="external">闭包</a></li><li><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976" target="_blank" rel="external">纯函数</a></li><li>Lodash的<code>_.memoize</code> <a href="https://lodash.com/docs/4.17.4#memoize" target="_blank" rel="external">文档</a>和<a href="https://github.com/lodash/lodash/blob/4.17.4/lodash.js#L10554-L10572" target="_blank" rel="external">源代码</a></li><li>更多的<code>memoization</code>例子在<a href="https://www.sitepoint.com/implementing-memoization-in-javascript/" target="_blank" rel="external">这里</a>和<a href="http://inlehmansterms.net/2015/03/01/javascript-memoization/" target="_blank" rel="external">这里</a></li><li><a href="https://github.com/reactjs/reselect" target="_blank" rel="external">reactjs/reSelect</a></li></ul><p>【翻译原文】: <a href="https://medium.freecodecamp.org/understanding-memoize-in-javascript-51d07d19430e" target="_blank" rel="external">https://medium.freecodecamp.org/understanding-memoize-in-javascript-51d07d19430e</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Function&lt;/code&gt; 是编程的组成部分。它们有助于为我们的代码增加模块化和可重用性。&lt;/p&gt;&lt;p&gt;将程序划分为大块是很常见的功能，我们稍后可以使用这些功能来执行一些有用的操作。&lt;/p&gt;&lt;p&gt;有时，多次调用功能可能会变得昂贵（比如，计算一个数字的阶乘的函数）。但是有一种方法可以优化这些功能，使它们执行得更快：&lt;strong&gt;缓存&lt;/strong&gt;。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="Memoize" scheme="http://robin-front.github.io/tags/Memoize/"/>
    
  </entry>
  
  <entry>
    <title>css3中background-position的四值语法</title>
    <link href="http://robin-front.github.io/2017/07/04/background-position-of-css3-about-four-value-syntax/"/>
    <id>http://robin-front.github.io/2017/07/04/background-position-of-css3-about-four-value-syntax/</id>
    <published>2017-07-04T03:27:55.000Z</published>
    <updated>2017-07-04T03:27:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>刨根问底，每个css属性都要知道它的所有值实在不容易。今天看看 <code>background-position</code>.</p><p>background-positionCSS中的属性允许您在其容器内移动背景图像（或渐变）。<a id="more"></a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">html</span> &#123;</div><div class="line">  <span class="attribute">background-position</span>: <span class="number">100px</span> <span class="number">5px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>它有三种不同的取值：</p><ul><li>长度值（例如<code>100px 5px</code>）</li><li>百分比（例如<code>100% 5%</code>）</li><li>关键字（例如<code>top right</code>）</li></ul><p>默认值为<code>0 0</code>。这会将您的背景图像放在容器的左上角。</p><p>长度值很简单：第一个值是水平位置，第二个值是垂直位置。因此，<code>100px 5px</code>将图像向右移动100像素，向下移动五个像素。您可以设定长度值单位为<code>px</code>，<code>em</code>或<a href="http://www.w3.org/Style/Examples/007/units.en.html" target="_blank" rel="external">任何其他的CSS长度值</a>。</p><p>百分比有所不同。戴上你的数学帽子：用<code>x％</code>移动背景图像意味着 <strong>将图像中的<code>X％</code>点</strong> 与 <strong>容器中的<code>X％</code>点</strong> 对齐(PS：很多人解释的时候只会说向左向下移动了x%,这就无法解释50%)。例如，<code>50%</code>意味着它会将图像的中间与容器的中间对齐。<code>100%</code>意味着它会将图像的最后一个像素与容器的最后一个像素对齐，依此类推。</p><p>关键字只是百分比的捷径。这<code>top right</code>比记住和写作要容易得多<code>0 100%</code>，这就是关键字的意义。以下是所有五个关键字及其等价取值的列表：</p><ul><li><code>top</code>：垂直0％</li><li><code>right</code>：水平100％</li><li><code>bottom</code>：垂直100％</li><li><code>left</code>：水平0％</li><li><code>center</code>：如果水平尚未定义，则水平为50％。如果定义了则应用到垂直。</li></ul><p>有趣的是，您关键字使用的顺序并不重要：与之<code>top center</code>相同<code>center top</code>。只有当您使用单一关键字时，您才能做到这一点。<code>center 10%</code>是不一样的<code>10% center</code>。</p><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><p>此演示演示了<code>background-position</code>具有长度单位，百分比和关键字取值的集合示例。</p><iframe height="265" scrolling="no" title="background-position values" src="//codepen.io/team/css-tricks/embed/ogqrGw/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/team/css-tricks/pen/ogqrGw/" target="_blank" rel="external">background-position values</a> by CSS-Tricks (<a href="https://codepen.io/css-tricks" target="_blank" rel="external">@css-tricks</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><h1 id="声明值-Declaring-Values"><a href="#声明值-Declaring-Values" class="headerlink" title="声明值(Declaring Values)"></a>声明值(Declaring Values)</h1><p><code>background-position</code>现代浏览器中最多可以放置四个值（有关详细信息，请参阅<a href="#browser-support">浏览器支持列表</a>）。</p><p>如果您只声明 <strong>一个值</strong>，则该值是水平偏移量。浏览器将垂直偏移设置为<code>center</code>。</p><p>当您声明 <strong>两个值</strong> 时，第一个值是水平偏移量，第二个值是垂直偏移量。</p><p>当您开始使用三个或四个值时，事情会变得更加棘手，但您也可以更好地控制您的背景位置。</p><p>三或四值语法在关键字和长度或百分比单位之间进行交替。您可以在<code>background-position</code>的三值或四值中使用任何关键字值， <em>除</em> <code>center</code>之外。</p><p>当您指定 <strong>三个值</strong> 时，浏览器将“丢失”第四个值插入为<code>0.</code>以下是三值的示例<code>background-position</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#threevalues</span> &#123;</div><div class="line">  <span class="attribute">background-position</span>: right <span class="number">45px</span> bottom;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样就可以将背景图像定位在右侧的<code>45px</code>和容器底部的<code>0px</code>。</p><p>这是一个<code>background-position</code> <strong>四值</strong> 的例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#fourvalues</span> &#123;</div><div class="line">  <span class="attribute">background-position</span>: right <span class="number">45px</span> bottom <span class="number">20px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这将背景图片定位在右侧的<code>45px</code>和容器底部的<code>20px</code>。</p><p>注意上面示例中值的顺序：关键字后跟长度单位。三或四个值<code>background-position</code>必须遵循该格式，关键字在长度或百分比单位之前。</p><h1 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h1><p>此演示包括一个值，两个值，三个值和四个值的示例background-position。</p><iframe height="265" scrolling="no" title="background-position 1, 2, 3, and 4 value syntax" src="//codepen.io/team/css-tricks/embed/yyKdPB/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/team/css-tricks/pen/yyKdPB/" target="_blank" rel="external">background-position 1, 2, 3, and 4 value syntax</a> by CSS-Tricks (<a href="https://codepen.io/css-tricks" target="_blank" rel="external">@css-tricks</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><h1 id="更多参考"><a href="#更多参考" class="headerlink" title="更多参考"></a>更多参考</h1><ul><li><a href="http://www.w3.org/TR/css3-background/#the-background-position" target="_blank" rel="external">background-position 在CSS3规范</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/background-position" target="_blank" rel="external">background-position 在MDN</a></li><li><a href="http://css-tricks.com/positioning-offset-background-images/" target="_blank" rel="external">偏移背景图像</a></li></ul><h1 id="browser-support"><a href="#browser-support" class="headerlink" title="browser-support"></a>browser-support</h1><p>基本价值得到支持。四值语法具有此支持：</p><table><thead><tr><th style="text-align:center">Chrome</th><th style="text-align:center">Safari</th><th style="text-align:center">Firefox</th><th style="text-align:center">Opera</th><th style="text-align:center">IE</th><th style="text-align:center">Android</th><th style="text-align:center">iOS</th></tr></thead><tbody><tr><td style="text-align:center">25+</td><td style="text-align:center">7+</td><td style="text-align:center">13+</td><td style="text-align:center">10.5+</td><td style="text-align:center">9+</td><td style="text-align:center">4+</td><td style="text-align:center">7.1+</td></tr></tbody></table><p>【翻译原文：】<a href="https://css-tricks.com/almanac/properties/b/background-position/" target="_blank" rel="external">https://css-tricks.com/almanac/properties/b/background-position/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刨根问底，每个css属性都要知道它的所有值实在不容易。今天看看 &lt;code&gt;background-position&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;background-positionCSS中的属性允许您在其容器内移动背景图像（或渐变）。
    
    </summary>
    
      <category term="css" scheme="http://robin-front.github.io/categories/css/"/>
    
    
      <category term="background" scheme="http://robin-front.github.io/tags/background/"/>
    
      <category term="css3" scheme="http://robin-front.github.io/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>Array数组的indexOf、includes vs for-loop性能比较</title>
    <link href="http://robin-front.github.io/2017/07/03/arr-of-indexOf-vs-includes-and-for-loop/"/>
    <id>http://robin-front.github.io/2017/07/03/arr-of-indexOf-vs-includes-and-for-loop/</id>
    <published>2017-07-03T03:02:06.000Z</published>
    <updated>2017-07-03T03:02:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到一道算法题，然后有些人会使用 <code>includes</code>、<code>indexOf</code> 去判断是否存在另一个数。这让我不禁思考，这和 <code>for loop</code>有什么区别，能减少时间复杂度吗？我一开始也不是很清楚，但我可以找文档，找标准。我的第一判断是 <code>includes</code> 完全和 <code>for loop</code>没有区别的，只是es6 标准规范提供的语法糖，而 <code>indexOf</code> 还是有一定效率的。带着疑惑，查看 MDN 和 <a href="http://www.ecma-international.org/ecma-262" target="_blank" rel="external">ecma-262</a><a id="more"></a></p><h1 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h1><p><code>includes</code> 是 ES6 新增语法，返回 布尔值。最容易拿 <code>indexOf</code> 来比较， <code>indexOf</code> 不能判断 <code>NaN</code>, 而且不够语义，返回的是 匹配值的位置 或 <code>-1</code>。 <code>includes</code> 内部实现是这样的：</p><blockquote><ol><li>Let O be ? ToObject(this value).</li><li>Let len be ? ToLength(? Get(O, “length”)).</li><li>If len is 0, return false.</li><li>Let n be ? ToInteger(fromIndex). (If fromIndex is undefined, this step produces the value 0.)</li><li>If n ≥ 0, then<ol><li>Let k be n.</li></ol></li><li>Else n &lt; 0,<ol><li>Let k be len + n.</li><li>If k &lt; 0, let k be 0.</li></ol></li><li>Repeat, while k &lt; len<ol><li>Let elementK be the result of ? Get(O, ! ToString(k)).</li><li>If SameValueZero(searchElement, elementK) is true, return true.</li><li>Increase k by 1.</li></ol></li><li>Return false.</li></ol></blockquote><p>其中的 <code>SameValueZero</code> 内部实现是这样的：</p><blockquote><ol><li>If Type(x) is different from Type(y), return false.</li><li>If Type(x) is Number, then<ol><li>If x is NaN and y is NaN, return true.</li><li>If x is +0 and y is -0, return true.</li><li>If x is -0 and y is +0, return true.</li><li>If x is the same Number value as y, return true.</li></ol></li><li>Return false.</li><li>Return SameValueNonNumber(x, y).</li></ol></blockquote><p>从上面可以看出 <code>includes</code> 内部是使用 <code>while</code> 循环，并不能够降低时间复杂度。它能判断出 <code>NaN</code> 以及 <code>+0</code>等于<code>-0</code>。</p><p><strong>所以，返回值的语义化和 <code>NaN</code>的判断就是 <code>includes</code> 的场景。</strong></p><h1 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h1><p>好，<code>includes</code> 用来提升效率的幻想破灭了，那 <code>indexOf</code> 呢，规范是这么写的：</p><blockquote><ol><li>Let O be ? ToObject(this value).</li><li>Let len be ? ToLength(? Get(O, “length”)).</li><li>If len is 0, return -1.</li><li>Let n be ? ToInteger(fromIndex). (If fromIndex is undefined, this step produces the value 0.)</li><li>If n ≥ len, return -1.</li><li>If n ≥ 0, then<ol><li>If n is -0, let k be +0; else let k be n.</li></ol></li><li>Else n &lt; 0,<ol><li>Let k be len + n.</li><li>If k &lt; 0, let k be 0.</li></ol></li><li>Repeat, while k &lt; len<ol><li>Let kPresent be ? HasProperty(O, ! ToString(k)).</li><li>If kPresent is true, then<ol><li>Let elementK be ? Get(O, ! ToString(k)).</li><li>Let same be the result of performing Strict Equality Comparison searchElement === elementK.</li><li>If same is true, return k.</li></ol></li><li>Increase k by 1.</li></ol></li><li>Return -1.</li></ol></blockquote><p><code>Array</code>的 <code>indexOf</code> 也使用了 <code>while</code> 循环，并使用 <code>===</code> 全等比较。（<strong>注： 与 <code>String.prototype.indexOf</code> 并不同</strong>）</p><p><strong><code>indexOf</code> 使用场景是需要知道 匹配值的位置。</strong></p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>这是一个<a href="https://jsperf.com/includes-vs-indexof-vs-forloop/1" target="_blank" rel="external">性能测试比较</a></p><p><img src="https://raw.githubusercontent.com/Robin-front/blog/master/source/images/20170703/includes.vs.indexOf.png" alt="我的测试结果"></p><p>so? 如果单纯只是想比较，简单的才是最快的。 <code>includes</code>与<code>indexOf</code>效率相当，而<code>for Loop</code>最快，因为没有其他的前置判断和浏览器对它的优化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近遇到一道算法题，然后有些人会使用 &lt;code&gt;includes&lt;/code&gt;、&lt;code&gt;indexOf&lt;/code&gt; 去判断是否存在另一个数。这让我不禁思考，这和 &lt;code&gt;for loop&lt;/code&gt;有什么区别，能减少时间复杂度吗？我一开始也不是很清楚，但我可以找文档，找标准。我的第一判断是 &lt;code&gt;includes&lt;/code&gt; 完全和 &lt;code&gt;for loop&lt;/code&gt;没有区别的，只是es6 标准规范提供的语法糖，而 &lt;code&gt;indexOf&lt;/code&gt; 还是有一定效率的。带着疑惑，查看 MDN 和 &lt;a href=&quot;http://www.ecma-international.org/ecma-262&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ecma-262&lt;/a&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="Array" scheme="http://robin-front.github.io/tags/Array/"/>
    
      <category term="indexOf" scheme="http://robin-front.github.io/tags/indexOf/"/>
    
      <category term="includes" scheme="http://robin-front.github.io/tags/includes/"/>
    
      <category term="loop" scheme="http://robin-front.github.io/tags/loop/"/>
    
  </entry>
  
  <entry>
    <title>Web Animations API 入门教程总结回顾</title>
    <link href="http://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Conclusion/"/>
    <id>http://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Conclusion/</id>
    <published>2017-06-28T03:11:47.000Z</published>
    <updated>2017-06-28T03:11:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是 Web Animations API 入门教程系列的总结部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与<a href="https://twitter.com/dancwilson" target="_blank" rel="external">@dancwilson</a>联系。</p><p>我们已经涵盖了相当多的知识面，希望能够解决有关Web Animations API是什么（而不是什么）的问题。要总结这个系列，我们将回顾一下我们已经讨论过的内容，并看看尚未实现的内容。<a id="more"></a></p><h1 id="为什么要用API？"><a href="#为什么要用API？" class="headerlink" title="为什么要用API？"></a>为什么要用API？</h1><p>在介绍中，我们讨论了API是如何将CSS，JS和SVG中的各种方法结合起来进行动画处理，旨在充分利用它们。这意味着，例如，JavaScript可以锁定CSS多年来的硬件加速，并不限于CSS的声明性。API并不意味着替换像<a href="http://greensock.com/" target="_blank" rel="external">GSAP</a>这样的库，而只是为了在浏览器级别提供更多的选项。</p><p><a href="https://birtles.github.io/areweanimatedyet/" target="_blank" rel="external">Firefox</a>和<a href="https://www.chromestatus.com/features#animations" target="_blank" rel="external">Chrome</a>都已经开始实施，而Edge已经<a href="https://dev.modern.ie/platform/status/webanimationsjavascriptapi/" target="_blank" rel="external">积压了很多事没有做</a>。随着团队完成<a href="https://w3c.github.io/web-animations/" target="_blank" rel="external">规范</a>，<a href="https://github.com/web-animations/web-animations-js" target="_blank" rel="external">polyfill</a>可以让我们开始玩转它。</p><h1 id="动画基础"><a href="#动画基础" class="headerlink" title="动画基础"></a>动画基础</h1><p>要<a href="https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/">创建一个基本的动画</a>，我们通过提供关键帧和时序属性来跟踪类似于CSS的结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> player = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>).animate([</div><div class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(1)'</span>, <span class="attr">opacity</span>: <span class="number">1</span>, <span class="attr">offset</span>: <span class="number">0</span> &#125;,</div><div class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(.6)'</span>, <span class="attr">opacity</span>: <span class="number">.6</span>, <span class="attr">offset</span>: <span class="number">1</span> &#125;</div><div class="line">  ], &#123;</div><div class="line">    <span class="attr">duration</span>: <span class="number">700</span>,</div><div class="line">  &#125;);</div></pre></td></tr></table></figure><p><a href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/">时间轴控制</a>是当前CSS中明显不存在的部分。通过<code>playState</code>属性读取动画的状态，并改变状态，例如<code>play()</code>，<code>pause()</code>，和<code>finish()</code>。我们也可以通过读/写<code>playbackRate</code>属性将播放速度更改或更快。<code>currentTime</code>可读写，我们可以设置当动画与完成回调<code>onfinish</code>。</p><h1 id="多个动画和分组"><a href="#多个动画和分组" class="headerlink" title="多个动画和分组"></a>多个动画和分组</h1><p>Web Animations API允许对元素设置<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations/">多个动画</a>，创建单独的动画对象。<code>document</code>上默认的<code>timeline</code>可以使用<code>getAnimations()</code>方法让我们访问创建的所有动画。可以通过使用<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/">GroupEffects 和 SequenceEffects</a>（在polyfill中提供但不在Level 1规范中）将动画组合在一起或一个接一个地进行播放。</p><h1 id="运动路径与未来"><a href="#运动路径与未来" class="headerlink" title="运动路径与未来"></a>运动路径与未来</h1><p>在这个系列中，沿着<a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path/">一条路径运动</a>让我们看到了它在CSS中的第一个实现，但还有很多其他模块尚未实现。</p><h1 id="间距-Spacing"><a href="#间距-Spacing" class="headerlink" title="间距(Spacing)"></a>间距(Spacing)</h1><p>如果在关键帧中没有设置<code>offset</code>，则当前的实现使用默认的间隔，这意味着它们是均匀分布的（例如，三个帧将具有0,1,5和1的偏移量）。该规范还定义了一种基于属性来调整动画的方法，以使其具有恒定的变化率。当讨论<a href="http://w3c.github.io/web-animations/#spacing-keyframes" target="_blank" rel="external">Spacing keyframes</a>时，该规范描述了这一点。</p><h1 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h1><p>该规范已经演变成–包括<code>ready</code>在内的，每次动画取消或进入挂起状态（通常在更改为“运行”或“已暂停”）之前将会被新的<code>Promise</code>替换。除了<code>onfinish</code>, 我们在本系列中讨论的使用回调之外，我们还可使用<code>finished</code>返回的<code>Promise</code>在动画完成后运行其他功能。</p><h1 id="让我们继续谈论Web动画API"><a href="#让我们继续谈论Web动画API" class="headerlink" title="让我们继续谈论Web动画API"></a>让我们继续谈论Web动画API</h1><p>人们开始更多地谈论这个API，我希望这个讨论继续下去。规格，浏览器实现和polyfill已经持续了一段时间，他们准备好仔细检查。</p><p>有时CSS会有更多场景，有时候是<code>requestAnimationFrame</code>，有时使用类库会是最好的解决方案。知道什么时候使用什么是好的，这个API提供了不少以前我们以前没有的可用的东西，所以很有趣。</p><p>查看本系列的其余部分：</p><ul><li><a href="https://robin-front.github.io/2017/06/25/animations-intro/">介绍</a></li><li>第1部分：<a href="https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/">创建基本动画</a></li><li>第2部分：<a href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/">动画和时间线控制</a></li><li>第3部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations/">多个动画</a></li><li>第4部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/">GroupEffects和SequenceEffects</a></li><li>第5部分：<a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path/">运动路径</a></li><li><a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Conclusion/">总结与回顾</a></li></ul><p>【翻译原文】： <a href="http://danielcwilson.com/blog/2015/09/animations-conclusion/" target="_blank" rel="external">http://danielcwilson.com/blog/2015/09/animations-conclusion/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是 Web Animations API 入门教程系列的总结部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与&lt;a href=&quot;https://twitter.com/dancwilson&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@dancwilson&lt;/a&gt;联系。&lt;/p&gt;&lt;p&gt;我们已经涵盖了相当多的知识面，希望能够解决有关Web Animations API是什么（而不是什么）的问题。要总结这个系列，我们将回顾一下我们已经讨论过的内容，并看看尚未实现的内容。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="Web Animations" scheme="http://robin-front.github.io/tags/Web-Animations/"/>
    
  </entry>
  
  <entry>
    <title>Web Animations API 入门教程第5部分: 可爱的运动路径</title>
    <link href="http://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path/"/>
    <id>http://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path/</id>
    <published>2017-06-28T01:59:47.000Z</published>
    <updated>2017-06-28T01:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是 Web Animations API 入门教程系列的第5部分。</p><p>重要信息：自撰写本文以来，运动路径的规范（和Chromium实现）已经发生了重大变化。以下在概念上仍然有效，但是属性名称和更多内容已经改变。截至2016年10月，请查看<a href="https://codepen.io/danwilson/post/css-motion-paths-2016" target="_blank" rel="external">CSS运动路径</a>。</p><p>最后，沿着路径动画…不再仅仅是SVG的领域。<a id="more"></a></p><h1 id="运动路径：当前方向（Spec）"><a href="#运动路径：当前方向（Spec）" class="headerlink" title="运动路径：当前方向（Spec）"></a>运动路径：当前方向（Spec）</h1><iframe height="265" scrolling="no" title="Motion Path Infinity" src="//codepen.io/danwilson/embed/MwLmby/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/MwLmby/" target="_blank" rel="external">Motion Path Infinity</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><p>随着API规范的运用，运动路径出现了不同的形式。最初有可能的一个方向是一个形式的特效（如前面所讨论的<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/">GroupEffect</a>），但随后借助CSS模块的运动路径的气势一点点上升（<a href="https://www.w3.org/TR/motion-1/" target="_blank" rel="external">拥有它自己的规范</a>）。</p><p>因此，沿着路径动画将只是另一组CSS属性，可以动画化，正如<code>opacity</code>和<code>tranform</code>也可以。这样，CSS过渡和关键帧可以使用它,Web Animations API也是…这是伟大的，因为我们想要尽可能多的这些方法之间共享给我们更多的灵活性。Chrome和Opera已经发布了一个初步的实现，所以我们可以在今天开始玩它，尽管还没有在polyfill找到它的任何使用方式。</p><p>让我们分解这些属性，我们如何使用它们，现在还有什么事情可以阻碍我们。</p><h1 id="运动路径属性"><a href="#运动路径属性" class="headerlink" title="运动路径属性"></a>运动路径属性</h1><p>我们将讨论<code>motion</code>的三个属性。现在，要查看示例，您将需要运行Chrome 46或Opera 33。</p><h2 id="motion-path"><a href="#motion-path" class="headerlink" title="motion-path"></a>motion-path</h2><p>起始点是<code>motion-path</code>定义元素可以移动的路径，遵循SVG 1.1中的路径工作方式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#motioner</span> &#123;</div><div class="line">  <span class="attribute">motion-path</span>: <span class="built_in">path</span>(<span class="string">"M200 200 S 200.5 200.1 348.7 184.4z"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这也可以<code>fill-rule</code>在路径调用中作为可选的第一个参数。我建议您阅读<a href="http://svgpocketguide.com/book/#section-4" target="_blank" rel="external">Joni Trythall的“优秀口袋指南”</a>，就SVG进行讨论。</p><p>根据规范，您还可以使用基本形状，例如<code>circle</code>，<code>polygon</code>，<code>ellipse</code>，和<code>inset</code>。如果您尝试过使用<a href="http://alistapart.com/article/css-shapes-101" target="_blank" rel="external">CSS shape</a>，这些应该看起来很熟悉。</p><p>根据Blink的初始实现，我只看过这个<code>path()</code>方法可以工作，所以我一直没有正确使用形状或者还没到时候。</p><h2 id="motion-offset"><a href="#motion-offset" class="headerlink" title="motion-offset"></a>motion-offset</h2><p>驱动运动，并将元素放在我们使用的路径上的某个位置<code>motion-offset</code>。这可以是双倍长度值或百分比。因此，从路径的起点到最后，我们设置一个从0到100％的动画。使用我们拥有的Web Animations API</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> m = <span class="built_in">document</span>.getElementById(<span class="string">'motioner'</span>);</div><div class="line">m.animate([</div><div class="line">  &#123; <span class="attr">motionOffset</span>: <span class="number">0</span> &#125;,</div><div class="line">  &#123; <span class="attr">motionOffset</span>: <span class="string">'100%'</span> &#125;</div><div class="line">], <span class="number">1000</span>);</div></pre></td></tr></table></figure><p>以及CSS的写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#motioner</span> &#123;</div><div class="line">  <span class="attribute">animation</span>: path-animation <span class="number">1s</span>;</div><div class="line">&#125;</div><div class="line">@<span class="keyword">keyframes</span> path-animation &#123;</div><div class="line">  0% &#123;</div><div class="line">    <span class="attribute">motion-offset</span>: <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  100% &#123;</div><div class="line">    <span class="attribute">motion-offset</span>: <span class="string">'100%'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><iframe height="265" scrolling="no" title="CSS Motion Path Spiral" src="//codepen.io/danwilson/embed/ZGmeRO/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/ZGmeRO/" target="_blank" rel="external">CSS Motion Path Spiral</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><p>该CodePen演示显示了从外部到内部沿着螺旋路径移动的几个点。随着每个点接近中心，它变得越来越快，变得越来越透明。 <code>.animate()</code>在每个点被称为两次无限迭代和一个延迟，其中一个调用集中在运动偏移，另一个焦点在缩放和不透明度上。我分解了他们，指出了不同的解决方案，当然，他们也可以结合在一起。</p><p>这种方法还使用功能检测，您将会注意到，如果您在Safari，Firefox，Edge或旧版Chrome / Opera中查看，因为您将看到一条消息而不是动画。有几种方法可以做到这一点，比如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> m = <span class="built_in">document</span>.getElementById(<span class="string">'motioner'</span>);</div><div class="line"><span class="keyword">if</span> (m.style.motionOffset !== <span class="literal">undefined</span>) &#123; ... &#125;</div></pre></td></tr></table></figure><p>当然，我们不想在真正的网页中完全阻止用户，所以如果支持，我们可以有另一个动画（或者没有动画）切换到<code>Motion Path</code>动画。像往常一样，渐进增强(Progressive Enhancement)是我们的朋友。</p><h2 id="motion-rotation"><a href="#motion-rotation" class="headerlink" title="motion-rotation"></a>motion-rotation</h2><p>最后的属性是motion-rotation，它处理元素沿着路径移动时面向哪个方向。有四种主要方法可以指定这一点。</p><ul><li>auto 表示元素将随路径旋转。</li><li>reverse 元素也将随着路径旋转，但会增加180度，因此将向后。</li><li>auto Xdeg / reverse Xdeg 除了添加X度也会一样</li><li>Xdeg 将不再与路径一起旋转，元素将保持固定朝向相同的方向。</li></ul><iframe height="265" scrolling="no" title="CSS MotionPath" src="//codepen.io/danwilson/embed/qdLQjz/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/qdLQjz/" target="_blank" rel="external">CSS MotionPath</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><h1 id="少了点什么东西？"><a href="#少了点什么东西？" class="headerlink" title="少了点什么东西？"></a>少了点什么东西？</h1><p>这是第一个版本，当然，浏览器制造商和规范作者仍在讨论这一切。在尝试这一过程中，我注意到的最大的一件事就是缺少适应不同屏幕/容器尺寸的路径。</p><p>路径只是按照它们的定义出现。当使用SVG时，我们获得灵活性，因为我们在容器上具有不同的坐标系和属性，如 <a href="http://sarasoueidan.com/blog/svg-coordinate-systems/#svg-viewbox" target="_blank" rel="external">viewBox</a>。使用CSS中定义的运动路径，路径的大小不能被其他属性另外修改或约束。元素上定义的宽度和高度仅适用于元素，而不是其运动路径。您可以使用媒体查询或JavaScript来定义不同条件的不同路径，但是想通过<code>motion</code>属性灵活地设置它们是不可能的事。</p><h1 id="回顾和下一节"><a href="#回顾和下一节" class="headerlink" title="回顾和下一节"></a>回顾和下一节</h1><p>我们将看到规范的方向，但现在尝试这样做是很有趣的，看看它可能提供什么（和不提供什么）。我正在收集我在CodePen上找到的<a href="http://codepen.io/collection/AQWaem" target="_blank" rel="external">CSS Motion Path演示文稿</a>，而Eric Willigers（Chrome开发团队的相关实现任务的所有者）拥有一个<a href="https://docs.google.com/document/d/15nn0tc9meyahzSBAauYtIUpGFsuHaieZt403k1v9B90/edit" target="_blank" rel="external">Google Doc的例子</a>。</p><p>我们将在下次再次介绍我们所讨论的内容，并且再看几个目前唯一的规范主题。</p><p>查看本系列的其余部分：</p><ul><li><a href="https://robin-front.github.io/2017/06/25/animations-intro/">介绍</a></li><li>第1部分：<a href="https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/">创建基本动画</a></li><li>第2部分：<a href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/">动画和时间线控制</a></li><li>第3部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations/">多个动画</a></li><li>第4部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/">GroupEffects和SequenceEffects</a></li><li>第5部分：<a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path/">运动路径</a></li><li><a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Conclusion/">总结与回顾</a></li></ul><p>【翻译原文】： <a href="http://danielcwilson.com/blog/2015/09/animations-part-5/" target="_blank" rel="external">http://danielcwilson.com/blog/2015/09/animations-part-5/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是 Web Animations API 入门教程系列的第5部分。&lt;/p&gt;&lt;p&gt;重要信息：自撰写本文以来，运动路径的规范（和Chromium实现）已经发生了重大变化。以下在概念上仍然有效，但是属性名称和更多内容已经改变。截至2016年10月，请查看&lt;a href=&quot;https://codepen.io/danwilson/post/css-motion-paths-2016&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CSS运动路径&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;最后，沿着路径动画…不再仅仅是SVG的领域。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="Web Animations" scheme="http://robin-front.github.io/tags/Web-Animations/"/>
    
  </entry>
  
  <entry>
    <title>Web Animations API 入门教程第4部分: GroupEffects &amp; SequenceEffects</title>
    <link href="http://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/"/>
    <id>http://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/</id>
    <published>2017-06-27T03:24:55.000Z</published>
    <updated>2017-06-27T03:24:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是 Web Animations API 入门教程系列的第4部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与<a href="https://twitter.com/dancwilson" target="_blank" rel="external">@dancwilson</a>联系。</p><p>让我们继续讨论Web动画API中的多个动画，通过讨论今天在polyfill中提供的几个部分来提供分组和排序。<a id="more"></a></p><h1 id="KeyframeEffects"><a href="#KeyframeEffects" class="headerlink" title="KeyframeEffects"></a>KeyframeEffects</h1><p>A KeyframeEffect需要三个参数：动画元素(element)，关键帧数组(keyframes)和时间选项(timing options)。这些都是我们以前使用过的参数<code>element.animate()</code>。这个新对象本质上是单个动画的蓝图，当我们讨论分组(group)和队列(sequence)动画的方法时，我们会看到它。它不启动动画，它只是定义动画。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>);</div><div class="line"><span class="keyword">var</span> timings = &#123;</div><div class="line">  <span class="attr">duration</span>: <span class="number">1000</span>,</div><div class="line">  <span class="attr">fill</span>: <span class="string">'both'</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> keyframes = [</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">1</span> &#125;.</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">0</span> &#125;</div><div class="line">];</div><div class="line"></div><div class="line"><span class="keyword">var</span> effect = <span class="keyword">new</span> KeyframeEffect(elem, keyframes, timings);</div></pre></td></tr></table></figure><h1 id="GroupEffects"><a href="#GroupEffects" class="headerlink" title="GroupEffects"></a>GroupEffects</h1><p>虽然在任何浏览器中都没有实现此功能，甚至在Level 2规范中找不到，但是polyfill提供了一种组合动画并将其一起播放的方法。 <strong>GroupEffect</strong>（是的，它是未来将集成在Level 2规范）组合一个或多个KeyframeEffects同时播放。</p><iframe height="265" scrolling="no" title="Group Effects with WAAPI" src="//codepen.io/danwilson/embed/zGeVey/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/zGeVey/" target="_blank" rel="external">Group Effects with WAAPI</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><p>一个<code>GroupEffect</code>任务需要一个<code>Effects</code>参数，我们可以传递代表我们多个动画的<code>KeyframeEffect</code>数组。一旦定义，我们可以在准备好的时候在默认时间轴上播放动画组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>);</div><div class="line"><span class="keyword">var</span> elem2 = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate2'</span>);</div><div class="line"><span class="keyword">var</span> timings = &#123;</div><div class="line">  <span class="attr">duration</span>: <span class="number">1000</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> keyframes = [</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">1</span> &#125;.</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">0</span> &#125;</div><div class="line">];</div><div class="line"></div><div class="line"><span class="keyword">var</span> kEffects = [</div><div class="line">  <span class="keyword">new</span> KeyframeEffect(elem, keyframes, timings),</div><div class="line">  <span class="keyword">new</span> KeyframeEffect(elem2, keyframes, timings)</div><div class="line">];</div><div class="line"><span class="keyword">var</span> group = <span class="keyword">new</span> GroupEffect(kEffects);</div><div class="line"><span class="built_in">document</span>.timeline.play(group);</div></pre></td></tr></table></figure><h1 id="SequenceEffects"><a href="#SequenceEffects" class="headerlink" title="SequenceEffects"></a>SequenceEffects</h1><p>类似于<code>GroupEffect</code>，<code>SequenceEffect</code>允许我们将多个动画（由<code>KeyframeEffects</code> 指定）组合在一起…不是并行播放它们，而是一个接一个地播放它们。您也可以按照polyfill中的定义将<code>GroupEffect</code>和<code>SequenceEffect</code>一起使用（例如具有多个序列的分组）。</p><iframe height="265" scrolling="no" title="SequenceEffect with WAAPI" src="//codepen.io/danwilson/embed/vNYQLL/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/vNYQLL/" target="_blank" rel="external">SequenceEffect with WAAPI</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><p>队列提供给你一些我们必须用CSS或者我们在 animations API中看到的东西。我们必须根据早期动画的持续时间或使用 <strong>finish</strong> 回调来维持延迟。这些方法可能难以维护，或者不会如此精确。</p><p>使用先前在<code>GroupEffect</code>代码段中的变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sequence = <span class="keyword">new</span> SequenceEffect(kEffects);</div><div class="line"><span class="built_in">document</span>.timeline.play(sequence);</div></pre></td></tr></table></figure><h1 id="创建动画的备用方法"><a href="#创建动画的备用方法" class="headerlink" title="创建动画的备用方法"></a>创建动画的备用方法</h1><p>我们以前看过<code>element.animate()</code>创建动画的方式。这是创建动画的快捷方式，立即播放，并获取<code>Animation</code>对象的引用。我们专注于这一点，因为Chrome支持了一段时间了，polyfill也是。Firefox是第一个支持替代方式的：·构造函数。它向我们展示了另一种使用方法<code>KeyframeEffect</code>，而且它在Level 1规范中，所以我们应该很快会看到它的更多应用。</p><p>首先提醒一下如何<code>element.animate()</code>工作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>);</div><div class="line"><span class="keyword">var</span> timings = &#123;</div><div class="line">  <span class="attr">duration</span>: <span class="number">1000</span>,</div><div class="line">  <span class="attr">fill</span>: <span class="string">'both'</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> keyframes = [</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">1</span> &#125;.</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">0</span> &#125;</div><div class="line">];</div><div class="line"></div><div class="line">elem.animate(keyframes, timings);</div></pre></td></tr></table></figure><p>使用与上述相同的变量，以下是使用<code>Animation</code>构造函数的等价写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> kEffect = <span class="keyword">new</span> KeyframeEffect(elem, keyframes, timings);</div><div class="line"><span class="keyword">var</span> player = <span class="keyword">new</span> Animation(kEffect, elem.ownerDocument.timeline);</div><div class="line">player.play();</div></pre></td></tr></table></figure><p>这里的主要区别在于，动画不会立即开始播放，所以在提前创建动画以便稍后播放时，这将非常有用。</p><h1 id="回顾和下一节"><a href="#回顾和下一节" class="headerlink" title="回顾和下一节"></a>回顾和下一节</h1><p>当Level 2规范通过工作草案时，我们应该看到更多关于这些不同效果的定义。本系列中还有两个计划的章节。下一次我们将再次看看未来，还有什么我们可以期待看到。</p><p>查看本系列的其余部分：</p><ul><li><a href="https://robin-front.github.io/2017/06/25/animations-intro/">介绍</a></li><li>第1部分：<a href="https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/">创建基本动画</a></li><li>第2部分：<a href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/">动画和时间线控制</a></li><li>第3部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations/">多个动画</a></li><li>第4部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/">GroupEffects和SequenceEffects</a></li><li>第5部分：<a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path/">运动路径</a></li><li><a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Conclusion/">总结与回顾</a></li></ul><p>【翻译原文】：<a href="http://danielcwilson.com/blog/2015/09/animations-part-4/" target="_blank" rel="external">http://danielcwilson.com/blog/2015/09/animations-part-4/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是 Web Animations API 入门教程系列的第4部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与&lt;a href=&quot;https://twitter.com/dancwilson&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@dancwilson&lt;/a&gt;联系。&lt;/p&gt;&lt;p&gt;让我们继续讨论Web动画API中的多个动画，通过讨论今天在polyfill中提供的几个部分来提供分组和排序。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="Web Animations" scheme="http://robin-front.github.io/tags/Web-Animations/"/>
    
  </entry>
  
  <entry>
    <title>Web Animations API 入门教程第3部分: 多个Animations对象</title>
    <link href="http://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations/"/>
    <id>http://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations/</id>
    <published>2017-06-27T02:17:19.000Z</published>
    <updated>2017-06-27T02:17:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是 Web Animations API 入门教程系列的第3部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与<a href="https://twitter.com/dancwilson" target="_blank" rel="external">@dancwilson</a>联系。</p><p>在我们讨论<a href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/">动画和时间线控制</a>之后，让我们来讨论多个动画。<a id="more"></a></p><h1 id="每个元素的多个动画"><a href="#每个元素的多个动画" class="headerlink" title="每个元素的多个动画"></a>每个元素的多个动画</h1><iframe height="265" scrolling="no" title="Multiple animate calls" src="//codepen.io/danwilson/embed/PqxvJo/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/PqxvJo/" target="_blank" rel="external">Multiple animate calls</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><p>在这个例子中，每个矩形都有三个动画应用（涉及到transform，opacity和color）。您可以多次调用元素的<code>animate()</code>方法，类似于允许多个动画的CSS。</p><p>使用CSS：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#toAnimate</span> &#123;</div><div class="line">  <span class="attribute">animation</span>: pulse <span class="number">1s</span>, activate <span class="number">3000ms</span>, have-fun-with-it <span class="number">2.5s</span>;</div><div class="line">&#125;</div><div class="line">@<span class="keyword">keyframes</span> pulse &#123; <span class="comment">/* ... */</span> &#125;</div><div class="line">@<span class="keyword">keyframes</span> activate &#123; <span class="comment">/* ... */</span> &#125;</div><div class="line">@<span class="keyword">keyframes</span> have-fun-with-it &#123; <span class="comment">/* ... */</span> &#125;</div></pre></td></tr></table></figure><p>使用Web Animations API：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> animated = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>);</div><div class="line"><span class="keyword">var</span> pulseKeyframes, <span class="comment">//在这里定义 keyframes.</span></div><div class="line">    activateKeyframes,</div><div class="line">    haveFunKeyframes;</div><div class="line"><span class="keyword">var</span> pulse = animated.animate(pulseKeyframes, <span class="number">1000</span>); <span class="comment">// 第二个数值参数作为持续时间的缩写</span></div><div class="line"><span class="keyword">var</span> activate = animated.animate(activateKeyframes, <span class="number">3000</span>);</div><div class="line"><span class="keyword">var</span> haveFunWithIt = animated.animate(haveFunKeyframes, <span class="number">2500</span>);</div></pre></td></tr></table></figure><p>使用Web Animations API，这将创建三个Animation对象，每个对象可以通过时间轴(timeline)或播放速率(playback rate)进行暂停，播放，完成，取消的操作。</p><h1 id="获取-Animations，全部动画对象"><a href="#获取-Animations，全部动画对象" class="headerlink" title="获取 Animations，全部动画对象"></a>获取 Animations，全部动画对象</h1><p>所以你可以知道一个动画开始播放了，但是当你想在元素上调用<code>animate()</code>时你却还没有捕获到Animation的引用。那要怎么做？</p><iframe height="265" scrolling="no" title="Pause All those Random Dots!" src="//codepen.io/danwilson/embed/PqgKVK/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/PqgKVK/" target="_blank" rel="external">Pause All those Random Dots!</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><p>该规范允许<code>getAnimations()</code>在文档上的方法。在最新版本的规范中，它直接在<code>document（document.getAnimations()）</code>上，在Firefox 48+上它是这样实现的。然而，对于Chrome 52 和<a href="https://github.com/web-animations/web-animations-js" target="_blank" rel="external">polyfill</a>（如V2.2.0的），则根据该旧规范将其置于新的<code>timeline</code>对象上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如果引用了 polyfill ，你可以这样写</span></div><div class="line"><span class="keyword">var</span> animations = <span class="built_in">document</span>.getAnimations ? <span class="built_in">document</span>.getAnimations() : <span class="built_in">document</span>.timeline.getAnimations();</div><div class="line"><span class="comment">// 返回一个数组，包含所有正在进行的（除了已完成的和被取消的）动画</span></div></pre></td></tr></table></figure><p>在CodePen示例中，您将看到随机的持续时间，延迟和无限持续时间的变换移动的几个点。“暂停全部”按钮调用<code>getAnimations()</code>并遍历所有, 返回的玩家（每个动画对象）并暂停每一个。</p><h1 id="下一节…"><a href="#下一节…" class="headerlink" title="下一节…"></a>下一节…</h1><p>在下一部分中，我们将看看WAAPI动画可以创建的不同方式（因为它不仅仅是<code>element.animate</code>）。提示：<code>document.timeline</code>会出现更多的体现。</p><p>查看本系列的其余部分：</p><ul><li><a href="https://robin-front.github.io/2017/06/25/animations-intro/">介绍</a></li><li>第1部分：<a href="https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/">创建基本动画</a></li><li>第2部分：<a href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/">动画和时间线控制</a></li><li>第3部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations/">多个动画</a></li><li>第4部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/">GroupEffects和SequenceEffects</a></li><li>第5部分：<a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path/">运动路径</a></li><li><a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Conclusion/">总结与回顾</a></li></ul><p>【翻译原文】: <a href="http://danielcwilson.com/blog/2015/08/animations-part-3/" target="_blank" rel="external">http://danielcwilson.com/blog/2015/08/animations-part-3/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是 Web Animations API 入门教程系列的第3部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与&lt;a href=&quot;https://twitter.com/dancwilson&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@dancwilson&lt;/a&gt;联系。&lt;/p&gt;&lt;p&gt;在我们讨论&lt;a href=&quot;http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/&quot;&gt;动画和时间线控制&lt;/a&gt;之后，让我们来讨论多个动画。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="Web Animations" scheme="http://robin-front.github.io/tags/Web-Animations/"/>
    
  </entry>
  
  <entry>
    <title>Web Animations API入门教程第2部分：动画和时间线控制</title>
    <link href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/"/>
    <id>http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/</id>
    <published>2017-06-26T09:51:00.000Z</published>
    <updated>2017-06-26T09:51:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是 Web Animations API 入门教程系列的第2部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与<a href="https://twitter.com/dancwilson" target="_blank" rel="external">@dancwilson</a>联系。</p><p>现在我们了解如何使用Web Animations API <a href="https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/">创建基本动画</a>，让我们来谈谈状态（states），控制(controls)，回调(callback)和时间轴(timelines)。<a id="more"></a></p><h1 id="Animations-播放状态和控制"><a href="#Animations-播放状态和控制" class="headerlink" title="Animations 播放状态和控制"></a>Animations 播放状态和控制</h1><p>当你调用时<code>element.animate()</code>，返回一个<code>Animation</code>对象（以前称为<code>AnimationPlayerspec</code>），动画开始播放。要查看动画的当前状态，您可以检查<code>readonly</code>属性<code>playState</code>，该属性将返回五个字符串之一。我们也可以通过调用四种方法之一修改动画的当前状态：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> player = element.animate(<span class="comment">/* ... */</span>);</div><div class="line"><span class="built_in">console</span>.log(player.playState); <span class="comment">//"running"</span></div><div class="line"></div><div class="line">player.pause(); <span class="comment">//"paused"</span></div><div class="line">player.play();  <span class="comment">//"running"</span></div><div class="line">player.cancel(); <span class="comment">//"idle"... 跳到原始状态</span></div><div class="line">player.finish(); <span class="comment">//"finished"...跳到结束状态</span></div></pre></td></tr></table></figure><p>此外<code>running</code>，<code>paused</code>，<code>idle</code>，和<code>finished</code>播放状态有一个<code>pending</code>状态定义当播放或暂停任务正在等待批准即将发生。</p><p>这个“步行圆圈”示例显示六个圆缩放。您可以暂停或播放每个圈子，以查看上述播放状态的一部分。</p><iframe height="265" scrolling="no" title="Blob That Walks" src="//codepen.io/danwilson/embed/WvXRYg/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/WvXRYg/" target="_blank" rel="external">Blob That Walks</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><h1 id="播放速率"><a href="#播放速率" class="headerlink" title="播放速率"></a>播放速率</h1><p>在之前的CodePen示例中，还有一个“2x”按钮，您可以按更改动画的播放速度，将其切换到双倍速度。这是通过读/写<code>playbackRate</code>属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> player = element.animate(<span class="comment">/* ... */</span>);</div><div class="line"><span class="built_in">console</span>.log(player.playbackRate); <span class="comment">//1</span></div><div class="line"></div><div class="line">player.playbackRate = <span class="number">2</span>; <span class="comment">//双倍速度, 也可以使用十进制数字控制它降低速度.</span></div></pre></td></tr></table></figure><h1 id="动画完成后的回调"><a href="#动画完成后的回调" class="headerlink" title="动画完成后的回调"></a>动画完成后的回调</h1><p>使用CSS transitions，当转换结束时，通常会触发一个事件。类似地，<code>Animation</code>允许您指定一个<code>onfinish</code>函数，在动画完成或调用之前讨论过的<code>finish()</code>方法时调用它。请注意，根据规范，无法完成无限次迭代的动画集，也不能完成一个具有<code>playbackRate = 0</code> 的动画集。还有一个<code>oncancel</code>处理程序，以及在<code>Animation</code>完成时使用<code>Promises</code>的写法。</p><p>以下示例用于<code>onfinish</code>在动画完成后显示一些统计信息（并且它也很好地切换到下一次关于时间轴的讨论）。</p><iframe height="265" scrolling="no" title="Timer Countdown" src="//codepen.io/danwilson/embed/RPMVZJ/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/RPMVZJ/" target="_blank" rel="external">Timer Countdown</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><h1 id="时间轴"><a href="#时间轴" class="headerlink" title="时间轴"></a>时间轴</h1><p>每个<code>Animation</code>都公开两个读/写时间相关属性 - <code>currentTime</code>和<code>startTime</code>。现在，我们将重点关注前者。</p><p><code>currentTime</code>返回动画当前的毫秒数。最大值将为延迟时间 +（持续时间<em>迭代次数）（`delay + (duration </em>iterations)`），因此无限次迭代将不具有最大值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> player = element.animate([</div><div class="line">  &#123;<span class="attr">opacity</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">opacity</span>: <span class="number">0</span>&#125;</div><div class="line">], &#123;</div><div class="line">  <span class="attr">duration</span>: <span class="number">1000</span>,</div><div class="line">  <span class="attr">delay</span>: <span class="number">500</span>,</div><div class="line">  <span class="attr">iterations</span>: <span class="number">3</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">player.onfinish = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(player.currentTime); <span class="comment">// 3500</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>播放速率将影响时间轴的持续时间。如果您将播放速度设置为10，则您的最大时间保持不变，但您的时间轴会快10倍。这个概念也在之前的“计时器倒计时”示例中显示。</p><p>由于<code>currentTime</code>是可 读/写，我们也可以使用它来跳转到时间轴中的某一点。它也可以让我们同步两个动画，如下例所示。</p><iframe height="265" scrolling="no" title="Syncing Timelines - WAAPI" src="//codepen.io/danwilson/embed/YXYWKK/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/YXYWKK/" target="_blank" rel="external">Syncing Timelines - WAAPI</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><h1 id="还有一个选项：-reverse"><a href="#还有一个选项：-reverse" class="headerlink" title="还有一个选项： reverse()"></a>还有一个选项： reverse()</h1><p>你也可以使用<code>reverse()</code>反转一个与之非常相似的动画<code>play()</code>（比如它会有相同的playState），除了它将以相反的方式遍历时间轴。当动画完成时，<code>currentTime</code>将为0。</p><iframe height="265" scrolling="no" title="waRKOm" src="//codepen.io/danwilson/embed/waRKOm/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/waRKOm/" target="_blank" rel="external">waRKOm</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><h1 id="下一节…"><a href="#下一节…" class="headerlink" title="下一节…"></a>下一节…</h1><p>这包含了很多的信息，但仍然只是熟悉一下WAAPI有哪些可用的。下面我们来看一些更高级的用法。</p><p>查看本系列的其余部分：</p><ul><li><a href="https://robin-front.github.io/2017/06/25/animations-intro/">介绍</a></li><li>第1部分：<a href="https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/">创建基本动画</a></li><li>第2部分：<a href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/">动画和时间线控制</a></li><li>第3部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations/">多个动画</a></li><li>第4部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/">GroupEffects和SequenceEffects</a></li><li>第5部分：<a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path/">运动路径</a></li><li><a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Conclusion/">总结与回顾</a></li></ul><p>【翻译原文】: <a href="http://danielcwilson.com/blog/2015/07/animations-part-2/" target="_blank" rel="external">http://danielcwilson.com/blog/2015/07/animations-part-2/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是 Web Animations API 入门教程系列的第2部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与&lt;a href=&quot;https://twitter.com/dancwilson&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@dancwilson&lt;/a&gt;联系。&lt;/p&gt;&lt;p&gt;现在我们了解如何使用Web Animations API &lt;a href=&quot;https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/&quot;&gt;创建基本动画&lt;/a&gt;，让我们来谈谈状态（states），控制(controls)，回调(callback)和时间轴(timelines)。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="Web Animations" scheme="http://robin-front.github.io/tags/Web-Animations/"/>
    
  </entry>
  
</feed>
