<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>三寸稚笔</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://robin-front.github.io/"/>
  <updated>2017-11-29T01:49:43.000Z</updated>
  <id>http://robin-front.github.io/</id>
  
  <author>
    <name>robin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>简洁代码与冗余代码</title>
    <link href="http://robin-front.github.io/2017/11/29/clean-code-dirty-code/"/>
    <id>http://robin-front.github.io/2017/11/29/clean-code-dirty-code/</id>
    <published>2017-11-29T01:49:43.000Z</published>
    <updated>2017-11-29T01:49:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简洁代码与冗余代码"><a href="#简洁代码与冗余代码" class="headerlink" title="简洁代码与冗余代码"></a>简洁代码与冗余代码</h1><p>这篇文章将重点介绍适用于现代 react 软件开发的简洁代码之道。我还会谈谈 ES6/ES2015 带来的一些“语法糖”。<a id="more"></a></p><h2 id="什么是简洁代码之道，为什么我如此关心？"><a href="#什么是简洁代码之道，为什么我如此关心？" class="headerlink" title="什么是简洁代码之道，为什么我如此关心？"></a>什么是简洁代码之道，为什么我如此关心？</h2><p>简洁代码之道的一贯编码风格是让你的代码更易写、易读和易维护。经常，程序员在一个问题上花了许多时间，一旦问题被解决，就提交代码。我一直主张，你的工作并没有完成，因为你只是让你的代码“正常工作”而已。</p><p>这是一个机会来精简你的代码，通过删除死代码（僵尸代码）、重构、删除被注释的代码！努力提高可维护性。扪心自问，“6个月后其他人还能理解你的代码吗？”</p><p>简单来说，编写能让你自豪到带回家和母亲炫耀的代码。</p><p>为什么你要这么关心这个问题？因为如果你是一个好开发者，你会很懒。听我说完，我是赞扬的意思。一个好的开发者，面对同一件事要做很多遍的状况，通常会寻找一个自动解决（或更好的）方案来完成眼前的任务。所以，因为你很懒，关注简洁代码的技术将会减少你拉取代码一遍又一遍地 review 同一段代码的频率。</p><h2 id="通过嗅觉测试精简代码"><a href="#通过嗅觉测试精简代码" class="headerlink" title="通过嗅觉测试精简代码"></a>通过嗅觉测试精简代码</h2><p>精简代码应该通过嗅觉测试。不明白我是什么意思？我们都看着（自己的或别人的）代码说：“这里不太对劲。” 记住，如果感觉不太对劲，那可能真的不对劲。一起对代码深思熟虑是好的。但如果你发觉你正在把一个方形的钉子插进一个圆形的洞里，那就请停下来，退一步，并且休息一下。最多十次，你会找到更好的解决办法的。</p><h2 id="精简代码就是-DRY-（禁止重复）"><a href="#精简代码就是-DRY-（禁止重复）" class="headerlink" title="精简代码就是 DRY （禁止重复）"></a>精简代码就是 DRY （禁止重复）</h2><p>DRY 是 “Don’t repeat yourself!” 的缩写。如果一件事你做了很多遍，合并重复的代码。如果你在你代码里发现了设计模式，那是一个删除重复的迹象。有时候这意味着你站得离屏幕远远地，直到你看不清文字，也无法寻找模式。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Dirty</span></div><div class="line"><span class="keyword">const</span> MyComponent = <span class="function"><span class="params">()</span> =&gt;</span> (</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;OtherComponent type="a" className="colorful" foo=&#123;123&#125; bar=&#123;456&#125; /&gt;</div><div class="line">    &lt;OtherComponent type="b" className="colorful" foo=&#123;123&#125; bar=&#123;456&#125; /&gt;    </div><div class="line">  &lt;/div&gt;</div><div class="line">);</div></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Clean</span></div><div class="line"><span class="keyword">const</span> MyOtherComponent = <span class="function">(<span class="params">&#123; type &#125;</span>) =&gt;</span> (</div><div class="line">  &lt;OtherComponent type=&#123;type&#125; className="colorful" foo=&#123;123&#125; bar=&#123;456&#125; /&gt;</div><div class="line">);</div><div class="line">const MyComponent = () =&gt; (</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;MyOtherComponent type="a" /&gt;</div><div class="line">    &lt;MyOtherComponent type="b" /&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">);</div></pre></td></tr></table></figure><p>有时候，就像上面的例子那样 —— 删除重复代码并不会减少代码量。但是，删除重复代码一般会提高可维护性。</p><p>要注意，不要在删除重复代码这件事上做得太过分了，所以要知道什么时候该说什么。</p><h2 id="简洁的代码是可预测和可测试的"><a href="#简洁的代码是可预测和可测试的" class="headerlink" title="简洁的代码是可预测和可测试的"></a>简洁的代码是可预测和可测试的</h2><p>编写单元测试不仅仅是一个好主意，它已经几乎变成强制性的。毕竟，你怎样确保新特性没有在某些地方引起一些 bugs。</p><p>许多 react 开发者依靠零配置的 <a href="https://facebook.github.io/jest/" target="_blank" rel="noopener">jest</a> 测试库，并产出覆盖报告。如果你对前后视觉对照测试感兴趣，请尝试一下 美国运通开源的 <a href="https://github.com/americanexpress/jest-image-snapshot" target="_blank" rel="noopener">Jest Image Snapshot</a>。</p><h2 id="简洁的代码能自我说明"><a href="#简洁的代码能自我说明" class="headerlink" title="简洁的代码能自我说明"></a>简洁的代码能自我说明</h2><p>你之前有遇到过吗？你写了一些代码，并确保它拥有完整的注释。将会发生这样的情况，你发现一个 bug, 所以你回去修改代码。你还记得修改注释并对应新的逻辑吗？也许记得。也许不记得。下一个看你代码的人可能已经掉进兔子洞（被绕进去了）因为他还在看以前的注释。</p><p>只给复杂的思路添加注释。不要给显而易见的代码添加注释。更少量的注释也有利于减少视觉干扰。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Dirty</span></div><div class="line"><span class="keyword">const</span> fetchUser = <span class="function">(<span class="params">id</span>) =&gt;</span> (</div><div class="line">  fetch(buildUri<span class="string">`/users/<span class="subst">$&#123;id&#125;</span>`</span>) <span class="comment">// Get User DTO record from REST API</span></div><div class="line">    .then(convertFormat) <span class="comment">// Convert to snakeCase</span></div><div class="line">    .then(validateUser) <span class="comment">// Make sure the the user is valid</span></div><div class="line">);</div></pre></td></tr></table></figure><p>而简洁版，我们重命名函数以便更好地描述他们是做什么的，因此消除了注释的必要并减少视觉干扰。这限制了代码与注释不匹配的潜在混乱。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Clean</span></div><div class="line"><span class="keyword">const</span> fetchUser = <span class="function">(<span class="params">id</span>) =&gt;</span> (</div><div class="line">  fetch(buildUri<span class="string">`/users/<span class="subst">$&#123;id&#125;</span>`</span>)</div><div class="line">    .then(snakeToCamelCase)</div><div class="line">    .then(validateUser)</div><div class="line">);</div></pre></td></tr></table></figure><h2 id="命名的重要性"><a href="#命名的重要性" class="headerlink" title="命名的重要性"></a>命名的重要性</h2><p>在我前面的文章 <a href="http://americanexpress.io/faccs-are-an-antipattern" target="_blank" rel="noopener">子组件的函数是一种反模式</a>, 我强调了命名的重要性。我们应该严肃思考变量名、函数名、甚至文件名。</p><p>下面是一些指南：</p><ul><li>布尔值变量、或返回布尔值的函数，应该以 “is”, “has”, “should” 开头。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Dirty</span></div><div class="line"><span class="keyword">const</span> done = current &gt;= goal;</div><div class="line"><span class="comment">// Clean</span></div><div class="line"><span class="keyword">const</span> isComplete = current &gt;= goal;</div></pre></td></tr></table></figure><ul><li>函数名应该描述函数的功能是什么，而不是怎样实现这个功能。换句话说，不要在命名中暴露实现细节。为什么？因为不知道哪一天你就会换一种实现，而你不应该为重构实现方式而去更改业务代码。举个例子，今天你可能通过 REST API 加载你的配置，但可能明天你又改成用 javascipt 实现。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Dirty</span></div><div class="line"><span class="keyword">const</span> loadConfigFromServer = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  ...</div><div class="line">&#125;;</div><div class="line"><span class="comment">// Clean</span></div><div class="line"><span class="keyword">const</span> loadConfig = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="简洁代码遵循成熟的设计模式和最佳实践"><a href="#简洁代码遵循成熟的设计模式和最佳实践" class="headerlink" title="简洁代码遵循成熟的设计模式和最佳实践"></a>简洁代码遵循成熟的设计模式和最佳实践</h2><p>计算机普及很长时间了。多年来，程序员在解决某些问题的时候发现模式。被称为 设计模式。换句话说，它是随着时间推移被证明的有用的算法。你可以站在这些巨人的肩上，以便避免再犯这些错误。</p><p>然后有一些最佳实践，它们和设计模式很类似，但更广义，不具体指编码算法。它们可能涉及到类似“你应该在编码时使用 lint 工具” 或者 “当你写一个类库时，请包含 react 作为 <code>peerDependency</code>”。</p><ul><li>将函数功能缩小，每一个都职责单一。这个叫做职责单一原则。确保每个函数做好并只做一件事。意思是你可以将一个复杂的组件拆分成许多小的部分。这也会让代码更易测试。</li><li>注意抽象接口。换句话说，不要强制让你的业务代码使用私有变量或私有方法。</li><li>遵循严格的 linting 规则，它会帮助你编写简洁、风格统一的代码。</li></ul><h2 id="简洁的代码不一定要花费更长时间"><a href="#简洁的代码不一定要花费更长时间" class="headerlink" title="简洁的代码不一定要花费更长时间"></a>简洁的代码不一定要花费更长时间</h2><p>我听到编写简洁的代码会降低工作效率。真是一派胡言。是的，为了冲刺，一开始你需要放慢脚步，但是写了几行代码后，你的步伐会越来越快。</p><p>并且不要考虑将来再“重构”它，并花时间修复来自 code review 的评论。如果你将代码拆分成小模块，每个都职责单一，很可能将来大部分模块都不会碰。这就是通过“写下它，忘了它”来了省时间。</p><h2 id="冗余代码-VS-简洁代码的实践例子"><a href="#冗余代码-VS-简洁代码的实践例子" class="headerlink" title="冗余代码 VS. 简洁代码的实践例子"></a>冗余代码 VS. 简洁代码的实践例子</h2><p>看看下面的代码。继续看，并返回到前面我所讲的内容。你有看到什么模式吗？注意到 <code>Thingie</code> 组件和 <code>ThingieWithTitle</code> 组件除了 <code>Title</code> 组件之外都完全相同。这满足了 DRY 的条件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Dirty</span></div><div class="line"><span class="keyword">import</span> Title <span class="keyword">from</span> <span class="string">'./Title'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> Thingie = <span class="function">(<span class="params">&#123; description &#125;</span>) =&gt;</span> (</div><div class="line">  &lt;div class="thingie"&gt;</div><div class="line">    &lt;div class="description-wrapper"&gt;</div><div class="line">      &lt;Description value=&#123;description&#125; /&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">);</div><div class="line">export const ThingieWithTitle = (&#123; title, description &#125;) =&gt; (</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;Title value=&#123;title&#125; /&gt;</div><div class="line">    &lt;div class="description-wrapper"&gt;</div><div class="line">      &lt;Description value=&#123;description&#125; /&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">);</div></pre></td></tr></table></figure><p>这里允许我们传递 <code>children</code> 到 <code>Thingie</code>, 然后创建一个 <code>ThingieWithTitle</code> 包裹 <code>Thingie</code>，传递 <code>Title</code> 作为它的子节点。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Clean</span></div><div class="line"><span class="keyword">import</span> Title <span class="keyword">from</span> <span class="string">'./Title'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> Thingie = <span class="function">(<span class="params">&#123; description, children &#125;</span>) =&gt;</span> (</div><div class="line">  &lt;div class="thingie"&gt;</div><div class="line">    &#123;children&#125;</div><div class="line">    &lt;div class="description-wrapper"&gt;</div><div class="line">      &lt;Description value=&#123;description&#125; /&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">);</div><div class="line">export const ThingieWithTitle = (&#123; title, ...others &#125;) =&gt; (</div><div class="line">  &lt;Thingie &#123;...others&#125;&gt;</div><div class="line">    &lt;Title value=&#123;title&#125; /&gt;</div><div class="line">  &lt;/Thingie&gt;</div><div class="line">);</div></pre></td></tr></table></figure><h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>看下面的代码段。它默认使用 <code>icon-large</code> 作为 <code>className</code> 的声明值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Dirty</span></div><div class="line"><span class="keyword">const</span> Icon = <span class="function">(<span class="params">&#123; className, onClick &#125;</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> additionalClasses = className || <span class="string">'icon-large'</span>;</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">span</span></span></span></div><div class="line">      <span class="attr">className</span>=<span class="string">&#123;</span>`<span class="attr">icon-hover</span> $&#123;<span class="attr">additionalClasses</span>&#125;`&#125;</div><div class="line">      <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span>&gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">  );</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>这里我们使用 ES6 默认语法，用字符串来替换未定义的值。这也允许我们使用箭头函数，并消除 return 的使用。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Clean</span></div><div class="line"><span class="keyword">const</span> Icon = <span class="function">(<span class="params">&#123; className = <span class="string">'icon-large'</span>, onClick &#125;</span>) =&gt;</span> (</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&#123;</span>`<span class="attr">icon-hover</span> $&#123;<span class="attr">className</span>&#125;`&#125; <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span> /&gt;</span></span></div><div class="line">);</div></pre></td></tr></table></figure><p>下面是更简洁的版本，默认值通过 react 设置。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Cleaner</span></div><div class="line"><span class="keyword">const</span> Icon = <span class="function">(<span class="params">&#123; className, onClick &#125;</span>) =&gt;</span> (</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&#123;</span>`<span class="attr">icon-hover</span> $&#123;<span class="attr">className</span>&#125;`&#125; <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span> /&gt;</span></span></div><div class="line">);</div><div class="line">Icon.defaultProps = &#123;</div><div class="line">  className: 'icon-large',</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>为什么这样更简洁？为什么这样更好？三个版本做的不是同样一件事吗？对于大部分情况来说，确实是的。但是，让 react 设置默认值的好处是会产生更高效的代码。默认 props 基于类的组件生命周期,同时允许你使用 <code>propTypes</code> 检查默认值。但还有一个好处：简化组件自身的默认逻辑。</p><p>举个例子，你可以这样做，在一个变量里存储所有默认的 props。我不建议你这样做，我只是说你可以有这种做法。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> defaultProps <span class="keyword">from</span> <span class="string">'./defaultProps'</span>;</div><div class="line">...</div><div class="line">Icon.defaultProps = defaultProps.Icon;</div></pre></td></tr></table></figure><h2 id="从-render-函数中分离状态"><a href="#从-render-函数中分离状态" class="headerlink" title="从 render 函数中分离状态"></a>从 render 函数中分离状态</h2><p>在 render 函数中混合你的状态数据加载逻辑会让组件变得更复杂。相反，写一个职责单一的状态容器组件去加载数据。然后用另一个职责单一的组件去显示数据。这叫做 <a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" target="_blank" rel="noopener">容器模式</a>。</p><p>下面这个例子，用户数据在同一个组件中加载和显示。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Dirty</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  state = &#123; <span class="attr">loading</span>: <span class="literal">true</span> &#125;;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">const</span> &#123; loading, user &#125; = <span class="keyword">this</span>.state;</div><div class="line">    <span class="keyword">return</span> loading</div><div class="line">      ? <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">      : <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">          <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">            First name: &#123;user.firstName&#125;</div><div class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">            First name: &#123;user.lastName&#125;</div><div class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">          ...</div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  componentDidMount() &#123;</div><div class="line">    fetchUser(<span class="keyword">this</span>.props.id)</div><div class="line">      .then(<span class="function">(<span class="params">user</span>) =&gt;</span> &#123; <span class="keyword">this</span>.setState(&#123; <span class="attr">loading</span>: <span class="literal">false</span>, user &#125;)&#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在简洁版本，关注点 —— 数据加载，显示加载动画，和显示数据被分离了。不仅让代码更容易理解。而且很容易独立地测试每个关注点。同时 <code>RenderUser</code> 是一个无状态组件。结果是可预测的。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Clean</span></div><div class="line"><span class="keyword">import</span> RenderUser <span class="keyword">from</span> <span class="string">'./RenderUser'</span>;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  state = &#123; <span class="attr">loading</span>: <span class="literal">true</span> &#125;;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">const</span> &#123; loading, user &#125; = <span class="keyword">this</span>.state;</div><div class="line">    <span class="keyword">return</span> loading ? &lt;Loading /&gt; : &lt;RenderUser user=&#123;user&#125; /&gt;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  componentDidMount() &#123;</div><div class="line">    fetchUser(this.props.id)</div><div class="line">      .then(user =&gt; &#123; this.setState(&#123; loading: false, user &#125;)&#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="使用无状态组件-SFC"><a href="#使用无状态组件-SFC" class="headerlink" title="使用无状态组件 SFC"></a>使用无状态组件 SFC</h2><p>无状态组件（SFC）在 React v0.14.0 的时候被推出。它们被用来大大简化一个仅用于渲染的组件。但很多开发者还没有放下过去。举个例子，下面这个组件具备转换成 SFC 的条件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Dirty</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableRowWrapper</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></div><div class="line">        &#123;this.props.children&#125;</div><div class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>简洁版清理了很多冗余版本的干扰的东西。通过 react 的核心优化，有可能使用更少的内存，没有实例被创建。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Clean</span></div><div class="line"><span class="keyword">const</span> TableRowWrapper = <span class="function">(<span class="params">&#123; children &#125;</span>) =&gt;</span> (</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></div><div class="line">    &#123;children&#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line">);</div></pre></td></tr></table></figure><h2 id="Rest-spread-…操作符"><a href="#Rest-spread-…操作符" class="headerlink" title="Rest/spread (…操作符)"></a>Rest/spread (…操作符)</h2><p>大约一年前，在我心中 <code>Object.assign</code> 将会变成每个人最好的新朋友。但是，时代变了，ES2016/ES7 的 <a href="https://github.com/tc39/proposal-object-rest-spread" target="_blank" rel="noopener">rest/spread spec</a> 来了。</p><p>看一个给组件传递 props 的案例。你想在组件内使用 <code>className</code>，但把剩余的 props 传递给子组件。你可能会这样做。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Dirty</span></div><div class="line"><span class="keyword">const</span> MyComponent = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> others = <span class="built_in">Object</span>.assign(&#123;&#125;, props);</div><div class="line">  <span class="keyword">delete</span> others.className;</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;props.className&#125;</span>&gt;</span></span></div><div class="line">      &#123;React.createElement(MyOtherComponent, others)&#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  );</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>不够优雅，不是么？但使用 rest/spread, 就像看到一块蛋糕一样。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Clean</span></div><div class="line"><span class="keyword">const</span> MyComponent = <span class="function">(<span class="params">&#123; className, ...others &#125;</span>) =&gt;</span> (</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;<span class="name">MyOtherComponent</span> &#123;<span class="attr">...others</span>&#125; /&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">);</div></pre></td></tr></table></figure><h2 id="适时使用解构"><a href="#适时使用解构" class="headerlink" title="适时使用解构"></a>适时使用解构</h2><p>ES6 有一个概念叫 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="noopener">destructure</a>解构赋值。它允许你取出 object 或 array 里的某个值。</p><h3 id="object-destructuring-对象解构"><a href="#object-destructuring-对象解构" class="headerlink" title="object destructuring 对象解构"></a>object destructuring 对象解构</h3><p>比如，给 <code>componentWillReceiveProps</code> 传递了 <code>newProps</code>，我们给 <code>state.active</code> 设置一个新的 <code>active</code> 值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Dirty</span></div><div class="line">componentWillReceiveProps(newProps) &#123;</div><div class="line">  <span class="keyword">this</span>.setState(&#123;</div><div class="line">    <span class="attr">active</span>: newProps.active</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在简洁版本中，我们将解构 <code>newProps</code> 里的 <code>active</code>， 不仅不再需要引用 <code>newProps.active</code>, 而且可以只使用对象中的属性名 <code>setState</code>:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Clean</span></div><div class="line">componentWillReceiveProps(&#123; active &#125;) &#123;</div><div class="line">  <span class="keyword">this</span>.setState(&#123; active &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="array-destructuring-数组解构"><a href="#array-destructuring-数组解构" class="headerlink" title="array destructuring 数组解构"></a>array destructuring 数组解构</h3><p>经常忽视 ES6 的数组解构特性。下面这个例子，它从 <code>local</code> 取出一个值,比如 “es-US”, 拆分并赋值给 <code>language</code>(en) 和 <code>country</code>(US)</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Dirty</span></div><div class="line"><span class="keyword">const</span> splitLocale = locale.split(<span class="string">'-'</span>);</div><div class="line"><span class="keyword">const</span> language = splitLocale[<span class="number">0</span>];</div><div class="line"><span class="keyword">const</span> country = splitLocale[<span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="comment">// Clean</span></div><div class="line"><span class="keyword">const</span> [language, country] = locale.split(<span class="string">'-'</span>);</div></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我希望我让你看到编写简洁代码的好处，并可以应用这里呈现的实际例子。一旦你拥抱简洁代码，它将成为你的第二天性。你和未来的你将会感激“写下它，忘了它”的生活方式。</p><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简洁代码与冗余代码&quot;&gt;&lt;a href=&quot;#简洁代码与冗余代码&quot; class=&quot;headerlink&quot; title=&quot;简洁代码与冗余代码&quot;&gt;&lt;/a&gt;简洁代码与冗余代码&lt;/h1&gt;&lt;p&gt;这篇文章将重点介绍适用于现代 react 软件开发的简洁代码之道。我还会谈谈 ES6/ES2015 带来的一些“语法糖”。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="react" scheme="http://robin-front.github.io/tags/react/"/>
    
      <category term="best practices" scheme="http://robin-front.github.io/tags/best-practices/"/>
    
  </entry>
  
  <entry>
    <title>Dynamic import() 与 静态 import 相比较，有哪些不同</title>
    <link href="http://robin-front.github.io/2017/11/27/dynamic-import/"/>
    <id>http://robin-front.github.io/2017/11/27/dynamic-import/</id>
    <published>2017-11-27T02:56:29.000Z</published>
    <updated>2017-11-27T02:56:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dynamic-import-有哪些特点"><a href="#Dynamic-import-有哪些特点" class="headerlink" title="Dynamic import() 有哪些特点"></a>Dynamic import() 有哪些特点</h1><blockquote><p>Dynamic <strong>import()</strong> 已被 Chrome 63 和 Safari Technology Preview 24 支持。</p></blockquote><p><a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener">Dynamic <strong><code>import()</code></strong></a> 采用 类函数 的方法来塑造 <code>import</code>，相比 static <code>import</code> 解锁了新功能。这篇文章对比了两者并概览新功能。<a id="more"></a></p><h2 id="Static-import（概括）"><a href="#Static-import（概括）" class="headerlink" title="Static import（概括）"></a>Static import（概括）</h2><p>九月份，Chrome 61 发布并支持在 <a href="https://jakearchibald.com/2017/es-modules-in-browsers/" target="_blank" rel="noopener">modules</a> 中使用 ES2015 <code>import</code> 声明。</p><p>仔细看下面这个模块，位于 <code>./utils.mjs</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Default export</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Hi from the default export!'</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// Named export `doStuff`</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> doStuff = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Doing stuff…'</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>下面是使用 静态 <code>import</code> 引入 <code>./utils.mjs</code> 模块：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span><span class="javascript"></span></div><div class="line">  <span class="keyword">import</span> * <span class="keyword">as</span> <span class="built_in">module</span> <span class="keyword">from</span> <span class="string">'./utils.mjs'</span>;</div><div class="line">  <span class="built_in">module</span>.default();</div><div class="line">  <span class="comment">// → logs 'Hi from the default export!'</span></div><div class="line">  <span class="built_in">module</span>.doStuff();</div><div class="line">  <span class="comment">// → logs 'Doing stuff…'</span></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> 上面这个例子使用 <strong>.mjs</strong> 来标识这是一个模块文件而不是普通脚本。在网页端，文件扩展名并不是问题，只要服务端设置了正确的 MIME 类型（比如给 javascript 文件设置 Content-Type:text/javascript）在 HTTP header。<strong>.mjs</strong> 在其他一些平台上特别有用，如 Node.js 这类没有 MIME 类型或其他 Hooks 如 <strong>type=”module”</strong> 来确定模块或普通脚本。我们在这里使用相同的扩展名来保持跨平台的一致性，并清楚地区分模块和普通脚本。</p></blockquote><p>这个导入模块的语法形式是 <strong>静态</strong> 声明：它只接受字符串作为模块标识符，并通过运行前的 “linking” 过程将模块绑定到本地作用域。静态 <code>import</code> 语法只能用于文件顶部。静态<code>import</code> 支持一些重要的用例，如：<code>static analysis</code>, <code>bundling tools</code>, 和 <code>tree-shaking</code>。</p><p>在一些案例中，下面这些特性会非常有用：</p><ul><li>请求时导入模块（或有条件地）</li><li>运行时计算模块标识符</li><li>在普通脚本中导入模块（而不是在模块中导入）</li></ul><p>但是这些用 静态 <code>import</code> 都无法做到。</p><h2 id="Dynamic-import-🔥"><a href="#Dynamic-import-🔥" class="headerlink" title="Dynamic import() 🔥"></a>Dynamic import() 🔥</h2><p><a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener">Dynamic <strong><code>import()</code></strong></a> 采用 类函数 的方法来塑造满足这些用例的 <code>import</code>。<code>import(moduleSpecifier)</code> 为请求模块的模块名称空间返回一个 promise。它是在获取，实例化和评估模块的所有依赖关系之后创建的，模块本身也是。</p><p>下面是如何使用 动态 import，并使用 <code>./utils.mjs</code> 模块：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span><span class="javascript"></span></div><div class="line">  <span class="keyword">const</span> moduleSpecifier = <span class="string">'./utils.mjs'</span>;</div><div class="line">  <span class="keyword">import</span>(moduleSpecifier)</div><div class="line">    .then(<span class="function">(<span class="params"><span class="built_in">module</span></span>) =&gt;</span> &#123;</div><div class="line">      <span class="built_in">module</span>.default();</div><div class="line">      <span class="comment">// → logs 'Hi from the default export!'</span></div><div class="line">      <span class="built_in">module</span>.doStuff();</div><div class="line">      <span class="comment">// → logs 'Doing stuff…'</span></div><div class="line">    &#125;);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> 尽管 <strong>import()</strong> 看起来像一个函数调用，但它只是恰好被规定为使用括号的一种 <em>语法</em> （类似于 <strong>super()</strong>）。这意味着 <strong>import</strong> 不会继承 <strong>Function.prototype</strong> ，所以不能使用 <strong>call</strong> 和 <strong>apply</strong>。像 <strong>const importAlias = import</strong> 这样的代码也不能运行 —— <strong>import</strong> 甚至不是一个 object 对象！但是这在实践中并不重要。</p></blockquote><p>下面是一个例子，展示了如何在一个小型单页应用的导航上使用 动态 <code>import()</code> 启用懒加载模块：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>My library<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"books.html"</span> <span class="attr">data-entry-module</span>=<span class="string">"books"</span>&gt;</span>Books<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"movies.html"</span> <span class="attr">data-entry-module</span>=<span class="string">"movies"</span>&gt;</span>Movies<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"video-games.html"</span> <span class="attr">data-entry-module</span>=<span class="string">"video-games"</span>&gt;</span>Video Games<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span>This is a placeholder for the content that will be loaded on-demand.<span class="tag">&lt;/<span class="name">main</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">  <span class="keyword">const</span> main = <span class="built_in">document</span>.querySelector(<span class="string">'main'</span>);</div><div class="line">  <span class="keyword">const</span> links = <span class="built_in">document</span>.querySelectorAll(<span class="string">'nav &gt; a'</span>);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> link <span class="keyword">of</span> links) &#123;</div><div class="line">    link.addEventListener(<span class="string">'click'</span>, <span class="keyword">async</span> (event) =&gt; &#123;</div><div class="line">      event.preventDefault();</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">const</span> <span class="built_in">module</span> = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">`/<span class="subst">$&#123;link.dataset.entryModule&#125;</span>.mjs`</span>);</div><div class="line">        <span class="comment">// The module exports a function named `loadPageInto`.</span></div><div class="line">        <span class="built_in">module</span>.loadPageInto(main);</div><div class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</div><div class="line">        main.textContent = error.message;</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure><p>当正确使用 动态 <code>import()</code> 开启懒加载功能时将会非常强大。为了演示目的，<a href="https://twitter.com/addyosmani" target="_blank" rel="noopener">Addy</a> 修改了一个 <a href="https://hnpwa-vanilla.firebaseapp.com/" target="_blank" rel="noopener">Hacker News PWA</a> 示例，在首次加载时静态地导入所有依赖，包括评论。<a href="https://dynamic-import.firebaseapp.com/" target="_blank" rel="noopener">升级版</a> 使用 动态 <code>import()</code>延迟加载评论，避免加载，解析和编译成本，直到用户确实需要它们。</p><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>静态 <code>import</code> 和动态 <code>import()</code> 都很有用。它们都有各自的特点和使用场景。使用静态 <code>import</code> 来初始绘制依赖关系，尤其是首屏内容。另一种情况，考虑到按需加载则使用动态 <code>import()</code>。</p><blockquote><p>译者注： static import 是没有括号的，dynamic import() 是带括号的。不注意的可能会混淆。用法的区别：</p><ul><li>static import: <code>import $ from &#39;jquery&#39;</code> 有声明提升，一般只放在头部位置</li><li>dynamic import(): <code>const $ = import(&#39;jquery&#39;)</code> 可以放在任何位置</li></ul></blockquote><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Dynamic-import-有哪些特点&quot;&gt;&lt;a href=&quot;#Dynamic-import-有哪些特点&quot; class=&quot;headerlink&quot; title=&quot;Dynamic import() 有哪些特点&quot;&gt;&lt;/a&gt;Dynamic import() 有哪些特点&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;Dynamic &lt;strong&gt;import()&lt;/strong&gt; 已被 Chrome 63 和 Safari Technology Preview 24 支持。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/tc39/proposal-dynamic-import&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dynamic &lt;strong&gt;&lt;code&gt;import()&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt; 采用 类函数 的方法来塑造 &lt;code&gt;import&lt;/code&gt;，相比 static &lt;code&gt;import&lt;/code&gt; 解锁了新功能。这篇文章对比了两者并概览新功能。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="dynamic import" scheme="http://robin-front.github.io/tags/dynamic-import/"/>
    
      <category term="es6" scheme="http://robin-front.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>使用 react 16 portal 做一些很酷的事情</title>
    <link href="http://robin-front.github.io/2017/11/16/using-a-react-16-portal-to-do-something-cool/"/>
    <id>http://robin-front.github.io/2017/11/16/using-a-react-16-portal-to-do-something-cool/</id>
    <published>2017-11-15T23:31:59.000Z</published>
    <updated>2017-11-15T23:31:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>React 16 已经发布了，其中一个很有趣的是添加了 “Portals”。</p><p>Portals 可以让你在父组件外渲染 react 受控 DOM 节点。<a href="https://reactjs.org/docs/portals.html" target="_blank" rel="noopener">react doc</a> 也使用了一个模态框的例子很好地解释了它。用也做 tooltips 也很合适（这是我<a href="https://codepen.io/davidgilbertson/pen/ooXVyw" target="_blank" rel="noopener">早前做的一个例子</a>）。</p><p>但这些都并不是很有趣，让我们做一些更不可思议的事情…<a id="more"></a></p><p>因为所有 portal 做的，都是将一个元素放到其他元素上，你并没有被限制放在 <em>当前</em> document 的任何地方。你可以添加到另一个 document 的 body 中，可能是完全不同浏览器窗口的一个 document。</p><p>下面我有一个基本的页面（左边），包含一个计数器及深红色按钮。另一个窗口（右边）同样是 react app 的一部分。</p><p>右边的窗口是属于 <em>同一个 React app</em> 这个事实应该让你感到惊讶。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/2000/1*ogsV-9IGNtaVjne2fb_oEA.png" data-original="https://cdn-images-1.medium.com/max/2000/1*ogsV-9IGNtaVjne2fb_oEA.png"></p><p>上面图片中能看到的所有东西（除了树）都是在下面代码展示的同一个组件中：</p><script src="https://gist.github.com/davidgilbertson/69a8c158ca9b5e202d083408dbabdf49.js"></script><p>你已经成功了，<code>&lt;MyWindowPortal&gt;</code> 有一点特殊，里面的所有东西都会被渲染到另一个 window 下。</p><p>尤其是，<code>&lt;MyWindowPortal&gt;</code> 做了两件事。</p><ul><li>1、 当组件渲染时打开一个浏览器窗口。</li><li>2、 创建一个 <code>portal</code> 并将 <code>props.children</code> 添加到新窗口的 body。</li></ul><p>这不是最酷的事情吗？</p><p>我是多么兴奋，必须得冷静一下。</p><p>…</p><p>I saw a duck!</p><p>…</p><p>上面提到的 body中的组件就是下面这样。 React 16 新增的部分 <code>ReactDOM.createPortal</code> 在 11 行 —— 那就是黑魔法。</p><script src="https://gist.github.com/davidgilbertson/de5e5b84373ee60d91525ab37278913e.js"></script><p>那有意义吗？组件并没有返回什么，只是做了一些其他事情。</p><p>换一个角度来想可能是这样的：按理来说，一个父组件对子组件说：“嘿，渲染 DOM， 然后把结果添加到我这里。”，然后子组件照做了。但是这次，任性的子组件说，“不！我要将东东渲染到另一个窗口，然后写一篇关于它的博客。”</p><p>现在，我知道你在想什么。</p><p>你有点渴，并且想知道你是否该喝点水了。是的，去吧。</p><p>另一件你可能在想的事情是：将一些 DOM 注入到无样式的空白窗口有什么好处？可能 Craigslist 或 Wikipedia 也不知道。但你的网站很美，任何时候都不能弹出小窗口。</p><p>好吧，好消息来了，大家注意了！</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/1000/1*eU-7ArIucnG5OreaPIJlEg.png" data-original="https://cdn-images-1.medium.com/max/1000/1*eU-7ArIucnG5OreaPIJlEg.png"></p><p>起初，我还在想是否有一个简单的方式将样式复制到新窗口。然后我想起我的生活只是被一些毫无意义的事件填充，它们唯一的目的只是让我分心，阻止我内心的空虚寂寞冷。</p><p>所以亲自写这个函数就是乐趣！</p><p>看下面：</p><script src="https://gist.github.com/davidgilbertson/ed3c8bb8569bc64b094b87aa88bed5fa.js"></script><p>事实上，我并不是很了解 <code>styleSheet</code>。我期待从评论中得知有什么奇技淫巧。</p><p>现在我可以在打开新窗口的时候很简单地复制样式，像这样：</p><script src="https://gist.github.com/davidgilbertson/4937ac726094735ab44e295f3113df53.js"></script><iframe height="265" scrolling="no" title="React Portal Chat Window" src="//codepen.io/davidgilbertson/embed/xPVMqp/?height=265&theme-id=0&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/davidgilbertson/pen/xPVMqp/" target="_blank" rel="noopener">React Portal Chat Window</a> by David Gilbertson (<a href="https://codepen.io/davidgilbertson" target="_blank" rel="noopener">@davidgilbertson</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</iframe><p>我不认为这能在 Medium app 的 iOS/Android 平台上运行，所以请在浏览器打开。</p><p>好了，我认为这篇文章该结束了。</p><p>Bye!</p><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React 16 已经发布了，其中一个很有趣的是添加了 “Portals”。&lt;/p&gt;&lt;p&gt;Portals 可以让你在父组件外渲染 react 受控 DOM 节点。&lt;a href=&quot;https://reactjs.org/docs/portals.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;react doc&lt;/a&gt; 也使用了一个模态框的例子很好地解释了它。用也做 tooltips 也很合适（这是我&lt;a href=&quot;https://codepen.io/davidgilbertson/pen/ooXVyw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;早前做的一个例子&lt;/a&gt;）。&lt;/p&gt;&lt;p&gt;但这些都并不是很有趣，让我们做一些更不可思议的事情…
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="react" scheme="http://robin-front.github.io/tags/react/"/>
    
      <category term="portal" scheme="http://robin-front.github.io/tags/portal/"/>
    
  </entry>
  
  <entry>
    <title>react 组件设计模式</title>
    <link href="http://robin-front.github.io/2017/11/09/react-component-patterns/"/>
    <id>http://robin-front.github.io/2017/11/09/react-component-patterns/</id>
    <published>2017-11-09T15:10:26.000Z</published>
    <updated>2017-11-09T15:10:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="react-component-模式"><a href="#react-component-模式" class="headerlink" title="react component 模式"></a>react component 模式</h1><blockquote><p>有状态组件（Stateful）和无状态组件（Stateless）、容器组件（Container）与展示组件（Presentational）、高阶组件（HOC）、渲染回调（Render Callbacks）等</p></blockquote><p>我在工作中使用 React 有一段时间了——一个 facebook 使用 js 渲染用户界面的框架——刚开始的时候我想知道一些概念。这些文字是尝试总结我实践这么久以来学到的一些模式——可能对于刚开始进入组件世界的开发者有用。<a id="more"></a></p><h2 id="有状态-Stateful-与-无状态-Stateless-组件"><a href="#有状态-Stateful-与-无状态-Stateless-组件" class="headerlink" title="有状态(Stateful) 与 无状态(Stateless) 组件"></a>有状态(Stateful) 与 无状态(Stateless) 组件</h2><p>就像有状态和无状态的 web 服务一样， React 组件也能在用户使用时保存和操作状态（有状态）。或只是一个简单的组件，按受 props 并返回需要显示的内容（无状态）。</p><p>一个简单的 <em>无状态</em> 按钮组件只接受 props:</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/1600/1*fgZOSwpdU7MMNxltRcXAcQ.png" data-original="https://cdn-images-1.medium.com/max/1600/1*fgZOSwpdU7MMNxltRcXAcQ.png"></p><p>而下面是一个 <strong>有状态</strong> 的计数组件（使用了 <code>Button</code> 组件）：</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/1600/1*TYPgsZUZMoo7lW7xv4gxYw.png" data-original="https://cdn-images-1.medium.com/max/1600/1*TYPgsZUZMoo7lW7xv4gxYw.png"></p><p>就像你所看到的，最后一个组件的 constructor 保持了一个组件的 state, 而第一个组件则是一个简单组件，只通过 props 渲染了文字。这个关注分离可能非常简单，但是让 <code>Button</code> 组件高度复用。</p><h2 id="容器-Container-与-展示-Presentational-组件"><a href="#容器-Container-与-展示-Presentational-组件" class="headerlink" title="容器(Container) 与 展示(Presentational) 组件"></a>容器(Container) 与 展示(Presentational) 组件</h2><p>当使用外部数据运行时，我们可以把这个组件分成这两个新类别。<strong>容器组件</strong> 负责获取数据，存在在 react 作用域外部，就像连接 <em>Redux</em> 或 <em>Relay</em> ———— 而 <strong>展示组件</strong> 则不依赖 react 应用的其他部分，仅仅取决于它自身的 state 和接收的 props。让我们拿用户列表作为展示组件的例子：</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/1600/1*wbih6jbxJiIgNOXgRpcROA.png" data-original="https://cdn-images-1.medium.com/max/1600/1*wbih6jbxJiIgNOXgRpcROA.png"></p><p>这个列表可以使用我们的 <strong>容器组件</strong> 更新：</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/1600/1*TJxCVhawM2e99dZsxu11oA.png" data-original="https://cdn-images-1.medium.com/max/1600/1*TJxCVhawM2e99dZsxu11oA.png"></p><p>这种方法将数据获取与渲染分离，同时让 <code>UserList</code> 高度复用。如果你想进一步学习这种模式，这里有<a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" target="_blank" rel="noopener">一篇文章</a>解释地很好。</p><h2 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h2><p>高阶组件————或叫 HOC。当你想要重用逻辑的时候非常感兴趣。他们是 javascript 函数，将一个组件作为参数，并返回新组件。</p><p>假设你需要做一个可伸缩的的菜单组件，当用户点的时候，展示它里面的内容。所以，为了替代在父级组件上控制 state，你可以简单地创建一个通用的 <strong>高阶组件</strong> 来处理它：</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/1600/1*qchJXtrHlR46phKFDDJeeQ.png" data-original="https://cdn-images-1.medium.com/max/1600/1*qchJXtrHlR46phKFDDJeeQ.png"></p><p>这种方式允许我们将逻辑应用通过装饰模式（decorator）应用在 <code>ToggleableMenu</code> 组件上。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/1600/1*RQuGzKKbT7R9OIDBzhO8gg.png" data-original="https://cdn-images-1.medium.com/max/1600/1*RQuGzKKbT7R9OIDBzhO8gg.png"></p><p>现在我们可以任意传递子级到 <code>ToggleableMenu</code> 组件了：</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/1600/1*rWCZQqL0Rbizbrw_yjgxgA.png" data-original="https://cdn-images-1.medium.com/max/1600/1*rWCZQqL0Rbizbrw_yjgxgA.png"></p><p>如果你熟悉使用 <code>redux</code> 的 <code>connect</code> 或 react router 的 <code>withRouter</code> 函数，那你已经在用 <strong>HOCs</strong> 了。</p><h2 id="渲染回调（Render-Callbacks）"><a href="#渲染回调（Render-Callbacks）" class="headerlink" title="渲染回调（Render Callbacks）"></a>渲染回调（Render Callbacks）</h2><p>另一种让组件逻辑复用的很棒的方法是 将组件子级转换成函数。这也是为什么 <strong>渲染回调（Render Callbacks）</strong> 也叫作 <strong>Function as Child Components</strong>。我们可以拿可伸展的菜单高阶组件作为例子，并使用 <strong>渲染回调</strong> 重写它。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/1600/1*Ul-ubPnaOFtY4mTeM5PW3A.png" data-original="https://cdn-images-1.medium.com/max/1600/1*Ul-ubPnaOFtY4mTeM5PW3A.png"></p><p>现在我们可以传递一个函数作为 <code>Toggleable</code> 的子组件：</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/1600/1*cwoZiIT3Gcau5lDwyCQzQw.png" data-original="https://cdn-images-1.medium.com/max/1600/1*cwoZiIT3Gcau5lDwyCQzQw.png"></p><p>上面的代码已经使用函数作为子级，但，如果我们想要像高阶组件的例子那样复用它（多个菜单），我们可以简单地使用 <code>Toggleable</code> 逻辑创建一个新组件：</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/1600/1*DVfPDwHw_eH9dUeX9w5GEg.png" data-original="https://cdn-images-1.medium.com/max/1600/1*DVfPDwHw_eH9dUeX9w5GEg.png"></p><p>我们的新产品 <code>ToggleableMenu</code> 组件已经准备好了：</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/1600/1*hzpuJMAMTRQZK_vKCK_jhQ.png" data-original="https://cdn-images-1.medium.com/max/1600/1*hzpuJMAMTRQZK_vKCK_jhQ.png"></p><p>这种方式真的非常有用，当我们需要更改渲染内容而不用管 state 操作时：就像你所看到的，我们可以将渲染逻辑移动到 <code>ToggleableMenu</code> 的子级函数中，但却保持我们 <code>Toggleable</code> 组件的 state 逻辑！</p><h2 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h2><p>上面的例子只是一些可以用在 react 编程中的基础模式，如果你真的想深入这个主题，我建议你看看这些了不起的文章：</p><ul><li><a href="https://www.youtube.com/watch?v=YaZg8wg39QQ" target="_blank" rel="noopener">React Component Patterns by Michael Chan</a></li><li><a href="https://github.com/chantastic/reactpatterns.com" target="_blank" rel="noopener">React Patterns</a></li><li><a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" target="_blank" rel="noopener">Presentational and Container Components</a></li><li><a href="https://medium.com/@franleplant/react-higher-order-components-in-depth-cf9032ee6c3e" target="_blank" rel="noopener">React Higher Order Components in depth</a></li><li><a href="https://medium.com/merrickchristensen/function-as-child-components-5f3920a9ace9" target="_blank" rel="noopener">Function as Child Components</a></li><li><a href="https://github.com/acdlite/recompose" target="_blank" rel="noopener">Recompose</a></li><li><a href="https://github.com/paypal/downshift" target="_blank" rel="noopener">Downshift</a></li></ul><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;react-component-模式&quot;&gt;&lt;a href=&quot;#react-component-模式&quot; class=&quot;headerlink&quot; title=&quot;react component 模式&quot;&gt;&lt;/a&gt;react component 模式&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;有状态组件（Stateful）和无状态组件（Stateless）、容器组件（Container）与展示组件（Presentational）、高阶组件（HOC）、渲染回调（Render Callbacks）等&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;我在工作中使用 React 有一段时间了——一个 facebook 使用 js 渲染用户界面的框架——刚开始的时候我想知道一些概念。这些文字是尝试总结我实践这么久以来学到的一些模式——可能对于刚开始进入组件世界的开发者有用。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="React" scheme="http://robin-front.github.io/tags/React/"/>
    
      <category term="Components" scheme="http://robin-front.github.io/tags/Components/"/>
    
      <category term="Higher Order ComponentsRender" scheme="http://robin-front.github.io/tags/Higher-Order-ComponentsRender/"/>
    
      <category term="Callback" scheme="http://robin-front.github.io/tags/Callback/"/>
    
      <category term="patterns" scheme="http://robin-front.github.io/tags/patterns/"/>
    
      <category term="设计模式" scheme="http://robin-front.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>javascript 事件循环是如何工作的以及使用async／await提升异步编程的5种方式</title>
    <link href="http://robin-front.github.io/2017/11/06/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-async-and-await/"/>
    <id>http://robin-front.github.io/2017/11/06/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-async-and-await/</id>
    <published>2017-11-06T02:40:21.000Z</published>
    <updated>2017-11-06T02:40:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="javascript-事件循环是如何工作的以及使用async／await提升异步编程的5种方式"><a href="#javascript-事件循环是如何工作的以及使用async／await提升异步编程的5种方式" class="headerlink" title="javascript 事件循环是如何工作的以及使用async／await提升异步编程的5种方式"></a>javascript 事件循环是如何工作的以及使用async／await提升异步编程的5种方式</h1><p>这次我们将通过回顾在单线程环境中编程的缺点来扩展先前的第一篇文章，以及如何克服它来建立一个令人惊叹的 javascript UIs。像以往一样，在文章的最后，我会分享使用 async/await 写简洁代码的 5 个小贴士。<a id="more"></a></p><h2 id="为什么单线程是一个限制？"><a href="#为什么单线程是一个限制？" class="headerlink" title="为什么单线程是一个限制？"></a>为什么单线程是一个限制？</h2><p>在我们推出的<a href="https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf" target="_blank" rel="noopener">第一篇文章</a>, 我们仔细思考了这个问题，<em>当我们调用了一个非常耗时的函数时发生了什么</em>。</p><p>想象一下，例如浏览器中运行着一个复杂的图像变换算法。</p><p>当调用栈执行函数时，浏览器不能做任何其他事——它被阻塞了。这意味着浏览器不能渲染，不能执行其他代码，暂时卡住了。那问题也来了————你的UI界面也不再顺畅和高效。</p><p>你的应用被卡住了。</p><p>它很丑陋，完全毁了你的用户体验：</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*MCt4ZC0dMVhJsgo1u6lpYw.jpeg" data-original="https://cdn-images-1.medium.com/max/800/1*MCt4ZC0dMVhJsgo1u6lpYw.jpeg"></p><h2 id="javascript-程序的组成部分"><a href="#javascript-程序的组成部分" class="headerlink" title="javascript 程序的组成部分"></a>javascript 程序的组成部分</h2><p>你可能会把你的 javascript 应用写在单个 <code>.js</code> 文件里，但你的程序肯定包含着好几块，只有其只一块正在执行，其他的会稍后执行。最常见的块就是函数。</p><p>问题是，大多数新开发者似乎都觉得，这个 <em>稍后执行</em> 并不是严格地在 <em>当前执行</em> 之后立即执行。换句话说，任务当前不能立即完成，通过定义，将会异步完成。意味着不会出现上面所说的阻塞行为，就像你所期望或希望发生的那样。</p><p>让我们看看下面的例子：</p><script src="https://gist.github.com/zlatkov/7a8b43e4fb8059bc810aa6aa4941148e.js"></script><p>你可能已经意识到，标准的 <code>Ajax</code> 事件不会同步完成。意味着当执行代码 <code>ajax(...)</code> 的时候，并不会立即返回值并赋值给变量 <code>response</code>。</p><p>一个简单的方法就是使用一个叫 回调函数（callback）的函数去等待异步函数返回的结果。</p><script src="https://gist.github.com/zlatkov/cbd87df9ff2922512609a36d4155274a.js"></script><p>提醒一下：你实际可以发起一个 <strong>同步</strong> 的 <code>Ajax</code> 请求。但永远不要这样做。如果你发送一个同步 Ajax 请求, 你 javascript 应用的 UI 就会被阻塞————用户将不能点击，输入数据，导航或滚动。这会阻碍用户交互，非常糟糕的体验。</p><p>就像下面这样，但请永远不要这样做，不要毁了网页：</p><script src="https://gist.github.com/zlatkov/1b834ae5eb037f46347d71d4c497d43c.js"></script><p>我们只是用 Ajax 请求做一个例子，你可以异步执行任意一段代码。</p><p>可以通过 <code>setTimeout(callback, milliseconds)</code> 函数来做到。<code>setTimeout</code> 函数建立一个延后发生的事件。就像这样：</p><script src="https://gist.github.com/zlatkov/688a0b41ae10e45bd202d02bb12df264.js"></script><p>将会输出</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">first</span></div><div class="line"><span class="keyword">third</span></div><div class="line"><span class="keyword">second</span></div></pre></td></tr></table></figure><h2 id="剖析事件循环"><a href="#剖析事件循环" class="headerlink" title="剖析事件循环"></a>剖析事件循环</h2><p>我们会从一个奇怪的要求开始————尽管允许异步编码（就像刚刚讨论的<code>setTimeout</code>），直到 ES6， javascript从未有过真正直接的异步的概念。javascript 引擎在执行单一代码块的时刻不会再做任何事情。</p><p>关于javascript 引擎（google专用的V8引擎）的更多细节，请查看我们<a href="https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e" target="_blank" rel="noopener">之前的文章</a>.</p><p>那么，谁让 javascript 引擎执行程序块呢？现实中，javascript 引擎并不是孤立运行的————它运行在一个 <em>宿主</em> 环境中，对于大多数开发者来说，典型的是网页浏览器或者 Node.js。事实上，javascript 被嵌入到各种设备中，从机器人到小灯泡。每个设备代表 javascript 引擎的不同的宿主环境类型。</p><p>在所有环境中，不变的是拥有共同的称为 <strong>事件循环</strong> 的内置机制，控制处理多个程序块的执行时机。</p><p>这意味着 JS 引擎只是在执行环境中按需调用任意代码。它（执行JS代码的）是一个事件调度的环境。</p><p>那，举个例子，当你的 JS 程序发起一个 Ajax 请求去从服务器中获取一些数据，你在一个函数里设置了“响应”的代码（称为“回调函数”），JS 引擎告诉宿主环境：“嘿，我现在会暂停执行，但当网络请求完成时，并返回一些数据，请回来调用这个函数。”</p><p>浏览器会监听网络响应，并在拿到数据时返回给你，它会通过插入到 <em>事件循环</em> 中来调度回调函数。</p><p>让我们看看下面的图表：</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*FA9NGxNB6-v1oI2qGEtlRQ.png" data-original="https://cdn-images-1.medium.com/max/800/1*FA9NGxNB6-v1oI2qGEtlRQ.png"></p><p>你可以在<a href="https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf" target="_blank" rel="noopener">以前的文章</a>阅读到更多关于堆内存和调用栈的讨论。</p><p>这些 web APIs 是什么？本质上来讲，它们是无法访问的线程，你只能利用它。它们只是浏览器的并发访问的一部分。如果你是 Node.js 开发者，它们是 C++ APIs。</p><p>那么，<em>事件循环</em> 到底是什么呢？</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*KGBiAxjeD9JT2j6KDo0zUg.png" data-original="https://cdn-images-1.medium.com/max/800/1*KGBiAxjeD9JT2j6KDo0zUg.png"></p><p>事件循环有一个简单的工作————监视调用栈和回调队列。如果调用栈清空了，它会获取队列里的第一个事件放入调用栈，高效地运行。</p><p>在事件循环中，像这样的一个迭代被称为 <strong>tick</strong>。每个事件都只是一个回调函数。</p><script src="https://gist.github.com/zlatkov/6d2e3006addd24cd73e5b576312a1c98.js"></script><p>让我们一起“执行”这段代码，然后看看发生了什么：</p><p>1、状态是清空的。浏览器控制台是清空的，调用栈也是空的。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*9fbOuFXJHwhqa6ToCc_v2A.png" data-original="https://cdn-images-1.medium.com/max/800/1*9fbOuFXJHwhqa6ToCc_v2A.png"></p><p>2、<code>console.log(&#39;Hi&#39;)</code>被添加进调用栈。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*dvrghQCVQIZOfNC27Jrtlw.png" data-original="https://cdn-images-1.medium.com/max/800/1*dvrghQCVQIZOfNC27Jrtlw.png"></p><p>3、<code>console.log(&#39;Hi&#39;)</code>被执行。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*yn9Y4PXNP8XTz6mtCAzDZQ.png" data-original="https://cdn-images-1.medium.com/max/800/1*yn9Y4PXNP8XTz6mtCAzDZQ.png"></p><p>4、 <code>console.log(&#39;Hi&#39;)</code> 被移出调用栈。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*iBedryNbqtixYTKviPC1tA.png" data-original="https://cdn-images-1.medium.com/max/800/1*iBedryNbqtixYTKviPC1tA.png"></p><p>5、<code>setTimeout(function cb1() { ... })</code>被添加进调用栈。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*HIn-BxIP38X6mF_65snMKg.png" data-original="https://cdn-images-1.medium.com/max/800/1*HIn-BxIP38X6mF_65snMKg.png"></p><p>6、 <code>setTimeout(function cb1() { ... })</code>被执行。浏览器通过 web api 创建了一个定时器。它将为你处理倒计时。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*vd3X2O_qRfqaEpW4AfZM4w.png" data-original="https://cdn-images-1.medium.com/max/800/1*vd3X2O_qRfqaEpW4AfZM4w.png"></p><p>7、<code>setTimeout(function cb1() { ... })</code>被执行完毕并移出调用栈。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*_nYLhoZPKD_HPhpJtQeErA.png" data-original="https://cdn-images-1.medium.com/max/800/1*_nYLhoZPKD_HPhpJtQeErA.png"></p><p>8、<code>console.log(&#39;Bye&#39;)</code>被添加进调用栈。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*1NAeDnEv6DWFewX_C-L8mg.png" data-original="https://cdn-images-1.medium.com/max/800/1*1NAeDnEv6DWFewX_C-L8mg.png"></p><p>9、<code>console.log(&#39;Bye&#39;)</code>被执行。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*UwtM7DmK1BmlBOUUYEopGQ.png" data-original="https://cdn-images-1.medium.com/max/800/1*UwtM7DmK1BmlBOUUYEopGQ.png"></p><p>10、<code>console.log(&#39;Bye&#39;)</code>被移出调用栈。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*-vHNuJsJVXvqq5dLHPt7cQ.png" data-original="https://cdn-images-1.medium.com/max/800/1*-vHNuJsJVXvqq5dLHPt7cQ.png"></p><p>11、在 <em>至少</em> 5000毫秒之后，定时器完成，并将 <code>cb1</code> 回调推入回调队列。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*eOj6NVwGI2N78onh6CuCbA.png" data-original="https://cdn-images-1.medium.com/max/800/1*eOj6NVwGI2N78onh6CuCbA.png"></p><p>12、事件循环从回调队列里取出 <code>cb1</code> 并推入调用栈。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*jQMQ9BEKPycs2wFC233aNg.png" data-original="https://cdn-images-1.medium.com/max/800/1*jQMQ9BEKPycs2wFC233aNg.png"></p><p>13、<code>cb1</code> 被执行，并添加 <code>console.log(&#39;cb1&#39;)</code> 到调用栈。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*hpyVeL1zsaeHaqS7mU4Qfw.png" data-original="https://cdn-images-1.medium.com/max/800/1*hpyVeL1zsaeHaqS7mU4Qfw.png"></p><p>14、<code>console.log(&#39;cb1&#39;)</code> 被执行。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*lvOtCg75ObmUTOxIS6anEQ.png" data-original="https://cdn-images-1.medium.com/max/800/1*lvOtCg75ObmUTOxIS6anEQ.png"></p><p>15、<code>console.log(&#39;cb1&#39;)</code> 被移出调用栈。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*Jyyot22aRkKMF3LN1bgE-w.png" data-original="https://cdn-images-1.medium.com/max/800/1*Jyyot22aRkKMF3LN1bgE-w.png"></p><p>16、<code>cb1</code> 被移出调用栈。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*t2Btfb_tBbBxTvyVgKX0Qg.png" data-original="https://cdn-images-1.medium.com/max/800/1*t2Btfb_tBbBxTvyVgKX0Qg.png"></p><p>快速回顾一下：</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*TozSrkk92l8ho6d8JxqF_w.gif" data-original="https://cdn-images-1.medium.com/max/800/1*TozSrkk92l8ho6d8JxqF_w.gif"></p><p>有趣的是 ES6 指定了 事件循环如何工作，意味着技术上来讲，事件循环是在 JS 引擎的职责范围内的，它将不再扮演宿主环境的角色。这一变化的一个主要原因是 ES6 Promise 的介绍说：因为后者需要直接访问和细粒度地控制事件队列循环的调度操作。（稍后我们会更详细地讨论它们）</p><h2 id="setTimeout-…-如何工作"><a href="#setTimeout-…-如何工作" class="headerlink" title="setTimeout(…) 如何工作"></a>setTimeout(…) 如何工作</h2><p>值得注意地的， <code>setTimeout(…)</code> 并不会自动将回调函数添加进事件循环队列。它只是设定一个定时器。当定时器到期时，运行环境将回调事件推入事件循环。所以未来 <code>tick</code> 会取出回调并执行它。看一眼这个代码：</p><script src="https://gist.github.com/zlatkov/9345a7c43b2407ddd1c52a6173a97dd9.js"></script><p>它并不意味着 <code>myCallback</code> 将会在1000毫秒的时候立即执行，而是在1000毫秒后，<code>myCallback</code> 被添加进事件循环队列。但是，队列里可能已经有其他事件被更早地添加进来————你的回调必须等待。</p><p>有相当多的文章和教程在开始使用异步js时建议使用 <code>setTimeout(callback, 0)</code>。现在你知道事件循环是怎么回事以及 setTimeout 如何工作：调用第二个参数为 0 的 setTimeout 只是推迟执行回调函数直至调用栈清空。</p><p>看一下下面的代码：</p><script src="https://gist.github.com/zlatkov/b12986d07676bc17fe51398847ebc917.js"></script><p>尽管定时器设置为 0ms, 但浏览器控制台的结果是：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">Hi</span></div><div class="line"><span class="keyword">Bye</span></div><div class="line"><span class="symbol">callback</span></div></pre></td></tr></table></figure><h2 id="ES6-里的-Jobs-是什么？"><a href="#ES6-里的-Jobs-是什么？" class="headerlink" title="ES6 里的 Jobs 是什么？"></a>ES6 里的 Jobs 是什么？</h2><p>在 ES6 介绍中，出现了一个新概念 “Jobs Queue”。它是事件循环之上的一层。当你处理 Promise 异步操作的时候，你几乎经常碰到它（我们也会谈谈它）。</p><p>我们先来谈谈这个概念，以便稍后讨论异步 Promise 表现的时候，你能理解那些行为是如何被调度和处理的。</p><p>想像一下，Job Queue 是一个附属于事件队列中每一个 tick 结尾的队列。某些异步行为可能会发生在事件循环的某一刻，却不会引起一个全新的事件添加到事件循环队列中。但会添加一个项目（也叫Job）到当前 tick 的 Job Queue。</p><p>这意味着你可以添加一个功能，让它稍后执行。并且你可以放心，它刚好会在其他事件之前，在那之后执行。</p><p>一个 Job 也能引起其他的 Job 添加到相同的队列后面。理论上，Job “循环”也是有可能产生的（一个不断添加其他 Jobs的Job之类）。这样需要资源的程序就必须移动到事件循环的下一个 tick。概念上看，这就类似于需要长时候运行或死循环（就像 <code>while (true) ..</code>）。</p><p>Job 就像 <code>setTimeout(callback, 0)</code> 的 <code>hack</code>，但通过引入一个更加明确的概念来实现：稍后执行，但尽可能快。</p><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>正如你所知道的，回调函数是迄今为止 javascript 程序中最常见的表达和管理异步的方式。的确，回调是 javascript 语言中最基本的异步模式。无数的JS程序，甚至是即使是非常复杂的一个，也不会少了最基础的回调异步模式。</p><p>除了回调，其他的不会没有缺点。许多开发者尝试寻找更好的异步模式。但是，如果不能很好地理解引擎下的工作原理，就不可能有效地使用任何抽象概念。</p><p>在接下来的章节，我们将探索这些抽象概念，深入地展示为什么更复杂的异步模式（这将在随后的帖子中讨论）是必须的，甚至是推荐的。</p><h2 id="嵌套回调"><a href="#嵌套回调" class="headerlink" title="嵌套回调"></a>嵌套回调</h2><p>看下面的代码：</p><script src="https://gist.github.com/zlatkov/cf5d201413729777fa6b8d5af1f8eaa4.js"></script><p>我们有三个函数嵌套在一起，每一个就代表异步系列的一步。</p><p>这种代码经常被称为“回调地狱（callback hell）”。但“回调地狱”实际上与嵌套、缩进没什么关系。这是一个更深入的问题。</p><p>首先，我们等待“点击”事件，然后等待定时器被触发，然后等待 Ajax 请求响应数据，在这一点，它可能会再次重复。</p><p>粗略地看，这段代码似乎自然而然地将异步映射为连续的步骤：</p><script src="https://gist.github.com/zlatkov/c279bb1865ad3a8ff8c890d842b105c1.js"></script><p>然后我们有：</p><script src="https://gist.github.com/zlatkov/8c9c5601ba6b35adf652b7a6797d1a14.js"></script><p>再然后有：</p><script src="https://gist.github.com/zlatkov/250ccf280b4f191f87bca3a0b8337a41.js"></script><p>最后我们有：</p><script src="https://gist.github.com/zlatkov/6dc48448f85e010542ac9ba86482f38d.js"></script><p>这样用连续的方式表达异步看起来更自然，不是吗？这种方式一定行得通，对吧？</p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>看一下这个代码：</p><script src="https://gist.github.com/zlatkov/bf8888880822b83e4a9c1bfc4b21c6a9.js"></script><p>这非常简单：将 <code>x</code> 和 <code>y</code> 的值相加然后输出在控制台。但是，如果 <code>x</code> 和 <code>y</code> 的值在用于表达式之前丢失了，或还不确定怎么办呢？让我们想象一下，我们有两个函数 <code>loadx</code> 和 <code>loady</code> 分别从服务端加载 <code>x</code> 和 <code>y</code> 的值。然后，有一个函数 <code>sum</code> 会在 <code>x</code> 和 <code>y</code> 都获取到值的时候相加。</p><p>代码看起来可能是这样的（非常丑陋，不是吗）：</p><script src="https://gist.github.com/zlatkov/1ffa6e00a2750217f1a168fe36deda08.js"></script><p>这里有一些非常值得注意的事情——在上面的代码段中，我们假设 <code>x</code> 和 <code>y</code> 都是未来值，并且我们表达了一个操作函数 <code>sum</code> 并不关心 <code>x</code>或<code>y</code>或两者是否都可用。</p><p>当然，这种基于回调的方式不尽人意。这只是首先的一小步，为了更好地理解为什么不需要关心 <em>未来值</em> 何时可用这方面。</p><h2 id="Promise-Value"><a href="#Promise-Value" class="headerlink" title="Promise Value"></a>Promise Value</h2><p>让我们粗略地看一下，如何使用 Promise 来表达 <code>x + y</code>:</p><script src="https://gist.github.com/zlatkov/e7098be769383bac5336c54d952beb53.js"></script><p>这个代码段中有两层 Promise.</p><p><code>fetchX()</code> 和 <code>fetchY()</code> 被直接调用，并且他们的返回值被传递到 <code>sum(...)</code> 。潜在的值可能在现在或稍后准备好，但每个 Promise 规定了它们的表现是相同的。我们以独立的方式分析 <code>x</code> 和 <code>y</code>的值。它们是未来的值，有一段期限。</p><p>第二层是<code>sum(...)</code> 创建的 Promise(来源于 <code>Promise.all([ ... ])</code>)。我们等待着调用 <code>then(...)</code> .当 <code>sum(...)</code> 操作符完成时，我们相加的未来的值已经准备好，并且可以输出。我们为了等待 <code>x</code> 和<code>y</code> 值，在 <code>sum(...)</code>中隐藏了逻辑。</p><p><strong>注意：</strong> 在<code>sum(…)</code>之中，调用 <code>Promise.all([ … ])</code> 创建一个 Promise （等待 <code>promiseX</code> 和 <code>promiseY</code> 完成）。调用链 <code>.then(...)</code> 创建另一个 Promise，立即返回 <code>values[0] + values[1]</code> （相加的结果）。<code>sum(...)</code> 后面调用的 <code>then(...)</code> 实际上是第二个Promise 返回的，而不是第一个 <code>Promise.all([ ... ])</code> 返回的。同样，我们没有链接第二个 <code>then(...)</code>, 它也同样已经创建了另一个 Promise。这一 Promise 链的内容将在本章结尾详细解释。</p><p>使用 Promise, <code>then(...)</code> 实际上可以传入两个函数，第一个对应完成状态，第二个是对应失败状态。</p><script src="https://gist.github.com/zlatkov/33582dc127209706688796092e268772.js"></script><p>如果在获取 <code>x</code> 或 <code>y</code> 的时候发生错误，或者在相加的时候出错，<code>sum(...)</code> 会返回失败，并且传入 <code>then(...)</code> 的第二个错误处理函数会收到 Promise 返回的值。</p><p>因为 Promise 封装了依赖时间的状态——等待底层值的完成或失败——从外部看，Promise 本身是依赖时间的，因此 Promise 可以以可预测的方式组合起来，而不用考虑时间和结果。</p><p>此外，一旦 Promise 解决了，它将永入停留在那个状态——它这时变成一个 <em>不可变的</em> 值——并且根据需要可以观察多次。</p><p>链式调用 Promise 真的非常有用：</p><script src="https://gist.github.com/zlatkov/f94c8e16cbbb8b8940744b348c70de14.js"></script><p>调用 <code>delay(2000)</code> 创建一个 Promise 将会在 2000ms 后达到条件，然后从第一个 <code>then(...)</code> 成功回调返回，这会造成第二个 <code>then(...)</code> 会等待 2000ms 的 Promise.</p><p><strong>注意：</strong> 因为 Promise 从外部看来如果被解决了是无法再改变的，现在把值传到任何一部分都是安全的，它不能被恶意或意外地修改。尤其是关系到多个 Promise 遵守协议。一方不可能影响另一方遵守协议的能力。不变性听起来关系到学术性的话题。但它实际上是 Promise 设计的最基本也是最重要的部分，不应该随便错过。</p><h2 id="用还是不用-Promise"><a href="#用还是不用-Promise" class="headerlink" title="用还是不用 Promise"></a>用还是不用 Promise</h2><p>关于 Promise 有一个很重要的细节就是要知道某个值是否是 Promise。换句话说，某个值表现得像 Promise 吗？</p><p>我们知道，Promise 通过 <code>new Promise(…)</code> 语法构造，然后你认为 <code>p instanceof Promise</code> 足以检查它是否是一个 Promise。但，并不完全是。</p><p>主要是因为你可以有通过其他的浏览窗口接收一个 Promise 值（比如：iframe），它有它所属的 Promise， 不同于当前窗口的，并且检测是否是 Promise 实例会返回失败。</p><p>此外，一个类库或框架可能会选择自己使用的 Promise 实现版本，而不是使用 ES6 原生实现的 Promise。通过类库使用 Promise 可能在不支持 Promise 的浏览器上工作得很好。</p><h2 id="被吞掉的异常"><a href="#被吞掉的异常" class="headerlink" title="被吞掉的异常"></a>被吞掉的异常</h2><p>如果任何时候创建一个 Promise ，或正在监听它决策的时候，发生了意外错误，比如 <code>TypeError</code> 或者 <code>ReferenceError</code>, 异常将会被捕获，并且这个 Promise 将会被强制变成失败状态。</p><p>举个例子：</p><script src="https://gist.github.com/zlatkov/ba13f1f0a37b0156417bc389785d37ea.js"></script><p>但如果一个 Promise 还没有变成成功状态，却在观察期间发生了异常会怎样呢（在 <code>then(...)</code> 注册了回调）？尽管这个异常可以捕获，但它的处理方式可能让你有点吃惊。让我们挖得更深一点。</p><script src="https://gist.github.com/zlatkov/2ab398f4d3eeccb80556de844de2cd92.js"></script><p>这看起来发生在 <code>foo.bar()</code> 的异常确实被吞掉了。虽然事实并没有。有一些更深的东西发生了错误，但是，我们并没有监听到。<code>p.then(…)</code> 返回另一个 Promise，而且这个 Promise 会因为 <code>TypeError</code> 变成失败状态。</p><h2 id="处理未捕获的异常"><a href="#处理未捕获的异常" class="headerlink" title="处理未捕获的异常"></a>处理未捕获的异常</h2><p>还有其他一些许多人认为 <em>更好</em> 的解决办法。</p><p>一个普遍的建议就是 Promise 应该添加一个 <code>done(…)</code>，意味着 Promise 链式调用已“完成”。<code>done(…)</code> 不会再创建并返回一个 Promise，所以传递回调函数到 <code>done(..)</code> 显然不能与不存在的 Promise 连接上报异常。</p><p>你可能期望发现任何未捕获的错误的情况：任何 <code>done(..)</code> 中的异常都会抛出全局的未捕获的错误（基本都会出现在控制台）：</p><script src="https://gist.github.com/zlatkov/ae156463adf288ca0ac9da9e8964fa18.js"></script><h2 id="ES8-有什么变化？Async-await"><a href="#ES8-有什么变化？Async-await" class="headerlink" title="ES8 有什么变化？Async/await"></a>ES8 有什么变化？Async/await</h2><p>javascript ES8 推出了 <code>async/await</code> 让 Promise 的工作更容易更简单。我们简要地看看 <code>async/await</code> 提供了什么并利用它们写一些异步代码。</p><p>那么，让我们来看看 <code>async/await</code> 是如何工作的。</p><p>你可以使用 <code>async</code> 声明定义一个异步函数。这样的函数返回一个<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction" target="_blank" rel="noopener">异步函数对象</a>。<code>AsyncFunction</code> 对象代表异步函数执行代码，并包含在那个宿主函数中。</p><p>当异步函数被调用时，它返回一个 <code>Promise</code>。当异步函数返回一个值时，那就不是一个 <code>Promise</code>。<code>Promise</code> 会被自动创建，并且会通过返回值来完成状态。当 <code>async</code> 抛出异常，<code>Promise</code> 将抛出值并变成失败状态。</p><p>一个 <code>async</code> 函数可以包含一个 <code>await</code> 表达式，它会暂停执行函数内的代码并等待 Promise 返回结果，然后继续执行异步函数并返回结果。</p><p>你可以认为 <code>Promise</code> 与 Java中的<code>Future</code>或者 <code>C#</code> 的任务。</p><blockquote><p>使用 <code>async/await</code> 的目的是为了简化使用 Promise 的行为。</p></blockquote><p>看下面的代码：</p><script src="https://gist.github.com/zlatkov/8f74044b900d1ea4d365ca3992b50ea3.js"></script><p>同样的，异步函数内抛出异常相当于普通函数抛出一个被拒绝的 Promise：</p><script src="https://gist.github.com/zlatkov/159929de0c27b2ddfc9c8e100ce51b43.js"></script><p><code>await</code> 语句只有用在 <code>async</code> 函数内，并允许你在 Promise 进行同步等待。如果我们要在 <code>async</code> 函数外使用 Promise, 我们仍要使用 <code>then</code> 来执行回调：</p><script src="https://gist.github.com/zlatkov/448a79cab54330c062a13a84ebb06cf7.js"></script><p>你也可以使用“异步函数表达式”来定义异步函数。一个异步函数表达式和一个异步函数声明很类似，几乎有相同的语法。他们之前主要的不同就是函数名。异步函数表达式可以省略函数名，创建一个匿名函数。异步函数表达式可以被当成 IIFE（自执行函数）来使用，一经定义就执行。</p><p>看下这个：</p><script src="https://gist.github.com/zlatkov/0873db2fd9f5883a2e1bae414e43a5cc.js"></script><p>更重要的地，<code>async/await</code> 在主流浏览器中的支持情况：</p><p><img src="/js/lazyload-plugin/loading.svg" alt="If this compatibility is not what you are after, there are also several JS transpilers like Babel and TypeScript." data-original="https://cdn-images-1.medium.com/max/800/0*z-A-JIe5OWFtgyd2."></p><p>最后，最重要的是不要盲目地选择“最新”的写法去实现异步函数。本质是要理解异步 javascript 的内部原理。了解它为什么如此关键，并深入理解你的选择的内部原理。每种方法都有优缺点，就像编程中的其他部分一样。</p><h1 id="编写高可维护性，健壮的代码的5个提示"><a href="#编写高可维护性，健壮的代码的5个提示" class="headerlink" title="编写高可维护性，健壮的代码的5个提示"></a>编写高可维护性，健壮的代码的5个提示</h1><h2 id="1、-简洁的代码"><a href="#1、-简洁的代码" class="headerlink" title="1、 简洁的代码"></a>1、 简洁的代码</h2><p>使用 async/await 允许你写很少的代码。每次你使用 async/await 跳过一些不必须要步骤：写 <code>.then</code> 时，创建一个匿名函数去处理回应，给返回值命名。例如：</p><script src="https://gist.github.com/zlatkov/b66f922b26bb6d5fd701c7ba40ac81d7.js"></script><p>与：</p><script src="https://gist.github.com/zlatkov/f506c8de2c73ba1c4c9ec78c5871816c.js"></script><h2 id="2、错误处理"><a href="#2、错误处理" class="headerlink" title="2、错误处理"></a>2、错误处理</h2><p>Async/await 让处理同步和异步错误使用相同的方法——广为人知的 <code>try/catch</code>。</p><script src="https://gist.github.com/zlatkov/c5fc0706d2d37ce3bb9db75e8a991807.js"></script><p>与：</p><script src="https://gist.github.com/zlatkov/1f858a186da7d19fab77893e34e46adc.js"></script><h2 id="3、条件语句"><a href="#3、条件语句" class="headerlink" title="3、条件语句"></a>3、条件语句</h2><p>使用 <code>async/await</code> 写条件句更简单：</p><script src="https://gist.github.com/zlatkov/30e8c04023639ed289a5d107b6989269.js"></script><p>与：</p><script src="https://gist.github.com/zlatkov/3dea9285325304af9a73aceb3beb6742.js"></script><h2 id="4、堆栈帧"><a href="#4、堆栈帧" class="headerlink" title="4、堆栈帧"></a>4、堆栈帧</h2><p>与 <code>async/await</code> 不同，Promise 抛出的错误栈并没有包含错误发生在哪里。</p><script src="https://gist.github.com/zlatkov/8e728cc4d6ad1e302454e957fcce0580.js"></script><p>与：</p><script src="https://gist.github.com/zlatkov/7282966e52cab3eee85794d5e8df6928.js"></script><h2 id="5、调试"><a href="#5、调试" class="headerlink" title="5、调试"></a>5、调试</h2><p>如果你使用过 Promise, 你一定知道调试它们是一个噩梦。例如，如果你在一个 <code>.then</code> 打了个断点，并且使用调试快捷键操作，像“stop-over”，调试器并不会移动到下一个 <code>.then</code> ，因为它只是同步代码的“一步”。使用 <code>async/await</code> 你可以精确地定位到每一步 <code>await</code>，就好像他们是正常的同步函数一样。</p><p>书写异步函数不仅对应用程序很重要，对类库也同样如此。</p><p>举个例子： <a href="https://www.sessionstack.com/?utm_source=medium&amp;utm_medium=blog&amp;utm_content=Post-4-eventloop-outro" target="_blank" rel="noopener">Sessionstak</a> 类记录了网页上发生的所有事情。所有 DOM 操作，用户交互，javascript 异常，堆栈跟踪，失败的网络请求，以及调试信息。</p><p>这一切都发生在生产环境下却不影响用户体验。我们必须高度优化我们的代码，让它们尽可能地异步，这样就可以增加事件循环处理事件的数量。</p><p>也不止是类库，当你在 SessionStack 重播用户的会话时，我们必须在发生问题时，将用户浏览器的状态重现出来，我们必须重建整个状态，允许你在时间轴上向后或向前跳跃。为了让这成为可能，我们大量使用了异步javascript提供的机会。</p><p>这里有一个<a href="https://www.sessionstack.com/?utm_source=medium&amp;utm_medium=blog&amp;utm_content=Post-4-eventloop-GetStarted" target="_blank" rel="noopener">免费的计划</a>让你来体验一下。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/0*xSEaWHGqqlcF8g5H." data-original="https://cdn-images-1.medium.com/max/800/0*xSEaWHGqqlcF8g5H."></p><p>参考：</p><ul><li><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch2.md" target="_blank" rel="noopener">https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch2.md</a></li><li><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch3.md" target="_blank" rel="noopener">https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch3.md</a></li><li><a href="http://nikgrozev.com/2017/10/01/async-await/" target="_blank" rel="noopener">http://nikgrozev.com/2017/10/01/async-await/</a></li></ul><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;javascript-事件循环是如何工作的以及使用async／await提升异步编程的5种方式&quot;&gt;&lt;a href=&quot;#javascript-事件循环是如何工作的以及使用async／await提升异步编程的5种方式&quot; class=&quot;headerlink&quot; title=&quot;javascript 事件循环是如何工作的以及使用async／await提升异步编程的5种方式&quot;&gt;&lt;/a&gt;javascript 事件循环是如何工作的以及使用async／await提升异步编程的5种方式&lt;/h1&gt;&lt;p&gt;这次我们将通过回顾在单线程环境中编程的缺点来扩展先前的第一篇文章，以及如何克服它来建立一个令人惊叹的 javascript UIs。像以往一样，在文章的最后，我会分享使用 async/await 写简洁代码的 5 个小贴士。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="tutorial" scheme="http://robin-front.github.io/tags/tutorial/"/>
    
      <category term="web development" scheme="http://robin-front.github.io/tags/web-development/"/>
    
      <category term="programming" scheme="http://robin-front.github.io/tags/programming/"/>
    
      <category term="asynchronous" scheme="http://robin-front.github.io/tags/asynchronous/"/>
    
      <category term="events loop" scheme="http://robin-front.github.io/tags/events-loop/"/>
    
      <category term="promise" scheme="http://robin-front.github.io/tags/promise/"/>
    
      <category term="async await" scheme="http://robin-front.github.io/tags/async-await/"/>
    
  </entry>
  
  <entry>
    <title>你可能并不需要 redux</title>
    <link href="http://robin-front.github.io/2017/10/25/you-might-not-need-redux/"/>
    <id>http://robin-front.github.io/2017/10/25/you-might-not-need-redux/</id>
    <published>2017-10-25T09:04:54.000Z</published>
    <updated>2017-10-25T09:04:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="你可能并不需要-redux"><a href="#你可能并不需要-redux" class="headerlink" title="你可能并不需要 redux"></a>你可能并不需要 redux</h1><p><strong>人们常常在真正需要用到 redux 之前就选择了它。</strong> “如果我们的应用没有使用 redux，变得不好扩展怎么办？” 后来，开发者们又都皱着眉头指头他们的代码间接地评论 redux.“为什么实现一个小功能需要更改三个文件？” 为什么一定要用 redux 呢!<a id="more"></a></p><p>大家痛苦地指责 <code>redux</code>, <code>react</code>, 函数式编程、 不变性等这些东西，我能理解他们。我们很自然地会拿 redux 和不需要‘按模板’来更新 state 的实现方式进行比较，并得出 redux 只会让事情变复杂的结论。某种程度上看，redux 是被设计成这样的。</p><p>redux 做了一个权衡，它要求你：</p><ul><li>将应用的状态抽象成简单对象或数组。</li><li>将系统的变化抽象成简单对象。</li><li>将处理逻辑抽象成纯函数。</li></ul><p>不管是不是应用在 react 应用程序上，这些限制都是必需的。事实上，这些都是很严格的约束。就算只是在你应用程序的一部分中使用，也应该认真考虑它。</p><p>有人会问，你有充分的理由解释为什么要做这些限制吗？</p><p>这些限制对我很有吸引力，因为它们让我的应用拥有以下优点：</p><ul><li><a href="https://egghead.io/lessons/javascript-redux-persisting-the-state-to-the-local-storage?course=building-react-applications-with-idiomatic-redux" target="_blank" rel="noopener">将 state 存储在本地，并用它启动，开箱即用</a></li><li><a href="http://redux.js.org/docs/recipes/ServerRendering.html" target="_blank" rel="noopener">在服务端预渲染 state，并随 html 发送到客户端，从它启动，开箱即用</a></li><li><a href="https://github.com/dtschust/redux-bug-reporter" target="_blank" rel="noopener">序列化用户交互并触发它，以及进行状态快照，自动 bugs 上报，以便让开发者重现 errors</a></li><li><a href="https://github.com/philholden/redux-swarmlog" target="_blank" rel="noopener">通过网络传递 action 对象，而不会对写代码的方式产生大的影响</a></li><li><a href="http://redux.js.org/docs/recipes/ImplementingUndoHistory.html" target="_blank" rel="noopener">保持重做历史和实现可预测的变化，而不会对写法产生剧大的影响</a></li><li><a href="https://github.com/gaearon/redux-devtools" target="_blank" rel="noopener">开发环境中可以随意穿梭在历史的各个状态中，并在代码更改时根据交互历史重新计算当前状态，一种 TDD 驱动</a></li><li><a href="https://github.com/romseguy/redux-devtools-chart-monitor" target="_blank" rel="noopener">为开发工具提供全面的检测和控制能力，以便产品开发者为他们的 app 构建自定义开发工具</a></li><li><a href="https://youtu.be/gvVpSezT5_M?t=11m51s" target="_blank" rel="noopener">当复用大部分业务逻辑的同时，也提供备用 UI</a></li></ul><p>如果你正在开发<a href="https://hyperterm.org/" target="_blank" rel="noopener">可扩展的 terminal</a>, <a href="https://hacks.mozilla.org/2016/09/introducing-debugger-html/" target="_blank" rel="noopener">javascript 调试器</a>, 或<a href="https://twitter.com/necolas/status/727538799966715904" target="_blank" rel="noopener">某些类型的 webapp</a>, redux 可能很值得一试，或者至少借鉴它的一些思想（顺便提一下，这些并<a href="https://github.com/evancz/elm-architecture-tutorial" target="_blank" rel="noopener">不是</a> <a href="https://github.com/omcljs/om" target="_blank" rel="noopener">新事物</a>）。</p><p><strong>但是，如果你只是在学习 react, 那么不要把 redux 当成你的首选。</strong></p><p>相反，学会 <a href="https://facebook.github.io/react/docs/thinking-in-react.html" target="_blank" rel="noopener">思考 react</a>, 如果你发现你真的需要它，或者你想尝试一些新东西，那就重新考虑 redux 吧。但是一定要谨慎对待它，就像对待固执已见的工具一样。</p><p><strong>如果你对 redux 的方式感到压力。这是一个信号，可能你的队友太认真了。</strong> 它只是你工具箱里的一个工具，一个<a href="https://www.youtube.com/watch?v=uvAXVMwHJXU" target="_blank" rel="noopener">疯狂</a> 的<a href="https://www.youtube.com/watch?v=xsSnOQynTHs" target="_blank" rel="noopener">实验</a>。</p><p><strong>最后，不要忘记，你可以不用 redux,而实现 redux 的思想。</strong></p><p>举个例子，考虑一个带有 local state 的 react 组件:</p><script src="https://gist.github.com/gaearon/a9bbb73d57b6e4cc17d7b50807b62f9a.js"></script><p>看上去很好。严格地说，它没有达到高度复用。</p><p><strong>但是，这样使用 Local state 就很好。</strong></p><p>权衡之下，redux 提供解耦，将“发生了什么交互”与“数据如何改变”解耦。</p><p>举个例子，可以从我们的组件中提取出一个 reducer:</p><script src="https://gist.github.com/gaearon/64e2c4adce2b4918c96c3db2b44d8f68.js"></script><p>注意，我们没有运行 npm install 却应用了 redux ! 哇哦！</p><p>你的状态组件是否也需要这样写呢？可能不需要。除非你有计划地从这种解耦方式中获益。有计划是我们的一种说法，这是关键。</p><p><a href="http://redux.js.org/" target="_blank" rel="noopener">redux 库</a>本身只是“安装” reducer 和单个全局 store 对象的工具集。你可以只使用部分或者全部功能，这取决于你。</p><p><strong>但，如果你付出了什么，一定要确保你有所收获。</strong></p><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;你可能并不需要-redux&quot;&gt;&lt;a href=&quot;#你可能并不需要-redux&quot; class=&quot;headerlink&quot; title=&quot;你可能并不需要 redux&quot;&gt;&lt;/a&gt;你可能并不需要 redux&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;人们常常在真正需要用到 redux 之前就选择了它。&lt;/strong&gt; “如果我们的应用没有使用 redux，变得不好扩展怎么办？” 后来，开发者们又都皱着眉头指头他们的代码间接地评论 redux.“为什么实现一个小功能需要更改三个文件？” 为什么一定要用 redux 呢!
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="react" scheme="http://robin-front.github.io/tags/react/"/>
    
      <category term="redux" scheme="http://robin-front.github.io/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 ios11 webview 的 viewport</title>
    <link href="http://robin-front.github.io/2017/09/21/Understanding-the-WebView-Viewport-in-iOS-11/"/>
    <id>http://robin-front.github.io/2017/09/21/Understanding-the-WebView-Viewport-in-iOS-11/</id>
    <published>2017-09-21T03:34:30.000Z</published>
    <updated>2017-09-21T03:34:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解-ios11-webview-的-viewport"><a href="#深入理解-ios11-webview-的-viewport" class="headerlink" title="深入理解 ios11 webview 的 viewport"></a>深入理解 ios11 webview 的 viewport</h1><p>ios11 带来了一些新的东西，凭直觉，围绕状态栏区域的展现对于程序员使用的像 Apache Cordova 或 Ionic 这样的工具显得尤为重要。尤其是，这个改动影响到所有为 ios11 构建的、基于 web 的、使用了固定标题栏的 app 之中。这篇文章帮助你理解 ios11 webview 的 viewport。</p><p><strong>注： 现有的 app 可以继续正常工作，因为原有的 viewport 表现并没有被改变。这个改变只影响那些使用 xcode9 来为 ios11 构建的应用。</strong></p><p>为了理解这个改动，我们需要先了解一下背景知识。<a id="more"></a></p><h2 id="状态栏和安全区域"><a href="#状态栏和安全区域" class="headerlink" title="状态栏和安全区域"></a>状态栏和安全区域</h2><p>在 ios 的早期版本中，状态栏是屏幕顶部的不可触摸的黑色长条。它是系统 UI 的一部分，而 app 运行在它的下面。</p><p>随着 ios7 的发布，一切发生了改变。它变成了一个透明的状态栏，从而显示了 app 导航栏的颜色。对于像 Cordova 这样显示在 webview 的 app, 意味着通常需要检测是否 ios 并添加 <code>padding-top: 20px</code> 到固定的头部导航, 以便正确填充那部分空间。</p><p>后来发布的较新版本的 ios 添加了一些小修订。包含了一些新功能，比如当有电话呼入或在后台使用定位功能时顶部会展示额外的状态栏。</p><p>在原生应用方面，存在大量的导航栏和自动布局指南。会有一些布局指示在屏幕的顶部或底部以便自动调整高度，让状态栏不会遮住应用。如果在顶部设置了 UINavigationBar， ios 会自动在状态栏拓展它的颜色。对于 web，很不幸，没有等价的办法。</p><h2 id="iOS11-的改变"><a href="#iOS11-的改变" class="headerlink" title="iOS11 的改变"></a>iOS11 的改变</h2><p><img src="/js/lazyload-plugin/loading.svg" alt="The default viewport behaviour in iOS 11 on an iPhone 8." data-original="https://ayogo.com/wp-content/uploads/2017/09/iphone8-viewport-auto-crop-zop.png"></p><p>ios11 和先前版本的不同之处在于， webview 内容现在重视安全区域了。这意味着，如果设置头部栏 <code>top: 0</code>, 它会渲染在屏幕顶部的<code>20px</code>之下，也就是状态栏下面。当向下浏览时，会移到状态栏后面。当向上浏览时，又会移动状态栏下面与状态栏部对齐。（留下尴尬的20像素空白）</p><p>可以看看下面剪辑的视频中了解到有多么糟糕：</p><video src="https://cdn.css-tricks.com/wp-content/uploads/2017/09/ios11-viewport.mp4" width="300" height="330" controls name="fitvid0"></video><h2 id="为什么苹果公司会改成这个样子"><a href="#为什么苹果公司会改成这个样子" class="headerlink" title="为什么苹果公司会改成这个样子"></a>为什么苹果公司会改成这个样子</h2><p>如果你看过 iPhone X 的设计，就知道它这样改动是有道理的： iPhone X 的屏幕顶部有个为摄像头和话筒留出的不规则区域。如果真的渲染到屏幕顶部，就会被麦克风挡住。</p><p>通过对齐状态栏底部，可以确保头部栏可以一直被访问。</p><p>酷！…除了现在 app 上面滑动内容时在状态栏底下留下的尴尬的空白。</p><h2 id="iOS11-解决方案"><a href="#iOS11-解决方案" class="headerlink" title="iOS11 解决方案"></a>iOS11 解决方案</h2><p>值得庆幸的是，Apple 给我们提供了一个通过设置 viewport meta 标签的解决方案。更幸运的是，它还向下兼容旧的，过期的 UIWebView。</p><p>我们正在找的 viewport 选项就是 <code>viewport-fit</code>,它有三个可选值：</p><ul><li>contain： 这意味着 iOS11 下，固定栏会被包含在安全区域内。</li><li>cover： 这意味着固定栏是相对 viewport 固定的，就算会被立大状态栏遮蔽。这就回到了 iOS10 的表现。</li><li>auto： 这和 contain 选项的表现是一样的。</li></ul><p>所以为了恢复到固定在屏幕的最顶端，就像 iOS10 一样在状态栏下面。可以添加 <code>viewport-fit=cover</code> 到 viewport meta 标签。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="" data-original="https://ayogo.com/wp-content/uploads/2017/09/iphone8-viewport-cover-crop-zop.png"></p><h2 id="iPhone-X"><a href="#iPhone-X" class="headerlink" title="iPhone X"></a>iPhone X</h2><p>但 iPhone X 的小刘海怎么办？这个状态栏不再是 <code>20px</code> 高，并且因为里面有摄像头和扬声器，头部栏会完全无法访问。同样要注意固定在屏幕底部的页脚，它会被麦克风遮住。</p><p><strong>注：如果有启动脚本，应用将只会运行在 iPhone X 的全屏幕上。现有的 app 会在顶部和底部有黑色区域。</strong></p><p><img src="/js/lazyload-plugin/loading.svg" alt="" data-original="https://ayogo.com/wp-content/uploads/2017/09/iphonex-viewport-cover-crop-zop-300x264.png"></p><p>幸运的是，Apple 给出了一个关于安全区域的 css 指南。他们添加一个类似 css 变量，叫做 css 常数。可以把它看做是系统的 css 变量并且不可覆盖。可以在 css 中通过<code>constant()</code> 函数来调用它们，并且已向 css 标准化工作小组提案。</p><p>这四个布局常量是：</p><ul><li>constant(safe-area-inset-top): viewport 顶部插入的安全区域（使用 css 像素）</li><li>constant(safe-area-inset-bottom): viewport 底部插入的安全区域（使用 css 像素）</li><li>constant(safe-area-inset-left): viewport 左边插入的安全区域（使用 css 像素）</li><li>constant(safe-area-inset-right): viewport 右边插入的安全区域（使用 css 像素）</li></ul><p>这是 Apple 给我们的最后一个礼物，也是向下兼容的。</p><h2 id="css-constants-的例子"><a href="#css-constants-的例子" class="headerlink" title="css constants 的例子"></a>css constants 的例子</h2><p>假设有一个头部固定栏，现在 iOS10 下的 css 如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">header</span> &#123;</div><div class="line">    <span class="attribute">position</span>: fixed;</div><div class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">44px</span>;</div><div class="line"></div><div class="line">    <span class="attribute">padding-top</span>: <span class="number">20px</span>; <span class="comment">/* Status bar height */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>为了调整自适应 iPhone X 和 iOS11 设备，会添加 <code>viewport-fit=cover</code> 选项到 viewport meta 标签上，并且更改 css， 引用 css constant。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">header</span> &#123;</div><div class="line">    <span class="comment">/* ... */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Status bar height on iOS 10 */</span></div><div class="line">    <span class="attribute">padding-top</span>: <span class="number">20px</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Status bar height on iOS 11+ */</span></div><div class="line">    <span class="attribute">padding-top</span>: <span class="built_in">constant</span>(safe-area-inset-top);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>重要的是，要保留回退值，因为旧设备不能解释 css <code>constant()</code> 语法。别外，也可以在 css <code>calc()</code> 表达式中使用 constants.</p><p><img src="/js/lazyload-plugin/loading.svg" alt="" data-original="https://ayogo.com/wp-content/uploads/2017/09/iphonex-viewport-constants-crop-zop-300x264.png"></p><p>记住，你也会想要在屏幕底部做这件事的。</p><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;深入理解-ios11-webview-的-viewport&quot;&gt;&lt;a href=&quot;#深入理解-ios11-webview-的-viewport&quot; class=&quot;headerlink&quot; title=&quot;深入理解 ios11 webview 的 viewport&quot;&gt;&lt;/a&gt;深入理解 ios11 webview 的 viewport&lt;/h1&gt;&lt;p&gt;ios11 带来了一些新的东西，凭直觉，围绕状态栏区域的展现对于程序员使用的像 Apache Cordova 或 Ionic 这样的工具显得尤为重要。尤其是，这个改动影响到所有为 ios11 构建的、基于 web 的、使用了固定标题栏的 app 之中。这篇文章帮助你理解 ios11 webview 的 viewport。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;注： 现有的 app 可以继续正常工作，因为原有的 viewport 表现并没有被改变。这个改变只影响那些使用 xcode9 来为 ios11 构建的应用。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;为了理解这个改动，我们需要先了解一下背景知识。
    
    </summary>
    
      <category term="css" scheme="http://robin-front.github.io/categories/css/"/>
    
    
      <category term="ios11" scheme="http://robin-front.github.io/tags/ios11/"/>
    
      <category term="viewport" scheme="http://robin-front.github.io/tags/viewport/"/>
    
      <category term="css-constant" scheme="http://robin-front.github.io/tags/css-constant/"/>
    
      <category term="viewport-fit" scheme="http://robin-front.github.io/tags/viewport-fit/"/>
    
  </entry>
  
  <entry>
    <title>IphoneX 的缺口（小刘海）及其css样式解决方案</title>
    <link href="http://robin-front.github.io/2017/09/21/the-notch-and-css/"/>
    <id>http://robin-front.github.io/2017/09/21/the-notch-and-css/</id>
    <published>2017-09-21T02:23:04.000Z</published>
    <updated>2017-09-21T02:23:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IphoneX-的缺口（小刘海）及其css样式解决方案"><a href="#IphoneX-的缺口（小刘海）及其css样式解决方案" class="headerlink" title="IphoneX 的缺口（小刘海）及其css样式解决方案"></a>IphoneX 的缺口（小刘海）及其css样式解决方案</h1><p>苹果公司的 IphoneX 拥有了全面屏，只保留了‘小刘海’给摄像头和一些传感设备。结果就是让屏幕设计陷入尴尬的境地，就像限制网页有一个“安全区域”和白色边缘条。虽然没有太多的黑魔法去消除它，但给 <code>body</code> 设置一个 <code>background-color</code> 属性也可以做到。或者扩展网页以覆盖整个屏幕（该死的缺口），可以给 viewport 的 meta 标签添加 <code>viewport-fit=cover</code>。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1000,f_auto,q_auto/v1505590717/iphonex-safari_njxeiw.png" data-original="https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1000,f_auto,q_auto/v1505590717/iphonex-safari_njxeiw.png"><a id="more"></a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, viewport-fit=cover"</span>&gt;</span></div></pre></td></tr></table></figure><p>然后，由你自己决定如何处理安全区域的重叠。这里有一些新的 css 可以帮助适配它。<a href="http://stephenradford.me/removing-the-white-bars-in-safari-on-iphone-x/" target="_blank" rel="noopener">Stephen Radford documents</a></p><blockquote><p>为了适配缺口，可以引入 ios 11 版本包含的一些常量，这些常量需要使用了 <code>viewport-fit=cover</code> 才会生效。</p><ul><li>safe-area-inset-top</li><li>safe-area-inset-right</li><li>safe-area-inset-left</li><li>safe-area-inset-bottom</li></ul><p>这些常量可以被用在 <code>margin</code>, <code>padding</code>, 或者绝对定位的 <code>top</code>, <code>left</code> 等属性上。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">padding</span>: <span class="selector-tag">constant</span>(<span class="selector-tag">safe-area-inset-top</span>) <span class="selector-tag">constant</span>(<span class="selector-tag">safe-area-inset-right</span>) <span class="selector-tag">constant</span>(<span class="selector-tag">safe-area-inset-bottom</span>) <span class="selector-tag">constant</span>(<span class="selector-tag">safe-area-inset-left</span>);</div></pre></td></tr></table></figure></blockquote><p>还有另外一个尴尬的局面关于缺口，安全区域和 fixed 定位。<a href="https://ayogo.com/blog/ios11-viewport/" target="_blank" rel="noopener">Darryl Pogue reports:</a></p><blockquote><p>ios 11与早期的版本不太一样，它现在遵守安全区域这一规则。这意味着，如果你有一个 header bar， 并且设置 <code>position: fixed;top: 0;</code>，它初始化时会渲染在顶部的 <code>20px</code> 下面：对齐顶部状态栏的底部。当你向下浏览网页，它会隐藏状态栏。如果向上滚动，状态栏又来跑出来（留下尴尬的20px间隙）。</p><video src="https://cdn.css-tricks.com/wp-content/uploads/2017/09/ios11-viewport.mp4" controls name="fitvid0"></video></blockquote><p>幸运的是这也很容易解决。只需要添加 <code>viewport-fit=cover</code> 到 <code>meta viewport</code> 标签上。</p><p>如果覆盖了全屏幕，那可能需要耍点小聪明去避免挡住内容。</p><p></p><blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">I think I’ve fixed the notch issue in landscape 🍾 <a href="https://twitter.com/hashtag/iphoneX?src=hash" target="_blank" rel="noopener">#iphoneX</a> <a href="https://t.co/hGytyO3DRV" target="_blank" rel="noopener">pic.twitter.com/hGytyO3DRV</a></p>&mdash; Vojta Stavik (@vojtastavik) <a href="https://twitter.com/vojtastavik/status/907911237983449088" target="_blank" rel="noopener">September 13, 2017</a></blockquote><p></p><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IphoneX-的缺口（小刘海）及其css样式解决方案&quot;&gt;&lt;a href=&quot;#IphoneX-的缺口（小刘海）及其css样式解决方案&quot; class=&quot;headerlink&quot; title=&quot;IphoneX 的缺口（小刘海）及其css样式解决方案&quot;&gt;&lt;/a&gt;IphoneX 的缺口（小刘海）及其css样式解决方案&lt;/h1&gt;&lt;p&gt;苹果公司的 IphoneX 拥有了全面屏，只保留了‘小刘海’给摄像头和一些传感设备。结果就是让屏幕设计陷入尴尬的境地，就像限制网页有一个“安全区域”和白色边缘条。虽然没有太多的黑魔法去消除它，但给 &lt;code&gt;body&lt;/code&gt; 设置一个 &lt;code&gt;background-color&lt;/code&gt; 属性也可以做到。或者扩展网页以覆盖整个屏幕（该死的缺口），可以给 viewport 的 meta 标签添加 &lt;code&gt;viewport-fit=cover&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1000,f_auto,q_auto/v1505590717/iphonex-safari_njxeiw.png&quot; alt=&quot;https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1000,f_auto,q_auto/v1505590717/iphonex-safari_njxeiw.png&quot;&gt;
    
    </summary>
    
      <category term="css" scheme="http://robin-front.github.io/categories/css/"/>
    
    
      <category term="viewport" scheme="http://robin-front.github.io/tags/viewport/"/>
    
      <category term="css" scheme="http://robin-front.github.io/tags/css/"/>
    
      <category term="iphoneX" scheme="http://robin-front.github.io/tags/iphoneX/"/>
    
      <category term="notch" scheme="http://robin-front.github.io/tags/notch/"/>
    
  </entry>
  
  <entry>
    <title>如何处理4种常见的内存泄露</title>
    <link href="http://robin-front.github.io/2017/09/19/how-to-handle-4-common-memory-leaks/"/>
    <id>http://robin-front.github.io/2017/09/19/how-to-handle-4-common-memory-leaks/</id>
    <published>2017-09-19T01:38:51.000Z</published>
    <updated>2017-09-19T01:38:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何处理4种常见的内存泄露"><a href="#如何处理4种常见的内存泄露" class="headerlink" title="如何处理4种常见的内存泄露"></a>如何处理4种常见的内存泄露</h1><h2 id="什么是内存泄露"><a href="#什么是内存泄露" class="headerlink" title="什么是内存泄露"></a>什么是内存泄露</h2><p>本质上来说，内存泄露可以被定义为 <strong>当内存不再被应用使用，却因为某些原因没有被操作系统回收或释放到自由内存池</strong></p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/1600/1*0B-dAUOH7NrcCDP6GhKHQw.jpeg" data-original="https://cdn-images-1.medium.com/max/1600/1*0B-dAUOH7NrcCDP6GhKHQw.jpeg"></p><p>编程语言支持多种不同的内存管理。某些内存是否在使用实际上是不可判定的。换句话说，只要开发者才清楚哪些内存块是可以被操作系统回收。</p><p>某些编程语言提供一些特性帮助开发者进行内存回收。其他的期望开发者完全明白哪些内存是无用的。维基有一系列关于内存管理的好文章。<a id="more"></a></p><h2 id="四种常见的内存泄露"><a href="#四种常见的内存泄露" class="headerlink" title="四种常见的内存泄露"></a>四种常见的内存泄露</h2><h3 id="1-全局变量"><a href="#1-全局变量" class="headerlink" title="1. 全局变量"></a>1. 全局变量</h3><p>javascript 通过一个有趣的方式处理未声明的变量：引用未声明的变量会在全局对象里创建一个变量。在浏览器中，全局对象是<code>window</code>, 换句话说：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123;</div><div class="line">    bar = <span class="string">"some text"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123;</div><div class="line">    <span class="built_in">window</span>.bar = <span class="string">"some text"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>如果 <code>bar</code> 预想中是 <code>foo</code> 函数作用域内的局部变量，但又忘记使用 <code>var</code> 去声明，那么预料之外的全局变量就被创建了。</p><p>在这个例子中，一个简单的字符串泄露不会有多大害处，但这种写法当然会有更糟情况。</p><p>另一个意外创建全局变量的方式是通过 <code>this</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.var1 = <span class="string">"potential accidental global"</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Foo called on its own, this points to the global object (window)</span></div><div class="line"><span class="comment">// rather than being undefined.</span></div><div class="line">foo();</div></pre></td></tr></table></figure><blockquote><p>为了防止这种情况发生，需要在 javascript 文件的开头添加 <code>&#39;use strict&#39;</code>.这会使用严格模式解析javascript以防止意外的全局变量。<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noopener">了解更多javascript严格模式的执行情况</a></p></blockquote><p>尽管我们在谈论意外的全局变量，但仍然会有无数的明确的全局变量。这些被定义为不可回收的（除非指定为null或重新分配）。特别是应该关注用于临时存储和处理大量数据的全局变量。如果必须要用全局变量去存储大量数据，当你处理完之后，<strong>请勿必记得指定为null或重新全配</strong></p><h3 id="2-被遗忘的定时器和回调"><a href="#2-被遗忘的定时器和回调" class="headerlink" title="2. 被遗忘的定时器和回调"></a>2. 被遗忘的定时器和回调</h3><p>在 javascript 中使用 <code>setInterval</code> 非常常见。</p><p>大部分类库提供观察者和其他调用回调的工具，小心地引用那些 <strong>拥有会变得不可访问的实例</strong> 的回调。<code>setInterval</code> 的例子，尽管这很常见：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> serverData = loadData();</div><div class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> renderer = <span class="built_in">document</span>.getElementById(<span class="string">'renderer'</span>);</div><div class="line">    <span class="keyword">if</span>(renderer) &#123;</div><div class="line">        renderer.innerHTML = <span class="built_in">JSON</span>.stringify(serverData);</div><div class="line">    &#125;</div><div class="line">&#125;, <span class="number">5000</span>); <span class="comment">//This will be executed every ~5 seconds.</span></div></pre></td></tr></table></figure><p>这个例子说明了定时器会发生的事：定时器引用了不再需要的node节点和数据。</p><p>被 <code>renderer</code> 引用的对象在将来某个时刻可能会被删除，让整个内部块都变得不必要了。但是，因为定时器还在运行，所以处理程序不能被回收（定时器需要被停止才能回收）。如果定时处理程序不能被回收，那么相关的一切都不能被回收。这意味着可能存储着大量数据的 <code>serverData</code> 也不能被回收。</p><p>观察者的例子中，很重要的一点是当不在需要的时候，必须明确移除他们（或者让相关的对象变得不可访问）。</p><p>在过去，这对于某些不能很好地管理内存的浏览器（像IE6）是非常重要的。如今，大部分浏览器有能力并且会回收不可访问的观察者处理程序，就算有时监听器没有被明确地移除。这仍然是很好的做法，不管怎样，在对象被处理掉之前明确地移除观察者。举个实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'launch-button'</span>);</div><div class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">   counter++;</div><div class="line">   element.innerHtml = <span class="string">'text '</span> + counter;</div><div class="line">&#125;</div><div class="line">element.addEventListener(<span class="string">'click'</span>, onClick);</div><div class="line"><span class="comment">// Do stuff</span></div><div class="line">element.removeEventListener(<span class="string">'click'</span>, onClick);</div><div class="line">element.parentNode.removeChild(element);</div><div class="line"><span class="comment">// Now when element goes out of scope,</span></div><div class="line"><span class="comment">// both element and onClick will be collected even in old browsers // that don't handle cycles well.</span></div></pre></td></tr></table></figure><p>框架或类库，比如 jQuery 在删除 node 节点的时候就移除了监听事件（当使用它的API的时候），这是类库内部处理的，为了防止内存泄露产生。就算在有问题的浏览器下运行，比如…对，IE6 ：）</p><h3 id="闭包（closure）"><a href="#闭包（closure）" class="headerlink" title="闭包（closure）"></a>闭包（closure）</h3><p>javascript 开发一个关键点是 <strong>闭包</strong>： 一个内部函数可以访问（封闭的）外部函数的变量。由于 javascript 运行环境的实现，以下方式很可能造成内存泄露：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> theThing = <span class="literal">null</span>;</div><div class="line"><span class="keyword">var</span> replaceThing = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> originalThing = theThing;</div><div class="line">  <span class="keyword">var</span> unused = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (originalThing) <span class="comment">// a reference to 'originalThing'</span></div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</div><div class="line">  &#125;;</div><div class="line">  theThing = &#123;</div><div class="line">    <span class="attr">longStr</span>: <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>).join(<span class="string">'*'</span>),</div><div class="line">    <span class="attr">someMethod</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"message"</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;;</div><div class="line">setInterval(replaceThing, <span class="number">1000</span>);</div></pre></td></tr></table></figure><p>这段代码做了一件事：每次调用 <code>replaceThing</code> 时，<code>theThing</code> 指向了一个包含大数据和闭包（someMethod）的新对象，同时， <code>unused</code> 也指向一个引用了 <code>originalThing</code>（<code>theThing</code> 指向前一次 <code>replaceThing</code> 调用） 的闭包，已经有点混乱了，啊哈？重点是，<strong>一旦为一个具有相同父级作用域的闭包创建作用域，作用域是共享的</strong></p><p>这种情况下， 为闭包 <code>someMethod</code> 创建的作用域与 <code>unused</code> 共享。<code>unused</code> 有一个指向 <code>originalThing</code> 的引用。尽管 <code>unused</code> 从未被使用，但是 <code>someMethod</code> 可以通过 <code>theThing</code> 也就是 <code>replaceThing</code> 外围的作用域（例如：全局范围内）调用。与此同时 <code>someMethod</code> 与 <code>unused</code> 共享闭包作用域，<code>unused</code> 引用 <code>originalThing</code> 迫使它保持在内存中（在两个闭包共享的作用域范围）。这阻止了它被回收。</p><p>当这段代码反复地运行时，可以观察到内存使用率稳定地增长。GC 运行时也并未减少。本质上，一个闭包链被创建了（通过根作用域的 <code>theThing</code> 变量）。而每一个闭包作用域附带着引用了大数据，结果就是内存泄露。</p><p>这个问题被 Meteor 团队发现并发表了<a href="https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156" target="_blank" rel="noopener">著名的文章描述这个问题</a>。</p><h3 id="4-额外的-DOM-引用"><a href="#4-额外的-DOM-引用" class="headerlink" title="4. 额外的 DOM 引用"></a>4. 额外的 DOM 引用</h3><p>有时在数据结构中引用 DOM 节点很有用。假设你想迅速地更新一个表格中的几行内容。可能感觉在字典中或数据中引用 DOM row 是有意义的。在这种情况发生时，两个对相同 DOM 的引用被保持：一个在 DOM 树，另一个在字典中。如果将来某个时间点，你想删除这几行表格，你要确保这两个者失去引用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> elements = &#123;</div><div class="line">    <span class="attr">button</span>: <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>),</div><div class="line">    <span class="attr">image</span>: <span class="built_in">document</span>.getElementById(<span class="string">'image'</span>)</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    image.src = <span class="string">'http://example.com/image_name.png'</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeImage</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// The image is a direct child of the body element.</span></div><div class="line">    <span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">'image'</span>));</div><div class="line">    <span class="comment">// At this point, we still have a reference to #button in the</span></div><div class="line">    <span class="comment">//global elements object. In other words, the button element is</span></div><div class="line">    <span class="comment">//still in memory and cannot be collected by the GC.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里还有额外的点需要注意，当涉及到 DOM 树或子节点的引用。比如说在 javascript 代码中引用了表格的某个格子（一个<code>&lt;td&gt;</code>标签）。某天你决定删除表格但还保持着单元格的引用。直观的假设就是 GC 会回收表格，但保留单元格。事实上，这是不可能的：单元格是表格的子节点，它保持着对父级表格的引用。javascript 代码保持单元格的引用导致 <strong>整个表格被保留在内存中</strong>。所以请谨慎考虑引用 DOM 元素。</p><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;如何处理4种常见的内存泄露&quot;&gt;&lt;a href=&quot;#如何处理4种常见的内存泄露&quot; class=&quot;headerlink&quot; title=&quot;如何处理4种常见的内存泄露&quot;&gt;&lt;/a&gt;如何处理4种常见的内存泄露&lt;/h1&gt;&lt;h2 id=&quot;什么是内存泄露&quot;&gt;&lt;a href=&quot;#什么是内存泄露&quot; class=&quot;headerlink&quot; title=&quot;什么是内存泄露&quot;&gt;&lt;/a&gt;什么是内存泄露&lt;/h2&gt;&lt;p&gt;本质上来说，内存泄露可以被定义为 &lt;strong&gt;当内存不再被应用使用，却因为某些原因没有被操作系统回收或释放到自由内存池&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*0B-dAUOH7NrcCDP6GhKHQw.jpeg&quot; alt=&quot;https://cdn-images-1.medium.com/max/1600/1*0B-dAUOH7NrcCDP6GhKHQw.jpeg&quot;&gt;&lt;/p&gt;&lt;p&gt;编程语言支持多种不同的内存管理。某些内存是否在使用实际上是不可判定的。换句话说，只要开发者才清楚哪些内存块是可以被操作系统回收。&lt;/p&gt;&lt;p&gt;某些编程语言提供一些特性帮助开发者进行内存回收。其他的期望开发者完全明白哪些内存是无用的。维基有一系列关于内存管理的好文章。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="memory leaks" scheme="http://robin-front.github.io/tags/memory-leaks/"/>
    
  </entry>
  
  <entry>
    <title>避免大型，复杂的布局和布局颠覆</title>
    <link href="http://robin-front.github.io/2017/08/30/avoid-large-complex-layouts-and-layout-thrashing/"/>
    <id>http://robin-front.github.io/2017/08/30/avoid-large-complex-layouts-and-layout-thrashing/</id>
    <published>2017-08-30T02:11:00.000Z</published>
    <updated>2017-08-30T02:11:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="避免大型，复杂的布局和布局颠覆"><a href="#避免大型，复杂的布局和布局颠覆" class="headerlink" title="避免大型，复杂的布局和布局颠覆"></a>避免大型，复杂的布局和布局颠覆</h1><p>布局是浏览器查找元素的几何信息：其大小和页面中的位置。每个元素将基于所使用的CSS，元素的内容或父元素显示或隐式的大小调整信息。该过程在 Chrome，Opera，Safari 和 Internet Explorer中称为“布局”。在 Firefox 中，它被称为 Reflow （回流），但是这个过程的作用是相同的。</p><p>类似于 style 计算，布局成本的直接相关是：</p><ul><li>需要布局的元素数量。</li><li>这些布局的复杂性。<a id="more"></a></li></ul><p>TL; DR</p><ul><li>布局通常作用于整个文档。</li><li>DOM 元素的数量将影响性能; 您应尽可能避免触发布局。</li><li>评估布局模型性能; 新的Flexbox通常比旧版Flexbox或基于浮动的布局模型更快。</li><li>避免强制同步布局和布局颠覆; 先读取样式值，然后再进行样式更改。</li></ul><h2 id="尽可能避免布局"><a href="#尽可能避免布局" class="headerlink" title="尽可能避免布局"></a>尽可能避免布局</h2><p>当您更改样式时，浏览器将检查以查看是否有任何更改需要计算布局，并为该渲染树进行更新。对“几何属性”的更改，如宽度，高度，左侧或顶部都需要布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 改变宽高</div><div class="line"> * 触发 layout.</div><div class="line"> */</div><div class="line"><span class="selector-class">.box--expanded</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">350px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>布局几乎总是作用于整个文档</strong>。如果你有很多元素，那么需要很长时间来确定它们的位置和尺寸。</p><p>如果不可能避免布局，那么关键是再次使用 Chrome DevTools 来查看花费多长时间，并确定布局是否是瓶颈的原因。首先，打开 DevTools，转到“时间轴”选项卡，点击记录并与您的网站进行交互。当您停止录制时，您会看到您的网站执行的细目：</p><p><img src="/js/lazyload-plugin/loading.svg" alt="" data-original="https://developers.google.com/web/fundamentals/performance/rendering/images/avoid-large-complex-layouts-and-layout-thrashing/big-layout.jpg"></p><p>当在上面的例子中挖掘每一帧时，我们看到在布局中花费了超过20毫秒，当我们的屏幕在动画中有16ms时，这太高了。您还可以看到，DevTools 会告诉您 DOM 树的大小（在这种情况下为1,618个元素），以及需要多少个节点进行布局。</p><blockquote><p>注意：想要明确列出哪些 CSS 属性触发布局(layout)，绘画(paint)或复合(composite)？查看<a href="https://csstriggers.com/" target="_blank" rel="noopener">CSS触发器</a>。</p></blockquote><h2 id="在旧的布局模型上使用-flexbox"><a href="#在旧的布局模型上使用-flexbox" class="headerlink" title="在旧的布局模型上使用 flexbox"></a>在旧的布局模型上使用 flexbox</h2><p>网络上有一系列的布局模式，其中一些比其他模型更受广泛支持。最旧的 CSS 布局模型允许我们在屏幕上进行相对，绝对地定位元素和浮动元素。</p><p>下面的截图显示了在1,300个盒子上使用浮点数时的布局成本。诚然，这是一个例证，因为大多数应用程序将使用各种方法来定位元素。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="" data-original="https://developers.google.com/web/fundamentals/performance/rendering/images/avoid-large-complex-layouts-and-layout-thrashing/layout-float.jpg"></p><p>如果我们更新样本以使用 Flexbox，这是Web平台上最近的一个补充，我们得到了一个不同的图片：</p><p><img src="/js/lazyload-plugin/loading.svg" alt="" data-original="https://developers.google.com/web/fundamentals/performance/rendering/images/avoid-large-complex-layouts-and-layout-thrashing/layout-flex.jpg"></p><p>现在，在相同数量的元素和相同的视觉外观的布局中，我们花费更少的时间（在这种情况下，3.5ms对14ms）。重要的是要记住，对于某些浏览器环境，您可能无法选择 Flexbox，因为它比<a href="http://caniuse.com/#search=flexbox" target="_blank" rel="noopener">浮动布局更不受支持</a>，但您应该至少应该调查布局模型对您的性能的影响，并将其最小化执行成本</p><p>无论您是否选择Flexbox，您仍然应该 <strong>尝试避免</strong> 在应用程序的高压点 <strong>完全触发布局</strong>！</p><h2 id="避免强制同步布局"><a href="#避免强制同步布局" class="headerlink" title="避免强制同步布局"></a>避免强制同步布局</h2><p>运送一个框架到屏幕有这样的顺序：</p><p><img src="/js/lazyload-plugin/loading.svg" alt="" data-original="https://developers.google.com/web/fundamentals/performance/rendering/images/avoid-large-complex-layouts-and-layout-thrashing/frame.jpg"></p><p>首先 JavaScript 运行，然后进行风格计算，然后进行布局。然而，可以强制浏览器使用 JavaScript 更早地执行布局。它被称为 <strong>强制同步布局</strong>。</p><p>要记住的第一件事是，由于 JavaScript 运行，所有旧的布局值都是已知的，可供您查询。所以如果你想在下一帧之前写出一个元素的高度（我们称之为“box”），你可以编写一些这样的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Schedule our function to run at the start of the frame.</span></div><div class="line">requestAnimationFrame(logBoxHeight);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">logBoxHeight</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// Gets the height of the box in pixels and logs it out.</span></div><div class="line">  <span class="built_in">console</span>.log(box.offsetHeight);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果您在要求其高度之前更改了 box 的样式，那么事情会变得有问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">logBoxHeight</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  box.classList.add(<span class="string">'super-big'</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Gets the height of the box in pixels</span></div><div class="line">  <span class="comment">// and logs it out.</span></div><div class="line">  <span class="built_in">console</span>.log(box.offsetHeight);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在，为了回答高度问题，浏览器必须首先应用样式更改（因为添加了 <code>super-big</code> 类），然后运行布局。只有这样才能恢复正确的高度。这是不必要的和潜在的昂贵的工作。</p><p>因此，您应该始终批评这类的样式读取，并首先执行（浏览器可以使用上一帧的布局值），然后执行任何写操作：</p><p>完成上述功能将是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">logBoxHeight</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// Gets the height of the box in pixels</span></div><div class="line">  <span class="comment">// and logs it out.</span></div><div class="line">  <span class="built_in">console</span>.log(box.offsetHeight);</div><div class="line"></div><div class="line">  box.classList.add(<span class="string">'super-big'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在大多数情况下，您不应该需要应用样式，然后查询值; 使用最后一帧的值应该是足够的。过早地运行 style 计算和布局是浏览器同步和布局潜在的瓶颈，这不是您通常想要做的事情。</p><h2 id="避免布局颠覆"><a href="#避免布局颠覆" class="headerlink" title="避免布局颠覆"></a>避免布局颠覆</h2><p>有一种方法可以使强制同步布局更加糟糕：<em>快速连续地做很多事情</em>。看看这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">resizeAllParagraphsToMatchBlockWidth</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// Puts the browser into a read-write-read-write cycle.</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; paragraphs.length; i++) &#123;</div><div class="line">    paragraphs[i].style.width = box.offsetWidth + <span class="string">'px'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>此代码循环遍历一组段落，并设置每个段落的宽度以匹配名为“box”的元素的宽度。它看起来很无害，但问题是循环的每次迭代读取一个样式值（<code>box.offsetWidth</code>），然后立即使用它来更新一个paragraph（<code>paragraphs[i].style.width</code>）的宽度。在循环的下一个迭代中，浏览器必须考虑到 <code>offsetWidth</code> 上一次请求（在上一次迭代中）样式已经改变的事实，因此它必须应用样式更改并运行布局。这将在每一次迭代中发生！</p><p>此示例的解决方法是缓存读取值，然后写值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Read.</span></div><div class="line"><span class="keyword">var</span> width = box.offsetWidth;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">resizeAllParagraphsToMatchBlockWidth</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; paragraphs.length; i++) &#123;</div><div class="line">    <span class="comment">// Now write.</span></div><div class="line">    paragraphs[i].style.width = width + <span class="string">'px'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果您想保证安全性，您应该检查<a href="https://github.com/wilsonpage/fastdom" target="_blank" rel="noopener">FastDOM</a>，这将自动为您分配读取和写入数据，并且应防止您意外触发强制同步布局或布局颠覆。</p><p>【翻译原文】:<a href="https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing?hl=en" target="_blank" rel="noopener">Avoid Large, Complex Layouts and Layout Thrashing</a></p><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;避免大型，复杂的布局和布局颠覆&quot;&gt;&lt;a href=&quot;#避免大型，复杂的布局和布局颠覆&quot; class=&quot;headerlink&quot; title=&quot;避免大型，复杂的布局和布局颠覆&quot;&gt;&lt;/a&gt;避免大型，复杂的布局和布局颠覆&lt;/h1&gt;&lt;p&gt;布局是浏览器查找元素的几何信息：其大小和页面中的位置。每个元素将基于所使用的CSS，元素的内容或父元素显示或隐式的大小调整信息。该过程在 Chrome，Opera，Safari 和 Internet Explorer中称为“布局”。在 Firefox 中，它被称为 Reflow （回流），但是这个过程的作用是相同的。&lt;/p&gt;&lt;p&gt;类似于 style 计算，布局成本的直接相关是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;需要布局的元素数量。&lt;/li&gt;&lt;li&gt;这些布局的复杂性。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="layout" scheme="http://robin-front.github.io/tags/layout/"/>
    
      <category term="css" scheme="http://robin-front.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>使用 requestIdleCallback</title>
    <link href="http://robin-front.github.io/2017/08/25/using-requestIdleCallback/"/>
    <id>http://robin-front.github.io/2017/08/25/using-requestIdleCallback/</id>
    <published>2017-08-25T07:40:26.000Z</published>
    <updated>2017-08-25T07:40:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-requestIdleCallback"><a href="#使用-requestIdleCallback" class="headerlink" title="使用 requestIdleCallback"></a>使用 requestIdleCallback</h1><p>许多网站和应用程序都有很多脚本来执行。您的 JavaScript 通常需要尽快运行，但同时您不希望它阻碍用户那条路。如果您在用户滚动页面时发送分析数据，或者在轻触按钮时将元素附加到 DOM，则您的 Web 应用程序将无法响应，从而导致用户体验不佳。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://developers.google.com/web/updates/images/2015-08-27-using-requestidlecallback/main.png" data-original="https://developers.google.com/web/updates/images/2015-08-27-using-requestidlecallback/main.png"></p><p>好消息是，现在有一个 API 可以帮助：<code>requestIdleCallback</code>。以同样的方式，<code>requestAnimationFrame</code> 我们可以正确地安排动画，并最大限度地提高 60fps 的机会，<code>requestIdleCallback</code> 当一个框架结束时，或当用户处于非活动状态时，可以安排工作。这意味着有机会在用户不使用的情况下进行工作。它可用于 Chrome 47！这是一个实验性的功能，规格还在不断变化，所以将来会发生变化。<a id="more"></a></p><h2 id="检查-requestIdleCallback-支持"><a href="#检查-requestIdleCallback-支持" class="headerlink" title="检查 requestIdleCallback 支持"></a>检查 requestIdleCallback 支持</h2><p>这是早期的 <code>requestIdleCallback</code>，所以在使用它之前，您应该检查它是否可用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="string">'requestIdleCallback'</span> <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</div><div class="line">  <span class="comment">// Use requestIdleCallback to schedule work.</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="comment">// Do what you’d do today.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>你也可以 polyfill 它的行为，这需要回到 <code>setTimeout</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.requestIdleCallback = <span class="built_in">window</span>.requestIdleCallback ||</div><div class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">cb</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> start = <span class="built_in">Date</span>.now();</div><div class="line">    <span class="keyword">return</span> setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      cb(&#123;</div><div class="line">        <span class="attr">didTimeout</span>: <span class="literal">false</span>,</div><div class="line">        <span class="attr">timeRemaining</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">          <span class="keyword">return</span> <span class="built_in">Math</span>.max(<span class="number">0</span>, <span class="number">50</span> - (<span class="built_in">Date</span>.now() - start));</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;, <span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="built_in">window</span>.cancelIdleCallback = <span class="built_in">window</span>.cancelIdleCallback ||</div><div class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</div><div class="line">    clearTimeout(id);</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>使用 <code>setTimeout</code> 不是很好，因为它不知道 <code>requestIdleCallback</code> 的空闲时间是如何工作的，但是如果 <code>requestIdleCallback</code> 不可用的话，你可以直接调用你的回调，你没有比这更差的方式。有了垫片，<code>requestIdleCallback</code> 就可以使用，你将被默认重定向到直接调用，这是很棒的。</p><p>现在，我们假设它存在。</p><h2 id="使用requestIdleCallback"><a href="#使用requestIdleCallback" class="headerlink" title="使用requestIdleCallback"></a>使用requestIdleCallback</h2><p>调用 <code>requestIdleCallback</code> 非常类似于 <code>requestAnimationFrame</code>, 它需要回调函数作为其第一个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">requestIdleCallback(myNonEssentialWork);</div></pre></td></tr></table></figure><p>当 <code>myNonEssentialWork</code> 被调用时，它将被赋予一个 <code>deadline</code>, 它是一个包含函数的对象，该函数返回一个数字，指示您的工作剩余多少时间：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNonEssentialWork</span> (<span class="params">deadline</span>) </span>&#123;</div><div class="line">  <span class="keyword">while</span> (deadline.timeRemaining() &gt; <span class="number">0</span>)</div><div class="line">    doWorkIfNeeded();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>timeRemaining</code> 可以调用该函数来获取最新值。当 <code>timeRemaining()</code> 返回零时，您可以安排另一个 <code>requestIdleCallback</code>, 如果您还有更多的工作要做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNonEssentialWork</span> (<span class="params">deadline</span>) </span>&#123;</div><div class="line">  <span class="keyword">while</span> (deadline.timeRemaining() &gt; <span class="number">0</span> &amp;&amp; tasks.length &gt; <span class="number">0</span>)</div><div class="line">    doWorkIfNeeded();</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (tasks.length &gt; <span class="number">0</span>)</div><div class="line">    requestIdleCallback(myNonEssentialWork);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="调用你的任务"><a href="#调用你的任务" class="headerlink" title="调用你的任务"></a>调用你的任务</h2><p>如果浏览器真的很忙，你该怎么办？您可能会担心您的回调可能永远不会被调用。嗯，虽然 <code>requestIdleCallback</code> 类似 <code>requestAnimationFrame</code>，但它也有所不同，它需要一个可选的第二个参数：具有 <code>timeout</code> 属性的 <code>options</code> 对象。此超时（如果设置）为浏览器提供了必须执行回调的时间（以毫秒为单位）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Wait at most two seconds before processing events.</span></div><div class="line">requestIdleCallback(processPendingAnalyticsEvents, &#123; <span class="attr">timeout</span>: <span class="number">2000</span> &#125;);</div></pre></td></tr></table></figure><p>如果您的回调由于超时触发而执行，您会注意到两件事情：</p><ul><li><code>timeRemaining()</code> 将返回零。</li><li>对象的 <code>didTimeout</code> 属性 <code>deadline</code> 将为 <code>true</code>。</li></ul><p>如果你看到这 <code>didTimeout</code> 是真的，你很可能只想运行这个工作并完成它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNonEssentialWork</span> (<span class="params">deadline</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// Use any remaining time, or, if timed out, just run through the tasks.</span></div><div class="line">  <span class="keyword">while</span> ((deadline.timeRemaining() &gt; <span class="number">0</span> || deadline.didTimeout) &amp;&amp;</div><div class="line">         tasks.length &gt; <span class="number">0</span>)</div><div class="line">    doWorkIfNeeded();</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (tasks.length &gt; <span class="number">0</span>)</div><div class="line">    requestIdleCallback(myNonEssentialWork);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>由于潜在的中断，这种超时可能会导致您的用户（工作可能会导致您的应用程序变得无响应或janky）设置此参数时要谨慎。在哪里可以让浏览器决定何时调用回调。</p><h2 id="使用-requestIdleCallback-发送分析数据"><a href="#使用-requestIdleCallback-发送分析数据" class="headerlink" title="使用 requestIdleCallback 发送分析数据"></a>使用 requestIdleCallback 发送分析数据</h2><p>让我们来看看 <code>requestIdleCallback</code> 发送分析数据。在这种情况下，我们可能会想跟踪一个事件，比如说 - 点击导航菜单。不过，由于通常在萤幕上设定动画，我们希望避免立即将此事件发送到 Google Analytics（分析）。我们将创建一系列事件来发送和请求在将来的某个时间发送它们：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> eventsToSend = [];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onNavOpenClick</span> (<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// Animate the menu.</span></div><div class="line">  menu.classList.add(<span class="string">'open'</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Store the event for later.</span></div><div class="line">  eventsToSend.push(</div><div class="line">    &#123;</div><div class="line">      <span class="attr">category</span>: <span class="string">'button'</span>,</div><div class="line">      <span class="attr">action</span>: <span class="string">'click'</span>,</div><div class="line">      <span class="attr">label</span>: <span class="string">'nav'</span>,</div><div class="line">      <span class="attr">value</span>: <span class="string">'open'</span></div><div class="line">    &#125;);</div><div class="line"></div><div class="line">  schedulePendingEvents();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在我们需要使用 <code>requestIdleCallback</code> 来处理任何待处理的事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">schedulePendingEvents</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// Only schedule the rIC if one has not already been set.</span></div><div class="line">  <span class="keyword">if</span> (isRequestIdleCallbackScheduled)</div><div class="line">    <span class="keyword">return</span>;</div><div class="line"></div><div class="line">  isRequestIdleCallbackScheduled = <span class="literal">true</span>;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (<span class="string">'requestIdleCallback'</span> <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</div><div class="line">    <span class="comment">// Wait at most two seconds before processing events.</span></div><div class="line">    requestIdleCallback(processPendingAnalyticsEvents, &#123; <span class="attr">timeout</span>: <span class="number">2000</span> &#125;);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    processPendingAnalyticsEvents();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在这里，您可以看到我设置了2秒的超时时间，但这个值取决于你的应用程序。对于分析数据，有意义的是，将使用超时时间来确保数据在合理的时间内报告，而不仅仅是在将来的某个时间点。</p><p>最后我们需要编写 <code>requestIdleCallback</code> 将执行的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">processPendingAnalyticsEvents</span> (<span class="params">deadline</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// Reset the boolean so future rICs can be set.</span></div><div class="line">  isRequestIdleCallbackScheduled = <span class="literal">false</span>;</div><div class="line"></div><div class="line">  <span class="comment">// If there is no deadline, just run as long as necessary.</span></div><div class="line">  <span class="comment">// This will be the case if requestIdleCallback doesn’t exist.</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> deadline === <span class="string">'undefined'</span>)</div><div class="line">    deadline = &#123; <span class="attr">timeRemaining</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">Number</span>.MAX_VALUE &#125; &#125;;</div><div class="line"></div><div class="line">  <span class="comment">// Go for as long as there is time remaining and work to do.</span></div><div class="line">  <span class="keyword">while</span> (deadline.timeRemaining() &gt; <span class="number">0</span> &amp;&amp; eventsToSend.length &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">var</span> evt = eventsToSend.pop();</div><div class="line"></div><div class="line">    ga(<span class="string">'send'</span>, <span class="string">'event'</span>,</div><div class="line">        evt.category,</div><div class="line">        evt.action,</div><div class="line">        evt.label,</div><div class="line">        evt.value);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Check if there are more events still to send.</span></div><div class="line">  <span class="keyword">if</span> (eventsToSend.length &gt; <span class="number">0</span>)</div><div class="line">    schedulePendingEvents();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对于这个例子，我假设如果 <code>requestIdleCallback</code> 不存在分析数据应该立即发送。然而，在生产应用程序中，延迟发送超时可能会更好，以确保它不会与任何交互冲突，并导致 jank。</p><h2 id="使用-requestIdleCallback-进行-DOM-更改"><a href="#使用-requestIdleCallback-进行-DOM-更改" class="headerlink" title="使用 requestIdleCallback 进行 DOM 更改"></a>使用 <code>requestIdleCallback</code> 进行 DOM 更改</h2><p>另一种 <code>requestIdleCallback</code> 真正有助于表现的情况是当您进行非必要的 DOM 更改时，例如将项目添加到不断增长的惰性列表的末尾。我们来看一下如何将 requestIdleCallback 实际应用在一个典型的框架。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://developers.google.com/web/updates/images/2015-08-27-using-requestidlecallback/frame.jpg" data-original="https://developers.google.com/web/updates/images/2015-08-27-using-requestidlecallback/frame.jpg"></p><p>浏览器可能太忙，无法在给定的框架中运行任何回调，所以您不应该期望在框架结尾处有任何空闲时间来执行任何更多的工作。这使得它不同于 <code>setImmediate</code> 这类每帧都运行的东西。</p><p>如果回调在框架结束时被触发，它将被调度到当前帧已经提交之后，这意味着将应用样式更改，并且重要的是布局计算。如果我们在空闲回调内部进行 DOM 更改，这些布局计算将无效。如果有任何读取下一帧布局的事件，例如 <code>getBoundingClientRect</code>，<code>clientWidth</code>等等，浏览器将不得不进行<a href="https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing#avoid-forced-synchronous-layouts" target="_blank" rel="noopener">强制同步布局</a>，这是一个潜在的性能瓶颈。</p><p>不要在空闲回调中 DOM 更改的另一个原因是更改 DOM 的时间影响是不可预测的，因此我们可以很容易地超过浏览器提供的期限。</p><p>最好的做法是只能在 <code>requestAnimationFrame</code> 回调内部进行 DOM 更改，因为它是由浏览器安排的那种类型的工作。这意味着我们的代码将需要使用一个文档片段，然后可以将其附加在下一个 <code>requestAnimationFrame</code> 回调中。如果您正在使用 VDOM 库，则可以使用 <code>requestIdleCallback</code> 进行更改，但是您可以在下一个回调中应用 DOM 修补程序 <code>requestAnimationFrame</code>，而不是空闲回调。</p><p>所以考虑到这一点，让我们来看看代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">processPendingElements</span> (<span class="params">deadline</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// If there is no deadline, just run as long as necessary.</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> deadline === <span class="string">'undefined'</span>)</div><div class="line">    deadline = &#123; <span class="attr">timeRemaining</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">Number</span>.MAX_VALUE &#125; &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!documentFragment)</div><div class="line">    documentFragment = <span class="built_in">document</span>.createDocumentFragment();</div><div class="line"></div><div class="line">  <span class="comment">// Go for as long as there is time remaining and work to do.</span></div><div class="line">  <span class="keyword">while</span> (deadline.timeRemaining() &gt; <span class="number">0</span> &amp;&amp; elementsToAdd.length &gt; <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">    <span class="comment">// Create the element.</span></div><div class="line">    <span class="keyword">var</span> elToAdd = elementsToAdd.pop();</div><div class="line">    <span class="keyword">var</span> el = <span class="built_in">document</span>.createElement(elToAdd.tag);</div><div class="line">    el.textContent = elToAdd.content;</div><div class="line"></div><div class="line">    <span class="comment">// Add it to the fragment.</span></div><div class="line">    documentFragment.appendChild(el);</div><div class="line"></div><div class="line">    <span class="comment">// Don't append to the document immediately, wait for the next</span></div><div class="line">    <span class="comment">// requestAnimationFrame callback.</span></div><div class="line">    scheduleVisualUpdateIfNeeded();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Check if there are more events still to send.</span></div><div class="line">  <span class="keyword">if</span> (elementsToAdd.length &gt; <span class="number">0</span>)</div><div class="line">    scheduleElementCreation();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在这里我创建元素并使用该 <code>textContent</code> 属性来填充它，但是您的元素创建代码可能会更多的操作！在创建元素后 <code>scheduleVisualUpdateIfNeeded</code>，调用该元素将会建立一个单独的 <code>requestAnimationFrame</code> 回调，然后依次将文档片段附加到正文中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleVisualUpdateIfNeeded</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (isVisualUpdateScheduled)</div><div class="line">    <span class="keyword">return</span>;</div><div class="line"></div><div class="line">  isVisualUpdateScheduled = <span class="literal">true</span>;</div><div class="line"></div><div class="line">  requestAnimationFrame(appendDocumentFragment);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">appendDocumentFragment</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// Append the fragment and reset.</span></div><div class="line">  <span class="built_in">document</span>.body.appendChild(documentFragment);</div><div class="line">  documentFragment = <span class="literal">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>一切顺利，我们现在将把项目附加到 DOM 时看起来更少 jank。优秀！</p><h2 id="常问问题"><a href="#常问问题" class="headerlink" title="常问问题"></a>常问问题</h2><ul><li>是否有 polyfill？ 可悲的是，没有。如果你想要透明的重定向到 <code>setTimeout</code>，那就有一个 <code>shim</code> 。该API存在的原因是因为它在Web平台中插入了非常真实的差距。但是没有JavaScript API来确定框架结束时的空闲时间，所以最多只能做出猜测。像 <code>setTimeout</code>，<code>setInterval</code> 或者 <code>setImmediate</code> 这样的 API 可以用于调度工作，但是并不是按照 <code>requestIdleCallback</code> 这样的方式避开用户交互。</li><li>如果我设置 <code>timeout</code>，会发生什么？ 如果 <code>timeRemaining()</code> 返回零，但是您选择运行更长时间，您可以这样做，而不用担心浏览器停止工作。但是，浏览器为您提供了最终期限，以确保您的用户顺利体验，因此除非有非常好的理由，否则您应始终遵守最终期限。</li><li><code>timeRemaining()</code> 会返回有最大值吗？ 是的，现在是 <code>50ms</code> 。在尝试维护响应式应用程序时，所有对用户交互的响应应保持在 100ms 以下。如果用户在 50ms 窗口中进行交互，在大多数情况下应允许空闲回调完成，并且浏览器可以响应用户的交互。您可能会得到多个空闲的回调（如果浏览器确定有足够的时间来运行它们），那么它们将被一个个安排。</li><li>有没有什么工作我不应该在 <code>requestIdleCallback</code> 里执行？ 理想情况下，您所做的工作应该是具有相对可预测特征的小块（微任务）。例如，特别是更改 DOM 将具有不可预测的执行时间，因为它将触发样式计算，布局，绘画和合成。因此，您应该仅在上述 requestAnimationFrame 回调中进行 DOM 更改。要注意的另一件事是解决（或拒绝）Promises，因为在空闲回调完成后回调将立即执行，即使没有更多的时间剩余。</li><li>我会总是在一帧结束时被执行 <code>requestIdleCallback</code> ？不，不总是。浏览器将在帧结束时的空闲时间或用户处于非活动状态的时段内调度回调。您不应该期望每帧调用回调，并且如果要求它在给定的时间范围内运行，则应该使用超时。</li><li>我可以有多个 <code>requestIdleCallback</code> 回调吗？ 是的，你可以拥有非常多个 <code>requestAnimationFrame</code> 回调。值得记住的是，如果你的第一个回调使用了它在回调期间的剩余时间，那么任何其他回调都不会有更多的时间。然后，其他回调将不得不等待浏览器下一个空闲，才能运行。根据您要完成的工作，可能会有一个空闲的回调，并将工作分配到那里。或者，您可以使用超时时间来确保回调都有机会执行。</li><li>如果我在另一个内部设置一个新的空闲回调，会发生什么？ 新的空闲回调将被安排尽快运行，从下一个帧开始（而不是当前的）。</li></ul><h2 id="利用空闲"><a href="#利用空闲" class="headerlink" title="利用空闲"></a>利用空闲</h2><p><code>requestIdleCallback</code> 是一个非常棒的方法，以确保您可以运行您的代码，但没有阻碍用户的交互。使用起来很简单，非常灵活。但仍然属于早期，而且规范还没有完全解决，所以你所提供的任何反馈都是值得欢迎的。</p><p>【翻译原文】:<a href="https://developers.google.com/web/updates/2015/08/using-requestidlecallback" target="_blank" rel="noopener">useing requestIdleCallback</a></p><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用-requestIdleCallback&quot;&gt;&lt;a href=&quot;#使用-requestIdleCallback&quot; class=&quot;headerlink&quot; title=&quot;使用 requestIdleCallback&quot;&gt;&lt;/a&gt;使用 requestIdleCallback&lt;/h1&gt;&lt;p&gt;许多网站和应用程序都有很多脚本来执行。您的 JavaScript 通常需要尽快运行，但同时您不希望它阻碍用户那条路。如果您在用户滚动页面时发送分析数据，或者在轻触按钮时将元素附加到 DOM，则您的 Web 应用程序将无法响应，从而导致用户体验不佳。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://developers.google.com/web/updates/images/2015-08-27-using-requestidlecallback/main.png&quot; alt=&quot;https://developers.google.com/web/updates/images/2015-08-27-using-requestidlecallback/main.png&quot;&gt;&lt;/p&gt;&lt;p&gt;好消息是，现在有一个 API 可以帮助：&lt;code&gt;requestIdleCallback&lt;/code&gt;。以同样的方式，&lt;code&gt;requestAnimationFrame&lt;/code&gt; 我们可以正确地安排动画，并最大限度地提高 60fps 的机会，&lt;code&gt;requestIdleCallback&lt;/code&gt; 当一个框架结束时，或当用户处于非活动状态时，可以安排工作。这意味着有机会在用户不使用的情况下进行工作。它可用于 Chrome 47！这是一个实验性的功能，规格还在不断变化，所以将来会发生变化。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="performance" scheme="http://robin-front.github.io/tags/performance/"/>
    
      <category term="optimization" scheme="http://robin-front.github.io/tags/optimization/"/>
    
      <category term="requestIdleCallback" scheme="http://robin-front.github.io/tags/requestIdleCallback/"/>
    
  </entry>
  
  <entry>
    <title>IntersectionObserver API</title>
    <link href="http://robin-front.github.io/2017/08/24/intersectionobserver/"/>
    <id>http://robin-front.github.io/2017/08/24/intersectionobserver/</id>
    <published>2017-08-24T01:59:34.000Z</published>
    <updated>2017-08-24T01:59:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IntersectionObserver"><a href="#IntersectionObserver" class="headerlink" title="IntersectionObserver"></a>IntersectionObserver</h1><p>假设你想追踪 DOM 里的一个元素是否进入 <a href="https://en.wikipedia.org/wiki/Viewport" target="_blank" rel="noopener">viewport</a> 的可视区。你做这件事可能是因为你想在这个时机 lazyload 图片或者你需要知道用户是否真的在看一个某个广告横幅。你可以通过添加 <code>scroll</code> 事件钩子或使用定时器去调用元素的 <code>getBoundingClientRect()</code> 方法。然而，这种方法真的很慢，因为每次调用 <code>getBoundingClientRect()</code> <a href="https://gist.github.com/paulirish/5d52fb081b3570c81e3a" target="_blank" rel="noopener">会造成浏览器 re-layout 当前页面</a> 并会在你的页面造成很大的卡顿和闪烁。 <code>iframe</code> 里的元素是否可见这样的事情几乎很难做到。 基于单一源模型，浏览器不会让你访问包含 <code>iframe</code> 的页面的任何数据。这是频繁使用 <code>iframe</code> 加载广告的常见问题。</p><p>为了让可见度测试更有效率， <a href="https://wicg.github.io/IntersectionObserver/" target="_blank" rel="noopener">IntersectionObserver</a> 被设计出来了。<code>IntersectionObserver</code> 让你知道观察的元素何时进入或退出浏览器 <code>viewport</code>。<a id="more"></a></p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://developers.google.com/web/updates/images/2016/04/intersectionobserver/iframe.gif" data-original="https://developers.google.com/web/updates/images/2016/04/intersectionobserver/iframe.gif"></p><h2 id="如何创建一个-IntersectionObserver"><a href="#如何创建一个-IntersectionObserver" class="headerlink" title="如何创建一个 IntersectionObserver"></a>如何创建一个 IntersectionObserver</h2><p>API 相当简单，例子一看就懂：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> io = <span class="keyword">new</span> IntersectionObserver(</div><div class="line">    <span class="function"><span class="params">entries</span> =&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(entries);</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        <span class="comment">/* 使用默认选项，详细在下面会介绍 */</span></div><div class="line">    &#125;</div><div class="line">);</div><div class="line"><span class="comment">// 开始观察一个元素</span></div><div class="line">io.observe(element);</div><div class="line"></div><div class="line"><span class="comment">// 停止观察一个元素</span></div><div class="line"><span class="comment">// io.unobserve(element);</span></div><div class="line"></div><div class="line"><span class="comment">// 禁用整个 IntersectionObserver</span></div><div class="line"><span class="comment">// io.disconnect();</span></div></pre></td></tr></table></figure><p>使用默认选项，回调会在元素进入和完全退出 <code>viewport</code> 的时候触发。</p><p>如果你需要观察多个元素，建议在同一个 <code>IntersectionObserver</code> 实例上多次调用 <code>observe()</code> 来观察多个元素，这也是允许的调用方式。</p><p>回调函数回传的参数是一个数组对象 <a href="https://wicg.github.io/IntersectionObserver/#intersection-observer-entry" target="_blank" rel="noopener"><code>IntersectionObserverEntry</code></a> 。每个这样的对象都包含了每个观察元素的最新数据。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">🔽[IntersectionObserverEntry]</div><div class="line">  🔽 0: IntersectionObserverEntry</div><div class="line">       time: 3893.92</div><div class="line">    🔽 rootBounds: ClientRect</div><div class="line">        bottom: 920</div><div class="line">        height: 1024</div><div class="line">        left: 0</div><div class="line">        right: 1024</div><div class="line">        top: 0</div><div class="line">        width: 920</div><div class="line">    🔽 boundingClientRect: ClientRect</div><div class="line">       // ...</div><div class="line">    🔽 intersectionRect: ClientRect</div><div class="line">       // ...</div><div class="line">      intersectionRatio: 0.54</div><div class="line">    🔽 target: div#observee</div><div class="line">       // ...</div></pre></td></tr></table></figure><ul><li><a href="https://wicg.github.io/IntersectionObserver/#dom-intersectionobserverentry-rootbounds" target="_blank" rel="noopener"><code>rootBounds</code></a> 是对 root 元素调用 <code>getBoundingClientRect</code> 的结果，默认 root 元素是 viewport 。</li><li><a href="https://wicg.github.io/IntersectionObserver/#dom-intersectionobserverentry-boundingclientrect" target="_blank" rel="noopener"><code>boundingClientRect</code></a> 是被观察元素调用 <code>getBoundingClientRect</code> 的结果。</li><li><a href="https://wicg.github.io/IntersectionObserver/#dom-intersectionobserverentry-intersectionrect" target="_blank" rel="noopener"><code>intersectionRect</code></a> 是两个矩形的交叉部分，可能有效地告诉你被观察的元素的哪一部分是可见的。</li><li><a href="https://wicg.github.io/IntersectionObserver/#dom-intersectionobserverentry-intersectionratio" target="_blank" rel="noopener"><code>intersectionRatio</code></a> 是最相关的，告诉你元素有百分之几是可见的。</li></ul><p>有了这些信息，你现在可以实现元素进入 viewport 前及时加载的特性。非常有用。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://developers.google.com/web/updates/images/2016/04/intersectionobserver/intersectratio.png" data-original="https://developers.google.com/web/updates/images/2016/04/intersectionobserver/intersectratio.png"></p><p><code>IntersectionObservers</code> 是异步推送他们的数据，而回调是运行在主线程的。另外，规范提到 <code>IntersectionObserver</code> 应该使用 <a href="https://wicg.github.io/IntersectionObserver/#queue-intersection-observer-task" target="_blank" rel="noopener"><code>requestIdleCallback()</code></a>。 这意味着调用回调函数的优先级是非常低的，只会在浏览器有空闲的时候调用。这是有意设计的。</p><h2 id="Scrolling-divs"><a href="#Scrolling-divs" class="headerlink" title="Scrolling divs"></a>Scrolling divs</h2><p>我并不喜欢在 div 中滚动元素, 但我不会用 <code>scroll</code> 判定, 而是用 <code>IntersectionObserver</code>。 <a href="https://wicg.github.io/IntersectionObserver/#dictdef-intersectionobserverinit" target="_blank" rel="noopener"><code>option</code></a> 对象有一个 <a href="https://wicg.github.io/IntersectionObserver/#dom-intersectionobserverinit-root" target="_blank" rel="noopener"><code>root</code></a> 选项让你定义一个代替 viewport 的 root 元素。需要记住的是，要保证 root 元素是所有被观察元素的祖先。</p><h2 id="重叠所有元素"><a href="#重叠所有元素" class="headerlink" title="重叠所有元素"></a>重叠所有元素</h2><p>不！那是糟糕的开发者！请注意使用用户的 CPU 周期。让我们考虑一下无限滚动的例子： 在脚本中，添加一个哨兵来观察和回收是明智的选择。你应该在无限滚动的最后一个元素添加哨兵。当哨兵快要进入 viewport 的时候，在回调函数中加载数据，创建接下来的元素，并添加到哨兵之前的 DOM 结构中。如果重复利用哨兵，不需要再调用 <code>observe()</code>， <code>IntersectionObserver</code> 仍然会继续工作。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://developers.google.com/web/updates/images/2016/04/intersectionobserver/infinitescroller.png" data-original="https://developers.google.com/web/updates/images/2016/04/intersectionobserver/infinitescroller.png"></p><h3 id="更多地更新与回调调用"><a href="#更多地更新与回调调用" class="headerlink" title="更多地更新与回调调用"></a>更多地更新与回调调用</h3><p>就像前面提到的，当被监听元素进入或离开 viewport 的时候，回调函数会分别单次触发。 这让<code>IntersectionObserver</code> 可以给你这个问题的答案，“元素 X 是否在视图中？”。但在某些场景中，这还不够。</p><p><a href="https://wicg.github.io/IntersectionObserver/#dom-intersectionobserverinit-threshold" target="_blank" rel="noopener"><code>theshold</code></a> 选项登场。它允许你定义一个 <a href="https://wicg.github.io/IntersectionObserver/#dom-intersectionobserverentry-intersectionratio" target="_blank" rel="noopener"><code>intersectionRatio</code></a> 阈值数组。当达到每一个 <code>intersectionRatio</code> 值时，回调函数都会被调用。<code>theshold</code> 默认值是 <code>[0]</code>，就是我们解释的默认表现。当设定 <code>theshold</code> 为 <code>[0, 0.25, 0.5, 0.75, 1]</code>, 我们会在元素每四分之一的部分进入 viewport 时得到通知。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://developers.google.com/web/updates/images/2016/04/intersectionobserver/threshold.gif" data-original="https://developers.google.com/web/updates/images/2016/04/intersectionobserver/threshold.gif"></p><h3 id="还有其他问题吗？"><a href="#还有其他问题吗？" class="headerlink" title="还有其他问题吗？"></a>还有其他问题吗？</h3><p>到现在为止，还有一个选项没有被提到。<a href="https://wicg.github.io/IntersectionObserver/#dom-intersectionobserverinit-rootmargin" target="_blank" rel="noopener"><code>rootMargin</code></a> 允许你指定 <code>root</code> 元素的 <code>margin</code>，有效地允许你增加或缩减实际的交叉区域。<code>margin</code> 使用 css-style 的规则， <code>10px 20px 30px 40px</code> 分别表示上、右、下、左。总的来说，<code>IntersectionObserver</code> 的选项总结如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> IntersectionObserver(<span class="function"><span class="params">entries</span> =&gt;</span> &#123;<span class="comment">/* … */</span>&#125;, &#123;</div><div class="line">  <span class="comment">// The root to use for intersection.</span></div><div class="line">  <span class="comment">// If not provided, use the top-level document’s viewport.</span></div><div class="line">  root: <span class="literal">null</span>,</div><div class="line">  <span class="comment">// Same as margin, can be 1, 2, 3 or 4 components, possibly negative lengths.  </span></div><div class="line">  <span class="comment">// If an explicit root element is specified, components may be percentages of the</span></div><div class="line">  <span class="comment">// root element size.  If no explicit root element is specified, using a percentage</span></div><div class="line">  <span class="comment">// is an error.</span></div><div class="line">  rootMargin: <span class="string">"0px"</span>,</div><div class="line">  <span class="comment">// Threshold(s) at which to trigger callback, specified as a ratio, or list of</span></div><div class="line">  <span class="comment">// ratios, of (visible area / total area) of the observed element (hence all</span></div><div class="line">  <span class="comment">// entries must be in the range [0, 1]).  Callback will be invoked when the visible</span></div><div class="line">  <span class="comment">// ratio of the observed element crosses a threshold in the list.</span></div><div class="line">  threshold: [<span class="number">0</span>],</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3 id="iframe-魔法"><a href="#iframe-魔法" class="headerlink" title="iframe 魔法"></a>iframe 魔法</h3><p><code>IntersectionObserver</code> 被设计时明确考虑广告服务和网络社交服务，可能经常会用到 <code>iframe</code> 和有益于知道他们是否在看。如果观察 <code>iframe</code> 中的元素，那么滚动 <code>iframe</code> 和滚动父页面都可以在适当的时候触发回调函数。对于后者， <code>rootBounds</code> 将被设置为 <code>null</code> 以避免数据源泄漏。</p><h2 id="IntersectionObserver-不是什么？"><a href="#IntersectionObserver-不是什么？" class="headerlink" title="IntersectionObserver 不是什么？"></a><code>IntersectionObserver</code> 不是什么？</h2><p>需要知道的是， <code>IntersectionObserver</code> 是被故意设置成不完美和低延迟的。使用它们努力实现像滚动动画之类是注定会失败的。因为严格地说，当你获得数据时，数据已经过时了。这里有更多的关于 <code>IntersectionObserver</code> <a href="https://github.com/WICG/IntersectionObserver/blob/gh-pages/explainer.md" target="_blank" rel="noopener">原始用例</a>。</p><h2 id="可以在-callback-中做多少事情"><a href="#可以在-callback-中做多少事情" class="headerlink" title="可以在 callback 中做多少事情"></a>可以在 <code>callback</code> 中做多少事情</h2><p>在回调中花太多时候会让你的应用滞后，和常见的实践一样。</p><h2 id="使用-IntersectionObserver"><a href="#使用-IntersectionObserver" class="headerlink" title="使用 IntersectionObserver"></a>使用 IntersectionObserver</h2><p>对于 <code>IntersectionObserver</code>，浏览器的支持仍然很弱，所以它不会马上被普遍应用。同时，<a href="https://github.com/WICG/IntersectionObserver" target="_blank" rel="noopener">WICG</a> 的 polyfill 也被建立起来。显然，使用 polyfill 不如原生实现的效率好。</p><blockquote><p>Except as otherwise noted, the content of this page is licensed under the Creative Commons Attribution 3.0 License, and code samples are licensed under the Apache 2.0 License. For details, see our Site Policies. Java is a registered trademark of Oracle and/or its affiliates. 上次更新日期：六月 5, 2017</p></blockquote><p>【翻译原文】： <a href="https://developers.google.com/web/updates/2016/04/intersectionobserver" target="_blank" rel="noopener">intersectionobserver</a></p><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IntersectionObserver&quot;&gt;&lt;a href=&quot;#IntersectionObserver&quot; class=&quot;headerlink&quot; title=&quot;IntersectionObserver&quot;&gt;&lt;/a&gt;IntersectionObserver&lt;/h1&gt;&lt;p&gt;假设你想追踪 DOM 里的一个元素是否进入 &lt;a href=&quot;https://en.wikipedia.org/wiki/Viewport&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;viewport&lt;/a&gt; 的可视区。你做这件事可能是因为你想在这个时机 lazyload 图片或者你需要知道用户是否真的在看一个某个广告横幅。你可以通过添加 &lt;code&gt;scroll&lt;/code&gt; 事件钩子或使用定时器去调用元素的 &lt;code&gt;getBoundingClientRect()&lt;/code&gt; 方法。然而，这种方法真的很慢，因为每次调用 &lt;code&gt;getBoundingClientRect()&lt;/code&gt; &lt;a href=&quot;https://gist.github.com/paulirish/5d52fb081b3570c81e3a&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;会造成浏览器 re-layout 当前页面&lt;/a&gt; 并会在你的页面造成很大的卡顿和闪烁。 &lt;code&gt;iframe&lt;/code&gt; 里的元素是否可见这样的事情几乎很难做到。 基于单一源模型，浏览器不会让你访问包含 &lt;code&gt;iframe&lt;/code&gt; 的页面的任何数据。这是频繁使用 &lt;code&gt;iframe&lt;/code&gt; 加载广告的常见问题。&lt;/p&gt;&lt;p&gt;为了让可见度测试更有效率， &lt;a href=&quot;https://wicg.github.io/IntersectionObserver/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IntersectionObserver&lt;/a&gt; 被设计出来了。&lt;code&gt;IntersectionObserver&lt;/code&gt; 让你知道观察的元素何时进入或退出浏览器 &lt;code&gt;viewport&lt;/code&gt;。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="lazyload" scheme="http://robin-front.github.io/tags/lazyload/"/>
    
      <category term="performance" scheme="http://robin-front.github.io/tags/performance/"/>
    
      <category term="optimization" scheme="http://robin-front.github.io/tags/optimization/"/>
    
      <category term="IntersectionObserver" scheme="http://robin-front.github.io/tags/IntersectionObserver/"/>
    
  </entry>
  
  <entry>
    <title>使用 intersection observer 延迟加载图片</title>
    <link href="http://robin-front.github.io/2017/08/18/lazy-loading-images-using-intersection-observer/"/>
    <id>http://robin-front.github.io/2017/08/18/lazy-loading-images-using-intersection-observer/</id>
    <published>2017-08-18T02:14:15.000Z</published>
    <updated>2017-08-18T02:14:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-intersection-observer-延迟加载图片"><a href="#使用-intersection-observer-延迟加载图片" class="headerlink" title="使用 intersection observer 延迟加载图片"></a>使用 intersection observer 延迟加载图片</h1><p>如果您还没有看过，Paul Lewis 组织了一个令人敬畏的视频系列，演示如何构建媒体播放器以及拥有非常棒的特性的 Progressive Web Apps。他在YouTube上建立了<a href="https://www.youtube.com/playlist?list=PLNYkxOF6rcIBykcJ7bvTpqU7vt-oey72J" target="_blank" rel="noopener">一系列视频</a>，这些视频是在他建立网站的每一部分的过程中发生的。观看开发者展示他们工作的视频绝对是我最喜欢学习新事物的方法之一！</p><a id="more"></a><p>当他在演示他的代码时，我注意到他创建了一个出色的 helper 库来延迟加载图像。我一直在寻找改善我网站性能的方法，这无疑引起了我的兴趣。</p><h2 id="与懒惰加载有什么关系？"><a href="#与懒惰加载有什么关系？" class="headerlink" title="与懒惰加载有什么关系？"></a>与懒惰加载有什么关系？</h2><p>延迟加载图像背后的想法是，您等到用户向下滚动页面，并图像进入视图之前，再为这个图片发起网络请求。如果您的网页包含多个图像，但是只有在图像滚动到视图时才加载每个图像，您将最终节省带宽，并确保您的网页加载更快。</p><p>为了给你一个这样的想法，我们来想象下面有三个图像的页面。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://307a6ed092846b809be7-9cfa4cf7c673a59966ad8296f4c88804.ssl.cf3.rackcdn.com/intersection-observer/intersection-observer.png" data-original="https://307a6ed092846b809be7-9cfa4cf7c673a59966ad8296f4c88804.ssl.cf3.rackcdn.com/intersection-observer/intersection-observer.png"></p><p>如果用户登陆页面并且仅查看第一张图像，我们不想加载页面底部比萨的图像，直到用户向下滚动，并且等到图像真正在视图中。如果我们懒惰加载图像，这意味着用户只需要下载他们需要的东西，这使您的网页更精简。</p><p>对于更有经验的开发人员，您可能会熟悉延迟加载图像，毕竟这个概念已经有一段时间了。那么有什么新概念吗？！有很多懒加载库做得很好。我甚至以前在这个博客上写了一篇（<a href="https://deanhume.com/Home/BlogPost/lazy-loading-images-with-jquery/22" target="_blank" rel="noopener">很多年前</a>）。问题在于，几乎所有这些库都会绑定滚动事件，或者使用定时器来检查元素的边界，然后再确定是否在视图中。这种方法的问题是它强制浏览器重新布局（re-layout）整个页面，并且在某些情况下，您的网站会引起相当大的性能损失。我们可以做得更好！</p><h2 id="INTERSECTION-OBSERVER-来抢救！"><a href="#INTERSECTION-OBSERVER-来抢救！" class="headerlink" title="INTERSECTION OBSERVER 来抢救！"></a>INTERSECTION OBSERVER 来抢救！</h2><p>这是就是 Intersection Observer 的用处。Intersection Observer 内置于大多数现代浏览器中，让您知道被观察的元素何时进入或退出浏览器的视口。这使得它非常理想，因为它能够异步传输数据，并且不会影响主线程，使其成为提供反馈的有效手段。</p><p>在 <a href="https://github.com/googlechrome/sample-media-pwa" target="_blank" rel="noopener">Paul 的例子</a>中，他演示了如何使用 Intersection Observer 来延迟加载进入视口图像。我已经获取了他的初始代码，并稍微调整了一点，使我更容易理解。在本文中，我将通过了解 Intersection Observer 的基础知识，并向您展示如何以超级高效的方式做到延迟加载图像。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>想象一下一个基本的HTML页面，其中包含三个与上述相似的图像。在网页上，您将具有与以下熟悉的图像元素代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"js-lazy-image"</span> <span class="attr">data-src</span>=<span class="string">"burger.png"</span>&gt;</span></div></pre></td></tr></table></figure><p>您可能会注意到，在上面的代码中，图像文件没有 <code>src</code> 属性。这是因为它正在使用一个名为 <code>data-src</code> 的数据属性来指向图像源。当进入视口时，我们将使用它来加载图像。您还可能会注意到，图像元素还具有一个名为 “js-lazy-image” 的类 - 我们将在 JavaScript 代码中尽快使用这个类，以确定要延迟加载的元素。</p><p>接下来，我们需要创建将在页面上加载图像的代码。在我们的 JavaScript 文件中，我们需要创建一个新的 Intersection Observer 。</p><script src="https://gist.github.com/deanhume/1da60330fa8f6dc3d0f4885168a48f9e.js"></script><p>上面的例子看起来像很多代码，但是让我们一步一步地分解它。首先，我正在选择页面上具有类“js-lazy-image”的所有图像。接下来，我正在创建一个新的 <em>IntersectionObserver</em>，并使用它来观察我们选择的具有类“js-lazy-image”的所有图像。使用 <em>IntersectionObserver</em> 的默认选项，当元素部分进入视图或完全离开视口时，您的回调都将被调用。在这种情况下，我将几个额外的配置选项传递给 <em>IntersectionObserver</em>。使用 <code>rootMargin</code> 允许您指定根的边距，有效地允许您增加或缩小用于观察交点的区域。我们想确保如果图像在Y轴上的50像素内，我们将开始下载。</p><p>现在我们已经创建了一个 Intersection Observer，并且正在观察页面上的图像，我们可以进入到该元素进入视图时被触发的 intersection 事件。</p><script src="https://gist.github.com/deanhume/768666a8b37dce069d5ce7839100a4e4.js"></script><p>在上面的代码中，只要我们观察到的元素进入用户视口，<code>onIntersection</code> 功能将被触发。此时，我们可以循环查看我们观察到的图像，并确定哪个图像在视口中。如果当前元素处于交叉比例中，我们知道图像在用户视口中，我们可以加载它。加载图像后，我们不需要再观察图像，并且使用 <em><code>unobserve()</code></em> 将其从 Intersection Observer 中的条目列表中删除。</p><p>就是这样！一旦用户滚动并且图像进入视图，则将加载适当的图像。这个代码最好的办法是 Intersection Observer 比巴里·怀特（Barry White）更平滑。我尽量保持尽可能简洁的代码，但如果您想看到完整版本，我已经创建了一个Github repo，其中包含了一个<a href="https://deanhume.github.io/lazy-observer-load/" target="_blank" rel="noopener">有效的例子</a>。</p><h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><p>在这一点上，您可能会想知道浏览器对此功能的支持。<a href="http://caniuse.com/#feat=intersectionobserver" target="_blank" rel="noopener">Edge，Firefox，Chrome和Opera</a>目前支持 Intersection Observer，这是一个好消息。</p><p>但是，为了确保不支持此功能的浏览器的代码不会报错，我们可以使用功能检测来确定我们如何加载图像。我们来看看下面的代码。</p><script src="https://gist.github.com/deanhume/948c59af68c86da9d3b3f2955747a651.js"></script><p>在上面的代码中，我们正在检查 <em>IntersectionObserver</em> 是否在当前浏览器中可用，如果不支持我们只是简单地立即加载图像，否则我们使用我们的默认行为。</p><p>如果您真的喜欢 <em>IntersectionObserver</em> API 的简便性，并且想要使用 polyfill，则 WICG 已创建一个可在 <a href="https://github.com/WICG/IntersectionObserver/tree/gh-pages/polyfill" target="_blank" rel="noopener">Github repository</a> 中使用的功能。唯一的缺点是您不会获得原生实现给您的性能优势。</p><p>您甚至可以采取进一步措施，并为 <a href="https://www.robinosborne.co.uk/2016/05/16/lazy-loading-images-dont-rely-on-javascript/#a-no-JavaScript" target="_blank" rel="noopener">Robin Osborne</a> 建议的未启用 JavaScript 的用户添加支持。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中，我们已经使用 <em>IntersectionObserver</em> 来延迟加载图像，但是您可以使用它来进行更多操作。它可以用于确定某人是否正在查看广告，或者即使是在iFrame中的元素。易于理解的API使其可以打开许多选项。</p><p>如果您想了解有关交叉点观察者的更多信息，我建议您在Google Developers网站上阅读<a href="https://developers.google.com/web/updates/2016/04/intersectionobserver" target="_blank" rel="noopener">这篇有关信息</a>的文章。我还强烈建议在 Youtube 上观看<a href="https://www.youtube.com/watch?v=ncYQkOrKTaI&amp;list=PLNYkxOF6rcIBykcJ7bvTpqU7vt-oey72J&amp;index=7" target="_blank" rel="noopener">保罗·刘易斯的视频系列</a>，它包含了很棒的提示，你一定会学到一些东西。</p><p>【翻译原文】: <a href="https://deanhume.com/Home/BlogPost/lazy-loading-images-using-intersection-observer/10163" target="_blank" rel="noopener">LAZY LOADING IMAGES USING INTERSECTION OBSERVER</a></p><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用-intersection-observer-延迟加载图片&quot;&gt;&lt;a href=&quot;#使用-intersection-observer-延迟加载图片&quot; class=&quot;headerlink&quot; title=&quot;使用 intersection observer 延迟加载图片&quot;&gt;&lt;/a&gt;使用 intersection observer 延迟加载图片&lt;/h1&gt;&lt;p&gt;如果您还没有看过，Paul Lewis 组织了一个令人敬畏的视频系列，演示如何构建媒体播放器以及拥有非常棒的特性的 Progressive Web Apps。他在YouTube上建立了&lt;a href=&quot;https://www.youtube.com/playlist?list=PLNYkxOF6rcIBykcJ7bvTpqU7vt-oey72J&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一系列视频&lt;/a&gt;，这些视频是在他建立网站的每一部分的过程中发生的。观看开发者展示他们工作的视频绝对是我最喜欢学习新事物的方法之一！&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="lazyload" scheme="http://robin-front.github.io/tags/lazyload/"/>
    
      <category term="performance" scheme="http://robin-front.github.io/tags/performance/"/>
    
      <category term="optimization" scheme="http://robin-front.github.io/tags/optimization/"/>
    
      <category term="IntersectionObserver" scheme="http://robin-front.github.io/tags/IntersectionObserver/"/>
    
  </entry>
  
  <entry>
    <title>你可能不知道的JSON用法及误区</title>
    <link href="http://robin-front.github.io/2017/07/28/you-may-dont-know-JSON/"/>
    <id>http://robin-front.github.io/2017/07/28/you-may-dont-know-JSON/</id>
    <published>2017-07-28T01:17:36.000Z</published>
    <updated>2017-07-28T01:17:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="再谈-JSON-你可能不知道的一些-JSON-用法及误区"><a href="#再谈-JSON-你可能不知道的一些-JSON-用法及误区" class="headerlink" title="再谈 JSON, 你可能不知道的一些 JSON 用法及误区"></a>再谈 JSON, 你可能不知道的一些 JSON 用法及误区</h1><p>最近也是看到很多人在讨论 <code>JSON</code>, 但有些点说得不太准确，翻翻犀牛书，再次复习一下。</p><h2 id="JSON-stringify-value-replacer-space"><a href="#JSON-stringify-value-replacer-space" class="headerlink" title="JSON.stringify(value [, replacer [, space]])"></a>JSON.stringify(value [, replacer [, space]])</h2><p>第一个参数一般是对象（Object）或数组（Array），或 <code>javascript</code> 基本值。</p><h3 id="误区：不支持的值都会被忽略"><a href="#误区：不支持的值都会被忽略" class="headerlink" title="误区：不支持的值都会被忽略"></a>误区：不支持的值都会被忽略</h3><p><strong>首先 JSON 只能序列化可枚举的值，其次 <code>undefined</code>，<code>NaN</code>，<code>Infinity</code>，<code>function</code>, <code>Date</code>, <code>RegExp</code>, <code>Error</code> 这些值或对象都是不支持的，但并不是这些值都会被忽略。</strong><a id="more"></a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="built_in">Symbol</span>(), <span class="comment">// 新增的 ES6 基本值</span></div><div class="line">  b: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</div><div class="line">  <span class="attr">c</span>: <span class="literal">undefined</span>,</div><div class="line">  <span class="attr">d</span>: <span class="literal">NaN</span>,</div><div class="line">  <span class="attr">e</span>: <span class="literal">Infinity</span>,</div><div class="line">  <span class="attr">f</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">1</span>;&#125;,</div><div class="line">  <span class="attr">g</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(),</div><div class="line">  <span class="attr">h</span>: <span class="regexp">/^\d$/gi</span>,</div><div class="line">  <span class="attr">i</span>: <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'err'</span>),</div><div class="line">  <span class="attr">j</span>: &#123;&#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">JSON</span>.stringify(o);</div><div class="line"></div><div class="line"><span class="comment">// output: '&#123;"b":[1,2,3],"d":null,"e":null,"g":"2017-07-28T02:56:37.102Z","h":&#123;&#125;,"i":&#123;&#125;,"j":&#123;&#125;&#125;'</span></div></pre></td></tr></table></figure><p>由上可以看出：</p><ul><li><code>Symbol</code>, <code>undefined</code>, <code>function</code> 会直接被忽略</li><li><code>NaN</code>, <code>Infinity</code> 被转换成了 <code>null</code></li><li><code>RegExp</code>, <code>Error</code> 则被转成了空对象 {}</li></ul><h3 id="replacer"><a href="#replacer" class="headerlink" title="replacer"></a>replacer</h3><p>因为 <code>JSON.stringify()</code> 序列化不支持部分值，所以不能简单地使用 <code>JSON</code> 的两个方法进行深拷贝。但可以利用 <code>JSON.stringify()</code> 的第二个参数进行正确序列化。</p><p><strong>但这并不推荐，因为 JSON.parse() 仍然无法还原不被支持的值。只有对象字面量 Object 和 数组 Array 可以被正确还原，其他都变成字符串</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 沿用上一例子的代码</span></div><div class="line"><span class="keyword">var</span> replacer = <span class="function"><span class="keyword">function</span>(<span class="params">k ,v</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> type = <span class="keyword">typeof</span> v;</div><div class="line">  <span class="keyword">if</span>(type === <span class="string">'function'</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Function</span>.prototype.toString.call(v)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (type === <span class="string">'undefined'</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'undefined'</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (type === <span class="string">'number'</span>)&#123;</div><div class="line">    <span class="keyword">if</span> (v !== v)&#123;</div><div class="line">      <span class="keyword">return</span> <span class="string">'NaN'</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (v === <span class="literal">Infinity</span>)&#123;</div><div class="line">      <span class="keyword">return</span> <span class="string">'Infinity'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (type === <span class="string">'symbol'</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Symbol</span>.prototype.toString.call(v)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (v <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">RegExp</span>.prototype.toString.call(v)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (v <span class="keyword">instanceof</span> <span class="built_in">Error</span> &amp;&amp; v.name !== <span class="string">''</span> &amp;&amp; v.message !== <span class="string">''</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'new '</span> + v.name + <span class="string">'('</span>+ v.message +<span class="string">')'</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> v</div><div class="line">&#125;</div><div class="line"><span class="built_in">JSON</span>.stringify(o, replacer);</div><div class="line"></div><div class="line"><span class="comment">//  output: '&#123;"a":"Symbol()","b":[1,2,3],"c":"undefined","d":"NaN","e":"Infinity","f":"function ()&#123; return 1;&#125;","g":"2017-07-28T02:56:37.102Z","h":"/^\\d$/gi","i":"new Error(err)","j":&#123;&#125;&#125;'</span></div></pre></td></tr></table></figure><p>另外一个用法就是传入数组，指定需要序列化的key.这个在提取部分属性的时候也是很有用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 沿用上面的代码</span></div><div class="line"><span class="built_in">JSON</span>.stringify(o, [<span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>]);</div><div class="line"></div><div class="line"><span class="comment">// output: '&#123;"b":[1,2,3],"d":null&#125;'</span></div></pre></td></tr></table></figure><h3 id="space"><a href="#space" class="headerlink" title="space"></a>space</h3><p>是一个可选的美化属性，序列化时是没有换行和空格的，此参数可指定一个数值（大于10则限制为10）或一组字符（长度最长为10个字符), 此参数不为空会自动插入换行。</p><p><strong>但是设置为字符时，无法使用 parse 复原</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">JSON</span>.stringify(o, <span class="literal">null</span>, <span class="string">'-'</span>);</div><div class="line"><span class="comment">// '&#123;</span></div><div class="line"><span class="comment">// -"b": [</span></div><div class="line"><span class="comment">// --1,</span></div><div class="line"><span class="comment">// --2,</span></div><div class="line"><span class="comment">// --3</span></div><div class="line"><span class="comment">// -],</span></div><div class="line"><span class="comment">// -"d": null,</span></div><div class="line"><span class="comment">// -"e": null,</span></div><div class="line"><span class="comment">// -"g": "2017-07-28T02:56:37.102Z",</span></div><div class="line"><span class="comment">// -"h": &#123;&#125;,</span></div><div class="line"><span class="comment">// -"i": &#123;&#125;,</span></div><div class="line"><span class="comment">// -"j": &#123;&#125;</span></div><div class="line"><span class="comment">// &#125;'</span></div></pre></td></tr></table></figure><h2 id="JSON-parse-value-reviver"><a href="#JSON-parse-value-reviver" class="headerlink" title="JSON.parse(value[, reviver])"></a>JSON.parse(value[, reviver])</h2><p><code>JSON.parse</code> 与 <code>JSON.stringify</code> 操作正好相反，但 <code>value</code> 必须严格符合 <code>JSON</code> 格式，否则报错。</p><p>第二个参数可传入一个函数，用以转换解析出来的值。</p><p>比如 <code>Date</code> 对象在序列化之后无法逆转成一个 <code>Date</code> 对象，此时可写一个函数去转换：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reviver = <span class="function"><span class="keyword">function</span> (<span class="params">name, value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="regexp">/^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\d.\d\d\dZ$/</span>.test(value));</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'string'</span> &amp;&amp; <span class="regexp">/^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\d.\d\d\dZ$/</span>.test(value))&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(value)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> value</div><div class="line">&#125;</div><div class="line"><span class="comment">// 沿用前个例子的代码</span></div><div class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(o.g), reviver)</div><div class="line"><span class="comment">// output: Fri Jul 28 2017 10:56:37 GMT+0800 (+08)</span></div></pre></td></tr></table></figure><h2 id="toJSON"><a href="#toJSON" class="headerlink" title="toJSON()"></a>toJSON()</h2><p>有些文章会说 <code>Object.toJSON()</code> ，这是不对的，<code>Object</code> 原型上并没有定义 <code>toJSON</code> 方法，该方法只被定义在 <code>Date</code> 对象上。<code>JSON.stringify()</code> 在序列化的时候会首先查找该方法，如果有则直接返回 <code>toJSON</code> 的调用结果。这个一开始是让 <code>Date</code> 正确序列化成 <code>JSON</code> 时设计的。但我们也可以利用 <code>toJSON</code> 的屏蔽功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.toJSON = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Function</span>.prototype.toString.call(<span class="keyword">this</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 沿用上面的例子</span></div><div class="line"><span class="built_in">JSON</span>.stringify(o);</div><div class="line"><span class="comment">// &#123;"b":[1,2,3],"d":null,"e":null,"f":"function ()&#123; return 1;&#125;","g":"2017-07-28T02:56:37.102Z","h":&#123;&#125;,"i":&#123;&#125;,"j":&#123;&#125;&#125;</span></div></pre></td></tr></table></figure><p>会发现，<code>function</code> 没有被忽略，但此方法要慎用，在原型上添加方法可能产生副作用。</p><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;再谈-JSON-你可能不知道的一些-JSON-用法及误区&quot;&gt;&lt;a href=&quot;#再谈-JSON-你可能不知道的一些-JSON-用法及误区&quot; class=&quot;headerlink&quot; title=&quot;再谈 JSON, 你可能不知道的一些 JSON 用法及误区&quot;&gt;&lt;/a&gt;再谈 JSON, 你可能不知道的一些 JSON 用法及误区&lt;/h1&gt;&lt;p&gt;最近也是看到很多人在讨论 &lt;code&gt;JSON&lt;/code&gt;, 但有些点说得不太准确，翻翻犀牛书，再次复习一下。&lt;/p&gt;&lt;h2 id=&quot;JSON-stringify-value-replacer-space&quot;&gt;&lt;a href=&quot;#JSON-stringify-value-replacer-space&quot; class=&quot;headerlink&quot; title=&quot;JSON.stringify(value [, replacer [, space]])&quot;&gt;&lt;/a&gt;JSON.stringify(value [, replacer [, space]])&lt;/h2&gt;&lt;p&gt;第一个参数一般是对象（Object）或数组（Array），或 &lt;code&gt;javascript&lt;/code&gt; 基本值。&lt;/p&gt;&lt;h3 id=&quot;误区：不支持的值都会被忽略&quot;&gt;&lt;a href=&quot;#误区：不支持的值都会被忽略&quot; class=&quot;headerlink&quot; title=&quot;误区：不支持的值都会被忽略&quot;&gt;&lt;/a&gt;误区：不支持的值都会被忽略&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;首先 JSON 只能序列化可枚举的值，其次 &lt;code&gt;undefined&lt;/code&gt;，&lt;code&gt;NaN&lt;/code&gt;，&lt;code&gt;Infinity&lt;/code&gt;，&lt;code&gt;function&lt;/code&gt;, &lt;code&gt;Date&lt;/code&gt;, &lt;code&gt;RegExp&lt;/code&gt;, &lt;code&gt;Error&lt;/code&gt; 这些值或对象都是不支持的，但并不是这些值都会被忽略。&lt;/strong&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="JSON" scheme="http://robin-front.github.io/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>像 google 一样通过缩短 css 类名和作用域隔离来压缩优化 css 包的大小</title>
    <link href="http://robin-front.github.io/2017/07/24/reducing-css-bundle-size-by-cutting-the-class-names-and-using-scope-isolation/"/>
    <id>http://robin-front.github.io/2017/07/24/reducing-css-bundle-size-by-cutting-the-class-names-and-using-scope-isolation/</id>
    <published>2017-07-24T09:05:01.000Z</published>
    <updated>2017-07-24T09:05:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="像-google-一样通过缩短-css-类名和作用域隔离来压缩优化-css-包的大小"><a href="#像-google-一样通过缩短-css-类名和作用域隔离来压缩优化-css-包的大小" class="headerlink" title="像 google 一样通过缩短 css 类名和作用域隔离来压缩优化 css 包的大小"></a>像 google 一样通过缩短 css 类名和作用域隔离来压缩优化 css 包的大小</h1><blockquote><h2 id="就像-google-的做法一样"><a href="#就像-google-的做法一样" class="headerlink" title="就像 google 的做法一样"></a>就像 google 的做法一样</h2></blockquote><p>今年年初，我已经退出咨询公司并开始构建 <a href="https://go2cinema.com/" target="_blank" rel="noopener">GO2CINEMA</a> - 一个 <em>快速，简单和安全</em> 的方式来预订英国的电影票的网站。我做了一个辉煌的工作，使其快速，简单和安全。在其中某个阶段，我一直痴迷于关键渲染路径的优化。⚡️</p><p>我已经使用 <a href="https://github.com/gajus/usus" target="_blank" rel="noopener">ūsus</a> 解决了 HTML 的预渲染。ūsus 渲染单页应用程序（SPA）的 HTML，并<a href="https://medium.com/@gajus/pre-rendering-spa-for-seo-and-improved-perceived-page-loading-speed-47075aa16d24" target="_blank" rel="noopener">内嵌了用于呈现页面的 CSS</a>。但是，我并不喜欢在每个 HTML 文档内嵌 70 KB 的 css，特别是其中大部分是 CSS 类名。</p><a id="more"></a><h2 id="就像Google一样"><a href="#就像Google一样" class="headerlink" title="就像Google一样"></a>就像Google一样</h2><p>你有没有看过 <a href="https://www.google.com/" target="_blank" rel="noopener">https://www.google.com/</a> 的源代码？如果看过，您注意到的第一件事是会是，CSS 类名称没有超过几个字符。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*mGuDYFM56iyLi1MgZPC8bw.png" data-original="https://cdn-images-1.medium.com/max/800/1*mGuDYFM56iyLi1MgZPC8bw.png"></p><p>但是怎么样做到的呢？</p><h2 id="CSS-minifiers-的缺点"><a href="#CSS-minifiers-的缺点" class="headerlink" title="CSS minifiers 的缺点"></a>CSS minifiers 的缺点</h2><p>有一件事，<code>minifier</code> 不能做 - 改变选择器名称。这是因为 <code>CSS minifier</code> 不能控制 HTML 输出。同时，CSS 名称可以很长。</p><p>如果您使用 <code>CSS modules</code>，您的 CSS modules 可能会包含样式表文件名，本地标识名和随机哈希。使用 <a href="https://github.com/webpack-contrib/css-loader" target="_blank" rel="noopener">css-loader</a> <a href="https://github.com/webpack-contrib/css-loader" target="_blank" rel="noopener">localIdentName</a> 配置描述类名模板，例如<code>[name]___[local]___[hash:base64:5]</code>。因此，生成的类名称将如下所示 <code>.MovieView___movie-title___yvKVV</code> ; 如果你喜欢描述性的名字，它可能更长，例如 <code>.MovieView___movie-description-with-summary-paragraph___yvKVV</code> 。</p><h2 id="在编译时重命名-CSS-类名"><a href="#在编译时重命名-CSS-类名" class="headerlink" title="在编译时重命名 CSS 类名"></a>在编译时重命名 CSS 类名</h2><p>但是，如果您使用的是 <a href="https://webpack.js.org/" target="_blank" rel="noopener"><code>webpack</code></a> 和 <a href="https://github.com/gajus/babel-plugin-react-css-modules" target="_blank" rel="noopener"><code>babel-plugin-react-css-modules</code></a>，那么您很幸运 🍀 - 您可以使用 <code>css-loader</code> 的 <code>getLocalIdent</code> 配置项或者等效的 <code>babel-plugin-react-css-modules</code> 中的 <code>generateScopedName</code> 配置项来达到在编译时重命名类名的目的。</p><script src="https://gist.github.com/gajus/a70df30613ebd848ab1ce27f3e33aac2.js"></script><p><code>generateScopedName</code> 中很酷的是，同样的功能实例可以用于 <code>Babel</code> 和 <code>webpack</code> 的构建过程：</p><script src="https://gist.github.com/gajus/acc6684de7ef310e9fdcbfa502307e50.js"></script><h2 id="让名字变短"><a href="#让名字变短" class="headerlink" title="让名字变短"></a>让名字变短</h2><p>感谢 <code>babel-plugin-react-css-modules</code> 和 <code>css-loader</code> 共享相同的逻辑来生成 CSS 类名称，我们可以将类名改为任何我们喜欢的，甚至是随机哈希。然而，我想要最短的类名，而不是随机哈希。</p><p>为了生成最短的类名，我创建了类名索引，并使用该 <code>incstr</code> 模块为索引中的每个条目生成增量ID。</p><script src="https://gist.github.com/gajus/b61ab58c4243f189722c0c13e59cdd24.js"></script><p>这保证了类名简短并且唯一。现在，<code>.MovieView___movie-title___yvKVV</code> 和 <code>.MovieView___movie-description-with-summary-paragraph___yvKVV</code> 的类名都成了 <code>.a_a</code>, <code>.b_a</code>等。</p><p>这将 <code>GO2CINEMA</code> CSS 压缩包的大小从 140 KB 降低到 53KB。</p><h2 id="使用作用域隔离来进一步减少包的大小"><a href="#使用作用域隔离来进一步减少包的大小" class="headerlink" title="使用作用域隔离来进一步减少包的大小"></a>使用作用域隔离来进一步减少包的大小</h2><p>分离组件名称和本地标识符名称是一个很好的理由让我添加 <code>_</code> 到 CSS 类名 - 对于缩小文件大小特别有用。</p><p><a href="https://github.com/css/csso" target="_blank" rel="noopener">csso</a>（CSS minifier）具有<a href="https://github.com/css/csso#scopes" target="_blank" rel="noopener">作用域</a>配置。作用域定义了在某些标记上专门使用的类名列表，即来自不同作用域的选择器不会匹配同一个元素。这一条让优化规则更进一步。</p><p>要利用此功能，请使用 <a href="https://github.com/zoobestik/csso-webpack-plugin" target="_blank" rel="noopener"><code>csso-webpack-plugin</code></a> 来后处理 CSS 包：</p><script src="https://gist.github.com/gajus/720ece26d03ea901b515c9b80b6ac4c8.js"></script><p>这使 GO2CINEMA CSS 捆绑包的大小从 53 KB 降至 47 KB。</p><h2 id="这值得么？"><a href="#这值得么？" class="headerlink" title="这值得么？"></a>这值得么？</h2><p>这种压缩的第一个争议是觉得压缩算法本来就可以做到。使用 <a href="https://en.wikipedia.org/wiki/Brotli" target="_blank" rel="noopener">Brotli</a> 算法压缩的 GO2CINEMA CSS 包与长类名的原始包相比只压缩了 1 KB。</p><p>另一方面，设置这个缩小是一次性投入，它减少了需要解析的文档的大小。它还具有其他好处，例如阻止依赖 CSS类名称的扫描仪导航或意外匹配广告拦截器<a href="https://gist.github.com/spyesx/42fe84c0ef757d1c38a4" target="_blank" rel="noopener">黑名单</a>的 CSS选择器。</p><p>同时，您可以看到在 GO2CINEMA 和 venue 页面上使用的这种压缩的演示，例如</p><ul><li><a href="https://go2cinema.com/movies/wonder-woman-2017-1305237" target="_blank" rel="noopener">https://go2cinema.com/movies/wonder-woman-2017-1305237</a></li><li><a href="https://go2cinema.com/venues/odeon-oxford-magdalen-st-1001053" target="_blank" rel="noopener">https://go2cinema.com/venues/odeon-oxford-magdalen-st-1001053</a></li></ul><p>【翻译原文】：<a href="https://medium.freecodecamp.org/reducing-css-bundle-size-70-by-cutting-the-class-names-and-using-scope-isolation-625440de600b" target="_blank" rel="noopener">https://medium.freecodecamp.org/reducing-css-bundle-size-70-by-cutting-the-class-names-and-using-scope-isolation-625440de600b</a></p><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;像-google-一样通过缩短-css-类名和作用域隔离来压缩优化-css-包的大小&quot;&gt;&lt;a href=&quot;#像-google-一样通过缩短-css-类名和作用域隔离来压缩优化-css-包的大小&quot; class=&quot;headerlink&quot; title=&quot;像 google 一样通过缩短 css 类名和作用域隔离来压缩优化 css 包的大小&quot;&gt;&lt;/a&gt;像 google 一样通过缩短 css 类名和作用域隔离来压缩优化 css 包的大小&lt;/h1&gt;&lt;blockquote&gt;&lt;h2 id=&quot;就像-google-的做法一样&quot;&gt;&lt;a href=&quot;#就像-google-的做法一样&quot; class=&quot;headerlink&quot; title=&quot;就像 google 的做法一样&quot;&gt;&lt;/a&gt;就像 google 的做法一样&lt;/h2&gt;&lt;/blockquote&gt;&lt;p&gt;今年年初，我已经退出咨询公司并开始构建 &lt;a href=&quot;https://go2cinema.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GO2CINEMA&lt;/a&gt; - 一个 &lt;em&gt;快速，简单和安全&lt;/em&gt; 的方式来预订英国的电影票的网站。我做了一个辉煌的工作，使其快速，简单和安全。在其中某个阶段，我一直痴迷于关键渲染路径的优化。⚡️&lt;/p&gt;&lt;p&gt;我已经使用 &lt;a href=&quot;https://github.com/gajus/usus&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ūsus&lt;/a&gt; 解决了 HTML 的预渲染。ūsus 渲染单页应用程序（SPA）的 HTML，并&lt;a href=&quot;https://medium.com/@gajus/pre-rendering-spa-for-seo-and-improved-perceived-page-loading-speed-47075aa16d24&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;内嵌了用于呈现页面的 CSS&lt;/a&gt;。但是，我并不喜欢在每个 HTML 文档内嵌 70 KB 的 css，特别是其中大部分是 CSS 类名。&lt;/p&gt;
    
    </summary>
    
      <category term="css" scheme="http://robin-front.github.io/categories/css/"/>
    
    
      <category term="react" scheme="http://robin-front.github.io/tags/react/"/>
    
      <category term="webpack" scheme="http://robin-front.github.io/tags/webpack/"/>
    
      <category term="css" scheme="http://robin-front.github.io/tags/css/"/>
    
      <category term="minifier" scheme="http://robin-front.github.io/tags/minifier/"/>
    
  </entry>
  
  <entry>
    <title>桂林山水最强徒步攻略-大圩古镇-奇峰镇-会仙镇-葡萄镇至兴坪古镇20公里经典徒步路线</title>
    <link href="http://robin-front.github.io/2017/07/23/Daxu-village-Huixian-wetland-Putao-Xingping-of-Guilin/"/>
    <id>http://robin-front.github.io/2017/07/23/Daxu-village-Huixian-wetland-Putao-Xingping-of-Guilin/</id>
    <published>2017-07-23T02:42:17.000Z</published>
    <updated>2017-07-23T02:42:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我可不是一个酒店享受者，我的玩法是 don’t stop, keep your step.</p></blockquote><h1 id="桂林山水最强徒步攻略-大圩古镇-奇峰镇-会仙镇-葡萄镇至兴坪古镇20公里经典徒步路线"><a href="#桂林山水最强徒步攻略-大圩古镇-奇峰镇-会仙镇-葡萄镇至兴坪古镇20公里经典徒步路线" class="headerlink" title="桂林山水最强徒步攻略-大圩古镇-奇峰镇-会仙镇-葡萄镇至兴坪古镇20公里经典徒步路线"></a>桂林山水最强徒步攻略-大圩古镇-奇峰镇-会仙镇-葡萄镇至兴坪古镇20公里经典徒步路线</h1><p>对于每个地方并不打算去两次的人来说（除了一些体验特别好的地方），一次性打包看完一个地方所有感兴趣的地点是最合适的。所以，每次去完，总是把一个市，甚至一个省的攻略都做完了。或许也是一种强迫症吧。</p><p>其实国内很多景点都是坑，网上照片基本都不是原片。写攻略是为了方便别人，也是为坑了别人一起，哈哈，顺便记录。<a id="more"></a></p><h2 id="路线规划"><a href="#路线规划" class="headerlink" title="路线规划"></a>路线规划</h2><p>下面先简要看看总体路线规划：</p><p>Day 1: 火车 ——&gt; 桂林市 ——&gt; 大圩古镇（+熊村） Day 2: 大圩古镇 ——&gt; 奇峰镇（遇到不可抗因素）——&gt; 会仙镇 Day 3: 会仙湿地 ——&gt; 玻璃田 ——&gt; 葡萄镇 Day 4: 葡萄镇 至 兴坪古镇 经典徒步路线 20 公里 ——&gt; 相公山（日落） Day 5: 相公山（日出）——&gt; 相公山至兴坪古镇 ——&gt; 老寨山（日落）——&gt; 阳朔高铁最后一班回（8pm）</p><p>补充几张线路图：</p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/guilin/tubu.jpeg" data-original="/images/guilin/tubu.jpeg"> <img src="/js/lazyload-plugin/loading.svg" alt="/images/guilin/tubu2.jpeg" data-original="/images/guilin/tubu2.jpeg"> 葡萄镇至兴坪古镇 徒步路线图</p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/guilin/huixian.jpeg" data-original="/images/guilin/huixian.jpeg"> 会仙玻璃田路线图</p><h2 id="大圩古镇（大墟）"><a href="#大圩古镇（大墟）" class="headerlink" title="大圩古镇（大墟）"></a>大圩古镇（大墟）</h2><p>“明清时期繁华一时的大圩古镇”。</p><p>在桂林火车站旁边的桂林长途汽车总站坐开往冠岩的专线车，40分钟左右即可到达大圩，票价5元左右。</p><p>古镇不大，1小时足以游完，距大圩镇8公里（在大圩路口能看到指路牌）的熊村（大圩县城搭公交过去3元）。</p><p>村上保留着完整的旧时村落格局，有上百栋明清建筑，现存有湖南会馆、江西会馆、财神殿等，村子的老建筑上保留了许多文革标语。</p><p>小吃：姜汁桂花凉粉</p><p>“大圩江上芦田寺，百尺深潭万竹围。柳店积薪晨爨后，僮人荷叶裹盐归”</p><h2 id="奇峰镇（李家村）"><a href="#奇峰镇（李家村）" class="headerlink" title="奇峰镇（李家村）"></a>奇峰镇（李家村）</h2><p>在桂林火车站对面搭乘4路车，开往奇峰镇方向，在 <strong>东山村</strong> 下车。每趟运行单程时间大约是40分钟。（我是大圩直接坐摩的30元抄小路到奇峰镇）</p><p>奇峰镇外看奇峰，万点尖峰锁碧空。</p><p><strong>事实上，里面是军事管制区，只有本村村民才能进。公交车到村口就被强制下车。请不要来这里，没有开放</strong></p><h2 id="会仙镇"><a href="#会仙镇" class="headerlink" title="会仙镇"></a>会仙镇</h2><p>桂林汽车站，乘坐桂林—会仙的班车，每隔15分钟一趟，票价8元（直达），也可在雁中路口，师大侧门坐车。</p><blockquote><p>秋天去看一片金黄，或田地放水时，一片天镜。</p></blockquote><ul><li><p>会仙湿地： 正在开发中，酒店食宿全没有，一年后应该会有。到睦洞村委路口，然后乘坐前往毛家村的三轮车每人2元钱（实际上有时会坑你10元）。也可从路口步行至毛家村，大概40分钟左右，路边一大片农田，湿地公园有一大片荷花。一般摄影人会去龙山，售票口的人会建议你坐船过去上龙山。票价不菲。觉得值可以坐。如果是穷学生，那就买门票，走过去，船是走近路直接到山脚，走路就要十八弯，40分钟左右。再不济，往回走有条岔路，是通向刚刚入口方向，人少时没人守，免票进入，这是我出来的时候发现的。</p></li><li><p>玻璃田： 湿地是后开发的，最开始出名的是玻璃田这一块。山也不难找，就是下图的 D 点，上山点在村口医院前。</p></li></ul><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/guilin/huixian.jpeg" data-original="/images/guilin/huixian.jpeg"></p><h2 id="葡萄镇"><a href="#葡萄镇" class="headerlink" title="葡萄镇"></a>葡萄镇</h2><p>这是个中转休息点，是经典徒步路线的起点。从会仙过来的话，先坐车到 雁中路口，师大侧门，然后在南下的大路上拦去阳朔的车，在葡萄镇下车。</p><p>《石头城到兴坪徒步 - 居高临下欣赏山水画卷》（总长度22.5公里）: 这条徒步线路清幽古朴，游人罕至，途中每一次登高俯视，都将为您展开一幅不同的阳朔山水画卷。阳朔的经典摄影主题，葡萄田园风光(地处阳朔葡萄镇乌龙村，拍摄葡萄田园风光多为逆光拍摄，应选择有太阳的天气下午4-5时到达山顶等候拍摄)、相公山日出以及老寨山日落，都在这条线路上。途径古朴的石头城以及兴坪老街，又给这条线路增加了人文风情。线路最好分两天完成，这样可以夜宿相公山以便第二天观看日出。全程难度不大，两三人轻装便可出发，沿途村庄可以补给，也可带少量食物和水以防万一</p><p>当然，这条路线可以反着来走，但我是从会仙过来的，这样走更顺路，最后阳朔高铁回。</p><p>【徒步线路A：小耀门村–石头寨–大岩头村–小冲崴村–大坪村–水岩门村–相公山–黄泥田村–镰刀湾村–大河背村–渔村村–兴坪镇。（全程约19公里） 徒步线路B：小耀门村—石头寨—大岩头村—小冲崴村—大坪村–水岩门村–相公山–荷苞山村–冷水村–画山村–兴坪镇。（全程约18公里）】 (PS: 其实应该有25公里，我在石头城迷路，走得太累，后来还搭了一段顺风车到相公山)</p><h2 id="兴坪古镇"><a href="#兴坪古镇" class="headerlink" title="兴坪古镇"></a>兴坪古镇</h2><p>相公山到冷水村路不太好走，比想象中远，但其实应该有近路，因为在路上有岔路，但地图上没有标。去冷水村需要渡河，10元。本地人免费。冷水村到兴坪古镇一路是风景，也可坐三轮车过去。下车点就是20元人民币上的图。之后在老寨山看日落。下山在汽车站坐小面包 5元到阳朔高铁站回。</p><h2 id="详细影摄"><a href="#详细影摄" class="headerlink" title="详细影摄"></a>详细影摄</h2><p>上面都是交通简要，下面是影摄：</p><blockquote><p>（待更。。）</p></blockquote><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;我可不是一个酒店享受者，我的玩法是 don’t stop, keep your step.&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 id=&quot;桂林山水最强徒步攻略-大圩古镇-奇峰镇-会仙镇-葡萄镇至兴坪古镇20公里经典徒步路线&quot;&gt;&lt;a href=&quot;#桂林山水最强徒步攻略-大圩古镇-奇峰镇-会仙镇-葡萄镇至兴坪古镇20公里经典徒步路线&quot; class=&quot;headerlink&quot; title=&quot;桂林山水最强徒步攻略-大圩古镇-奇峰镇-会仙镇-葡萄镇至兴坪古镇20公里经典徒步路线&quot;&gt;&lt;/a&gt;桂林山水最强徒步攻略-大圩古镇-奇峰镇-会仙镇-葡萄镇至兴坪古镇20公里经典徒步路线&lt;/h1&gt;&lt;p&gt;对于每个地方并不打算去两次的人来说（除了一些体验特别好的地方），一次性打包看完一个地方所有感兴趣的地点是最合适的。所以，每次去完，总是把一个市，甚至一个省的攻略都做完了。或许也是一种强迫症吧。&lt;/p&gt;&lt;p&gt;其实国内很多景点都是坑，网上照片基本都不是原片。写攻略是为了方便别人，也是为坑了别人一起，哈哈，顺便记录。
    
    </summary>
    
      <category term="travel" scheme="http://robin-front.github.io/categories/travel/"/>
    
    
      <category term="travel" scheme="http://robin-front.github.io/tags/travel/"/>
    
  </entry>
  
  <entry>
    <title>马萨萨海滩(masasa beach) 旅行预算指南</title>
    <link href="http://robin-front.github.io/2017/07/22/masasa-beach-travel-guide/"/>
    <id>http://robin-front.github.io/2017/07/22/masasa-beach-travel-guide/</id>
    <published>2017-07-22T03:29:35.000Z</published>
    <updated>2017-07-22T03:29:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="假期旅行之菲律宾系列之二-——-马萨萨海滩-masasa-beach"><a href="#假期旅行之菲律宾系列之二-——-马萨萨海滩-masasa-beach" class="headerlink" title="假期旅行之菲律宾系列之二 —— 马萨萨海滩(masasa beach)"></a>假期旅行之菲律宾系列之二 —— 马萨萨海滩(masasa beach)</h1><p>马萨沙滩可以说是 Tingloy 最好的海滩，这是 Batangas 唯一不在大陆吕宋岛上。它的主要岛屿是鱼形马里卡班（Maricaban），位于 Calumpang 半岛的一角，将巴拉扬湾（Balayan Bay）与八打雁湾（Batangas Bay）分开。</p><p>事实是，这里的沙滩不像你在长滩岛或巴拉望岛所期望的那样像白色珍珠，但是马萨沙滩在缺乏亮度的沙滩中展现出波浪的气息。它的水晶般清澈，浅水散发出美丽的绿松石闪光，即使远距离也能吸引您的注意。<a id="more"></a></p><p>来这里主要是玩水，如果你喜欢游泳，来这里吧。我是在这学会狗爬式的。哈哈。。 先来看看一些照片。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="http://www.thepoortraveler.net/wp-content/uploads/2014/02/Mabini-Tingloy-Map.png" data-original="http://www.thepoortraveler.net/wp-content/uploads/2014/02/Mabini-Tingloy-Map.png"> 小岛是一个小鱼形状，很可爱</p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/masasa/IMG_1398.JPG" data-original="/images/masasa/IMG_1398.JPG"> 在 Anilao Port 坐公共船只</p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/masasa/IMG_1419.JPG" data-original="/images/masasa/IMG_1419.JPG"> 到达 小鱼岛 ，准备浮潜，小哥很卖力！</p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/masasa/IMG_1429.JPG" data-original="/images/masasa/IMG_1429.JPG"> 没错，螃蟹船很好看，他们喜欢涂成各种颜色，艺术细胞不错。以及。。真正蓝色的大海，而不是灰色的。</p><p>浮潜只需100p !!超便宜，一定要尝试一下，虽然只是带着你转一圈，但是可以看到各种海龟，珊瑚，长带鱼等。怪不得很多本地大学生来！经济漂亮！但是我没有拍到好的海底照片。。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/masasa/IMG_1439.JPG" data-original="/images/masasa/IMG_1439.JPG"> 沙子确实不怎么样，但是水还是不错</p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/masasa/IMG_1477.JPG" data-original="/images/masasa/IMG_1477.JPG"> 水清见底</p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/masasa/IMG_1478.JPG" data-original="/images/masasa/IMG_1478.JPG"> 全貌</p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/masasa/IMG_1539.JPG" data-original="/images/masasa/IMG_1539.JPG"> 家庭出行非常多</p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/masasa/IMG_1588.JPG" data-original="/images/masasa/IMG_1588.JPG"> 香蕉船</p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/masasa/IMG_1643.JPG" data-original="/images/masasa/IMG_1643.JPG"> 附近村庄的小卖部的老人</p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/masasa/IMG_1692.JPG" data-original="/images/masasa/IMG_1692.JPG"> 这是什么，谁能告诉我</p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/masasa/IMG_1702.JPG" data-original="/images/masasa/IMG_1702.JPG"> 其实来到这里再找住宿也可以，因为很多，到处都是</p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/masasa/IMG_1732.JPG" data-original="/images/masasa/IMG_1732.JPG"> 菲菲 <img src="/js/lazyload-plugin/loading.svg" alt="/images/masasa/IMG_1741.JPG" data-original="/images/masasa/IMG_1741.JPG"></p><h2 id="交通"><a href="#交通" class="headerlink" title="交通"></a>交通</h2><ul><li><p>bus,在八打雁市区 Batangas Grand Terminal下车（3-4 小时）（<strong>同样的，半夜出发，早上到达，不然会塞车</strong>） 在LRT- Gil Puyat 车站旁边有公共汽车站（DLTB liner 或 JAM liner）。（注意，越早越好。如果您选择一辆带有 CALABARZON 标志的公共汽车，旅行时间将会更短）P120-P180。</p></li><li><p>转吉普尼（1小时） 40 minutes. Fare: PhP 37. 终点站是 Mabini Multi-purpose port.（又名 Anilao Port）(在habagat season季节，终点站是 Talaga Port )</p></li><li><p>a. 在 Anilao Port 坐船(<strong>推荐</strong>)（45min） 如果要在岛上住一晚，就选择公共船只，最便宜，P80。旅行时间：45分钟 - 1小时。 直接坐船到 masasa beach。但是直达的船更少，不可预测，P100 （注意，最后一艘返回 Anilao的船是上午九点，所以不得不住一晚,有些船在较小的码头在中午12点可以接乘客回,具体可以咨询当地人上船地点）</p></li><li><p>b. 如果是一日游，租船P4500，可坐10人，可以讲价。如果租船，可以要求中途登陆 Sombrero岛，上岛费 P200，有些要P500.（算是跳岛游，比较贵）</p></li></ul><h2 id="住宿"><a href="#住宿" class="headerlink" title="住宿"></a>住宿</h2><p>我当时是在 facebook 上搜索 masasa 然后联系的住宿，P300 每人！没有酒店。其实那里旁边有村子，有很多过夜的地方。以前可以在沙滩露营过夜，但后来不允许了。</p><h2 id="其他项目"><a href="#其他项目" class="headerlink" title="其他项目"></a>其他项目</h2><ul><li>环岛游： 标准费率：P1500，岛上可以联系当地船只。</li><li>浮潜：P100 !!我是当时住宿的人帮我安排联系的，30min,时间不长</li></ul><h2 id="费用清单"><a href="#费用清单" class="headerlink" title="费用清单"></a>费用清单</h2><ul><li>到八打雁的票价车票：票价：P157 从LRT-Buendia 出发，P127 从阿拉邦出发。</li><li>吉隆尼到阿尼洛的吉普尼票价：P37</li><li>从Anilao出发的小船出租（岛屿游览）：每船P4500（最大10人）Masasa</li><li>海滩的小船出租（岛屿游览）：每船P1500（3pax最大）</li><li>公共小船到 Tingloy：P80（推荐）</li><li>三轮车到马萨沙滩：P120/辆</li><li>环境费：P30</li><li>马萨沙滩：免费</li><li>Sombrero Island 上岛费：P200</li><li>租帐篷 P200</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>masasa beach只有一个洗手间，收费，P10 每次；</li><li>过夜可能没有电，带好充电宝；</li><li>看好天气，晴天比阴天更漂亮，水更清；</li></ul><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;假期旅行之菲律宾系列之二-——-马萨萨海滩-masasa-beach&quot;&gt;&lt;a href=&quot;#假期旅行之菲律宾系列之二-——-马萨萨海滩-masasa-beach&quot; class=&quot;headerlink&quot; title=&quot;假期旅行之菲律宾系列之二 —— 马萨萨海滩(masasa beach)&quot;&gt;&lt;/a&gt;假期旅行之菲律宾系列之二 —— 马萨萨海滩(masasa beach)&lt;/h1&gt;&lt;p&gt;马萨沙滩可以说是 Tingloy 最好的海滩，这是 Batangas 唯一不在大陆吕宋岛上。它的主要岛屿是鱼形马里卡班（Maricaban），位于 Calumpang 半岛的一角，将巴拉扬湾（Balayan Bay）与八打雁湾（Batangas Bay）分开。&lt;/p&gt;&lt;p&gt;事实是，这里的沙滩不像你在长滩岛或巴拉望岛所期望的那样像白色珍珠，但是马萨沙滩在缺乏亮度的沙滩中展现出波浪的气息。它的水晶般清澈，浅水散发出美丽的绿松石闪光，即使远距离也能吸引您的注意。
    
    </summary>
    
      <category term="travel" scheme="http://robin-front.github.io/categories/travel/"/>
    
    
      <category term="travel" scheme="http://robin-front.github.io/tags/travel/"/>
    
      <category term="philippine" scheme="http://robin-front.github.io/tags/philippine/"/>
    
  </entry>
  
  <entry>
    <title>Borawan island、Pagbilao Beach 和 Dampalitan island旅行预算指南——一个周末三个沙滩</title>
    <link href="http://robin-front.github.io/2017/07/22/borawan-island-Pagbilao-beach-and-Dampalitan-island/"/>
    <id>http://robin-front.github.io/2017/07/22/borawan-island-Pagbilao-beach-and-Dampalitan-island/</id>
    <published>2017-07-22T00:30:22.000Z</published>
    <updated>2017-07-22T00:30:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一个孩子的冒险故事 ————讲故事的人</p></blockquote><h1 id="假期旅行之菲律宾系列之一-————-Borawan岛、Pagbilao岛、Dampalitan岛"><a href="#假期旅行之菲律宾系列之一-————-Borawan岛、Pagbilao岛、Dampalitan岛" class="headerlink" title="假期旅行之菲律宾系列之一 ———— Borawan岛、Pagbilao岛、Dampalitan岛"></a>假期旅行之菲律宾系列之一 ———— Borawan岛、Pagbilao岛、Dampalitan岛</h1><p>坐落在奎松南部的边缘，布尔戈斯（Padre Burgos）和帕格比洛（Pagbilao）的城镇面向泰巴巴斯湾（Tayabas Bay），这是分离大陆吕宋岛和马林杜克岛（Marinduque）的通道。马尼拉市区的这一边只有四到五个小时的路程，甚至远远近于 Pangasinan和碧瑶（Baguio）。<a id="more"></a></p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/20170722/IMG_4158.JPG" data-original="/images/20170722/IMG_4158.JPG"> 这是Puting Buhangin，Pagbilao（也叫Kuwebang Lampas）最推荐，请在这里规划最长的时间</p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/20170722/IMG_4157.JPG" data-original="/images/20170722/IMG_4157.JPG"></p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/20170722/IMG_4139.JPG" data-original="/images/20170722/IMG_4139.JPG"></p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/20170722/IMG_3918.JPG" data-original="/images/20170722/IMG_3918.JPG"> <img src="/js/lazyload-plugin/loading.svg" alt="/images/20170722/IMG_3904.JPG" data-original="/images/20170722/IMG_3904.JPG"> Borawan，背靠山，是另一种风景，和岩石拍照特别好看。这是 Borawan 的日落。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/20170722/IMG_3979.JPG" data-original="/images/20170722/IMG_3979.JPG"> 水面很平静，没有浪，很适合游泳</p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/20170722/IMG_3383.JPG" data-original="/images/20170722/IMG_3383.JPG"> Dampalitan， 水很清！ <img src="/js/lazyload-plugin/loading.svg" alt="/images/20170722/IMG_3613.JPG" data-original="/images/20170722/IMG_3613.JPG"> <img src="/js/lazyload-plugin/loading.svg" alt="/images/20170722/IMG_3654.JPG" data-original="/images/20170722/IMG_3654.JPG"> 天气很好！</p><h2 id="公共交通如何到达"><a href="#公共交通如何到达" class="headerlink" title="公共交通如何到达"></a>公共交通如何到达</h2><ul><li>公共汽车站：JAM liner, DLTB liner, JAC liner. 位于 Taft Ave.</li><li>乘公共汽车到卢塞纳市（Lucena）。马尼拉大都会有许多终点站到卢塞纳。票价介于P250-260之间。旅行时间：3-4小时。</li><li>在卢塞纳站下车（Lucena Grand Terminal）。</li><li>a. 从终点站乘坐另一辆巴士到 Unisan。公共汽车没有空调，票价在P35-40左右。旅行时间：1个半小时。 b. 也有小面包车 （Vans），有招客牌写着 Unisan，说去 QCRB Bank 下车，大概 60p 每人</li><li>在QCRB银行（Padre Burgos）下车，或者 <strong>提前告诉司机让你这里下车</strong>。</li><li>乘坐三轮车到 Aplaya。告诉司机你打算去Borawan， 只需 20p。</li><li>在 Aplaya 有小船出租。这些船只可以带您前往 Puting Buhangin（Pagbilao），Dampalitan岛和Borawan岛的一个岛屿游览。P1500 - P2000，适合10人以下。</li></ul><h2 id="行程参考时间表"><a href="#行程参考时间表" class="headerlink" title="行程参考时间表"></a>行程参考时间表</h2><p>半夜出发是最合适的，早上就到。如果早上出发，你会在路上塞车并浪费一整天。不要把白天玩的时间浪费在车上。</p><ol><li>2:00 - Buendia Bus Terminal(DLTB liner or JAM liner)坐车 (P227-P250, 4h)【凌晨两点出发，早上六点到】 目的地：Lucena Grand Terminal</li><li>6:00 - Lucena Grand Terminal换乘去 Unisan 的公交bus（P35 - P40）【1.5h, 预计七点半到】</li><li>7:00 - 在 QCRB BANK下车。换tricycle三轮车（10min），去Aplaya (和司机说要去 Borawan)</li><li>在Aplaya租船 8:00 出发。</li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>该地区有水母（jerryfish），请一定注意，Borawan沙滩尤其多，所以建了水网区域游泳，不要在非安全区域游泳。被水母蛰了也不要惊慌，提前了解处理方法，使用碱性溶液（如肥皂水等）清洗。Pagbilao岛、Dampalitan岛比较安全，下水前可以询问岛上工作人员能否下水，或与其他人一同下水，勿单独游泳。</p><h2 id="露营或酒店或租船"><a href="#露营或酒店或租船" class="headerlink" title="露营或酒店或租船"></a>露营或酒店或租船</h2><p>Borawan 和 Dampalitan Islands 没有度假村或酒店，但允许露营过夜。如果你不是野营的类型，那么大陆有几个度假村，你可以选择留下来。以下是我收集的简短列表：</p><ul><li>Silangang Nayon餐厅和度假村。位于Pagbilao，它是Bicol绑定的路途跋涉者之间的共同点，他们渴望品尝到他们美味的Pinoy海鲜菜肴。他们只有少量的房间，所以如果你要在旺季，提前预订。联系电话：（042）7160077，0922 8867677</li></ul><p>但，如果你认为你是一个野营旅行，为什么不露营呢？露营不仅降低了成本，还使您更好地欣赏岛屿，从而使您更接近自然。所有你需要的是一个帐篷和一些易于准备的食品。如果有冲泡食品，沙滩小卖部有热水出售，20p。</p><p>租船（完全可以去到再租，如果不放心，可以提前询问）： 09501928546，09094819703</p><p>大部分人会在 Borawan 沙滩 和 Pagbilao 沙滩过夜，这两个地方有冲凉房和公厕，免费使用。我建议在 Puthang Buhangin, Pagbilao 过夜，那里水最清。</p><h2 id="备用物品提示"><a href="#备用物品提示" class="headerlink" title="备用物品提示"></a>备用物品提示</h2><ul><li>化妆品和防晒霜 - 通常。在岛上有商店，但预计价格有点过高，所以更好地带上洗发水，肥皂，牙膏，卫生纸和湿巾。Dampalitan 岛上有公厕，但水有点稀少。</li><li>防蚊洗剂 - 很多人会忘记带来。岛上有蚊子。</li><li>手电筒 - 那里偶尔会停电</li><li>打火机和很多故事 - 你会被诱惑开始篝火，你将需要打火机点火和对话，以保持燃烧。</li><li>急救包 - 你永远不会知道意外什么时候发生。</li><li>浮潜装置 - 我们没有看到活珊瑚，但有很多鱼。特别是在 Dampalitan和Pagbilao，这两个沙滩水更清。</li><li>防水相机 - Kuwebang Lampas（在Puthang Buhangin, Pagbilao）是非常棒的，但去那里的水很深。如果您想要在洞穴内的图片，防水相机非常有用。</li></ul><h2 id="预算详细条目"><a href="#预算详细条目" class="headerlink" title="预算详细条目"></a>预算详细条目</h2><p>以下是您期望的费用和其他费用清单。</p><p>乘船游览费（8人乘车）： P800 - Borawan海滩（往返） P1800 - Borawan + Dampalitan + Puting Buhangin（三岛两天一夜，这是总船费，不是每次）</p><p>Borawan海滩 上岛费：P80 帐篷租金：P500(买一个帐篷去最好，便宜的才1000p左右，还能带回去) 小屋出租：P700-P850 过夜费： P220每人 帐篷占地费用：P200-P250(分占地大小)</p><p>Puting Buhangin，Pagbilao 上岛费：P80 帐篷出租：P300-400</p><p>Dampalitan 岛 上岛费：P80 帐篷占地费：P100 小屋出租：P850-P1000 水：P40/5L，P400/大桶</p><p>以上费用可能会涨价，但不会偏离太多。最重要是带好食物和饮用水。过夜请拿好票据，以免其他员工再次来收钱。</p><h2 id="一般顺序："><a href="#一般顺序：" class="headerlink" title="一般顺序："></a>一般顺序：</h2><ul><li><strong>推荐：Borawan（9：00-午餐） ==&gt; Puting buhangin（14：00-过夜） ===&gt; Dampalitan (10：00 - 14:00回程)</strong></li><li>Puting buhangin（9：00） ==&gt; Dampalitan（11：30-午餐） ===&gt; Borawan (14：00 - 过夜)</li><li>Puting buhangin（9：00-午餐）===&gt; Borawan（14：00-过夜）===&gt; Dampalitan(10:00- 14:00回程)</li></ul><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;一个孩子的冒险故事 ————讲故事的人&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 id=&quot;假期旅行之菲律宾系列之一-————-Borawan岛、Pagbilao岛、Dampalitan岛&quot;&gt;&lt;a href=&quot;#假期旅行之菲律宾系列之一-————-Borawan岛、Pagbilao岛、Dampalitan岛&quot; class=&quot;headerlink&quot; title=&quot;假期旅行之菲律宾系列之一 ———— Borawan岛、Pagbilao岛、Dampalitan岛&quot;&gt;&lt;/a&gt;假期旅行之菲律宾系列之一 ———— Borawan岛、Pagbilao岛、Dampalitan岛&lt;/h1&gt;&lt;p&gt;坐落在奎松南部的边缘，布尔戈斯（Padre Burgos）和帕格比洛（Pagbilao）的城镇面向泰巴巴斯湾（Tayabas Bay），这是分离大陆吕宋岛和马林杜克岛（Marinduque）的通道。马尼拉市区的这一边只有四到五个小时的路程，甚至远远近于 Pangasinan和碧瑶（Baguio）。
    
    </summary>
    
      <category term="travel" scheme="http://robin-front.github.io/categories/travel/"/>
    
    
      <category term="travel" scheme="http://robin-front.github.io/tags/travel/"/>
    
      <category term="philippine" scheme="http://robin-front.github.io/tags/philippine/"/>
    
  </entry>
  
  <entry>
    <title>高性能 react：3种加快应用程序的新工具</title>
    <link href="http://robin-front.github.io/2017/07/18/make-react-fast-again-tools-and-techniques-for-speeding-up-your-react-app/"/>
    <id>http://robin-front.github.io/2017/07/18/make-react-fast-again-tools-and-techniques-for-speeding-up-your-react-app/</id>
    <published>2017-07-18T07:25:02.000Z</published>
    <updated>2017-07-18T07:25:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高性能-react：3种加快应用程序的新工具"><a href="#高性能-react：3种加快应用程序的新工具" class="headerlink" title="高性能 react：3种加快应用程序的新工具"></a>高性能 react：3种加快应用程序的新工具</h1><p>react 通常很快，但很容易造成导致性能问题的小错误。缓慢的组件安装，深层组件树和不必要的渲染循环可以快速添加到一个感觉缓慢的应用程序。</p><p>幸运的是，有很多工具，有些甚至内置于 React，这有助于诊断性能问题。在这篇文章中，我将强调使 React 应用程序更快速的工具和技术。每个部分还有一个互动，（希望）有趣的演示！<a id="more"></a></p><h2 id="工具＃1：性能时间表"><a href="#工具＃1：性能时间表" class="headerlink" title="工具＃1：性能时间表"></a>工具＃1：性能时间表</h2><p>React 15.4.0引入了一个新的性能时间轴功能，可让您准确了解组件的挂载，更新和卸载。它还可以让您可视化相关的组件生命周期。</p><p>注意：现在，此功能仅适用于Chrome，Edge和IE，因为它利用了尚未在所有浏览器中实现的用户时间轴API（User Timing API）。</p><h3 id="怎么运行的"><a href="#怎么运行的" class="headerlink" title="怎么运行的"></a>怎么运行的</h3><ul><li>打开你的应用程序并附加查询参数：<code>react_perf</code>。例如，<code>http://localhost:3000?react_perf</code></li><li>打开Chrome DevTools 性能选项卡，然后按 <strong>记录（Record）</strong>。</li><li>执行您要分析的操作。</li><li>停止记录</li><li>在 <code>User Timing</code> 下检查可视化。</li></ul><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/1000/1*cOO5vUnbkdDUcqMW8ebJqA.png" data-original="https://cdn-images-1.medium.com/max/1000/1*cOO5vUnbkdDUcqMW8ebJqA.png"></p><h3 id="了解输出"><a href="#了解输出" class="headerlink" title="了解输出"></a>了解输出</h3><p>每个彩色条显示组件正在做“工作”的时间。由于JavaScript是单线程的，每当组件正在加载或呈现时，它会阻止主线程，并阻止其他代码运行。</p><p>方括号中的文字<code>[update]</code>描述了组件生命周期的哪个部分正在发生。时间轴会分解每个步骤，因此您可以在<code>[componentDidMount]</code> <code>[componentWillReceiveProps]</code> <code>[ctor]</code>（构造函数）和 <code>[render]</code> 方法上看到细粒度的时序.</p><p>堆叠的条表示组件树。虽然在React中具有相当深的组件树是典型的，但如果要优化经常安装的组件，则可以帮助减少封装组件的数量，因为每个组件都会增加小的性能和内存损失。</p><p>这里有一点值得注意的是，时间表中的时间序列是用于开发构建React的，它比生产环境更慢。事实上，甚至性能时间表本身会减慢您的应用程序。虽然这些数字不应该被认为是真实表现的性能，但是不同组件之间的相对定时是准确的。此外，组件是否更新完全不依赖于生产环境上的构建。</p><h3 id="演示＃1"><a href="#演示＃1" class="headerlink" title="演示＃1"></a>演示＃1</h3><p>为了乐趣，我操纵了TodoMVC应用程序，出现一些严重的性能问题。你可以在<a href="https://perf-demo.firebaseapp.com/?react_perf" target="_blank" rel="noopener">这里试试看</a>。</p><p>要查看时间轴，请打开Chrome开发工具，转到“性能”选项卡，然后单击记录。然后在应用程序中添加一些TODO，停止录制并检查时间轴。看看是否可以发现哪些组件导致性能问题:)</p><h2 id="工具＃2：为什么更新"><a href="#工具＃2：为什么更新" class="headerlink" title="工具＃2：为什么更新"></a>工具＃2：为什么更新</h2><p>影响 React 中性能的最常见问题之一是不必要的渲染循环。默认情况下，即使他们的 props 没有改变，React 组件将在父级 render 时重新 render。</p><p>例如，如果我有一个这样的简单组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DumbComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> &#123;this.props.value&#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>加上父组件:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">      <span class="tag">&lt;<span class="name">DumbComponent</span> <span class="attr">value</span>=<span class="string">&#123;3&#125;</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>无论何时父组件 render，<code>DumbComponent</code> 都会重新 render，尽管其 <code>props</code> 没有改变。</p><p>通常，如果 render 运行，并且没有对虚拟DOM进行任何更改，则这是一个浪费的渲染循环，因为该 render 方法应该是纯的，并且没有任何副作用。在大规模的 React 应用程序中，检测发生这种情况的地方可能很棘手，但幸运的是，有一个可以帮助的工具！</p><h3 id="使用-why-did-you-update"><a href="#使用-why-did-you-update" class="headerlink" title="使用 why-did-you-update"></a>使用 why-did-you-update</h3><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/1000/1*Lb4nr_WLwnLt63jUoszrnQ.png" data-original="https://cdn-images-1.medium.com/max/1000/1*Lb4nr_WLwnLt63jUoszrnQ.png"></p><p><code>why-did-you-update</code> 是一个挂接到 React 的库，并检测潜在的不必要的组件渲染。它检测组件的render方法何时被调用，尽管它的 <code>props</code> 没有改变。</p><h3 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h3><p>安装 <code>npm： npm i --save-dev why-did-you-update</code></p><p>在您的应用程序的任何地方添加此代码段：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">  <span class="keyword">const</span> &#123;whyDidYouUpdate&#125; = <span class="built_in">require</span>(<span class="string">'why-did-you-update'</span>)</div><div class="line">  whyDidYouUpdate(React)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>请注意，此工具在本地开发中非常出色，但确保在生产中已被禁用，因为它会减慢您的应用程序。</p><h3 id="了解输出-1"><a href="#了解输出-1" class="headerlink" title="了解输出"></a>了解输出</h3><p><code>why-did-you-update</code> 监视您的应用程序运行并记录可能会不必要地更改的组件。它允许您在渲染循环之前和之后看到 <code>props</code>，确定它可能是不必要的。</p><h3 id="演示＃2"><a href="#演示＃2" class="headerlink" title="演示＃2"></a>演示＃2</h3><p>为了演示<code>why-did-you-update</code>，我将库安装在 TodoMVC 应用程序的 Code Sandbox 上，这是一个在线 React 游戏场。打开浏览器控制台并添加一些 TODO 以查看输出。</p><p><a href="https://codesandbox.io/s/xGJP4QExn" target="_blank" rel="noopener">这是演示</a></p><blockquote><p>请注意，应用程序中的几个组件不必要地 render。尝试实现上述技术来防止不必要的渲染。如果正确完成，则<code>why-did-you-update</code>控制台中不应有输出。</p></blockquote><h2 id="工具＃3：反应开发工具"><a href="#工具＃3：反应开发工具" class="headerlink" title="工具＃3：反应开发工具"></a>工具＃3：反应开发工具</h2><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/1000/1*1Ih6h8djFyH13tfFK3D1sw.png" data-original="https://cdn-images-1.medium.com/max/1000/1*1Ih6h8djFyH13tfFK3D1sw.png"></p><p>React 开发者工具 Chrome 扩展程序具有可视化组件更新的内置功能。这有助于检测不必要的渲染循环。要使用它，首先请确保在<a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=zh-CN" target="_blank" rel="noopener">此处安装扩展</a>。</p><p>然后，点击Chrome DevTools中的“React”标签打开扩展程序，然后选中“Highlight Updates”。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*GP4vXvW3WO0vTbggDfus4Q.png" data-original="https://cdn-images-1.medium.com/max/800/1*GP4vXvW3WO0vTbggDfus4Q.png"></p><p>然后，只需使用你的应用程序。与各种组件交互，并观看 DevTools 工作的魔力。</p><h3 id="了解输出-2"><a href="#了解输出-2" class="headerlink" title="了解输出"></a>了解输出</h3><p>“react 开发人员工具”突出显示在给定时间点重新呈现的组件。根据更新的频率，使用不同的颜色。对于频繁更新的组件，蓝色显示不频繁更新，按更新频率依次为绿色，黄色和红色。</p><p>看到黄色或红色不一定是坏事。当调整滑块或触发频繁更新的其他UI元素时，可以预期。但是，如果您点击一个简单的按钮并看到红色，这可能意味着某些东西是错误的。该工具的目的是发现不必要的更新的组件。作为应用程序开发人员，您应该有一个一般的想法，哪些组件应该在给定的时间更新。</p><h3 id="演示＃3"><a href="#演示＃3" class="headerlink" title="演示＃3"></a>演示＃3</h3><p>为了演示组件突出显示，我安装了 TodoMVC 应用程序来不必要地更新某些组件。</p><p><a href="https://highlight-demo.firebaseapp.com/" target="_blank" rel="noopener">这是演示</a></p><p>打开上面的链接，然后打开 React Developer Tools 并启用更新突出显示。当您输入顶部文本输入时，您将看到所有 TODO 都不必要地突出显示。当您输入更快时，您将看到颜色更改以指示更频繁的更新。</p><h2 id="修复不必要的渲染"><a href="#修复不必要的渲染" class="headerlink" title="修复不必要的渲染"></a>修复不必要的渲染</h2><p>一旦识别出应用程序中不必要的重新渲染的组件，就会有一些简单的修复。</p><h3 id="使用PureComponent"><a href="#使用PureComponent" class="headerlink" title="使用PureComponent"></a>使用PureComponent</h3><p>在上面的例子中，<code>DumbComponent</code> 是它 props 的纯函数。也就是说，该组件只有在其 <code>props</code> 更改时才需要重新 render。React 有一种内置的特殊类型的组件，<code>PureComponent</code> 这个类型是为这个用例准备的。</p><p>而不是继承自 <code>React.Component</code>，请使用 <code>React.PureComponent</code>，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DumbComponent</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> &#123;this.props.value&#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后，该组件只有在其 <code>props</code> 实际更改时才会重新 render。而已！</p><p>请注意，<code>PureComponent</code>做一个 <code>props</code> 的浅比较，所以如果你使用复杂的数据结构，它可能会错过一些 <code>props</code> 更改，而不是更新您的组件。</p><h3 id="实现-shouldComponentUpdate"><a href="#实现-shouldComponentUpdate" class="headerlink" title="实现 shouldComponentUpdate"></a>实现 shouldComponentUpdate</h3><p><code>shouldComponentUpdate</code> 是 render 任何一个 <code>props</code> 或 <code>state</code> 更改之前调用的组件方法。如果 <code>shouldComponentUpdate</code> 返回 <code>true</code>，render 将被调用，如果它返回 <code>false</code>，没有任何反应。</p><p>通过实现此方法，您可以指示 React 避免重新渲染给定的组件，当其 <code>props</code> 不更改的时候。</p><p>例如，我们可以像下面这样，在一个组件中实现一个 <code>shouldComponentUpdate</code> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DumbComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  shouldComponentUpdate(nextProps) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.value !== nextProps.value) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">render() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="调试生产中的性能问题"><a href="#调试生产中的性能问题" class="headerlink" title="调试生产中的性能问题"></a>调试生产中的性能问题</h2><p>如果您在自己的机器上运行应用程序，“React Developer Tools”才能起作用。如果您有兴趣了解用户在生产中看到的性能问题，请尝试使用<a href="https://logrocket.com/" target="_blank" rel="noopener">LogRocket</a>。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/1000/1*s_rMyo6NbrAsP-XtvBaXFg.png" data-original="https://cdn-images-1.medium.com/max/1000/1*s_rMyo6NbrAsP-XtvBaXFg.png"></p><p><a href="https://logrocket.com/" target="_blank" rel="noopener">LogRocket</a> 就像是网络应用程序，记录 DVR 字面上 的一切，您网站上发生的。您可以使用错误或性能问题重播会话，而不是猜测为什么会出现问题，以快速了解根本原因。</p><p>LogRocket 为您的应用程序记录性能数据，Redux actions/state，日志，错误，网络请求/响应与标题+主体和浏览器元数据。它还在页面上记录HTML和CSS，重新创建即使是最复杂的单页应用程序的像素视频。</p><blockquote><p>【翻译原文链接】：<a href="https://medium.freecodecamp.org/make-react-fast-again-tools-and-techniques-for-speeding-up-your-react-app-7ad39d3c1b82" target="_blank" rel="noopener">https://medium.freecodecamp.org/make-react-fast-again-tools-and-techniques-for-speeding-up-your-react-app-7ad39d3c1b82</a></p></blockquote><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;高性能-react：3种加快应用程序的新工具&quot;&gt;&lt;a href=&quot;#高性能-react：3种加快应用程序的新工具&quot; class=&quot;headerlink&quot; title=&quot;高性能 react：3种加快应用程序的新工具&quot;&gt;&lt;/a&gt;高性能 react：3种加快应用程序的新工具&lt;/h1&gt;&lt;p&gt;react 通常很快，但很容易造成导致性能问题的小错误。缓慢的组件安装，深层组件树和不必要的渲染循环可以快速添加到一个感觉缓慢的应用程序。&lt;/p&gt;&lt;p&gt;幸运的是，有很多工具，有些甚至内置于 React，这有助于诊断性能问题。在这篇文章中，我将强调使 React 应用程序更快速的工具和技术。每个部分还有一个互动，（希望）有趣的演示！
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="react" scheme="http://robin-front.github.io/tags/react/"/>
    
      <category term="tools" scheme="http://robin-front.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>Redux 并不慢，只是你使用姿势不对 —— 一份优化指南</title>
    <link href="http://robin-front.github.io/2017/07/17/react-redux-optimization/"/>
    <id>http://robin-front.github.io/2017/07/17/react-redux-optimization/</id>
    <published>2017-07-17T09:12:02.000Z</published>
    <updated>2017-07-17T09:12:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redux-并不慢，只是你使用姿势不对-——-一份优化指南"><a href="#Redux-并不慢，只是你使用姿势不对-——-一份优化指南" class="headerlink" title="Redux 并不慢，只是你使用姿势不对 —— 一份优化指南"></a>Redux 并不慢，只是你使用姿势不对 —— 一份优化指南</h1><p><em>如何优化使用了 Redux 的 react 应用程序并不是显而易见的。但实际上相当简单。这是一个简短的指南，以及一些例子。</em></p><p>当优化使用 Redux 的 react 应用程序时，我经常听到有人说 Redux 缓慢。在99％的情况下，性能不佳的原因（适用于任何其他框架）与不必要的渲染相关联，因为 DOM 更新是昂贵的！在本文中，您将学习如何在使用 Redux 绑定 react 时避免不必要的 <code>render</code>。</p><p>通常，我们使用<a href="https://github.com/reactjs/react-redux" target="_blank" rel="noopener">官方 react 绑定的 Redux</a> 的 <a href="https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options" target="_blank" rel="noopener">connect</a> 高阶组件， 当您的 Redux <code>store</code> 更新时，react 组件就会更新。这是一个将组件包装在另一个组件中的函数，该组件订阅了 Redux <code>store</code> 中的更改，并渲染 <code>store</code>，这就是它的子节点更新的原因。<a id="more"></a></p><h2 id="快速入坑-react-redux，官方-react-绑定-Redux"><a href="#快速入坑-react-redux，官方-react-绑定-Redux" class="headerlink" title="快速入坑 react-redux，官方 react 绑定 Redux"></a>快速入坑 react-redux，官方 react 绑定 Redux</h2><p>该 <code>connect</code> 高阶组件实际上是已经过优化。要了解如何最好地使用它，最好了解先它是如何工作的！</p><p>Redux 以及 react-redux 实际上是相当小的库，所以源代码并不费解。我鼓励大家阅读源代码，或至少其中的一些。如果你想进一步，编写自己的实现，它将让你深入了解为什么库的设计方式是这样的。</p><p>不用多说，我们来看看 react 绑定的工作原理。正如我们公认的那样，react 绑定的核心部分就是 <code>connect</code> 高阶组件，这是它的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"></span></span></div><div class="line">  mapStateToProps,</div><div class="line">  mapDispatchToProps,</div><div class="line">  mergeProps,</div><div class="line">  &#123;</div><div class="line">    pure = true,</div><div class="line">    areStatesEqual = strictEqual,</div><div class="line">    areOwnPropsEqual = shallowEqual,</div><div class="line">    areStatePropsEqual = shallowEqual,</div><div class="line">    areMergedPropsEqual = shallowEqual,</div><div class="line">    ...extraOptions</div><div class="line">  &#125; = &#123;&#125;</div><div class="line">) &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>作为附注 - 唯一的强制性参数是 <code>mapStateToProps</code>，在大多数情况下，您只需要前两个参数。但是，我在这里使用完整的写法来说明 <code>react bindings</code> 是如何工作的。</p><p>传递给 <code>connect</code> 函数的所有参数都用于生成一个对象，该对象作为 <code>props</code> 传递到封装的组件上。<code>mapStateToProps</code> 用于将状态从 Redux store 映射到一个对象，<code>mapDispatchToProps</code> 用于生成包含函数的对象 - 通常这些函数是 <code>actions</code> 创建者。最后，<code>mergeProps</code> 有三个参数 <code>stateProps</code>，<code>dispatchProps</code> 和 <code>ownProps</code>。第一个是 <code>mapStateToProps</code> 的结果，第二个参数是 <code>mapDispatchToProps</code> 的结果，第三个参数是从组件本身继承的 <code>props</code> 对象。默认情况下，<code>mergeProps</code> 将这些参数简单地组合到一个对象中，但是如果您传递一个函数作为 <code>mergeProps</code> 参数，<code>connect</code> 则将使用该函数生成封装组件的 <code>props</code>。</p><p><code>connect</code> 函数的第四个参数是一个 <code>options</code> 对象。这包含5个选项：<code>pure</code> 可以是 <code>true</code> 或 <code>false</code>，以及确定是否重新渲染组件的4个函数（应该返回一个布尔值）。<code>pure</code> 默认设置为<code>true</code>。如果设置为<code>false</code>，则<code>connect</code> 将跳过任何优化，并且<code>options</code>对象中的4个函数将不生效。我个人不能想到一个用例，但是如果您希望关闭优化，则将其设置为<code>false</code>。</p><p>我们的 <code>mergeProps</code> 函数产生的对象与最后一个 <code>props</code> 对象进行比较。如果我们的 <code>connect</code> 认为 <code>props</code> 对象已经改变了，那么这个组件就会重新渲染。要了解库如何决定是否有变更，我们可以查看该 <code>shallowEqual</code> 功能。如果函数返回 <code>true</code>，组件将不会重新渲染，如果返回 <code>false</code>，它将重新渲染。<code>shallowEqual</code> 执行此比较。下面你会看到 <code>shallowEqual</code> 方法的一部分，它告诉你所有你需要知道的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keysA.length; i++) &#123;</div><div class="line">  <span class="keyword">if</span> (!hasOwn.call(objB, keysA[i]) ||</div><div class="line">      !is(objA[keysA[i]], objB[keysA[i]])) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>总而言之，这是上面的代码：</p><p>它在 object a 中的 key 上循环，并检查 object B 是否拥有相同的属性。然后它检查 object A中的属性（具有相同名称）是否等于对象B的属性。如果只有一个比较返回false，那么对象将被视为不相等，并且会发生重新渲染。</p><p>这导致我们一个黄金法则：</p><h2 id="只给您的组件它需要呈现的数据"><a href="#只给您的组件它需要呈现的数据" class="headerlink" title="只给您的组件它需要呈现的数据"></a>只给您的组件它需要呈现的数据</h2><p>这说得很含糊，所以让我们用一些实际的例子来阐述。</p><h3 id="拆分连接的组件"><a href="#拆分连接的组件" class="headerlink" title="拆分连接的组件"></a>拆分连接的组件</h3><p>我看到人们这样做 订阅容器组件一系列状态，并通过 <code>props</code> 传递所有东西。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> BigComponent = <span class="function">(<span class="params">&#123; a, b, c, d &#125;</span>) =&gt;</span> (</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;CompA a=&#123;a&#125; /&gt;</div><div class="line">    &lt;CompB b=&#123;b&#125; /&gt;</div><div class="line">    &lt;CompC c=&#123;c&#125; /&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">);</div><div class="line"></div><div class="line">const ConnectedBigComponent = connect(</div><div class="line">  (&#123; a, b, c &#125;) =&gt; (&#123; a, b, c &#125;)</div><div class="line">);</div></pre></td></tr></table></figure><p>现在，每次要么a，b或c变化，BigComponent包括CompA，CompB并且CompC将重新呈现。</p><p>相反，拆分您的组件，不要害怕更多地使用 connect：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ConnectedA = connect(CompA, (&#123; a &#125;) =&gt; (&#123; a &#125;));</div><div class="line"><span class="keyword">const</span> ConnectedB = connect(CompB, (&#123; b &#125;) =&gt; (&#123; b &#125;));</div><div class="line"><span class="keyword">const</span> ConnectedC = connect(CompC, (&#123; c &#125;) =&gt; (&#123; c &#125;));</div><div class="line"></div><div class="line"><span class="keyword">const</span> BigComponent = <span class="function"><span class="params">()</span> =&gt;</span> (</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;ConnectedA a=&#123;a&#125; /&gt;</div><div class="line">    &lt;ConnectedB b=&#123;b&#125; /&gt;</div><div class="line">    &lt;ConnectedC c=&#123;c&#125; /&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">);</div></pre></td></tr></table></figure><p>通过此次更新，<code>CompA</code> 将只有当<code>a</code>已经改变才会重新渲染，<code>CompB</code>当<code>b</code>改变等。考虑这样一个场景，每一个值<code>a</code>，<code>b</code>并<code>c</code>分别经常更新。对于每次更新，我们现在重新渲染一个，而不是所有组件。这几乎没有什么明显的三个组件，但如果你有更多！</p><h3 id="改变你的状态，使其尽可能的最小"><a href="#改变你的状态，使其尽可能的最小" class="headerlink" title="改变你的状态，使其尽可能的最小"></a>改变你的状态，使其尽可能的最小</h3><p>这是一个假设（稍微设计过）的例子：</p><p>你有一个大的项目列表，我们假设有300或更多。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;List&gt;</div><div class="line">  &#123;<span class="keyword">this</span>.props.items.map(<span class="function">(<span class="params">&#123; content, itemId &#125;</span>) =&gt;</span> (</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ListItem</span></span></span></div><div class="line">      <span class="attr">onClick</span>=<span class="string">&#123;selectItem&#125;</span></div><div class="line">      <span class="attr">content</span>=<span class="string">&#123;content&#125;</span></div><div class="line">      <span class="attr">itemId</span>=<span class="string">&#123;itemId&#125;</span></div><div class="line">      <span class="attr">key</span>=<span class="string">&#123;itemId&#125;</span></div><div class="line">    /&gt;</div><div class="line">  ))&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">List</span>&gt;</span></div></pre></td></tr></table></figure><p>当我们点击一​​个列表项时，一个动作被触发，更新一个存储值 - <code>selectedItem</code>。每个列表项连接到 Redux 并获取<code>selectedItem</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ListItem = connect(</div><div class="line">  <span class="function">(<span class="params">&#123; selectedItem &#125;</span>) =&gt;</span> (&#123; selectedItem &#125;)</div><div class="line">)(SimpleListItem);</div></pre></td></tr></table></figure><p>我们正在做正确的事情，我们仅将组件连接到所需的状态。但是，当<code>selectedItem</code>更新时，所有<code>ListItem</code>组件都将重新渲染，因为我们返回的对象<code>selectedItem</code>已经更改。在此之前 <code>{ selectedItem: 123 }</code>，现在是 <code>{ selectedItem: 120 }</code>。</p><p>请记住，我们正在使用该 <code>selectedItem</code> 值来检查当前项目是否被选中。所以我们的组件真正需要知道的是它是否被选择 - 实质上是一个<code>Boolean</code>。<code>Boolean</code> 是伟大的，因为只有两个可能的值，<code>true</code> 或者 <code>false</code>。所以如果我们返回一个布尔值，而不是 <code>selectedItem</code> ，仅 <code>Boolean</code> 更改的两个项目将会重新渲染，这就是我们需要的。<code>mapStateToProps</code> 实际上 <code>props</code> 它是组件的第二个参数，我们可以用它来检查这是否实际上是选定的项目。以下是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ListItem = connect(</div><div class="line">  <span class="function">(<span class="params">&#123; selectedItem &#125;, &#123; itemId &#125;</span>) =&gt;</span> (&#123; <span class="attr">isSelected</span>: selectedItem === itemId &#125;)</div><div class="line">)(SimpleListItem);</div></pre></td></tr></table></figure><p>现在，只要我们的 <code>selectedItem</code> 值发生变化，只有两个组件重新呈现 - <code>ListItem</code> 现在已经被选择了，而且原来那个已经被取消选择了。</p><h3 id="保持数据扁平化"><a href="#保持数据扁平化" class="headerlink" title="保持数据扁平化"></a>保持数据扁平化</h3><p>在 <a href="http://redux.js.org/docs/recipes/reducers/NormalizingStateShape.html" target="_blank" rel="noopener">Redux文档提到</a> 这是一种最佳实践。保持您的store 扁平化是有益的一些原因。但是对于本文的主旨，嵌套会造成问题，因为为了让我们的应用程序尽可能的快，我们希望我们的更新尽可能的细微。假设我们有一个这样的嵌套形状：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">articles</span>: [&#123;</div><div class="line">    <span class="attr">comments</span>: [&#123;</div><div class="line">      <span class="attr">users</span>: [&#123;</div><div class="line">      &#125;]</div><div class="line">    &#125;]</div><div class="line">  &#125;],</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>为了优化我们的 <code>Article</code>，<code>Comment</code> 和 <code>User</code> 组件，我们现在需要所有的人订阅 <code>articles</code>，然后深深伸入这种结构只返回他们所需要的状态。相反地​​，如此设计你的形状更有意义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">articles</span>: [&#123;</div><div class="line">    ...</div><div class="line">  &#125;],</div><div class="line">  <span class="attr">comments</span>: [&#123;</div><div class="line">    <span class="attr">articleId</span>: ..,</div><div class="line">    <span class="attr">userId</span>: ...,</div><div class="line">    ...</div><div class="line">  &#125;],</div><div class="line">  <span class="attr">users</span>: [&#123;</div><div class="line">    ...</div><div class="line">  &#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后使用映射函数选择注释和用户信息。关于这一点的更多信息可以在 <a href="http://redux.js.org/docs/recipes/reducers/NormalizingStateShape.html" target="_blank" rel="noopener">Redux文档中阅读关于规范化状态的信息</a>。</p><h2 id="彩蛋：用于选择-Redux-state-的库"><a href="#彩蛋：用于选择-Redux-state-的库" class="headerlink" title="彩蛋：用于选择 Redux state 的库"></a>彩蛋：用于选择 Redux state 的库</h2><p>这是完全可选的，取决于您。通常所有以上的建议都足够深入地让你写出快速的 react 和 Redux 应用程序。但是有两个优秀的库使得选择状态更容易一些：</p><p><a href="https://github.com/reactjs/reselect" target="_blank" rel="noopener">Reselect</a> 是 <code>selectors</code> 为您的 Redux 应用程序编写的引人注目的工具。从重新选择文档：</p><ul><li>选择器可以计算派生数据，允许 Redux 存储尽可能小的状态。</li><li>选择器效率高。除非其中一个参数发生变化，否则不会重新计算选择器。</li><li>选择器是可组合的。它们可以用作其他选择器的输入。</li></ul><p>对于具有复杂接口，复杂状态 和/或 频繁更新的应用程序，重新选择可以帮助您轻松使您的应用程序更快！</p><p><a href="http://ramdajs.com/" target="_blank" rel="noopener">Ramda</a> 是一个功能强大的库，具有更高阶的函数。换句话说 - 用函数创建函数。由于我们的映射函数只是这个函数，所以我们可以很方便地使用 <code>Ramda</code> 创建我们的选择器。<code>Ramda</code> 可以有选择器的所有功能并做的更多。查看 <a href="https://github.com/ramda/ramda/wiki/Cookbook" target="_blank" rel="noopener">Ramda 食谱</a>的一些例子，您可以使用 Ramda 做什么。</p><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redux-并不慢，只是你使用姿势不对-——-一份优化指南&quot;&gt;&lt;a href=&quot;#Redux-并不慢，只是你使用姿势不对-——-一份优化指南&quot; class=&quot;headerlink&quot; title=&quot;Redux 并不慢，只是你使用姿势不对 —— 一份优化指南&quot;&gt;&lt;/a&gt;Redux 并不慢，只是你使用姿势不对 —— 一份优化指南&lt;/h1&gt;&lt;p&gt;&lt;em&gt;如何优化使用了 Redux 的 react 应用程序并不是显而易见的。但实际上相当简单。这是一个简短的指南，以及一些例子。&lt;/em&gt;&lt;/p&gt;&lt;p&gt;当优化使用 Redux 的 react 应用程序时，我经常听到有人说 Redux 缓慢。在99％的情况下，性能不佳的原因（适用于任何其他框架）与不必要的渲染相关联，因为 DOM 更新是昂贵的！在本文中，您将学习如何在使用 Redux 绑定 react 时避免不必要的 &lt;code&gt;render&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;通常，我们使用&lt;a href=&quot;https://github.com/reactjs/react-redux&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方 react 绑定的 Redux&lt;/a&gt; 的 &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;connect&lt;/a&gt; 高阶组件， 当您的 Redux &lt;code&gt;store&lt;/code&gt; 更新时，react 组件就会更新。这是一个将组件包装在另一个组件中的函数，该组件订阅了 Redux &lt;code&gt;store&lt;/code&gt; 中的更改，并渲染 &lt;code&gt;store&lt;/code&gt;，这就是它的子节点更新的原因。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="react" scheme="http://robin-front.github.io/tags/react/"/>
    
      <category term="redux" scheme="http://robin-front.github.io/tags/redux/"/>
    
  </entry>
  
</feed>
