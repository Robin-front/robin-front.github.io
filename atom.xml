<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>三寸稚笔</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://robin-front.github.io/"/>
  <updated>2016-04-21T16:02:56.000Z</updated>
  <id>http://robin-front.github.io/</id>
  
  <author>
    <name>robin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>子进程child_process让Node.js具备命令行的功能</title>
    <link href="http://robin-front.github.io/2016/04/22/%E5%AD%90%E8%BF%9B%E7%A8%8Bchild-process%E8%AE%A9Node-js%E5%85%B7%E5%A4%87%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E5%8A%9F%E8%83%BD/"/>
    <id>http://robin-front.github.io/2016/04/22/子进程child-process让Node-js具备命令行的功能/</id>
    <published>2016-04-21T16:02:56.000Z</published>
    <updated>2016-04-21T16:02:56.000Z</updated>
    
    <content type="html">&lt;p&gt;在&lt;code&gt;Node&lt;/code&gt;中使用子进程的目的，正是希望从&lt;code&gt;Node&lt;/code&gt;应用程序中通过命令行的方式访问计算机资源。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;共有四种不同的技术来创建一个子进程&lt;/p&gt;
&lt;h3 id=&quot;child-process-spawn&quot;&gt;&lt;a href=&quot;#child-process-spawn&quot; class=&quot;headerlink&quot; title=&quot;child_process.spawn&quot;&gt;&lt;/a&gt;child_process.spawn&lt;/h3&gt;&lt;p&gt;&lt;code&gt;spawn&lt;/code&gt;是创建子进程最常见的方法。例：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; spawn = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;child_process&#39;&lt;/span&gt;).spawn,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pwd = spawn(&lt;span class=&quot;string&quot;&gt;&#39;pwd&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pwd.stdout.on(&lt;span class=&quot;string&quot;&gt;&#39;data&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;data&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;stdout:&#39;&lt;/span&gt; + data);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pwd.stderr.on(&lt;span class=&quot;string&quot;&gt;&#39;data&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;data&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;stderr&#39;&lt;/span&gt; + data);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pwd.on(&lt;span class=&quot;string&quot;&gt;&#39;close&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;code&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;child process close with code&#39;&lt;/span&gt; + code);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pwd.on(&lt;span class=&quot;string&quot;&gt;&#39;exit&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;code&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;child process exit with code&#39;&lt;/span&gt; + code);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;参数作为数组传入&lt;/li&gt;
&lt;li&gt;子进程对 &lt;code&gt;stdout&lt;/code&gt; 和 &lt;code&gt;stderr&lt;/code&gt; 相关事件可以进行捕获&lt;/li&gt;
&lt;li&gt;子进程退出代码为 1，表示发生了错误；没有错误时，退出代码为 0&lt;/li&gt;
&lt;li&gt;尽量使用&lt;code&gt;close&lt;/code&gt;事件而不是&lt;code&gt;exit&lt;/code&gt;事件，在进程结束后访问其数据可能会导致应用程序崩溃&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何使用 &lt;code&gt;stdin&lt;/code&gt; 标准输入对象呢：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; spawn = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;child_process&#39;&lt;/span&gt;).spawn,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    find = spawn(&lt;span class=&quot;string&quot;&gt;&#39;find&#39;&lt;/span&gt;, [&lt;span class=&quot;string&quot;&gt;&#39;.&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;-ls&#39;&lt;/span&gt;]),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    grep = spawn(&lt;span class=&quot;string&quot;&gt;&#39;grep&#39;&lt;/span&gt;, [&lt;span class=&quot;string&quot;&gt;&#39;test&#39;&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;grep.stdout.setEncoding(&lt;span class=&quot;string&quot;&gt;&#39;utf8&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;find.stdout.on(&lt;span class=&quot;string&quot;&gt;&#39;data&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;data&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  grep.stdin.write(data);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;grep.stdout.on(&lt;span class=&quot;string&quot;&gt;&#39;data&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;data&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(data);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面这段例子模拟了&lt;code&gt;Unix&lt;/code&gt;管道（|）功能，可以将一个命令的结果传递给另一个命令作为输入。&lt;/p&gt;
&lt;h3 id=&quot;child-process-exec-和-child-process-execFile&quot;&gt;&lt;a href=&quot;#child-process-exec-和-child-process-execFile&quot; class=&quot;headerlink&quot; title=&quot;child_process.exec 和 child_process.execFile&quot;&gt;&lt;/a&gt;child_process.exec 和 child_process.execFile&lt;/h3&gt;&lt;p&gt;通过 &lt;code&gt;child_process.exec&lt;/code&gt; 和 &lt;code&gt;child_process.execFile&lt;/code&gt; 来启动 &lt;code&gt;shell&lt;/code&gt; 执行命令可以缓存命令执行的结果&lt;/p&gt;
&lt;p&gt;&lt;code&gt;child_process.execFile&lt;/code&gt; 的第一个参数是命令或执行文件路径， 第二个参数是可选参数列表， 第三个参数是回调函数，该回调函数有三个参数： error, stdout 和 stderr。如果没有发生错误，执行结果会保存到 stdout。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;child_process.exec&lt;/code&gt; 则没有可选参数列表，只有 &lt;code&gt;execFile&lt;/code&gt; 方法的第一个和第三个参数。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; execFile = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;child_process&#39;&lt;/span&gt;).execFile,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    child;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;child = execFile(&lt;span class=&quot;string&quot;&gt;&#39;ls&#39;&lt;/span&gt;, [&lt;span class=&quot;string&quot;&gt;&#39;-l&#39;&lt;/span&gt;], &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;error, stdout, stderr&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (error == &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;stdout: &#39;&lt;/span&gt; + stdout);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;execFile&lt;/code&gt; 方法会更安全，因为它的命令行参数作为数组传入。&lt;/p&gt;
&lt;h3 id=&quot;child-process-fork&quot;&gt;&lt;a href=&quot;#child-process-fork&quot; class=&quot;headerlink&quot; title=&quot;child_process.fork&quot;&gt;&lt;/a&gt;child_process.fork&lt;/h3&gt;&lt;p&gt;&lt;code&gt;fork&lt;/code&gt; 其实是对 &lt;code&gt;spawn&lt;/code&gt;的封装，目的是为了启动子进程并运行 &lt;code&gt;Node.js&lt;/code&gt;模块。&lt;/p&gt;
&lt;p&gt;例：&lt;br&gt;&lt;code&gt;fork(&amp;#39;./child.js&amp;#39;)&lt;/code&gt; 相当于 &lt;code&gt;spawn(&amp;#39;node&amp;#39;, [&amp;#39;./child.js&amp;#39;])&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;此方法会在父进程与子进程之间建立一个真实的通信管道，用于进程之间的通信。但通过&lt;code&gt;fork&lt;/code&gt;生成的每个子进程都需要一个全新的 V8 实例，这需要耗费更多时间和内存。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; n = child_process.fork(&lt;span class=&quot;string&quot;&gt;&#39;./child.js&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;n.on(&lt;span class=&quot;string&quot;&gt;&#39;message&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;m&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;PARENT got message:&#39;&lt;/span&gt;, m);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;n.send(&amp;#123; hello: &lt;span class=&quot;string&quot;&gt;&#39;world&#39;&lt;/span&gt; &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;send&lt;/code&gt; 方法用于进程间通信， 通过监听&lt;code&gt;message&lt;/code&gt;事件来获取消息&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;code&gt;Node&lt;/code&gt;中使用子进程的目的，正是希望从&lt;code&gt;Node&lt;/code&gt;应用程序中通过命令行的方式访问计算机资源。&lt;br&gt;
    
    </summary>
    
      <category term="Node" scheme="http://robin-front.github.io/categories/Node/"/>
    
    
      <category term="Node" scheme="http://robin-front.github.io/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>React-v15.0升级指南</title>
    <link href="http://robin-front.github.io/2016/04/19/React-v15-0%E5%8D%87%E7%BA%A7%E6%8C%87%E5%8D%97/"/>
    <id>http://robin-front.github.io/2016/04/19/React-v15-0升级指南/</id>
    <published>2016-04-19T14:38:50.000Z</published>
    <updated>2016-04-19T14:38:50.000Z</updated>
    
    <content type="html">&lt;p&gt;React-v15.0升级指南&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;主要变化&quot;&gt;&lt;a href=&quot;#主要变化&quot; class=&quot;headerlink&quot; title=&quot;主要变化&quot;&gt;&lt;/a&gt;主要变化&lt;/h3&gt;&lt;h4 id=&quot;加入document-createElement-并且废弃-data-reactid&quot;&gt;&lt;a href=&quot;#加入document-createElement-并且废弃-data-reactid&quot; class=&quot;headerlink&quot; title=&quot;加入document.createElement 并且废弃 data-reactid&quot;&gt;&lt;/a&gt;加入&lt;code&gt;document.createElement&lt;/code&gt; 并且废弃 &lt;code&gt;data-reactid&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;经过我们讨论，&lt;code&gt;DOM&lt;/code&gt; 有很大的改变。其中最值得关注的一个变化就是，我们不再给每个 &lt;code&gt;DOM&lt;/code&gt;设置&lt;code&gt;data-reactid&lt;/code&gt;属性。虽然这更难看出一个网页是否使用了 &lt;code&gt;React&lt;/code&gt;，但优势是&lt;code&gt;DOM&lt;/code&gt;更轻量了。这一改变让我们使用 &lt;code&gt;document.createElement&lt;/code&gt;来初始渲染成为可能。在此之前，我们会生成大量的HTML字符串，然后使用 &lt;code&gt;node.innerHTML&lt;/code&gt;来插入。当时，我们决定尽快在大部分案例和支持的浏览器中使用&lt;code&gt;document.createElement&lt;/code&gt;。浏览器持续地改善，因此兼容所有浏览器不再是正确的。使用 &lt;code&gt;createElement&lt;/code&gt;可以让&lt;code&gt;React&lt;/code&gt;的其他功能运行得更快。原来的&lt;code&gt;ids&lt;/code&gt;用来映射&lt;code&gt;React&lt;/code&gt;组件的事件，这意味着，我们不得不对每一个事件做很多工作，即使我们尽可能地缓存这些数据。正如我们遇到过的，缓存和缓存失效很容易出错，我们发现许多问题都无法重现。现在我们在渲染的时候可以直接建立映射，因为我们有了节点的钩子。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;data-reactid&lt;/code&gt;仍然存在于服务端渲染中。不管怎样，这已经比以前要小很多了，并且这只是一个简单的自增计数器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;不再有额外的-lt-span-gt-标签&quot;&gt;&lt;a href=&quot;#不再有额外的-lt-span-gt-标签&quot; class=&quot;headerlink&quot; title=&quot;不再有额外的 &amp;lt;span&amp;gt;标签&quot;&gt;&lt;/a&gt;不再有额外的 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;标签&lt;/h4&gt;&lt;p&gt;另一个关于&lt;code&gt;DOM&lt;/code&gt;讨论的重大变化是如何渲染文本块。之前你可能关注到&lt;code&gt;React&lt;/code&gt;渲染了很多额外的&lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;标签。举个例子，我们在主页渲染&lt;code&gt;&amp;lt;div&amp;gt;Hello {this.props.name}&amp;lt;/div&amp;gt;&lt;/code&gt;，结果包含了两层&lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;标签。现在我们渲染时使用注释节点穿插在普通文本外来划分。这让我们同样拥有更新部分文本的能力，而不用额外的标签。很少人会这些真实的额外标签有依赖，所以你很可以不会受到任何影响。但是如果你在样式文件中对&lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;标签有定义，你可能需要作出相应的调整。你仍然可以在你的组件里显式地指定渲染这些标签。&lt;/p&gt;
&lt;h4 id=&quot;现在使用注释节点渲染-null&quot;&gt;&lt;a href=&quot;#现在使用注释节点渲染-null&quot; class=&quot;headerlink&quot; title=&quot;现在使用注释节点渲染 null&quot;&gt;&lt;/a&gt;现在使用注释节点渲染 &lt;code&gt;null&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;我们还利用注释节点来渲染&lt;code&gt;null&lt;/code&gt;。渲染&lt;code&gt;null&lt;/code&gt;是我们在&lt;code&gt;React v0.11&lt;/code&gt;版本添加的特性，并且通来渲染 &lt;code&gt;&amp;lt;noscript&amp;gt;&lt;/code&gt;元素来应用。现在通过渲染注释节点，你的样式可能会有一些错乱，尤其是当你使用了&lt;code&gt;:nth-child&lt;/code&gt;这样的选择器。&lt;code&gt;React&lt;/code&gt;使用&lt;code&gt;&amp;lt;noscript&amp;gt;&lt;/code&gt;标签，一直在考虑如何&lt;code&gt;React&lt;/code&gt;命中&lt;code&gt;DOM&lt;/code&gt;的实现细节。我们相信这些变化是安全的。另外，我们已经在许多典型的应用中看到这些变化在提升&lt;code&gt;React&lt;/code&gt;的性能。&lt;/p&gt;
&lt;h4 id=&quot;组件现在也可以返回-null&quot;&gt;&lt;a href=&quot;#组件现在也可以返回-null&quot; class=&quot;headerlink&quot; title=&quot;组件现在也可以返回 null&quot;&gt;&lt;/a&gt;组件现在也可以返回 &lt;code&gt;null&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;我们在&lt;code&gt;React v0.14&lt;/code&gt;添加了定义无状态组件的功能。不管怎样，&lt;code&gt;React 0.14&lt;/code&gt;仍然允许你定义一个非继承&lt;code&gt;React.Component&lt;/code&gt;或者使用 &lt;code&gt;React.createClass()&lt;/code&gt;创建的组件。所以我们不能准确地判断你的组件是一个函数还是一个类，并且也不允许你从中返回一个&lt;code&gt;null&lt;/code&gt;。这个问题在&lt;code&gt;React 15&lt;/code&gt;中已经解决，你可以在你任何组件中返回&lt;code&gt;null&lt;/code&gt;，不管是函数还是类。&lt;/p&gt;
&lt;h4 id=&quot;增加SVG支持&quot;&gt;&lt;a href=&quot;#增加SVG支持&quot; class=&quot;headerlink&quot; title=&quot;增加SVG支持&quot;&gt;&lt;/a&gt;增加&lt;code&gt;SVG&lt;/code&gt;支持&lt;/h4&gt;&lt;p&gt;所有的&lt;code&gt;SVG&lt;/code&gt;标签现在都已完美支持。（极少的标签在&lt;code&gt;React.DOM&lt;/code&gt;里不存在，但&lt;code&gt;JSX&lt;/code&gt;和&lt;code&gt;React.createElement&lt;/code&gt;支持所有标签名）。所有被浏览器支持的&lt;code&gt;SVG&lt;/code&gt;属性也全部支持。如果你发现少了什么属性，请给我们提 &lt;code&gt;issue&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;本文翻译自 &lt;a href=&quot;https://facebook.github.io/react/blog/2016/04/07/react-v15.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React v15.0&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;React-v15.0升级指南&lt;br&gt;
    
    </summary>
    
      <category term="react" scheme="http://robin-front.github.io/categories/react/"/>
    
    
      <category term="react" scheme="http://robin-front.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react-router动态路由与Webpack分片thunks</title>
    <link href="http://robin-front.github.io/2016/04/18/react-router%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E4%B8%8EWebpack%E5%88%86%E7%89%87thunks/"/>
    <id>http://robin-front.github.io/2016/04/18/react-router动态路由与Webpack分片thunks/</id>
    <published>2016-04-18T14:16:27.000Z</published>
    <updated>2016-04-18T14:16:27.000Z</updated>
    
    <content type="html">&lt;p&gt;对于大型应用来说，一个首当其冲的问题就是所需加载的 JavaScript 的大小。程序应当只加载当前渲染页所需的 JavaScript。有些开发者将这种方式称之为“代码分拆” — 将所有的代码分拆成多个小包，在用户浏览过程中按需加载。&lt;/p&gt;
&lt;p&gt;对于底层细节的修改不应该需要它上面每一层级都进行修改。举个例子，为一个照片浏览页添加一个路径不应该影响到首页加载的 JavaScript 的大小。也不能因为多个团队共用一个大型的路由配置文件而造成合并时的冲突。&lt;/p&gt;
&lt;p&gt;路由是个非常适于做代码分拆的地方：它的责任就是配置好每个 view。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你使用过单页应用的框架，那你可能应用过路由。路由可以让你的应用看起来好像有很多“页面”。用户可以通过 &lt;code&gt;youdomain.com/about&lt;/code&gt;来获取公司相关的介绍信息。&lt;/p&gt;
&lt;p&gt;在这里使用双引号，是因为这并不是一个真正意义上的“页面”。&lt;/p&gt;
&lt;p&gt;通过各种流行的构建工具的配置，所有的脚本最后都得到连成一片巨大的&lt;code&gt;.js&lt;/code&gt;文件。当你访问  &lt;code&gt;youdomain.com/about&lt;/code&gt; 这个页面的时候，你会下载应用程序的所有内容。但用户可能根本不想，也不会去浏览这些内容。这是非常糟糕的，也会让你的应用变得越来越大。&lt;/p&gt;
&lt;p&gt;对于一个不使用任何框架的普通网页，你首先是下载一个 &lt;code&gt;.html&lt;/code&gt; 文件，然后是从缓存中获取脚本和样式文件。用户只下载他需要的内容，仅此而已。&lt;/p&gt;
&lt;p&gt;你想让你的&lt;code&gt;React.js&lt;/code&gt;应用也按需加载吗？&lt;/p&gt;
&lt;h3 id=&quot;前提条件&quot;&gt;&lt;a href=&quot;#前提条件&quot; class=&quot;headerlink&quot; title=&quot;前提条件&quot;&gt;&lt;/a&gt;前提条件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;react-router&lt;/code&gt; 做为路由解决方案，因为这是功能最强大的 &lt;code&gt;React&lt;/code&gt;路由方案；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Webpack&lt;/code&gt;作为构建工具，因为它有强大的分片能力和齐全的功能&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;react-router&quot;&gt;&lt;a href=&quot;#react-router&quot; class=&quot;headerlink&quot; title=&quot;react-router&quot;&gt;&lt;/a&gt;react-router&lt;/h3&gt;&lt;p&gt;下面是一个常见的路由例子：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; HomePage = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;./HomePage.jsx&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; AboutPage = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;./AboutPage.jsx&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; FAQPage = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;./FAQPage.jsx&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;Router history=&amp;#123;history&amp;#125;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;lt;Route path=&quot;/&quot; component=&amp;#123;HomePage&amp;#125; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;lt;Route path=&quot;/about&quot; component=&amp;#123;AboutPage&amp;#125; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;lt;Route path=&quot;/faq&quot; component=&amp;#123;FAQPage&amp;#125; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/Router&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了方便解释，省略了很多代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果一个用户浏览 &lt;code&gt;yourdomain.com/about&lt;/code&gt;页面，他将看到&lt;code&gt;AboutPage&lt;/code&gt; 组件；如果查看 &lt;code&gt;yourdomain.com/faq&lt;/code&gt;页面，将看到 &lt;code&gt;FAQPage&lt;/code&gt;组件等等。当你使用路由去配置你的应用，这些组件和相关代码将被打包成一个&lt;code&gt;.js&lt;/code&gt;文件。&lt;/p&gt;
&lt;p&gt;值得庆幸的是，&lt;code&gt;react-router&lt;/code&gt;的 &lt;code&gt;&amp;lt;Route&amp;gt;&lt;/code&gt;标签有一个叫做&lt;code&gt;getComponent&lt;/code&gt;的异步的方法去获取组件。他是一个&lt;code&gt;function&lt;/code&gt;接受两个参数，分别是&lt;code&gt;location&lt;/code&gt;和&lt;code&gt;callback&lt;/code&gt;。当&lt;code&gt;react-router&lt;/code&gt;执行回调函数 &lt;code&gt;callback(null, ourComponent)&lt;/code&gt;时，路由只渲染&lt;code&gt;ourComponent&lt;/code&gt;组件。&lt;/p&gt;
&lt;h4 id=&quot;getComponent&quot;&gt;&lt;a href=&quot;#getComponent&quot; class=&quot;headerlink&quot; title=&quot;getComponent&quot;&gt;&lt;/a&gt;getComponent&lt;/h4&gt;&lt;p&gt;让我们来重写上面的例子来支持异步组件：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;Router history=&amp;#123;history&amp;#125;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;lt;Route&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    path=&quot;/&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    getComponent=&amp;#123;(location, callback) =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      // 在这里执行异步操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      callback(null, HomePage);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;lt;Route&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    path=&quot;/about&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    getComponent=&amp;#123;(location, callback) =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      // 在这里执行异步操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      callback(null, AboutPage);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;lt;Route&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    path=&quot;/faq&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    getComponent=&amp;#123;(location, callback) =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      // 在这里执行异步操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      callback(null, FAQPage);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/Router&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这些组件会在需要的时候异步加载。这些组件仍然会在同一个文件中，并且你的应用看起来不会有任何不同。但是没有它，我们的网页将无法运行。&lt;/p&gt;
&lt;h3 id=&quot;Webpack&quot;&gt;&lt;a href=&quot;#Webpack&quot; class=&quot;headerlink&quot; title=&quot;Webpack&quot;&gt;&lt;/a&gt;Webpack&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Webpack&lt;/code&gt; 有一个特性叫做 &lt;code&gt;chunking（分片）&lt;/code&gt;，意思就是通过输出多个文件（chunks）来替代一个总的大的文件。你代码里的分割点（&lt;code&gt;split points&lt;/code&gt;）决定了哪些模块被分到哪些文件里。&lt;/p&gt;
&lt;h4 id=&quot;Split-Points-分块点&quot;&gt;&lt;a href=&quot;#Split-Points-分块点&quot; class=&quot;headerlink&quot; title=&quot;Split Points(分块点)&quot;&gt;&lt;/a&gt;Split Points(分块点)&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Webpack&lt;/code&gt; 提供了很多方式去让我们设置分块点。但最有用的一个就是 &lt;code&gt;require.ensure&lt;/code&gt;方法。下面是一个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;loadModule&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;.ensure([], &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;require&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt; = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;module.js&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;, &lt;span class=&quot;string&quot;&gt;&quot;MyModule&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;module.js&lt;/code&gt; 模块将通过&lt;code&gt;Webpack&lt;/code&gt; 输出在第二个文件里，并且当浏览器执行&lt;code&gt;require.ensure&lt;/code&gt;的时候加载。（当&lt;code&gt;loadModule&lt;/code&gt;被调用的时候并不会加载）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;require.ensure&lt;/code&gt;方法的第三个参数是指定模块名称。它是一个可选项，如果不填，将会自动生成一个 ID作为文件名。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这离成功还差一步，我们还需要配置&lt;code&gt;Webpack.config.js&lt;/code&gt;文件来支持分片&lt;code&gt;thunks&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h4&gt;&lt;p&gt;在&lt;code&gt;Webpack&lt;/code&gt; 配置文件中的 &lt;code&gt;output&lt;/code&gt;选项设置&lt;code&gt;chunkFilename&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;output: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  chunkFilename: &lt;span class=&quot;string&quot;&gt;&#39;[name].chunk.js&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你也可以设置&lt;code&gt;[chunkhash]&lt;/code&gt;和&lt;code&gt;[ID]&lt;/code&gt;变量作为分块的文件名。如果没有指定&lt;code&gt;[name]&lt;/code&gt;变量，将会使用 &lt;code&gt;ID&lt;/code&gt; 作为分块文件名。&lt;/p&gt;
&lt;p&gt;这可以正常运行，但有个问题。通用的依赖通常都在一个单独的文件中。如果在你应用的模块中使用了&lt;code&gt;React&lt;/code&gt;，&lt;code&gt;React&lt;/code&gt;将包含在每一个分片文件&lt;code&gt;thunks&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;我们可以通过 &lt;code&gt;CommonsChunkPlugin&lt;/code&gt;插件来解决这个问题。在你的配置文件中添加 &lt;code&gt;plugins&lt;/code&gt; 选项：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;plugins: [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; webpack.optimize.CommonsChunkPlugin(&lt;span class=&quot;string&quot;&gt;&#39;common.js&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我喜欢使用 &lt;code&gt;common.js&lt;/code&gt; 作为文件名，因为这样很直观，但它也可以任意指定。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;非常好，代码分割完成。让我们配合&lt;code&gt;react-router&lt;/code&gt;一起使用。&lt;/p&gt;
&lt;h3 id=&quot;整合&quot;&gt;&lt;a href=&quot;#整合&quot; class=&quot;headerlink&quot; title=&quot;整合&quot;&gt;&lt;/a&gt;整合&lt;/h3&gt;&lt;p&gt;还记得我们上面提到的异步加载组件的路由吗？上面通过 &lt;code&gt;require&lt;/code&gt;引用 &lt;code&gt;HomePage&lt;/code&gt;组件。让我们配合使用 &lt;code&gt;getComponent&lt;/code&gt; 和 &lt;code&gt;require.ensure&lt;/code&gt; 来实现按需加载。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;Route&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  path=&lt;span class=&quot;string&quot;&gt;&quot;/&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  getComponent=&amp;#123;(location, callback) =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;.ensure([], &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;require&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; HomePage = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;./HomePage.jsx&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      callback(&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;, HomePage);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;, &lt;span class=&quot;string&quot;&gt;&#39;HomePage&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;把 &lt;code&gt;require&lt;/code&gt;放在 &lt;code&gt;callback&lt;/code&gt;里更简洁：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;Route&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  path=&lt;span class=&quot;string&quot;&gt;&quot;/&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  getComponent=&amp;#123;(location, callback) =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;.ensure([], &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;require&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      callback(&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;./HomePage.jsx&#39;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;, &lt;span class=&quot;string&quot;&gt;&#39;HomePage&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;完整的代码如下：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;Router history=&amp;#123;history&amp;#125;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;lt;Route&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    path=&quot;/&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    getComponent=&amp;#123;(location, callback) =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      require.ensure([], function (require) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        callback(null, require(&#39;./HomePage.jsx&#39;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;lt;Route&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    path=&quot;/about&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    getComponent=&amp;#123;(location, callback) =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      require.ensure([], function (require) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        callback(null, require(&#39;./AboutPage.jsx&#39;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;lt;Route&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    path=&quot;/faq&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    getComponent=&amp;#123;(location, callback) =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      require.ensure([], function (require) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        callback(null, require(&#39;./FAQPage.jsx&#39;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/Router&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;本文翻译自 &lt;a href=&quot;http://blog.mxstbr.com/2016/01/react-apps-with-pages/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.mxstbr.com/2016/01/react-apps-with-pages/&lt;/a&gt;&lt;br&gt;参考 &lt;a href=&quot;http://react-guide.github.io/react-router-cn/docs/guides/advanced/DynamicRouting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://react-guide.github.io/react-router-cn/docs/guides/advanced/DynamicRouting.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;对于大型应用来说，一个首当其冲的问题就是所需加载的 JavaScript 的大小。程序应当只加载当前渲染页所需的 JavaScript。有些开发者将这种方式称之为“代码分拆” — 将所有的代码分拆成多个小包，在用户浏览过程中按需加载。&lt;/p&gt;
&lt;p&gt;对于底层细节的修改不应该需要它上面每一层级都进行修改。举个例子，为一个照片浏览页添加一个路径不应该影响到首页加载的 JavaScript 的大小。也不能因为多个团队共用一个大型的路由配置文件而造成合并时的冲突。&lt;/p&gt;
&lt;p&gt;路由是个非常适于做代码分拆的地方：它的责任就是配置好每个 view。&lt;br&gt;
    
    </summary>
    
      <category term="react" scheme="http://robin-front.github.io/categories/react/"/>
    
      <category term="Webpack" scheme="http://robin-front.github.io/categories/react/Webpack/"/>
    
    
      <category term="react" scheme="http://robin-front.github.io/tags/react/"/>
    
      <category term="Webpack" scheme="http://robin-front.github.io/tags/Webpack/"/>
    
      <category term="react-router" scheme="http://robin-front.github.io/tags/react-router/"/>
    
  </entry>
  
  <entry>
    <title>Node全局对象：global、process和Buffer</title>
    <link href="http://robin-front.github.io/2016/04/14/Node%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%EF%BC%9Aglobal%E3%80%81process%E5%92%8CBuffer/"/>
    <id>http://robin-front.github.io/2016/04/14/Node全局对象：global、process和Buffer/</id>
    <published>2016-04-14T15:39:02.000Z</published>
    <updated>2016-04-14T15:39:02.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;code&gt;global&lt;/code&gt;对象，也是&lt;code&gt;Node&lt;/code&gt;的全局命名空间；&lt;br&gt;&lt;code&gt;process&lt;/code&gt;对象，它提供了一些关键功能，例如对三种标准I/O流的封装，以及将同步函数转换为异步回调的功能；&lt;br&gt;&lt;code&gt;Buffer&lt;/code&gt;类，它提供了存储和操作原始数据的功能，同样它也是全局可见的&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;global&quot;&gt;&lt;a href=&quot;#global&quot; class=&quot;headerlink&quot; title=&quot;global&quot;&gt;&lt;/a&gt;global&lt;/h2&gt;&lt;p&gt;global与浏览器中的&lt;code&gt;window&lt;/code&gt;对象是相似的，它们的关健不同点是：&lt;/p&gt;
&lt;p&gt;浏览器中的&lt;code&gt;window&lt;/code&gt;对象是一个真正全局的对象。如果在客户端 &lt;code&gt;JavaScript&lt;/code&gt;中定义一个全局变量，它将能够被Web页面以及每一个独立的库访问到。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 而&lt;code&gt;Node&lt;/code&gt;模块中创建一个顶层变量（函数之外的变量），它仅仅在该模块中是全局的，而在其他模块中是不可见的。只有那些被模块显式导出的部分才能被引用该模块的应用程序所使用。 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这意味着，由于不小心使用了重复的全局变量名称而引起的数据冲突问题将会大大减少。&lt;/p&gt;
&lt;h2 id=&quot;process&quot;&gt;&lt;a href=&quot;#process&quot; class=&quot;headerlink&quot; title=&quot;process&quot;&gt;&lt;/a&gt;process&lt;/h2&gt;&lt;p&gt;每个&lt;code&gt;Node&lt;/code&gt;应用程序都是一个&lt;code&gt;process&lt;/code&gt;对象实例，所以，应用程序自然能直接使用某些内建于 &lt;code&gt;process&lt;/code&gt; 对象的功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;process.execPath&lt;/code&gt; 方法可以返回当前 &lt;code&gt;Node&lt;/code&gt; 应用程序的执行路径&lt;/li&gt;
&lt;li&gt;&lt;code&gt;process.version&lt;/code&gt; 提供了 &lt;code&gt;Node&lt;/code&gt; 版本信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;process.platform&lt;/code&gt; 提供服务器平台信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;process.memoryUsage&lt;/code&gt; 方法可以查询当前&lt;code&gt;Node&lt;/code&gt; 应用程序的内存使用量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt; &lt;code&gt;process.nextTick&lt;/code&gt; 方法 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个方法可以将一个回调函数挂载到&lt;code&gt;Node&lt;/code&gt;程序的事件循环机制中，并在下一个事件循环发生时调用该函数。 例：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;asynchFunction&lt;/span&gt; = &lt;span class=&quot;title&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;data, cb&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  process.nextTick(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cb(val)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;虽然使用 &lt;code&gt;setTimout&lt;/code&gt; 方法并传入一个0毫秒的延迟可以过到同样的目的&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;setTimout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cb(val)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 但是，&lt;code&gt;setTimout&lt;/code&gt;并不像 &lt;code&gt;process.nextTick&lt;/code&gt;那样高效，&lt;code&gt;process.nextTick&lt;/code&gt;的调用速度远远快于&lt;code&gt;setTimout&lt;/code&gt;方法 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先你需要将耗时的处理过和打散并分解成多个部分，每个部分分别通过 &lt;code&gt;process.nextTick&lt;/code&gt;调用，最终使得应用程序可以对其他请求进行处理，而无需等待耗时计算过程完成。&lt;/p&gt;
&lt;h2 id=&quot;Buffer&quot;&gt;&lt;a href=&quot;#Buffer&quot; class=&quot;headerlink&quot; title=&quot;Buffer&quot;&gt;&lt;/a&gt;Buffer&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Buffer&lt;/code&gt; 是用于处理二进制数据的一种方式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;流处理往往采用的是二进制数据，而非字符串&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Buffer&lt;/code&gt; 支持的编码方式包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ascii 七位 &lt;code&gt;ASCII&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;utf8 多字节编码的 &lt;code&gt;Unicode&lt;/code&gt; 字符&lt;/li&gt;
&lt;li&gt;usc2 两字节，little endian 方式编码的 Unicode 字符&lt;/li&gt;
&lt;li&gt;base64 Base64 编码&lt;/li&gt;
&lt;li&gt;hex 每个字节编码为两个十六进制字符&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;global&lt;/code&gt;对象，也是&lt;code&gt;Node&lt;/code&gt;的全局命名空间；&lt;br&gt;&lt;code&gt;process&lt;/code&gt;对象，它提供了一些关键功能，例如对三种标准I/O流的封装，以及将同步函数转换为异步回调的功能；&lt;br&gt;&lt;code&gt;Buffer&lt;/code&gt;类，它提供了存储和操作原始数据的功能，同样它也是全局可见的&lt;br&gt;
    
    </summary>
    
      <category term="Node" scheme="http://robin-front.github.io/categories/Node/"/>
    
    
      <category term="Node" scheme="http://robin-front.github.io/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>Node与REPL</title>
    <link href="http://robin-front.github.io/2016/04/13/%E8%AE%B0node%E4%B8%8EREPL/"/>
    <id>http://robin-front.github.io/2016/04/13/记node与REPL/</id>
    <published>2016-04-13T15:15:44.000Z</published>
    <updated>2016-04-13T15:15:44.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这几个月，搜芽前端团队搞了&lt;code&gt;Reactjs+Redux&lt;/code&gt;项目，在很多时候，比如部署，都需要使用&lt;code&gt;Node&lt;/code&gt;，苦于我的肤浅，于是决定补一下功课。最近都会记录一些 &lt;code&gt;Node&lt;/code&gt;相关的笔记。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Node-的优势&quot;&gt;&lt;a href=&quot;#Node-的优势&quot; class=&quot;headerlink&quot; title=&quot;Node 的优势&quot;&gt;&lt;/a&gt;Node 的优势&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;应用程序可以很容易地扩展，因为执行一个单线程并不会有非常大的开销&lt;/li&gt;
&lt;li&gt;无需诉求于多线程开发，却达到了节约又能高效使用资源的目的。换句话说，你不必创建一个线程安全的应用程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;全局变量在 &lt;code&gt;Node&lt;/code&gt; 中是非常危险的，特别是你忘记 &lt;code&gt;var&lt;/code&gt;关键字的时候。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;REPL&quot;&gt;&lt;a href=&quot;#REPL&quot; class=&quot;headerlink&quot; title=&quot;REPL&quot;&gt;&lt;/a&gt;REPL&lt;/h3&gt;&lt;p&gt;&lt;code&gt;REPL(read-eval-print-loop)&lt;/code&gt; 是&lt;code&gt;Node&lt;/code&gt;的一个交互式组件。在 &lt;code&gt;REPL&lt;/code&gt;环境下输入的任何内容都由底层的 &lt;code&gt;V8 Javascript引擎&lt;/code&gt;进行处理。&lt;/p&gt;
&lt;h4 id=&quot;一些操作技巧&quot;&gt;&lt;a href=&quot;#一些操作技巧&quot; class=&quot;headerlink&quot; title=&quot;一些操作技巧&quot;&gt;&lt;/a&gt;一些操作技巧&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;_(下划线)&lt;/code&gt; 可以调用上一个表达式&lt;/li&gt;
&lt;li&gt;上下键仍然可以快捷输入历史命令, Tab 键自动补全&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可以使用重复的 &lt;code&gt;.(点)&lt;/code&gt; 来处理多行表达式，如：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; test = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...return val = x * y  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;退出 &lt;code&gt;REPL&lt;/code&gt;环境的方式有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ctrl + C&lt;/code&gt;两次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl + D&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.exit&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;REPL-命令&quot;&gt;&lt;a href=&quot;#REPL-命令&quot; class=&quot;headerlink&quot; title=&quot;REPL 命令&quot;&gt;&lt;/a&gt;REPL 命令&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;.break&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果多行输入发生混乱不知道当前位置时，使用 &lt;code&gt;.break&lt;/code&gt;会重新开始。不过会丢失之前输入的多行内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;.clear&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;重置语境并清空所有表达式。该命令可以使你重头再来。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;.exit&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;退出 &lt;code&gt;REPL&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;.help&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;显示所有可用的&lt;code&gt;REPL&lt;/code&gt;命令。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;.save&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将当前&lt;code&gt;REPL&lt;/code&gt;会话保存至文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;.load&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将文件加载到当前会话&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;定制-REPL&quot;&gt;&lt;a href=&quot;#定制-REPL&quot; class=&quot;headerlink&quot; title=&quot;定制 REPL&quot;&gt;&lt;/a&gt;定制 REPL&lt;/h4&gt;&lt;p&gt;首先需要引入 &lt;code&gt;REPL&lt;/code&gt; 模块：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; repl = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;repl&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过在&lt;code&gt;repl&lt;/code&gt;对象上调用 &lt;code&gt;start&lt;/code&gt;方法创建新的 &lt;code&gt;REPL&lt;/code&gt;：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;repl.start([prompt], [stream], [&lt;span class=&quot;built_in&quot;&gt;eval&lt;/span&gt;], [useGlobal], [ignoreUndefinded]);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;所有参数都可选。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;prompt&lt;/code&gt;&lt;br&gt;Default is &lt;code&gt;&amp;gt;&lt;/code&gt; 默认值为 &lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stream&lt;/code&gt;&lt;br&gt;默认值为&lt;code&gt;process.stdin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;eval&lt;/code&gt;&lt;br&gt;&lt;code&gt;eval&lt;/code&gt;的默认值是 &lt;code&gt;async&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;useGlobal&lt;/code&gt;&lt;br&gt;默认值为 false, 新建一个语境而不是使用全局对象。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ignoreUndefinded&lt;/code&gt;&lt;br&gt;默认值为 false。 不要忽略&lt;code&gt;undefined&lt;/code&gt;的返回值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以让&lt;code&gt;REPL&lt;/code&gt;在表达式无返回值时不输出&lt;code&gt;undefined&lt;/code&gt;可以这样实现：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;repl = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;repl&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 设置 `ignoreUndefinded` 为 `true` , 启动 `REPL`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;repl.start(&lt;span class=&quot;string&quot;&gt;&#39;&amp;gt;&#39;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这几个月，搜芽前端团队搞了&lt;code&gt;Reactjs+Redux&lt;/code&gt;项目，在很多时候，比如部署，都需要使用&lt;code&gt;Node&lt;/code&gt;，苦于我的肤浅，于是决定补一下功课。最近都会记录一些 &lt;code&gt;Node&lt;/code&gt;相关的笔记。&lt;br&gt;
    
    </summary>
    
      <category term="Node" scheme="http://robin-front.github.io/categories/Node/"/>
    
    
      <category term="Node" scheme="http://robin-front.github.io/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>postCSS常用插件</title>
    <link href="http://robin-front.github.io/2016/04/10/postCSS%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"/>
    <id>http://robin-front.github.io/2016/04/10/postCSS常用插件/</id>
    <published>2016-04-09T16:43:12.000Z</published>
    <updated>2016-04-09T16:43:12.000Z</updated>
    
    <content type="html">&lt;p&gt;PostCSS拥有非常多的插件，诸如自动为CSS添加浏览器前缀的插件autoprefixer、当前移动端最常用的px转rem插件px2rem，还有支持尚未成为CSS标准但特定可用的插件cssnext，还有很多很多。就连著名的Bootstrap在下一个版本Bootstrap 5也将使用PostCSS作为样式的基础。&lt;/p&gt;
&lt;p&gt;一句话来概括PostCSS：CSS编译器能够做到的事情，它也可以做到，而且能够做得更好&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;PostCSS性能&quot;&gt;&lt;a href=&quot;#PostCSS性能&quot; class=&quot;headerlink&quot; title=&quot;PostCSS性能&quot;&gt;&lt;/a&gt;PostCSS性能&lt;/h3&gt;&lt;p&gt;在PostCSS官方推特上看到，由JavaScript编写的PostCSS比C++编写的libsass还要快3倍.&lt;/p&gt;
&lt;p&gt;如果你对上面的性能截图有疑问，可以亲自来&lt;a href=&quot;https://github.com/postcss/benchmark&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;测试看看。&lt;/p&gt;
&lt;h3 id=&quot;常用的插件&quot;&gt;&lt;a href=&quot;#常用的插件&quot; class=&quot;headerlink&quot; title=&quot;常用的插件&quot;&gt;&lt;/a&gt;常用的插件&lt;/h3&gt;&lt;h4 id=&quot;autoprefixer&quot;&gt;&lt;a href=&quot;#autoprefixer&quot; class=&quot;headerlink&quot; title=&quot;autoprefixer&quot;&gt;&lt;/a&gt;autoprefixer&lt;/h4&gt;&lt;p&gt;首先是最火的官方插件 &lt;code&gt;autoprefixer&lt;/code&gt; 。&lt;code&gt;autoprefixer&lt;/code&gt; 是为我们的 &lt;code&gt;css&lt;/code&gt; 添加前缀的插件，它的数据来源于 &lt;a href=&quot;http://caniuse.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Can I use&lt;/a&gt;。目的是让我们写纯粹的 &lt;code&gt;css&lt;/code&gt;。例：&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;a&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;display&lt;/span&gt;: flex;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;会编译成：&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;a&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;display&lt;/span&gt;: -webkit-box;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;display&lt;/span&gt;: -webkit-flex;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;display&lt;/span&gt;: -ms-flexbox;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;display&lt;/span&gt;: flex&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h5 id=&quot;Options&quot;&gt;&lt;a href=&quot;#Options&quot; class=&quot;headerlink&quot; title=&quot;Options&quot;&gt;&lt;/a&gt;Options&lt;/h5&gt;&lt;p&gt;通过 &lt;code&gt;autoprefixer(options)&lt;/code&gt; 配置：&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var plugin = autoprefixer(&amp;#123; browsers: [&#39;&amp;gt; 1%&#39;, &#39;IE 7&#39;], cascade: false &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;browsers (array): 指定你需要支持的浏览器列表。可以直接指定浏览器版本（如 IE 7）,也可以使用选项（如： last 2 version 或 &amp;gt; 5%）,具体选项可以查看 &lt;a href=&quot;https://github.com/ai/browserslist#queries&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Browserslist&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;cascade (boolean): should Autoprefixer use Visual Cascade, if CSS is uncompressed. Default: true&lt;/li&gt;
&lt;li&gt;add (boolean): 是否添加浏览器兼容前缀. 默认值是true.&lt;/li&gt;
&lt;li&gt;remove (boolean): 是否去除无用的浏览器兼容前缀. 默认值是true.&lt;/li&gt;
&lt;li&gt;supports (boolean): should Autoprefixer add prefixes for @supports parameters. Default is true.&lt;br&gt;flexbox (boolean|string): should Autoprefixer add prefixes for flexbox properties. With “no-2009” value Autoprefixer will add prefixes only for final and IE versions of specification. Default is true.&lt;/li&gt;
&lt;li&gt;grid (boolean): should Autoprefixer add IE prefixes for Grid Layout properties. Default is true.&lt;/li&gt;
&lt;li&gt;stats (object): custom usage statistics for &amp;gt; 10% in my stats browsers query.&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;调试&quot;&gt;&lt;a href=&quot;#调试&quot; class=&quot;headerlink&quot; title=&quot;调试&quot;&gt;&lt;/a&gt;调试&lt;/h5&gt;&lt;p&gt;&lt;code&gt;info()&lt;/code&gt; 方法可用于查看调试信息.可以像下面这样查看哪些浏览器被选中以及哪些属性被添加兼容前缀：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var info = autoprefixer(&amp;#123; browsers: [&#39;last 1 version&#39;] &amp;#125;).info();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(info);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;postcss-safe-parser&quot;&gt;&lt;a href=&quot;#postcss-safe-parser&quot; class=&quot;headerlink&quot; title=&quot;postcss-safe-parser&quot;&gt;&lt;/a&gt;postcss-safe-parser&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/postcss/postcss-safe-parser&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;postcss-safe-parser&lt;/code&gt;&lt;/a&gt; 可以帮你查找并修补CSS语法错误。&lt;/p&gt;
&lt;h4 id=&quot;cssnano&quot;&gt;&lt;a href=&quot;#cssnano&quot; class=&quot;headerlink&quot; title=&quot;cssnano&quot;&gt;&lt;/a&gt;cssnano&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;http://cssnano.co/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;cssnano&lt;/code&gt;&lt;/a&gt; 是模块化的CSS压缩器。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;PostCSS拥有非常多的插件，诸如自动为CSS添加浏览器前缀的插件autoprefixer、当前移动端最常用的px转rem插件px2rem，还有支持尚未成为CSS标准但特定可用的插件cssnext，还有很多很多。就连著名的Bootstrap在下一个版本Bootstrap 5也将使用PostCSS作为样式的基础。&lt;/p&gt;
&lt;p&gt;一句话来概括PostCSS：CSS编译器能够做到的事情，它也可以做到，而且能够做得更好&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>postCSS-loader配置,让css随心所欲</title>
    <link href="http://robin-front.github.io/2016/04/09/postCSS-loader%E9%85%8D%E7%BD%AE/"/>
    <id>http://robin-front.github.io/2016/04/09/postCSS-loader配置/</id>
    <published>2016-04-09T14:47:09.000Z</published>
    <updated>2016-04-09T14:47:09.000Z</updated>
    
    <content type="html">&lt;p&gt;组件必不可少的一部分就是 &lt;code&gt;css&lt;/code&gt;，这里看下关于 &lt;code&gt;css&lt;/code&gt;的一些 &lt;code&gt;loaders&lt;/code&gt;。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;PostCSS&quot;&gt;&lt;a href=&quot;#PostCSS&quot; class=&quot;headerlink&quot; title=&quot;PostCSS&quot;&gt;&lt;/a&gt;PostCSS&lt;/h3&gt;&lt;p&gt;&lt;code&gt;PostCSS&lt;/code&gt; 官网是这么介绍自己的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PostCSS is a tool for transforming styles with JS plugins. These plugins can lint your CSS, support variables and mixins, transpile future CSS syntax, inline images, and more.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;他是一款通过 &lt;code&gt;JS&lt;/code&gt; 插件转换 &lt;code&gt;styles&lt;/code&gt; 样式的工具。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;Webpack&lt;/code&gt; 里面可以通过 &lt;code&gt;postCSS-loader&lt;/code&gt; 来使用 &lt;code&gt;PostCSS&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h4&gt;&lt;p&gt;首先是安装 &lt;code&gt;postCSS-loader&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install postcss-loader --save-dev&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面是一个 &lt;code&gt;Webpack config&lt;/code&gt; 的例子：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; precss       = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;precss&#39;&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// 实现类Sass的功能，变量，嵌套，mixins&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; autoprefixer = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;autoprefixer&#39;&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// 自动添加浏览器前缀&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.exports = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        loaders: [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                test:   &lt;span class=&quot;regexp&quot;&gt;/\.css$/&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                loader: &lt;span class=&quot;string&quot;&gt;&quot;style-loader!css-loader!postcss-loader&quot;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//在使用 css-loader,style-loader之前处理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    postcss: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123; &lt;span class=&quot;comment&quot;&gt;// postcss 插件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [precss, autoprefixer];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;上面的例子使用了两个 &lt;code&gt;postcss&lt;/code&gt; 插件，应该预先安装：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; npm install precss --save-dev&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; npm install autoprefixer --save-dev&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/blockquote&gt;
&lt;p&gt;在文件中引入的css将通过 &lt;code&gt;PostCSS&lt;/code&gt; 插件的处理:&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; css = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;./file.css&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;or&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;./file.css&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// =&amp;gt; CSS after Autoprefixer and CSSWring&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;插件组&quot;&gt;&lt;a href=&quot;#插件组&quot; class=&quot;headerlink&quot; title=&quot;插件组&quot;&gt;&lt;/a&gt;插件组&lt;/h4&gt;&lt;p&gt;如果你想对不同目录或类型的 &lt;code&gt;css&lt;/code&gt;使用不同的 &lt;code&gt;PostCSS&lt;/code&gt; 插件配置进行处理，可以使用 &lt;code&gt;?pack=name&lt;/code&gt; 参数&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.exports = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        loaders: [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                test:   &lt;span class=&quot;regexp&quot;&gt;/\.docs\.css$/&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                loader: &lt;span class=&quot;string&quot;&gt;&quot;style-loader!css-loader!postcss-loader?pack=cleaner&quot;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// 对docs目录下的css使用 cleaner 的配置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                test:   &lt;span class=&quot;regexp&quot;&gt;/\.css$/&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                loader: &lt;span class=&quot;string&quot;&gt;&quot;style-loader!css-loader!postcss-loader&quot;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// 对其他目录下的css使用 defaults 的配置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    postcss: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            defaults: [precss, autoprefixer],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            cleaner:  [autoprefixer(&amp;#123; browsers: [] &amp;#125;)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;写在-js-中的样式&quot;&gt;&lt;a href=&quot;#写在-js-中的样式&quot; class=&quot;headerlink&quot; title=&quot;写在 js 中的样式&quot;&gt;&lt;/a&gt;写在 js 中的样式&lt;/h4&gt;&lt;p&gt;可以通过 &lt;code&gt;postcss-js&lt;/code&gt; 插件处理写在 js 中的样式&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    test:   &lt;span class=&quot;regexp&quot;&gt;/\.style.js$/&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    loader: &lt;span class=&quot;string&quot;&gt;&quot;style-loader!css-loader!postcss-loader?parser=postcss-js&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;也可以通过 &lt;code&gt;babel&lt;/code&gt; 结合 &lt;code&gt;postcss-js&lt;/code&gt; 处理 &lt;code&gt;es6&lt;/code&gt; 语法中的样式&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    test:   &lt;span class=&quot;regexp&quot;&gt;/\.style.js$/&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    loader: &lt;span class=&quot;string&quot;&gt;&quot;style-loader!css-loader!postcss-loader?parser=postcss-js!babel&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你可以像下面这样写样式&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; colors &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;../config/colors&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;.menu&#39;&lt;/span&gt;: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        color: colors.main,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        height: &lt;span class=&quot;number&quot;&gt;25&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;&amp;amp;_link&#39;&lt;/span&gt;: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            color: &lt;span class=&quot;string&quot;&gt;&#39;white&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;组件必不可少的一部分就是 &lt;code&gt;css&lt;/code&gt;，这里看下关于 &lt;code&gt;css&lt;/code&gt;的一些 &lt;code&gt;loaders&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="Webpack" scheme="http://robin-front.github.io/categories/Webpack/"/>
    
    
      <category term="loaders" scheme="http://robin-front.github.io/tags/loaders/"/>
    
      <category term="Webpack" scheme="http://robin-front.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>babel-loader配置</title>
    <link href="http://robin-front.github.io/2016/04/08/babel-loader%E9%85%8D%E7%BD%AE/"/>
    <id>http://robin-front.github.io/2016/04/08/babel-loader配置/</id>
    <published>2016-04-08T00:36:38.000Z</published>
    <updated>2016-04-08T00:36:38.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install babel-loader babel-core babel-preset-es2015 --save-dev&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;npm 从 npm@3 之后不赞成自动安装&lt;code&gt;peerDependencies&lt;/code&gt;，所有必须在&lt;code&gt;package.json&lt;/code&gt;里明确指定 &lt;code&gt;babel-core&lt;/code&gt; 这样的宿主依赖。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;peerDependencies&lt;/code&gt;字段，主要用来供插件指定其所需要的主软件的版本。更多可以见&lt;a href=&quot;http://luckydrq.com/2014-10-23/peer-dependencies/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果是从babel 5升级到 babel 6，可以看这份&lt;a href=&quot;https://medium.com/@malyw/how-to-update-babel-5-x-6-x-d828c230ec53#.q6grpyp0f&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;指导&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h3&gt;&lt;p&gt;在&lt;code&gt;webpack.config.js&lt;/code&gt;里配置是比较推荐的方式：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  loaders: [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      test: &lt;span class=&quot;regexp&quot;&gt;/\.jsx?$/&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;// 匹配&#39;js&#39; or &#39;jsx&#39; 后缀的文件类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      exclude: &lt;span class=&quot;regexp&quot;&gt;/(node_modules|bower_components)/&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;// 排除某些文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      loader: &lt;span class=&quot;string&quot;&gt;&#39;babel&#39;&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;// 使用&#39;babel-loader&#39;也是一样的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      query: &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 参数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        presets: [&lt;span class=&quot;string&quot;&gt;&#39;es2015&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;选项&quot;&gt;&lt;a href=&quot;#选项&quot; class=&quot;headerlink&quot; title=&quot;选项&quot;&gt;&lt;/a&gt;选项&lt;/h3&gt;&lt;p&gt;选项的写法有两种&lt;/p&gt;
&lt;p&gt;一种是查询字符串的方式：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  loaders: [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      test: &lt;span class=&quot;regexp&quot;&gt;/\.jsx?$/&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      exclude: &lt;span class=&quot;regexp&quot;&gt;/(node_modules|bower_components)/&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      loader: &lt;span class=&quot;string&quot;&gt;&#39;babel?presets[]=es2015&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;另一种是指定 &lt;code&gt;query&lt;/code&gt;属性&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  loaders: [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      test: &lt;span class=&quot;regexp&quot;&gt;/\.jsx?$/&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      exclude: &lt;span class=&quot;regexp&quot;&gt;/(node_modules|bower_components)/&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      loader: &lt;span class=&quot;string&quot;&gt;&#39;babel&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      query: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        presets: [&lt;span class=&quot;string&quot;&gt;&#39;es2015&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;babel-loader&lt;/code&gt; 还支持以下选项：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cacheDirectory&lt;/code&gt;: 默认值是 &lt;code&gt;false&lt;/code&gt;。如果设置了这个参数，被转换的结果将会被缓存起来。当Webpack 再次编译时，将会首先尝试从缓存中读取转换结果，以此避免资源浪费。如果该值为空(loader: ‘babel-loader?cacheDirectory’)，&lt;code&gt;loader&lt;/code&gt;会使用系统默认的临时文件目录。&lt;/p&gt;
&lt;h3 id=&quot;问题及优化&quot;&gt;&lt;a href=&quot;#问题及优化&quot; class=&quot;headerlink&quot; title=&quot;问题及优化&quot;&gt;&lt;/a&gt;问题及优化&lt;/h3&gt;&lt;h4 id=&quot;性能问题&quot;&gt;&lt;a href=&quot;#性能问题&quot; class=&quot;headerlink&quot; title=&quot;性能问题&quot;&gt;&lt;/a&gt;性能问题&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;确保只转换尽可能少的文件，你可能匹配了过多的文件类型，或者匹配了所有的’.js’文件，你需要使用 &lt;code&gt;exclude: /(node_modules|bower_components)/&lt;/code&gt; 排除部分目录&lt;/li&gt;
&lt;li&gt;设置 &lt;code&gt;cacheDirectory&lt;/code&gt; 参数也可以让你的 &lt;code&gt;loader&lt;/code&gt; 性能提升2倍！&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;babel-给每个需要的文件注入helper扩展&quot;&gt;&lt;a href=&quot;#babel-给每个需要的文件注入helper扩展&quot; class=&quot;headerlink&quot; title=&quot;babel 给每个需要的文件注入helper扩展&quot;&gt;&lt;/a&gt;babel 给每个需要的文件注入&lt;code&gt;helper&lt;/code&gt;扩展&lt;/h4&gt;&lt;p&gt;您可以改为要求&lt;code&gt;babel&lt;/code&gt;作为一个独立运行的模块，以避免重复。&lt;/p&gt;
&lt;p&gt;下面的配置通过&lt;code&gt;babel-plugin-transform-runtime&lt;/code&gt;插件可以禁用babel向每个文件注入&lt;code&gt;helper&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需要先安装插件 &lt;code&gt;npm install babel-plugin-transform-runtime --save&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;loaders: [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// the &#39;transform-runtime&#39; plugin tells babel to require the runtime&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// instead of inlining it.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    test: &lt;span class=&quot;regexp&quot;&gt;/\.jsx?$/&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    exclude: &lt;span class=&quot;regexp&quot;&gt;/(node_modules|bower_components)/&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    loader: &lt;span class=&quot;string&quot;&gt;&#39;babel&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    query: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      presets: [&lt;span class=&quot;string&quot;&gt;&#39;es2015&#39;&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      plugins: [&lt;span class=&quot;string&quot;&gt;&#39;transform-runtime&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c
    
    </summary>
    
      <category term="Webpack" scheme="http://robin-front.github.io/categories/Webpack/"/>
    
    
      <category term="loader" scheme="http://robin-front.github.io/tags/loader/"/>
    
      <category term="babel-loader" scheme="http://robin-front.github.io/tags/babel-loader/"/>
    
  </entry>
  
  <entry>
    <title>Webpack-config</title>
    <link href="http://robin-front.github.io/2016/04/07/Webpack-config/"/>
    <id>http://robin-front.github.io/2016/04/07/Webpack-config/</id>
    <published>2016-04-06T17:03:50.000Z</published>
    <updated>2016-04-06T17:03:50.000Z</updated>
    
    <content type="html">&lt;p&gt;不得不说，&lt;code&gt;Webpack&lt;/code&gt; 配置确实烦琐了一些，很多人都使用&lt;code&gt;gulp&lt;/code&gt;的插件&lt;code&gt;gulp-webpack&lt;/code&gt;来做其他事情。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置Webpack&quot;&gt;&lt;a href=&quot;#配置Webpack&quot; class=&quot;headerlink&quot; title=&quot;配置Webpack&quot;&gt;&lt;/a&gt;配置Webpack&lt;/h3&gt;&lt;p&gt;Webpack的构建过程需要一个配置文件，一个典型的配置文件&lt;code&gt;webpack.config.js&lt;/code&gt;大概就是这样&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; webpack = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;webpack&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.exports = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 配置项&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;基本配置项&quot;&gt;&lt;a href=&quot;#基本配置项&quot; class=&quot;headerlink&quot; title=&quot;基本配置项&quot;&gt;&lt;/a&gt;基本配置项&lt;/h3&gt;&lt;h4 id=&quot;entry&quot;&gt;&lt;a href=&quot;#entry&quot; class=&quot;headerlink&quot; title=&quot;entry&quot;&gt;&lt;/a&gt;entry&lt;/h4&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.exports = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    entry:&lt;span class=&quot;string&quot;&gt;&#39;./example1.1&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    output:&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        filename:&lt;span class=&quot;string&quot;&gt;&#39;bundle1.1.js&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们也会碰到支持多个入口文件（entry）的情况，每一个入口都需要有自己的名字，具体对应entry的写法而言，有如下几种情况：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;entry:&lt;span class=&quot;string&quot;&gt;&#39;./example2.1&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 或者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;entry:[&lt;span class=&quot;string&quot;&gt;&#39;./example2.1&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;./example2.2&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//或者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;entry:&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;example2.1&#39;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&#39;example2.1.js&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;example2.2&#39;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&#39;example2.2.js&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第三种是比较推荐的写法，这种写法中，名字和模块文件名一一对应，每个模块都有独立的名字。也就是&lt;code&gt;output.filename&lt;/code&gt;中的[name]&lt;/p&gt;
&lt;h4 id=&quot;output&quot;&gt;&lt;a href=&quot;#output&quot; class=&quot;headerlink&quot; title=&quot;output&quot;&gt;&lt;/a&gt;output&lt;/h4&gt;&lt;h5 id=&quot;output-filename&quot;&gt;&lt;a href=&quot;#output-filename&quot; class=&quot;headerlink&quot; title=&quot;output.filename&quot;&gt;&lt;/a&gt;output.filename&lt;/h5&gt;&lt;p&gt;&lt;code&gt;output.filename&lt;/code&gt;除了可以指定具体的文件名以外，还可以使用一些占位符，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;name 模块名称&lt;/li&gt;
&lt;li&gt;hash 模块编译后的（整体）Hash值&lt;/li&gt;
&lt;li&gt;chunkhash 分片的Hash值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;[name]&lt;/p&gt;
&lt;p&gt;在上面的&lt;code&gt;entry&lt;/code&gt;中，前两种写法，模块是没有名字的，webpack会使用main作为模块名字，因此用数组来指定入口的情况，模块名会重复，而此时webpack会将它们的代码合并打包！而第三种写法，这里的[name]可以理解成模块名字。&lt;/p&gt;
&lt;p&gt;[hash]与[chunkhash]&lt;/p&gt;
&lt;p&gt;事实上，在webpack的文档中，这个name是指“chunk name”，即分片的名字，这里需要先剧透一下后面要说的“分片”的概念。所谓分片就是指一个入口模块的代码有可能会被分成多个文件，还有一些文件可能是来自模块的公共代码，而不是入口模块。因此这里的[name]并非严格与入口模块一一对应。&lt;/p&gt;
&lt;p&gt;了解了这些情况之后，[hash]和[chunkhash]就自然好理解了，一个是指本次打包相关的整体的hash，一个是指分片的hash。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.exports = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    entry:&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;example3.1&#39;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&#39;./example3.1&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;example3.2&#39;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&#39;./example3.2&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    output:&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//这里分别用hash和chunkhash，结果不一样&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        filename:&lt;span class=&quot;string&quot;&gt;&#39;[name]-[hash].js&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//filename:&#39;[name]-[chunkhash].js&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h5 id=&quot;output-path&quot;&gt;&lt;a href=&quot;#output-path&quot; class=&quot;headerlink&quot; title=&quot;output.path&quot;&gt;&lt;/a&gt;output.path&lt;/h5&gt;&lt;p&gt;&lt;code&gt;output.path&lt;/code&gt;来指定输出路径&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;output.path&lt;/code&gt;也可以使用占位符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果想保持打包前源文件的目录结构，需要把目录写到模块名上，如：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;entry:&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;example4.1&#39;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&#39;./src/example4.1&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;hello/example4.2&#39;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&#39;./src/hello/example4.2&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;output:&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    filename:&lt;span class=&quot;string&quot;&gt;&#39;[name].js&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    path:&lt;span class=&quot;string&quot;&gt;&#39;./dist&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意这里的&lt;code&gt;filename&lt;/code&gt;一定要包含&lt;code&gt;[name]&lt;/code&gt;才行，因为路径信息是带在模块名上的。&lt;/p&gt;
&lt;h3 id=&quot;CommonChunks插件&quot;&gt;&lt;a href=&quot;#CommonChunks插件&quot; class=&quot;headerlink&quot; title=&quot;CommonChunks插件&quot;&gt;&lt;/a&gt;CommonChunks插件&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Common Chunks&lt;/code&gt; 插件的作用就是提取代码中的公共模块，然后将公共模块打包到一个独立的文件中去，以便在其它的入口和模块中使用。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; webpack = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;webpack&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.exports = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    entry:&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        main1:&lt;span class=&quot;string&quot;&gt;&#39;./main&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        main2:&lt;span class=&quot;string&quot;&gt;&#39;./main.2&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    output:&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        filename:&lt;span class=&quot;string&quot;&gt;&#39;bundle.[name].js&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    plugins: [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt;  webpack.optimize.CommonsChunkPlugin(&lt;span class=&quot;string&quot;&gt;&#39;common.js&#39;&lt;/span&gt;, [&lt;span class=&quot;string&quot;&gt;&#39;main1&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;main2&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;参数&lt;code&gt;common.js&lt;/code&gt;表示公共模块的文件名，后面的数组元素与&lt;code&gt;entry&lt;/code&gt;一一对应，表示要提取这些模块中的公共模块。&lt;/p&gt;
&lt;p&gt;但是，要记得在HTML中加入公共部分common.js&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;./common.js&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;undefined&quot;&gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;./bundle.main1.js&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;undefined&quot;&gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;但模块化不应该有多个入口文件，入口文件不应时时改变，应在内部处理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;使用loader&quot;&gt;&lt;a href=&quot;#使用loader&quot; class=&quot;headerlink&quot; title=&quot;使用loader&quot;&gt;&lt;/a&gt;使用loader&lt;/h3&gt;&lt;p&gt;loader是webpack中一个重要的概念，它是指用来将一段代码转换成另一段代码的webpack插件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;虽然本质上说，loader也是插件，但因为webpack的体系中还有一个专门的名词就叫插件（plguin），为避免混淆，后面不再将loader与插件混淆说，后文中这将是两个相互独立的概念。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;loader的使用有三种方法，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在require中显式指定&lt;/li&gt;
&lt;li&gt;在配置项（webpack.config.js）中指定&lt;/li&gt;
&lt;li&gt;在命令行中指定&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第二种，在配置项中指定是最灵活的方式，它的指定方式是这样：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// loaders是一个数组，每个元素都用来指定loader&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    loaders: [&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        test: &lt;span class=&quot;regexp&quot;&gt;/\.jade$/&lt;/span&gt;,    &lt;span class=&quot;comment&quot;&gt;//test值为正则表达式，当文件路径匹配时启用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        loader: &lt;span class=&quot;string&quot;&gt;&#39;jade&#39;&lt;/span&gt;,    &lt;span class=&quot;comment&quot;&gt;//指定使用什么loader，可以用字符串，也可以用数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        exclude: &lt;span class=&quot;regexp&quot;&gt;/node_modules/&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;//可以使用exclude来排除一部分文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// exclude: /regexp/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        include: &lt;span class=&quot;string&quot;&gt;&#39;dist&#39;&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;// 用来指定包含的文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//可以使用query来指定参数，也可以在loader中用和require一样的用法指定参数，如`jade?p1=1`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        query: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            p1:&lt;span class=&quot;string&quot;&gt;&#39;1&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        test: &lt;span class=&quot;regexp&quot;&gt;/\.css$/&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        loader: &lt;span class=&quot;string&quot;&gt;&#39;style!css&#39;&lt;/span&gt;    &lt;span class=&quot;comment&quot;&gt;//loader可以和require用法一样串联&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        test: &lt;span class=&quot;regexp&quot;&gt;/\.css$/&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        loaders: [&lt;span class=&quot;string&quot;&gt;&#39;style&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;css&#39;&lt;/span&gt;]    &lt;span class=&quot;comment&quot;&gt;//也可以用数组指定loader&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;串联&quot;&gt;&lt;a href=&quot;#串联&quot; class=&quot;headerlink&quot; title=&quot;串联&quot;&gt;&lt;/a&gt;串联&lt;/h4&gt;&lt;p&gt;loader是可以串联使用的，也就是说，一个文件可以先经过A-loader再经过B-loader最后再经过C-loader处理。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;style!css!./style.css&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;参数&quot;&gt;&lt;a href=&quot;#参数&quot; class=&quot;headerlink&quot; title=&quot;参数&quot;&gt;&lt;/a&gt;参数&lt;/h4&gt;&lt;p&gt;loader还可以接受参数，不同的参数可以让loader有不同的行为（前提是loader确实支持不同的行为），具体每个loader支持什么样的参数可以参考loader的文档。&lt;/p&gt;
&lt;p&gt;参数的指定方式和&lt;code&gt;url&lt;/code&gt;很像，要通过&lt;code&gt;?&lt;/code&gt;来指定，例如指定&lt;code&gt;literate&lt;/code&gt;参数需要这样写：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;coffee?literate=1!./a.coffee&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;具体的可以对照&lt;a href=&quot;https://webpack.github.io/docs/list-of-loaders.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方的loader列表&lt;/a&gt;一一查看。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;不得不说，&lt;code&gt;Webpack&lt;/code&gt; 配置确实烦琐了一些，很多人都使用&lt;code&gt;gulp&lt;/code&gt;的插件&lt;code&gt;gulp-webpack&lt;/code&gt;来做其他事情。&lt;br&gt;
    
    </summary>
    
      <category term="Webpack" scheme="http://robin-front.github.io/categories/Webpack/"/>
    
    
      <category term="Webpack" scheme="http://robin-front.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>采用非直进式合并（git-merge-no-ff）</title>
    <link href="http://robin-front.github.io/2016/04/02/%E9%87%87%E7%94%A8%E9%9D%9E%E7%9B%B4%E8%BF%9B%E5%BC%8F%E5%90%88%E5%B9%B6%EF%BC%88git-merge-no-ff%EF%BC%89/"/>
    <id>http://robin-front.github.io/2016/04/02/采用非直进式合并（git-merge-no-ff）/</id>
    <published>2016-04-02T07:44:00.000Z</published>
    <updated>2016-04-02T07:44:00.000Z</updated>
    
    <content type="html">&lt;p&gt;使用Git当合并一个分支是一个相当常见的操作。在某些情况下，Git会默认将尝试在快进模式合并一个分支。如果不使用快进合并有什么不同？&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;假设我从&lt;code&gt;master&lt;/code&gt;创建一个名为&lt;code&gt;speedup&lt;/code&gt;分支。在这个分支上工作一段时间（三个提交，那些白色的圆圈）后，当我完成工作时，我把它&lt;code&gt;git push&lt;/code&gt;推到我自己的远程分支。同时，主分支&lt;code&gt;master&lt;/code&gt;什么都没发生，但仍处于相同的状态之前，我分出。这种情况在下面的图中描述。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Robin-front/blog/master/source/images/20160402/gitbranch.png&quot; alt=&quot;git push&quot;&gt;&lt;/p&gt;
&lt;p&gt;一旦该项目的维护者得到通知，我的分支已经准备好合并进&lt;code&gt;master&lt;/code&gt;，她可能使用git的常规步骤&lt;code&gt;git fetch&lt;/code&gt;操作后执行&lt;code&gt;git merge&lt;/code&gt;来合并。因为主分支并没有新的提交（灰色圆圈），Git会用快进执行合并。整个系列的提交将是线性的。历史会像下图（左侧）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Robin-front/blog/master/source/images/20160402/merging.png&quot; alt=&quot;git merge&quot;&gt;&lt;/p&gt;
&lt;p&gt;合并的另一个变型是使用 &lt;code&gt;-no-ff&lt;/code&gt; 选项（它代表不快进）。在这种情况下，分支历史看上去稍有不同（右侧），有一个附加的提交（虚线圆）强调合并。这个提交告诉我们有关合并分支的备注信息。&lt;/p&gt;
&lt;p&gt;Git的默认行为是尽可能使用快进。这可以改变的，非快进模式可以很容易地&lt;a href=&quot;http://stackoverflow.com/questions/2500296/can-i-make-fast-forwarding-be-off-by-default-in-git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;设定为默认合并模式&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设置非快进模式合并为默认合并方式&lt;br&gt;git config branch.master.mergeoptions  “–no-ff”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总之，非快进合并保持明确分支的概念。它可在保留分支复杂的非线性提交历史。在另一方面，快进合并保持线性历史上的变更，使其更容易使用其他工具（log, blame, bisect）。每个分支的来源将变得很不明显，但如果该项目强制要求提交信息和问题跟踪器之间的严格的交叉引用，这也不是什么大不了的事。&lt;/p&gt;
&lt;p&gt;你喜欢哪一种呢，快进式或非快进式？&lt;/p&gt;
&lt;p&gt;翻译自：&lt;br&gt;&lt;a href=&quot;http://ariya.ofilabs.com/2013/09/fast-forward-git-merge.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Fast-Forward Git Merge&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;使用Git当合并一个分支是一个相当常见的操作。在某些情况下，Git会默认将尝试在快进模式合并一个分支。如果不使用快进合并有什么不同？&lt;br&gt;
    
    </summary>
    
      <category term="git" scheme="http://robin-front.github.io/categories/git/"/>
    
    
      <category term="git" scheme="http://robin-front.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>快速上手Flow-静态类型检查器</title>
    <link href="http://robin-front.github.io/2016/03/16/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BFlow-%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%99%A8/"/>
    <id>http://robin-front.github.io/2016/03/16/快速上手Flow-静态类型检查器/</id>
    <published>2016-03-16T08:09:49.000Z</published>
    <updated>2016-03-16T08:09:49.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;why-Flow&quot;&gt;&lt;a href=&quot;#why-Flow&quot; class=&quot;headerlink&quot; title=&quot;why Flow&quot;&gt;&lt;/a&gt;why Flow&lt;/h3&gt;&lt;p&gt;javascript是一个弱类型语言，变量类型不需要声明，运算过程中会根据需要自动转换类型，这个是js的优点，够灵活，编码简单，但是同时也是软肋。有时候，有些类型转换的bug无从查起，特别是在复杂的应用中。&lt;/p&gt;
&lt;p&gt;Flow为Javascript添加了静态类型检查，以提高开发效率和代码质量。更明确的说，静态类型检查提供的好处像早期错误检查，帮助你发现一些只有在运行时才能发现的错误。&lt;/p&gt;
&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;p&gt;由于flow是用OCaml语言写的，npm上只有对应的二进制包。&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm &lt;span class=&quot;keyword&quot;&gt;install&lt;/span&gt; flow-&lt;span class=&quot;keyword&quot;&gt;bin&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可者使用 Homebrew 安装&lt;/p&gt;
&lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;brew &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;install &lt;/span&gt;flow&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;快速上手&quot;&gt;&lt;a href=&quot;#快速上手&quot; class=&quot;headerlink&quot; title=&quot;快速上手&quot;&gt;&lt;/a&gt;快速上手&lt;/h3&gt;&lt;p&gt;在项目目录下执行 &lt;code&gt;flow init&lt;/code&gt;，会生成一个 &lt;code&gt;.flowconfig&lt;/code&gt; 文件&lt;br&gt;只需要在待检查的js文件头部添加一行注释&lt;br&gt;&lt;figure class=&quot;highlight gherkin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/&lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@flow&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后在同一目录下运行&lt;code&gt;flow check&lt;/code&gt;即可。&lt;/p&gt;
&lt;h3 id=&quot;flow-server&quot;&gt;&lt;a href=&quot;#flow-server&quot; class=&quot;headerlink&quot; title=&quot;flow server&quot;&gt;&lt;/a&gt;flow server&lt;/h3&gt;&lt;p&gt;flow server是为了提高检测效率的后台程序，支持在后台运行，并且只监测有修改的文件。&lt;/p&gt;
&lt;p&gt;方法很简单，一条 flow 命令就能完成 Flow 服务器启动，文件检测，被更改文件的检测，即第一次使用 flow 命令会启动 Flow 服务器并且首次检测文件，再次使用 flow 命令会连接 Flow 服务器并且检测文件，之后使用 flow 命令时将会连接 Flow 服务器并且对修改过的文件进行检测。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flow check:检测所有声明了 @flow 的文件&lt;/li&gt;
&lt;li&gt;flow check –all:可以让Flow检测所有文件，包括没有声明 @flow 的文件&lt;/li&gt;
&lt;li&gt;flow stop:项目开发完成停止服务&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;flowconfig&quot;&gt;&lt;a href=&quot;#flowconfig&quot; class=&quot;headerlink&quot; title=&quot;flowconfig&quot;&gt;&lt;/a&gt;flowconfig&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;[ignore]忽略的文件，路径的匹配规则是正则表达式&lt;/li&gt;
&lt;li&gt;[include]需要检测的其他目录的文件&lt;/li&gt;
&lt;li&gt;[libs]当文件中有第三方库引用或者require全局的module时，需要在一个单独的文件里declare这个对象，这个的值是所有declare路径的集合&lt;/li&gt;
&lt;li&gt;[options]包含若干key-value的配置&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;flow的两种模式&quot;&gt;&lt;a href=&quot;#flow的两种模式&quot; class=&quot;headerlink&quot; title=&quot;flow的两种模式&quot;&gt;&lt;/a&gt;flow的两种模式&lt;/h3&gt;&lt;figure class=&quot;highlight gherkin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/&lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@flow&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;/ 只要带有这个注释，都会进行类型检测&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/&lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@flow&lt;/span&gt; weak &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;/ 只对有加类型声明的变量进行类型检测&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;类型声明-标注&quot;&gt;&lt;a href=&quot;#类型声明-标注&quot; class=&quot;headerlink&quot; title=&quot;类型声明/标注&quot;&gt;&lt;/a&gt;类型声明/标注&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;不声明变量类型的时候，Flow 也会自动检查隐性存在的类型转换。但更为严谨的方式是显式声明变量的类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以在代码里写上类型:&lt;br&gt;&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* @flow */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Changing the return type to number fixes the error&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(x: string, y: number)&lt;/span&gt;: number &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x.length * y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo(&lt;span class=&quot;string&quot;&gt;&#39;Hello&#39;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;也可以这样：&lt;br&gt;&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* @flow */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;T&lt;/span&gt; &lt;/span&gt;= number;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; x: &lt;span class=&quot;type&quot;&gt;T&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;下面是一个更详细的例子：&lt;br&gt;&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; People &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name: &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;(name:string)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    getAge():&lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;18&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getLength&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;param?:&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;&lt;/span&gt;):&lt;span class=&quot;title&quot;&gt;number&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/*param?:string传参类型什么，?表示此处可不传值；*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/*\:number为函数返回值类型,如果没有return可不写或写void*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s:&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&#39;string&#39;&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;/*字符*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; ss:&lt;span class=&quot;built_in&quot;&gt;String&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;String&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;string&#39;&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;/*字符对象*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* s = ss*/&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;//类型不同，flow会报错&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; n:&lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;/*数字*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; nn:&lt;span class=&quot;built_in&quot;&gt;Number&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Number&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;/*数字对象*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; b:&lt;span class=&quot;built_in&quot;&gt;boolean&lt;/span&gt; = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;/*bool值，仅能为true/false*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; bb:&lt;span class=&quot;built_in&quot;&gt;Boolean&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Boolean&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;/*bool值对象*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; o:&amp;#123;prop1:&lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;,prop2:&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;&amp;#125; = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/*对象熟悉声明*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        prop1: &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        prop2: &lt;span class=&quot;string&quot;&gt;&#39;21123&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; v:&lt;span class=&quot;built_in&quot;&gt;void&lt;/span&gt; = &lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;/*undefined*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a:&lt;span class=&quot;built_in&quot;&gt;any&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&#39;aa&#39;&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;/*任意类型，除undefined*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; m:mixed = &lt;span class=&quot;string&quot;&gt;&#39;1&#39;&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;/*任意类型+undefined*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; mm:mixed = &lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;/*任意类型+undefined*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; aa:&lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;&amp;gt; = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&lt;span class=&quot;comment&quot;&gt;/*数组内值类型声明*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; P:Class&amp;lt;People&amp;gt; = People;&lt;span class=&quot;comment&quot;&gt;/*自定义类型声明*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; p:People = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; People(&lt;span class=&quot;string&quot;&gt;&#39;pt&#39;&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;/*自定义People类型*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (param) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; param.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;兼容性&quot;&gt;&lt;a href=&quot;#兼容性&quot; class=&quot;headerlink&quot; title=&quot;兼容性&quot;&gt;&lt;/a&gt;兼容性&lt;/h3&gt;&lt;p&gt;Flow致力于支持最新的JavaScript标准。目前已经支持各种ES6特性如destructuring, classes, extended objects, optional function parameters，以及核心API扩展（比如Map, Set, Promise, 和 new methods on Object, Array, 和 Math)。其它特性（尤其是模块）正在开发中。Flow支持CommonJS / Node.js 规范的模块。&lt;/p&gt;
&lt;p&gt;Flow 也已经支持 React。&lt;/p&gt;
&lt;h3 id=&quot;代码编译&quot;&gt;&lt;a href=&quot;#代码编译&quot; class=&quot;headerlink&quot; title=&quot;代码编译&quot;&gt;&lt;/a&gt;代码编译&lt;/h3&gt;&lt;p&gt;在构建工具中添加flow检查的步骤。webpack和gulp都有对应的flow插件。&lt;/p&gt;
&lt;p&gt;我们在项目中用到的插件：&lt;br&gt;&lt;code&gt;eslint-plugin-flow-vars&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;p&gt;Flow官网最近访问不了，可以看这里：&lt;a href=&quot;https://github.com/facebook/flow/tree/master/website/docs&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/facebook/flow/tree/master/website/docs&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/amfe/article/issues/32&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;flow——A static type checker for javascript #32&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.alloyteam.com/2015/07/flow-a-static-type-checker-for-javascript-from-facebook/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;flow–facebook出品的javascript静态类型检查器&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;why-Flow&quot;&gt;&lt;a href=&quot;#why-Flow&quot; class=&quot;headerlink&quot; title=&quot;why Flow&quot;&gt;&lt;/a&gt;why Flow&lt;/h3&gt;&lt;p&gt;javascript是一个弱类型语言，变量类型不需要声明，运算过程中会根据需要自动转换类型，
    
    </summary>
    
      <category term="Flow" scheme="http://robin-front.github.io/categories/Flow/"/>
    
    
      <category term="Flow" scheme="http://robin-front.github.io/tags/Flow/"/>
    
  </entry>
  
  <entry>
    <title>React应用性能优化之IMMUTABLE.JS</title>
    <link href="http://robin-front.github.io/2016/03/14/React%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8BIMMUTABLE-JS/"/>
    <id>http://robin-front.github.io/2016/03/14/React应用性能优化之IMMUTABLE-JS/</id>
    <published>2016-03-13T16:15:07.000Z</published>
    <updated>2016-03-13T16:15:07.000Z</updated>
    
    <content type="html">&lt;p&gt;前一篇文章记录了React应用的性能优化点，今天还有个更闪耀的 Immutable.js。&lt;/p&gt;
&lt;h3 id=&quot;Immutable-js&quot;&gt;&lt;a href=&quot;#Immutable-js&quot; class=&quot;headerlink&quot; title=&quot;Immutable.js&quot;&gt;&lt;/a&gt;Immutable.js&lt;/h3&gt;&lt;p&gt;Immutable.js 本身和 React.js 没有必然的联系。它的意义在于它弥补了Javascript没有不可变数据结构的问题。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Javascript中对象都是参考类型，也就是a={a:1}; b=a; b.a=10;你发现a.a也变成10了。可变的好处是节省内存或是利用可变性做一些事情，但是，在复杂的开发中它的副作用远比好处大的多。于是才有了浅copy和深copy，就是为了解决这个问题。举个常见例子：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; defaultConfig&lt;/span&gt; = &amp;#123; &lt;span class=&quot;comment&quot;&gt;/* 默认值 */&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; config&lt;/span&gt; = $.extend(&amp;#123;&amp;#125;, defaultConfig, initConfig); &lt;span class=&quot;comment&quot;&gt;// jQuery用法。initConfig是自定义值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; config&lt;/span&gt; = $.extend(&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;, &amp;#123;&amp;#125;, defaultConfig, initConfig); &lt;span class=&quot;comment&quot;&gt;// 如果对象是多层的，就用到deep-copy了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;ES6出现原生的assign方法，但它相当于是浅copy。如果有了不可变的数据结构就省心了，ES5.1中对象有了freeze方法，也是浅copy，a=Object.freeze({a:1}); b=a; b.a=10; a.a还是1。在实际开发中浅copy通常不够。如果用immutableJS:&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; defaultConfig&lt;/span&gt; = Immutable.fromJS(&amp;#123; &lt;span class=&quot;comment&quot;&gt;/* 默认值 */&lt;/span&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; config&lt;/span&gt; = defaultConfig.merge(initConfig); &lt;span class=&quot;comment&quot;&gt;// defaultConfig不会改变，返回新值给config&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; config&lt;/span&gt; = defaultConfig.mergeDeep(initConfig); &lt;span class=&quot;comment&quot;&gt;// 深层merge&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述用deep-copy也可以做到，差别在于性能。每次deep-copy都要把整个对象递归的复制一份。而Immutable的实现有些像链表，添加一个新结点把旧结点的父子关系转移到新结点上，性能提升很多。ImmutableJS给的远不止这些，它提供了7种不可变的数据结构：List, Stack, Map, OrderedMap, Set, OrderedSet, Record （详见文档&lt;a href=&quot;http://facebook.github.io/immutable-js/docs/#/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Immutable.js&lt;/a&gt;，文档很geek，打开console试吧）。immutableJS ＋ 原生Javascript等于真正的函数式编程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/9e129aaf95d2a645a860dc26532796817e8085c0/687474703a2f2f696d672e616c6963646e2e636f6d2f7470732f69322f5442317a7a695f4b5858585858637458465858627262384f5658582d3631332d3537352e676966&quot; alt=&quot;immutable.js&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Immutable-优点&quot;&gt;&lt;a href=&quot;#Immutable-优点&quot; class=&quot;headerlink&quot; title=&quot;Immutable 优点&quot;&gt;&lt;/a&gt;Immutable 优点&lt;/h3&gt;&lt;h4 id=&quot;1-Immutable-降低了-Mutable-带来的复杂度&quot;&gt;&lt;a href=&quot;#1-Immutable-降低了-Mutable-带来的复杂度&quot; class=&quot;headerlink&quot; title=&quot;1. Immutable 降低了 Mutable 带来的复杂度&quot;&gt;&lt;/a&gt;1. Immutable 降低了 Mutable 带来的复杂度&lt;/h4&gt;&lt;p&gt;可变（Mutable）数据耦合了 Time 和 Value 的概念，造成了数据很难被回溯。&lt;/p&gt;
&lt;p&gt;比如下面一段代码：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;touchAndLog&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;touchFn&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; data = &amp;#123; key: &lt;span class=&quot;string&quot;&gt;&#39;value&#39;&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  touchFn(data);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(data.key); &lt;span class=&quot;comment&quot;&gt;// 猜猜会打印什么？&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在不查看 touchFn 的代码的情况下，因为不确定它对 data 做了什么，你是不可能知道会打印什么（这不是废话吗）。但如果 data 是 Immutable 的呢，你可以很肯定的知道打印的是 value。&lt;/p&gt;
&lt;h4 id=&quot;2-节省内存&quot;&gt;&lt;a href=&quot;#2-节省内存&quot; class=&quot;headerlink&quot; title=&quot;2. 节省内存&quot;&gt;&lt;/a&gt;2. 节省内存&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Immutable.js&lt;/code&gt; 使用了 Structure Sharing 会尽量复用内存，甚至以前使用的对象也可以再次被复用。没有被引用的对象会被垃圾回收。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &amp;#123; &lt;span class=&quot;built_in&quot;&gt;Map&lt;/span&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;immutable&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; a = &lt;span class=&quot;built_in&quot;&gt;Map&lt;/span&gt;(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  select: &lt;span class=&quot;string&quot;&gt;&#39;users&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  filter: &lt;span class=&quot;built_in&quot;&gt;Map&lt;/span&gt;(&amp;#123; name: &lt;span class=&quot;string&quot;&gt;&#39;Cam&#39;&lt;/span&gt; &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; b = a.set(&lt;span class=&quot;string&quot;&gt;&#39;select&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;people&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a === b; &lt;span class=&quot;comment&quot;&gt;// false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.get(&lt;span class=&quot;string&quot;&gt;&#39;filter&#39;&lt;/span&gt;) === b.get(&lt;span class=&quot;string&quot;&gt;&#39;filter&#39;&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面 a 和 b 共享了没有变化的 &lt;code&gt;filter&lt;/code&gt; 节点。&lt;/p&gt;
&lt;h4 id=&quot;3-Undo-Redo，Copy-Paste，甚至时间旅行这些功能做起来小菜一碟&quot;&gt;&lt;a href=&quot;#3-Undo-Redo，Copy-Paste，甚至时间旅行这些功能做起来小菜一碟&quot; class=&quot;headerlink&quot; title=&quot;3. Undo/Redo，Copy/Paste，甚至时间旅行这些功能做起来小菜一碟&quot;&gt;&lt;/a&gt;3. Undo/Redo，Copy/Paste，甚至时间旅行这些功能做起来小菜一碟&lt;/h4&gt;&lt;p&gt;因为每次数据都是不一样的，只要把这些数据放到一个数组里储存起来，想回退到哪里就拿出对应数据即可，很容易开发出撤销重做这种功能。&lt;/p&gt;
&lt;h3 id=&quot;为什么在React-js中使用Immutable-js&quot;&gt;&lt;a href=&quot;#为什么在React-js中使用Immutable-js&quot; class=&quot;headerlink&quot; title=&quot;为什么在React.js中使用Immutable.js&quot;&gt;&lt;/a&gt;为什么在React.js中使用Immutable.js&lt;/h3&gt;&lt;p&gt;熟悉React.js的都应该知道，React.js是一个UI = f(states)的框架，为了解决更新的问题，React.js使用了virtual dom，virtual dom通过diff修改dom，来实现高效的dom更新。&lt;br&gt;听起来很完美吧，但是有一个问题。当state更新时，如果数据没变，你也会去做virtual dom的diff，这就产生了浪费。这种情况其实很常见，如：&lt;/p&gt;
&lt;p&gt;熟悉 React 组件生命周期的话都知道：调用 setState 方法总是会触发 render 方法从而进行 vdom re-render 相关逻辑，哪怕实际上你没有更改到 Component.state 。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.state = &amp;#123;count: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.setState(&amp;#123;count: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;);&lt;span class=&quot;comment&quot;&gt;// 组件 state 并未被改变，但仍会触发 render 方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为了避免这种性能上的浪费，React 提供了一个 shouldComponentUpdate 来控制触发 vdom re-render 逻辑的条件。于是 PureRenderMixin 作为一种优化技巧被使用。但PureRenderMixin只是简单的浅比较，不使用于多层比较。那怎么办？？自己去做复杂比较的话，性能又会非常差。&lt;/p&gt;
&lt;p&gt;这时候 immutableJS 就派得上用场了：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; map1 = Immutable.fromJS(&amp;#123;a:&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, b:&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, c:&amp;#123;b:&amp;#123;c:&amp;#123;d:&amp;#123;e:&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;&amp;#125;&amp;#125;&amp;#125;&amp;#125;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; map2 = Immutable.fromJS(&amp;#123;a:&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, b:&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, c:&amp;#123;b:&amp;#123;c:&amp;#123;d:&amp;#123;e:&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;&amp;#125;&amp;#125;&amp;#125;&amp;#125;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Immutable.is(map1, map2); &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;每一次state更新只要有数据改变，那么PureRenderMixin可以立刻判断出数据改变，可以大大提升性能。&lt;/p&gt;
&lt;h3 id=&quot;实践&quot;&gt;&lt;a href=&quot;#实践&quot; class=&quot;headerlink&quot; title=&quot;实践&quot;&gt;&lt;/a&gt;实践&lt;/h3&gt;&lt;h4 id=&quot;与-React-搭配使用，Pure-Render&quot;&gt;&lt;a href=&quot;#与-React-搭配使用，Pure-Render&quot; class=&quot;headerlink&quot; title=&quot;与 React 搭配使用，Pure Render&quot;&gt;&lt;/a&gt;与 React 搭配使用，Pure Render&lt;/h4&gt;&lt;p&gt;可以使用 &lt;a href=&quot;https://github.com/jurassix/react-immutable-render-mixin&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;react-immutable-render-mixin&lt;/a&gt;&lt;br&gt;通过es6的修饰器 @decorator 来使用&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; React &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;react&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &amp;#123; immutableRenderDecorator &amp;#125; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;react-immutable-render-mixin&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@immutableRenderDecorator&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Component&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  render() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;或者直接&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; immutableRenderMixin &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;react-immutable-render-mixin&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;React.createClass(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  mixins: [immutableRenderMixin],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  render: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;className&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;#123;this.props.className&amp;#125;&lt;/span&gt;&amp;gt;&lt;/span&gt;foo&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;与-Redux-搭配使用&quot;&gt;&lt;a href=&quot;#与-Redux-搭配使用&quot; class=&quot;headerlink&quot; title=&quot;与 Redux 搭配使用&quot;&gt;&lt;/a&gt;与 Redux 搭配使用&lt;/h3&gt;&lt;p&gt;Redux 是目前流行的 Flux 衍生库。它简化了 Flux 中多个 Store 的概念，只有一个 Store，数据操作通过 Reducer 中实现；同时它提供更简洁和清晰的单向数据流（View -&amp;gt; Action -&amp;gt; Middleware -&amp;gt; Reducer），也更易于开发同构应用。目前已经在我们项目中大规模使用。&lt;/p&gt;
&lt;p&gt;由于 Redux 中内置的 combineReducers 和 reducer 中的 initialState 都为原生的 Object 对象，所以不能和 Immutable 原生搭配使用。&lt;/p&gt;
&lt;p&gt;幸运的是，Redux 并不排斥使用 Immutable，可以自己重写 combineReducers 或使用 redux-immutablejs 来提供支持。&lt;/p&gt;
&lt;p&gt;本文原文链接：&lt;br&gt;&lt;a href=&quot;https://www.zhihu.com/question/28016223/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;facebook immutable.js 意义何在，使用场景？&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/camsong/blog/issues/3&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Immutable 详解及 React 中实践&lt;/a&gt;基本没有改动。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;前一篇文章记录了React应用的性能优化点，今天还有个更闪耀的 Immutable.js。&lt;/p&gt;
&lt;h3 id=&quot;Immutable-js&quot;&gt;&lt;a href=&quot;#Immutable-js&quot; class=&quot;headerlink&quot; title=&quot;Immutable.js&quot;&gt;&lt;/a&gt;Immutable.js&lt;/h3&gt;&lt;p&gt;Immutable.js 本身和 React.js 没有必然的联系。它的意义在于它弥补了Javascript没有不可变数据结构的问题。&lt;br&gt;
    
    </summary>
    
      <category term="React" scheme="http://robin-front.github.io/categories/React/"/>
    
    
      <category term="React" scheme="http://robin-front.github.io/tags/React/"/>
    
      <category term="Immutable.js" scheme="http://robin-front.github.io/tags/Immutable-js/"/>
    
  </entry>
  
  <entry>
    <title>React应用性能优化之shouldComponentUpdate与key</title>
    <link href="http://robin-front.github.io/2016/03/10/React%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8BshouldComponentUpdate%E4%B8%8Ekey/"/>
    <id>http://robin-front.github.io/2016/03/10/React应用性能优化之shouldComponentUpdate与key/</id>
    <published>2016-03-10T14:32:13.000Z</published>
    <updated>2016-03-10T14:32:13.000Z</updated>
    
    <content type="html">&lt;p&gt;虽然React 的 vDom diff算法能保证最小程度的 DOM 改变，但当组件树嵌套得非常深时，就不得不需要渲染一个新的虚拟 DOM 来让应用运行得更加高效。&lt;/p&gt;
&lt;p&gt;下面看看加速应用程序的两种简单的配置方法：&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;shouldComponentUpdate&quot;&gt;&lt;a href=&quot;#shouldComponentUpdate&quot; class=&quot;headerlink&quot; title=&quot;shouldComponentUpdate&quot;&gt;&lt;/a&gt;shouldComponentUpdate&lt;/h3&gt;&lt;p&gt;设置新 props，调用 setState 方法或 forceUpdate 方法时，React 都会调用该组件所有子组件的 render 方法。但是在组件树深度嵌套或 render 方法十分复杂的时侯，页面就会有延迟。&lt;/p&gt;
&lt;p&gt;但此时，某些子组件并没有必要更新，或者永远都不需要更新，这时进行的计算过程是没有必要的。&lt;/p&gt;
&lt;p&gt;而 shouldComponentUpdate 方法正是用来判断是否需要调用指定组件的 render 方法。&lt;/p&gt;
&lt;p&gt;shouldComponentUpdate 方法返回一个布尔值。false 表示不要调用 render 方法；true 表示需要调用 render 方法计算出新的虚拟 DOM。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;此方法的默认值是 true。&lt;br&gt;并且，组件首次渲染时，shouldComponentUpdate 方法不会被调用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;shouldComponentUpdate 方法接受两个参数，新的 props 和新的 state：&lt;/p&gt;
&lt;figure class=&quot;highlight qml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;React.creatClass(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;shouldComponentUpdate&lt;/span&gt;: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;nextProps, nextState&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; nextProps.id !== &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.props.id&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;另外，我们也可以添加 React.addons.PureRenderMixin 插件来处理 shouldComponentUpdate。 这个插件会重写 shouldComponentUpdate 方法，并在该方法内对新老 props 及 state 进行对比， 如果发现它们完全一致则返回 false, 就像上面的例子一样。官方文档里也有介绍： &lt;a href=&quot;https://facebook.github.io/react/docs/pure-render-mixin.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PureRenderMixin&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;PureRenderMixin&lt;/span&gt; from &lt;span class=&quot;symbol&quot;&gt;&#39;react&lt;/span&gt;-addons-pure-render-mixin&#39;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;FooComponent&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Component&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  constructor(props) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;(props);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.shouldComponentUpdate = &lt;span class=&quot;type&quot;&gt;PureRenderMixin&lt;/span&gt;.shouldComponentUpdate.bind(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  render() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;lt;div className=&amp;#123;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.props.className&amp;#125;&amp;gt;foo&amp;lt;/div&amp;gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;key-键&quot;&gt;&lt;a href=&quot;#key-键&quot; class=&quot;headerlink&quot; title=&quot;key(键)&quot;&gt;&lt;/a&gt;key(键)&lt;/h3&gt;&lt;p&gt;在遍历列表的时候，没有组件添加 key 值会有 warnning 产生。那它是用来干嘛的呢？ 假设有一个 div 组件，它的 key 属性为 ‘foo’，之后又改为 ‘bar’， 那 React 就会跳过 DOM diff， 同时完会弃置 div 所有的子元素，并重新渲染。除了告诉 React 什么时候要抛弃一个节点之外，key 还可以在元素顺序改变时使用。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;render: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; items.map(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;item&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;li&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;key&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&#39;item.id&#39;&lt;/span&gt;&amp;gt;&lt;/span&gt;item.name&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果像上面这样，React 在li 列表顺序改变的时候就不会重新渲染，而是采用 insertBefore 操作，这也是最高效的方法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;但是要注意，key 值必须是独一无二的，最好不要是数字，绝对不能是遍历中的index。这样可以保证从一个父组件移动到另一个父组件的情况是不会被处理的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;key 值也是无法读取的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;虽然React 的 vDom diff算法能保证最小程度的 DOM 改变，但当组件树嵌套得非常深时，就不得不需要渲染一个新的虚拟 DOM 来让应用运行得更加高效。&lt;/p&gt;
&lt;p&gt;下面看看加速应用程序的两种简单的配置方法：&lt;br&gt;
    
    </summary>
    
      <category term="React" scheme="http://robin-front.github.io/categories/React/"/>
    
    
      <category term="React" scheme="http://robin-front.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>搜索命令之locate、whereis、which、find、grep</title>
    <link href="http://robin-front.github.io/2016/03/07/%E6%90%9C%E7%B4%A2%E5%91%BD%E4%BB%A4%E4%B9%8Blocate%E3%80%81whereis%E3%80%81which%E3%80%81find%E3%80%81grep/"/>
    <id>http://robin-front.github.io/2016/03/07/搜索命令之locate、whereis、which、find、grep/</id>
    <published>2016-03-06T16:58:03.000Z</published>
    <updated>2016-03-06T16:58:03.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;whereis&quot;&gt;&lt;a href=&quot;#whereis&quot; class=&quot;headerlink&quot; title=&quot;whereis&quot;&gt;&lt;/a&gt;whereis&lt;/h3&gt;&lt;p&gt;搜索命令所在路径及帮助文档所在位置&lt;/p&gt;
&lt;p&gt;选项：&lt;br&gt;-b 只查找可执行文件&lt;br&gt;-m 只查找帮助文件&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;也可以通过 whereis 命令来判断是否是shell内部命令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;which&quot;&gt;&lt;a href=&quot;#which&quot; class=&quot;headerlink&quot; title=&quot;which&quot;&gt;&lt;/a&gt;which&lt;/h3&gt;&lt;p&gt;搜索命令所在路么及别名&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;与whereis的区别在于 which 不仅可以查看命令所在路径，还可以查看到命令的别名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;locate&quot;&gt;&lt;a href=&quot;#locate&quot; class=&quot;headerlink&quot; title=&quot;locate&quot;&gt;&lt;/a&gt;locate&lt;/h3&gt;&lt;p&gt;搜索文件名最快的方式，根据后台数据库/var/lib/mlocate搜索&lt;/p&gt;
&lt;p&gt;updatedb 命令手动更新数据库，数据库更新不是即时的，一般需要一天&lt;br&gt;/etc/updatedb.conf 配置文件，用于配置搜索限制&lt;/p&gt;
&lt;h3 id=&quot;find&quot;&gt;&lt;a href=&quot;#find&quot; class=&quot;headerlink&quot; title=&quot;find&quot;&gt;&lt;/a&gt;find&lt;/h3&gt;&lt;p&gt;最强大的搜索命令，但同时带来性能问题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;find [搜索范围] [搜索条件]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;-name 按文件名搜索&lt;br&gt;-iname 不区分大小写搜索&lt;br&gt;-user 按照所有者搜索&lt;br&gt;-nouser 查找没有所有者的文件&lt;br&gt;-mtime 按修改文件的日期搜索，如：+10 查找10天前修改的文件， -10 查找10内修改的文件， 10 查找10天当天修改的文件&lt;br&gt;-atime 文件访问时间&lt;br&gt;-ctime 改变文件属性时间&lt;br&gt;-size 按照文件大小按索，如： find . -size 25k，注意 k 是小写， M是大写&lt;br&gt;-inum 按照i节点查找文件&lt;br&gt;-a 逻辑与 and,两个条件都满足，如： find /root -size +20k -a -size -1M 查找大于20k且小于1M的文件&lt;br&gt;-o 逻辑或 or,两个条件满足一个即可&lt;br&gt;-exec 命令 {} \; 对搜索结果执行操作，如： find /root -size 25k -exec rm -rf {} \; 查找/root目录下25k大小的文件之后删除&lt;/p&gt;
&lt;h3 id=&quot;grep&quot;&gt;&lt;a href=&quot;#grep&quot; class=&quot;headerlink&quot; title=&quot;grep&quot;&gt;&lt;/a&gt;grep&lt;/h3&gt;&lt;p&gt;在文件中搜索符合条件的字符串&lt;/p&gt;
&lt;p&gt;选项：&lt;br&gt;-i 忽略大小写&lt;br&gt;-v 排除指定字符串&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;grep 是包含匹配，只要含有匹配的字符串，一整行都会输出；find 是完全匹配，只输出文件名完全一样的文件&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;whereis&quot;&gt;&lt;a href=&quot;#whereis&quot; class=&quot;headerlink&quot; title=&quot;whereis&quot;&gt;&lt;/a&gt;whereis&lt;/h3&gt;&lt;p&gt;搜索命令所在路径及帮助文档所在位置&lt;/p&gt;
&lt;p&gt;选项：&lt;br&gt;-b 只查找可执行文件&lt;br&gt;-m 只查找帮助文件&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://robin-front.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://robin-front.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Fetch POST接收不到数据，注意content-type的设置</title>
    <link href="http://robin-front.github.io/2016/03/05/Fetch%20POST%E6%8E%A5%E6%94%B6%E4%B8%8D%E5%88%B0%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%B3%A8%E6%84%8Fcontent-type%E7%9A%84%E8%AE%BE%E7%BD%AE/"/>
    <id>http://robin-front.github.io/2016/03/05/Fetch POST接收不到数据，注意content-type的设置/</id>
    <published>2016-03-05T02:18:26.000Z</published>
    <updated>2016-03-05T02:18:26.000Z</updated>
    
    <content type="html">&lt;p&gt;最近我们前端组在做一个简易的文档系统，使用redux+mongodb。其中抛弃了Ajax，起用了Fetch。&lt;/p&gt;
&lt;p&gt;XMLHttpRequest 是一个设计粗糙的 API，不符合关注分离（Separation of Concerns）的原则，配置和调用方式非常混乱，而且基于事件的异步模型写起来也没有现代的 Promise，generator/yield，async/await 友好。&lt;/p&gt;
&lt;p&gt;Fetch 的出现就是为了解决 XHR 的问题，Fetch API 是基于 Promise 设计。&lt;/p&gt;
&lt;p&gt;刚开始用的时候发现个问题，POST数据发现后端获取不到，GET方式是没有问题的。如：&lt;/p&gt;
  &lt;figure class=&quot;highlight coffeescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;fetch(&lt;span class=&quot;string&quot;&gt;&#39;/group/update&#39;&lt;/span&gt;, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  method: &lt;span class=&quot;string&quot;&gt;&#39;post&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  body: JSON.stringify(params)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .&lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;(response)&lt;/span&gt; =&amp;gt;&lt;/span&gt; response.json())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .&lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;(json)&lt;/span&gt; =&amp;gt;&lt;/span&gt; dispatch(fetchUpdateGroupName(json, index)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .&lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;(err)&lt;/span&gt; =&amp;gt;&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;err:&#39;&lt;/span&gt;, err)))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以前一直用Jquery Ajax，很少情况需要设置Content-Type，而且看到有些博文介绍Fetch的时候说，Fetch()如果没有设置Content-Type，会自动获取。&lt;/p&gt;
&lt;p&gt;后来还是被家优提醒，以下代码才是正确的设置：&lt;/p&gt;
  &lt;figure class=&quot;highlight coffeescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;fetch(&lt;span class=&quot;string&quot;&gt;&#39;/group/update&#39;&lt;/span&gt;, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  method: &lt;span class=&quot;string&quot;&gt;&#39;post&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  headers: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;Content-Type&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;application/json&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  body: JSON.stringify(params)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .&lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;(response)&lt;/span&gt; =&amp;gt;&lt;/span&gt; response.json())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .&lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;(json)&lt;/span&gt; =&amp;gt;&lt;/span&gt; dispatch(fetchUpdateGroupName(json, index)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .&lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;(err)&lt;/span&gt; =&amp;gt;&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;err:&#39;&lt;/span&gt;, err)))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt; 注意： Fetch 支持几种数据类型的传输，其中包含Blob, BLOB (binary large object)，表示二进制大对象。其中有个只读属性，Blob.type(),此时的 Content-Type 应设置为此值。 &lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里顺便记录下POST常见的Content-Type:&lt;/p&gt;
&lt;h3 id=&quot;application-x-www-form-urlencoded&quot;&gt;&lt;a href=&quot;#application-x-www-form-urlencoded&quot; class=&quot;headerlink&quot; title=&quot;application/x-www-form-urlencoded&quot;&gt;&lt;/a&gt;application/x-www-form-urlencoded&lt;/h3&gt;&lt;p&gt;浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。提交的数据按照 key1=val1&amp;amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;POST http://www.123.com HTTP/1.1
Content-Type: application/x-www-form-urlencoded;charset=utf-8

title=test&amp;amp;sub%5B%5D=1&amp;amp;sub%5B%5D=2&amp;amp;sub%5B%5D=3
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;multipart-form-data&quot;&gt;&lt;a href=&quot;#multipart-form-data&quot; class=&quot;headerlink&quot; title=&quot;multipart/form-data&quot;&gt;&lt;/a&gt;multipart/form-data&lt;/h3&gt;&lt;p&gt;使用表单上传文件时，必须让 form 的 enctyped 等于这个值, 上传图片时，我们经常会看到下面这样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;POST http://www.example.com HTTP/1.1
Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA

------WebKitFormBoundaryrGKCBY7qhFd3TrwA
Content-Disposition: form-data; name=&amp;quot;text&amp;quot;

title
------WebKitFormBoundaryrGKCBY7qhFd3TrwA
Content-Disposition: form-data; name=&amp;quot;file&amp;quot;; filename=&amp;quot;chrome.png&amp;quot;
Content-Type: image/png

PNG ... content of chrome.png ...
------WebKitFormBoundaryrGKCBY7qhFd3TrwA--
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果我们使用 new FormData()作为数据主体提交，也需要设置这种类型。&lt;/p&gt;
&lt;h3 id=&quot;application-json&quot;&gt;&lt;a href=&quot;#application-json&quot; class=&quot;headerlink&quot; title=&quot;application/json&quot;&gt;&lt;/a&gt;application/json&lt;/h3&gt;&lt;p&gt;把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。但也有些服务端语言还没有支持这种方式，例如 php 就无法通过 $_POST 对象从上面的请求中获得内容。这时候，需要自己动手处理下：在请求头中 Content-Type 为 application/json 时，从 php://input 里获得原始输入流，再 json_decode 成对象。&lt;/p&gt;
&lt;p&gt;参考：&lt;br&gt;&lt;a href=&quot;https://imququ.com/post/four-ways-to-post-data-in-http.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;四种常见的 POST 提交数据方式&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近我们前端组在做一个简易的文档系统，使用redux+mongodb。其中抛弃了Ajax，起用了Fetch。&lt;/p&gt;
&lt;p&gt;XMLHttpRequest 是一个设计粗糙的 API，不符合关注分离（Separation of Concerns）的原则，配置和调用方式非常混乱，
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="fetch" scheme="http://robin-front.github.io/tags/fetch/"/>
    
      <category term="content-type" scheme="http://robin-front.github.io/tags/content-type/"/>
    
      <category term="POST" scheme="http://robin-front.github.io/tags/POST/"/>
    
  </entry>
  
  <entry>
    <title>如何少埋坑-艾神分享会</title>
    <link href="http://robin-front.github.io/2016/03/04/%E8%89%BE%E7%A5%9E%E5%88%86%E4%BA%AB%E4%BC%9A/"/>
    <id>http://robin-front.github.io/2016/03/04/艾神分享会/</id>
    <published>2016-03-04T14:47:41.000Z</published>
    <updated>2016-03-04T14:47:41.000Z</updated>
    
    <content type="html">&lt;p&gt;又很久没有记录东西了，真是个不自律的人- -！&lt;/p&gt;
&lt;p&gt;去年十月进入搜芽，感觉搜芽是一个共同成长的公司，有一种亲切感。这算是我第一次进一个前端团队比较大的公司，很多想法在分享与讨论中迸发。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近产品在预热中，相对有空，我们前端也在尝试一些新技术的应用,用react-redux做一个简易的文档系统。除了家优对技术架构比较熟，我们几个都比较生疏。但是最重要是不要心浮气燥，虽然最近心情不是很好，但我还是尽量静下心来研读文档，在开发中一步一坑地走下去。&lt;/p&gt;
&lt;p&gt;研发部也在组织分享会，今天是第一次分享会，艾神定的主题是http协议，主要和大家分享一个http请求从客户端到服务端处理返回的整个过程。&lt;/p&gt;
&lt;p&gt;说到艾神，当初见到他的第一印象就是没什么印象，老实、普通，所以当时不是很明白为什么大家叫他艾神。不过后来发现，艾神确实是一个很踏实的人，他是写java的，功力很深，逻辑很严谨。和他一起吃饭的时候，很喜欢和我们‘讲课’。&lt;/p&gt;
&lt;p&gt;当然，分享会其他讲http协议不是他的真正目的，他延伸出来的相关案例才是重点。艾神讲协议，是想让我们要注意分清什么是标准，什么是投机。工作中要知道错的为什么错，也要知道对的为什么对，要把程序的运行把控在自己手中，不能存在不确定性。否则埋了坑，一旦出现问题，就要花更多的时间去排查。&lt;/p&gt;
&lt;p&gt;我也是见过太多程序员，对一些问题十分马虎，错了就不断推脱，有时候bug补上了却不知道为什么，殊不知可能埋了更大的坑。&lt;/p&gt;
&lt;p&gt;艾神是个很靠谱的程序员&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;又很久没有记录东西了，真是个不自律的人- -！&lt;/p&gt;
&lt;p&gt;去年十月进入搜芽，感觉搜芽是一个共同成长的公司，有一种亲切感。这算是我第一次进一个前端团队比较大的公司，很多想法在分享与讨论中迸发。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>javascript获取本周和本月或任意月的时间段</title>
    <link href="http://robin-front.github.io/2015/10/30/javascript%E5%8F%96%E6%9C%AC%E5%91%A8%E5%92%8C%E6%9C%AC%E6%9C%88%E6%88%96%E4%BB%BB%E6%84%8F%E6%9C%88%E7%9A%84%E6%97%B6%E9%97%B4%E6%AE%B5/"/>
    <id>http://robin-front.github.io/2015/10/30/javascript取本周和本月或任意月的时间段/</id>
    <published>2015-10-30T15:36:01.000Z</published>
    <updated>2015-11-06T17:10:28.000Z</updated>
    
    <content type="html">&lt;p&gt;最近有功能从两个时间段变成单个select选择了，但后端不想改接口。只好适配一下，把今天、本周、本月及过去的月份转换一下。&lt;/p&gt;
&lt;p&gt;首先，更改一下select菜单，动态取出过去的月份，添加options。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var SearchTimer = [&amp;apos;全部&amp;apos;, &amp;apos;今天&amp;apos;, &amp;apos;本周&amp;apos;, &amp;apos;本月&amp;apos;];
(function(){
    var Month = new Date().getMonth();
    for(; Month &amp;gt; 0; Month--){
        SearchTimer.push(Month + &amp;apos;月份&amp;apos;);
    }
})();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来就是要把各个options在选择的时候转换成startTime和endTime.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;switch(timer){
    case &amp;apos;全部&amp;apos;: break;
    case &amp;apos;今天&amp;apos;: break;
    case &amp;apos;本周&amp;apos;: break;
    case &amp;apos;本月&amp;apos;: break;
    default:
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后是时间的处理，先需要格式化时间，注意补零，格式为yyyy-MM-dd HH:mm:ss。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function formatDate(date) { 
    var myyear = date.getFullYear(); 
    var mymonth = date.getMonth()+1; 
    var myweekday = date.getDate(); 
    var myhours = date.getHours(); 
    var myminutes = date.getMinutes(); 
    var myseconds = date.getSeconds(); 

    if(mymonth &amp;lt; 10){mymonth = &amp;quot;0&amp;quot; + mymonth; }
    if(myweekday &amp;lt; 10){myweekday = &amp;quot;0&amp;quot; + myweekday; }
    if(myhours &amp;lt; 10){myhours = &amp;quot;0&amp;quot; + myhours; }
    if(myminutes &amp;lt; 10){myminutes = &amp;quot;0&amp;quot; + myminutes; }
    if(myseconds &amp;lt; 10){myseconds = &amp;quot;0&amp;quot; + myseconds; }
    return (myyear+&amp;quot;-&amp;quot;+mymonth + &amp;quot;-&amp;quot; + myweekday+&amp;quot; &amp;quot;+myhours+&amp;quot;:&amp;quot;+myminutes+&amp;quot;:&amp;quot;+myseconds); 
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;今天的时间很好获取，然后是本周时间：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var now = new Date(); //当前日期 
    var nowDayOfWeek = now.getDay(); //今天本周的第几天 
    var nowDay = now.getDate(); //当前日 
    var nowMonth = now.getMonth(); //当前月 
    var nowYear = now.getFullYear(); //当前年 

function getWeekStartDate() { //获得本周的开端日期
    var weekStartDate = new Date(nowYear, nowMonth, nowDay - nowDayOfWeek); 
    return formatDate(weekStartDate); //调用上面的时间格式化
} 

function getWeekEndDate() { //获得本周的停止日期
    var weekEndDate = new Date(nowYear, nowMonth, nowDay + (6 - nowDayOfWeek)); 
    return formatDate(weekEndDate); 
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后是本月时间，但首先需要知道本月有多少天：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function getMonthDays(myMonth){ //获得某月的天数 
    myMonth = parseInt(myMonth); //这一步很重要，有时候传进来的可能是字符串，后面+1的时候会变成字符串相连
    var monthStartDate = new Date(nowYear, myMonth, 1); //当月1号的时间戳
    var monthEndDate = new Date(nowYear, myMonth + 1, 1);//下月1号的时间戳
    var days = (monthEndDate - monthStartDate)/(1000 * 60 * 60 * 24);//求差即可取得某月天数
    return days; 
}

function getMonthStartDate(){ //获得本月的开端日期 
    var monthStartDate = new Date(nowYear, nowMonth, 1); 
    return formatDate(monthStartDate); 
} 

function getMonthEndDate(){ //获得本月的停止日期
    var monthEndDate = new Date(nowYear, nowMonth, getMonthDays(nowMonth)); 
    return formatDate(monthEndDate); 
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后是过去任意月份的1号和最后一天：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var theMon = timer.replace(/(月份)$/, &amp;apos;&amp;apos;)-1; //先匹配出select的月份，如：‘9月份’，但getMonth()是从0天始的，所以需要减1，也正好可以转换成整型
startTime = formatDate(new Date(nowYear, theMon, 1));
endTime = formatDate(new Date(nowYear, theMon, getMonthDays(theMon)));//某月有几天，最后一天就是几天。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以最后返回时间段：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var startTime, endTime;
endTime = formatDate(new Date());
switch(timer){
    case &amp;apos;全部&amp;apos;: 
        startTime = undefined;
        endTime = undefined;
        break;
    case &amp;apos;今天&amp;apos;: 
        startTime = formatDate(new Date(nowYear, nowMonth, nowDay));
        break;
    case &amp;apos;本周&amp;apos;:
        startTime = getWeekStartDate();
        break;
    case &amp;apos;本月&amp;apos;:
        startTime = getMonthStartDate();
        break;
    default:
        var theMon = timer.replace(/(月份)$/, &amp;apos;&amp;apos;)-1;
        startTime = formatDate(new Date(nowYear, theMon, 1));
        endTime = formatDate(new Date(nowYear, theMon, getMonthDays(theMon)));
        break;
}
return {
    startTime: startTime,
    endTime: endTime
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;至此就转换完毕。&lt;/p&gt;
&lt;p&gt;当然，如果有需要，还可能获取季度。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function getQuarterStartMonth(){ //获得本季度的开端月份
    var quarterStartMonth = 0; 
    if(nowMonth&amp;lt;3){quarterStartMonth = 0; }//判断属于第一季度
    if(2&amp;lt;nowMonth &amp;amp;&amp;amp; nowMonth&amp;lt;6){quarterStartMonth = 3; }
    if(5&amp;lt;nowMonth &amp;amp;&amp;amp; nowMonth&amp;lt;9){quarterStartMonth = 6; }
    if(nowMonth&amp;gt;8){quarterStartMonth = 9; }
    return quarterStartMonth; 
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;只要判断属于哪一季度，即可知道开端月份和结束月份。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近有功能从两个时间段变成单个select选择了，但后端不想改接口。只好适配一下，把今天、本周、本月及过去的月份转换一下。&lt;/p&gt;
&lt;p&gt;首先，更改一下select菜单，动态取出过去的月份，添加options。&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://robin-front.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>angularJS自定义指令</title>
    <link href="http://robin-front.github.io/2015/10/17/angular%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/"/>
    <id>http://robin-front.github.io/2015/10/17/angular自定义指令/</id>
    <published>2015-10-16T16:31:51.000Z</published>
    <updated>2015-11-06T17:10:28.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;指令&quot;&gt;&lt;a href=&quot;#指令&quot; class=&quot;headerlink&quot; title=&quot;指令&quot;&gt;&lt;/a&gt;指令&lt;/h2&gt;&lt;p&gt;可以简单理解成特定DOM元素上执行的函数，它可以拓展元素的功能。&lt;/p&gt;
&lt;p&gt;一个定义指令的基本格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;angular.module(&amp;apos;myApp&amp;apos;, [])
    .direcitve(&amp;apos;myDirective&amp;apos;, function(){
        return {
        //指令的配置项
        }
    });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;directive() 方法可以接受两个参数：&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;name&quot;&gt;&lt;a href=&quot;#name&quot; class=&quot;headerlink&quot; title=&quot;name&quot;&gt;&lt;/a&gt;name&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;指令的名字，如： myDirective。在DOM中可以这样使用: `&amp;lt;my-directive&amp;gt;&amp;lt;/my-directive&amp;gt;`;或者 `&amp;lt;div my-directive&amp;gt;&amp;lt;/div&amp;gt;`; 
定义指令时的名称用驼峰命名，使用时用中划线方式。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;function&quot;&gt;&lt;a href=&quot;#function&quot; class=&quot;headerlink&quot; title=&quot;function&quot;&gt;&lt;/a&gt;function&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;这个函数可以返回一个对象，如上面；或者直接返回一个函数，它会被接收成 postLink 函数。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;指令的返回函数的所有配置项&quot;&gt;&lt;a href=&quot;#指令的返回函数的所有配置项&quot; class=&quot;headerlink&quot; title=&quot;指令的返回函数的所有配置项&quot;&gt;&lt;/a&gt;指令的返回函数的所有配置项&lt;/h2&gt;&lt;p&gt;先看看指令的所有参数配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;angular.module(&amp;apos;myApp&amp;apos;, [])
    .directive(&amp;apos;myDirective&amp;apos;, function(){
        return {
            restrict: string,//指令在DOM中的声明形式字符串，默认值是‘A’
            proiority: number,//优先级，默认值0
            terminal: boolean,//是否停止运行当前元素比本指令优先级低的指令
            template: string or function,//模板 或 返回模板的函数
            templateUrl: string,//模板文件的链接
            replace: boolean or string,//true为替换，默认值false为插入到指令元素内部
            scope: boolean or object,//指令作用域
            transclude: boolean,//嵌入
            controller: string or function(scope, element, attrs, transcluude, otherInjectables){},
            require: string,
            link: function(scope, iElement, iAttrs){},
            compile: function(tElement, tAttrs, transclude){
                return {
                    pre: function(scope, iElement, iAttrs, controller){},
                    post: function(scope, iElement, iAttrs, controller){}
                }

                return function postLink(){}
            }
        }
    });
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;1-restrict&quot;&gt;&lt;a href=&quot;#1-restrict&quot; class=&quot;headerlink&quot; title=&quot;1. restrict&quot;&gt;&lt;/a&gt;1. restrict&lt;/h3&gt;&lt;p&gt;可选值：&lt;br&gt;E(元素，用于独立的指令单元，意图表达更明确) &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;my-directive&amp;gt;&amp;lt;/my-directive&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A(属性，默认值, 最常用，兼容性最好) &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div my-directive=&amp;apos;expression&amp;apos;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;C(类名) &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;my-directive: expression&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;M(注释，尽量避免使用) &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;-- directive: my-directive expression --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;2-priority&quot;&gt;&lt;a href=&quot;#2-priority&quot; class=&quot;headerlink&quot; title=&quot;2. priority&quot;&gt;&lt;/a&gt;2. priority&lt;/h3&gt;&lt;p&gt;默认值是0；优先级高的指令总是优先执行。优先级相同的指令，先声明的先执行。&lt;/p&gt;
&lt;h3 id=&quot;3-terminal&quot;&gt;&lt;a href=&quot;#3-terminal&quot; class=&quot;headerlink&quot; title=&quot;3. terminal&quot;&gt;&lt;/a&gt;3. terminal&lt;/h3&gt;&lt;p&gt;设置为true,则停止运行当前元素上比本指令优先级低的指令，但优先级相同的仍然会执行。&lt;/p&gt;
&lt;h3 id=&quot;4-template&quot;&gt;&lt;a href=&quot;#4-template&quot; class=&quot;headerlink&quot; title=&quot;4. template&quot;&gt;&lt;/a&gt;4. template&lt;/h3&gt;&lt;p&gt;值可以是以下类型：&lt;/p&gt;
&lt;p&gt;a. 模板字符串&lt;br&gt;b. 一个可以接受两个参数的函数，并返回一个代表模板的字符串&lt;/p&gt;
&lt;h3 id=&quot;5-templateUrl&quot;&gt;&lt;a href=&quot;#5-templateUrl&quot; class=&quot;headerlink&quot; title=&quot;5. templateUrl&quot;&gt;&lt;/a&gt;5. templateUrl&lt;/h3&gt;&lt;p&gt;值可以是以下类型：&lt;/p&gt;
&lt;p&gt;a. 外部html文件路径的字符串&lt;br&gt;b. 一个可以接受两个参数的函数，并返回一个外部HTML文件路径的字符串&lt;/p&gt;
&lt;h3 id=&quot;6-replace&quot;&gt;&lt;a href=&quot;#6-replace&quot; class=&quot;headerlink&quot; title=&quot;6. replace&quot;&gt;&lt;/a&gt;6. replace&lt;/h3&gt;&lt;p&gt;默认值false. 值为 true 时，模板会被当作子元素插入到调用此指令的元素内部&lt;/p&gt;
&lt;h3 id=&quot;7-scope&quot;&gt;&lt;a href=&quot;#7-scope&quot; class=&quot;headerlink&quot; title=&quot;7. scope&quot;&gt;&lt;/a&gt;7. scope&lt;/h3&gt;&lt;p&gt;可选值：&lt;br&gt;    false: 默认值，直接调用相同的作用域对象；&lt;br&gt;    true: 从当前作用域对象继承一个新的作用域对象；&lt;br&gt;    {}[object]: 创建一个同当前作用域相隔离的作用域对象。&lt;/p&gt;
&lt;h4 id=&quot;隔离作用域&quot;&gt;&lt;a href=&quot;#隔离作用域&quot; class=&quot;headerlink&quot; title=&quot;隔离作用域&quot;&gt;&lt;/a&gt;隔离作用域&lt;/h4&gt;&lt;p&gt;具有隔离作用域的指令最主要的使用场景是创建可复用的组件，组件可以在未知上下文中使用，并且可以避免污染所处的外部作用域或不经意地污染内部作用域。&lt;/p&gt;
&lt;h4 id=&quot;绑定策略&quot;&gt;&lt;a href=&quot;#绑定策略&quot; class=&quot;headerlink&quot; title=&quot;绑定策略&quot;&gt;&lt;/a&gt;绑定策略&lt;/h4&gt;&lt;p&gt;使用了隔离作用域后，指令的模板就无法访问外部作用域了。但使用无数据的隔离作用域并不常见。AngularJS 有三种方法可以将指令内部的隔离作用域同外部作用域进行数据绑定。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;本地作用域属性：&lt;code&gt;@ (or @attr)&lt;/code&gt; 使用@符号将本地作用域同DOM属性的值进行绑定。指令内部作用域可以使用外部作用域的变量。&lt;/p&gt;
&lt;p&gt; js&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;myApp.controller(&amp;apos;myController&amp;apos;, [&amp;apos;$scope&amp;apos;, function($scope){
    $scope.btnText = &amp;apos;按钮&amp;apos;;
    $scope.validate= &amp;apos;1234&amp;apos;;
    $scope.submit = function(err){
        console.log(err);
    }
}]);

myApp.directive(&amp;apos;my-btn&amp;apos;, function(){
    return {
        restrict: &amp;apos;EA&amp;apos;,
        scope: {
            text: &amp;apos;@btnText&amp;apos;//key是在template里使用的变量，val是在使用指令时所绑定的attr。若@符号后不指定名称，则默认绑定为键名&amp;apos;text&amp;apos;
        },
        replace: true,
        template: &amp;apos;&amp;lt;button&amp;gt;{{text}}&amp;lt;/button&amp;gt;&amp;apos;//这里的{{text}}正是scope的text.
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; html&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;form action=&amp;quot;/&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;text&amp;quot;&amp;gt;
    &amp;lt;my-btn btn-text=&amp;quot;btnText&amp;quot;&amp;gt;&amp;lt;/my-btn&amp;gt;//这里的属性‘btn-text’正是指令的‘@btnText’,属性值‘btnText’正是父级作用域的‘$scope.btnText’
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;双向绑定： &lt;code&gt;= (or =attr)&lt;/code&gt; 可以将本地作用域上的属性同父级作用域上的属性进行双向的数据绑定。&lt;/p&gt;
&lt;p&gt; 例：&lt;br&gt; js,controller同上一例子,如果理解上面的例子，这里也是很好理解的，只是绑定的不是字符串，而是双向数据绑定。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;myApp.directive(&amp;apos;myInput&amp;apos;, function(){
    return {
        restrict: &amp;apos;A&amp;apos;,
        scope:{
            val: &amp;apos;=value&amp;apos;//key为template里的数据模型，&amp;apos;value&amp;apos;是html里的attr.
        },
        template: &amp;apos;&amp;lt;input type=&amp;quot;text&amp;quot; ng-model=&amp;quot;val&amp;quot;&amp;gt;&amp;apos;
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; html&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;form action=&amp;quot;/&amp;quot;&amp;gt;
    &amp;lt;div my-input value=&amp;quot;validate&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;//本地作用域的属性val与父级作用域的属性validate进行双向数据绑定
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;父级作用域绑定： &lt;code&gt;&amp;amp; (or &amp;amp;attr)&lt;/code&gt; 可以对父级作用域进行绑定，可以调用父方法。意味着对这个值进行设置时会生成一个指向父级作用域的包装函数。&lt;/p&gt;
&lt;p&gt; js&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;myApp.directive(&amp;apos;myError&amp;apos;, function(){
    return {
        restrict: &amp;apos;A&amp;apos;,
        scope: {
            validate: &amp;apos;&amp;amp;check&amp;apos;
        },
        template: &amp;apos;&amp;lt;input type=&amp;quot;text&amp;quot; ng-model=&amp;quot;text&amp;quot;&amp;gt;&amp;apos;+
                &amp;apos;&amp;lt;button ng-click=&amp;apos;validate({name: text})&amp;apos;&amp;gt;&amp;lt;/button&amp;gt;&amp;apos;//传递参数需要传递一个对象，name是参数名，text是参数值。
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; html&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;
    &amp;lt;div my-error check=&amp;quot;submit(name)&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div my-error check=&amp;quot;submit(name)&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;//因为是隔离作用域，他们之间的值是不会互相影响的，只是共用父方法。
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 要调用一个带有参数的父方法，需要传递一个对象，这个对象的key是参数名称，val是要传递给参数的内容&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;8-transclude&quot;&gt;&lt;a href=&quot;#8-transclude&quot; class=&quot;headerlink&quot; title=&quot;8. transclude&quot;&gt;&lt;/a&gt;8. transclude&lt;/h3&gt;&lt;p&gt;transclude是一个可选参数，默认值是false, 当值为true时，angularJS会将从DOM元素中获取的内容放到它发现ng-transclude指令的地方，如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;ul sidebox&amp;gt;
    &amp;lt;li&amp;gt;first&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;second&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;

angular.module(&amp;apos;myApp&amp;apos;, [])
    .directive(&amp;apos;sidebox&amp;apos;, function(){
        return {
            scope: {
                title: &amp;apos;@&amp;apos;
            },
            transclude: true,
            template: &amp;apos;&amp;lt;div class=&amp;quot;sidebox&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;apos;+
                    &amp;apos;&amp;lt;div class=&amp;quot;content&amp;quot; ng-tranclude&amp;gt;&amp;lt;/div&amp;gt;&amp;apos;
        }
    });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;只有希望创建一个可以包含任意内容的指令时，才使用transclude: true。，典型的例子是模态框或导航栏。&lt;/p&gt;
&lt;h3 id=&quot;9-controller&quot;&gt;&lt;a href=&quot;#9-controller&quot; class=&quot;headerlink&quot; title=&quot;9. controller&quot;&gt;&lt;/a&gt;9. controller&lt;/h3&gt;&lt;p&gt;值可以是一个字符串或一个函数。&lt;br&gt;string: 当设置为字符中时，指令会查找注册在应用中的同名控制器。&lt;br&gt;function: 直接通过匿名构造函数的方式来定义一个内联的控制器。&lt;/p&gt;
&lt;p&gt;控制器主要是用来提供可以指令间复用的行为。可以的将当前指令的API暴露给其他的指令使用。如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;angular.modue(&amp;apos;myApp&amp;apos;, [])
    .directive(&amp;apos;inputForm&amp;apos;, function(){
        return {
            restrict: &amp;apos;EA&amp;apos;,
            controller: function($scope){
                $scope.input = &amp;apos;手机号&amp;apos;;

                this.submit = function(){//通过this暴露接口
                    //do something...
                }
            }
        }
    });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;任意的服务同样可以被传递给controller。其中有一些特殊的服务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$scope 与指令元素相关联的当前作用域&lt;/li&gt;
&lt;li&gt;$element 当前指令对应的元素&lt;/li&gt;
&lt;li&gt;$attrs 当前元素的属性组成的对象&lt;/li&gt;
&lt;li&gt;$transclude transclude链接函数是实际被执行用来克隆元素和操作DOM的函数&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;10-controllerAs&quot;&gt;&lt;a href=&quot;#10-controllerAs&quot; class=&quot;headerlink&quot; title=&quot;10. controllerAs&quot;&gt;&lt;/a&gt;10. controllerAs&lt;/h3&gt;&lt;p&gt;controllerAs用来设置控制器别名，以此为名发布控制器，并且作用域可以访问controllerAs。这样可以在视图中引用控制器，甚至无需注入$scope。例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;angular.module(&amp;apos;myApp&amp;apos;, [])
    .directive(&amp;apos;myDirective&amp;apos;, function(){
        return {
            restrict: &amp;apos;A&amp;apos;,
            template: &amp;apos;&amp;lt;h4&amp;gt;{{myController.msg}}&amp;lt;/h4&amp;gt;&amp;apos;,//可以在tpl中直接访问controller
            controllerAs: &amp;apos;myController&amp;apos;,
            contrller: function(){
                this.msg = &amp;apos;Hello&amp;apos;;
            }
        }
    });
&amp;lt;div my-directive&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;又例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;angular.module(&amp;apos;myApp&amp;apos;, [])
    .controller(&amp;apos;myController&amp;apos;, function(){
        this.msg = &amp;apos;robin&amp;apos;;
    });
&amp;lt;div ng-controller=&amp;quot;myController as main&amp;quot;&amp;gt;{{main.robin}}&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;11-require&quot;&gt;&lt;a href=&quot;#11-require&quot; class=&quot;headerlink&quot; title=&quot;11. require&quot;&gt;&lt;/a&gt;11. require&lt;/h3&gt;&lt;p&gt;其值可以是字符串或数组，字符串或数组元素代表另个一个指令的名字。require 会将指令控制器注入到当前的指令中，并作为当前指令的链接函数的第四个参数。&lt;/p&gt;
&lt;p&gt;结合9.controller的例子，可以这样使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;angular.module(&amp;apos;myApp&amp;apos;, [])
    .directive(&amp;apos;otherForm&amp;apos;, function(){
        return {
            restrict: &amp;apos;A&amp;apos;,
            require: &amp;apos;^?inputForm&amp;apos;,
            link: function(scope, element, attrs, ctrl){
                ctrl.submit();
            }
        }
    });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果是数组：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;angular.module(&amp;apos;myApp&amp;apos;, [])
    .directive(&amp;apos;otherForm&amp;apos;, function(){
        return {
            restrict: &amp;apos;A&amp;apos;,
            require: [?^inputForm, inputForm2],
            link: function(scope, element, attrs, ctrl){
                ctrl[0].submit();
                ctrl[1].api();
            }
        }
    });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;require前缀：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;‘?’    如果在当前指令中没有找到所面要的控制器，会将null作为link的第四个参数；&lt;/li&gt;
&lt;li&gt;‘^’    指令会在上游的指令链中查找require参数所指定的控制器；&lt;/li&gt;
&lt;li&gt;‘?^’    前两个选项的组合；&lt;/li&gt;
&lt;li&gt;没有前缀    指令将在同级作用域查找所需控制器，如果没有找到会抛出一个错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;12-compile&quot;&gt;&lt;a href=&quot;#12-compile&quot; class=&quot;headerlink&quot; title=&quot;12. compile&quot;&gt;&lt;/a&gt;12. compile&lt;/h3&gt;&lt;p&gt;compile选项可以返回一个对象或函数。&lt;/p&gt;
&lt;p&gt;compile函数可以用来在指令和实时数据被放到DOM中之前进行DOM操作，在这里进行添加和删除节点等DOM操作是安全的。&lt;/p&gt;
&lt;p&gt;compile与link函数是互斥的。如果同时设置，compile的返回函数会被当作链接函数，link函数会被忽略。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;compile: function(tEle, tAttrs, transcludeFn){
    //...tEle代表未绑定事件的DOM元素
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;13-link&quot;&gt;&lt;a href=&quot;#13-link&quot; class=&quot;headerlink&quot; title=&quot;13. link&quot;&gt;&lt;/a&gt;13. link&lt;/h3&gt;&lt;p&gt;link函数会经常被使用。负责设置事件监听器、监听数据变化和实时的操作DOM。&lt;/p&gt;
&lt;p&gt;如果指令很简单，可以直接从工厂函数返回一个函数来代替。如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;angular.module(&amp;apos;myApp&amp;apos;, [])
    .directive(&amp;apos;myDirective&amp;apos;, function(){
        return {
            pre: function(tElement, tAttrs, transclude){},
            post: function(scope, iElement, iAttrs, controller){}
        }
    });

angular.module(&amp;apos;myApp&amp;apos;, [])
    .directive(&amp;apos;myDirective&amp;apos;, function(){
        return {
            link: function(scope, ele, attrs){
                return {
                    pre: function(tElement, tAttrs, transclude){},
                    post: function(scope, iElement, iAttrs, controller){}
                }
            }
        }
    });
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;指令&quot;&gt;&lt;a href=&quot;#指令&quot; class=&quot;headerlink&quot; title=&quot;指令&quot;&gt;&lt;/a&gt;指令&lt;/h2&gt;&lt;p&gt;可以简单理解成特定DOM元素上执行的函数，它可以拓展元素的功能。&lt;/p&gt;
&lt;p&gt;一个定义指令的基本格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;angular.module(&amp;apos;myApp&amp;apos;, [])
    .direcitve(&amp;apos;myDirective&amp;apos;, function(){
        return {
        //指令的配置项
        }
    });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;directive() 方法可以接受两个参数：&lt;br&gt;
    
    </summary>
    
      <category term="angularJS" scheme="http://robin-front.github.io/categories/angularJS/"/>
    
    
      <category term="angularJS" scheme="http://robin-front.github.io/tags/angularJS/"/>
    
      <category term="指令" scheme="http://robin-front.github.io/tags/%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>git分支</title>
    <link href="http://robin-front.github.io/2015/10/10/git%E5%88%86%E6%94%AF/"/>
    <id>http://robin-front.github.io/2015/10/10/git分支/</id>
    <published>2015-10-10T14:16:01.000Z</published>
    <updated>2015-11-06T17:10:28.000Z</updated>
    
    <content type="html">&lt;p&gt;git分支对于我们平常开发新功能，修复bug等有很大的帮助。下面是git分支的常用命令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;分支的新建与切换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git checkout -b version2.0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  这相当于执行下面这两条命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git branch version2.0
$ git checkout version2.0
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分支的合并&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git checkout master
$ git merge version2.0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  切换到主分支，把分去version2.0合并到主分支&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分支的删除&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git branch -d verdion2.0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  如果分支功能已经合并到主分支，分支就没有用了，可以删除。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;合并分支的冲突&lt;/p&gt;
&lt;p&gt;  合并并不总是顺利的，特别是多人合作的时候，很容易产生冲突。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD
&amp;lt;div id=&amp;quot;footer&amp;quot;&amp;gt;copyright&amp;lt;/div&amp;gt;
=======
&amp;lt;div id=&amp;quot;footer&amp;quot;&amp;gt;
  please contact us
&amp;lt;/div&amp;gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; version2.0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  ‘=======’把两个版本冲突的内容分隔开来，我们需要把这些标记都删掉，并留下合并后的代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;合并GUI工具&lt;/p&gt;
&lt;p&gt;  如果安装了可视化的合并工具，可以使用&lt;code&gt;$ git mergetool&lt;/code&gt;命令来调用。&lt;br&gt;  推荐的GUI合并工具有如：meld, kdiff3&lt;/p&gt;
&lt;p&gt;  可以这样调用指定的工具：&lt;code&gt;$ git mergetool -t meld&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;  也可以配置默认工具：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git config --global merge.tool kdiff3
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;git分支对于我们平常开发新功能，修复bug等有很大的帮助。下面是git分支的常用命令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;分支的新建与切换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git checkout -b version2.0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  这相当于执
    
    </summary>
    
      <category term="git" scheme="http://robin-front.github.io/categories/git/"/>
    
    
      <category term="git" scheme="http://robin-front.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>gulp 4.0的变化</title>
    <link href="http://robin-front.github.io/2015/10/09/gulp-4.0/"/>
    <id>http://robin-front.github.io/2015/10/09/gulp-4.0/</id>
    <published>2015-10-09T07:23:51.000Z</published>
    <updated>2015-11-06T17:10:28.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;升级日志&quot;&gt;&lt;a href=&quot;#升级日志&quot; class=&quot;headerlink&quot; title=&quot;升级日志&quot;&gt;&lt;/a&gt;升级日志&lt;/h3&gt;&lt;p&gt;先来看看新版有什么不同（&lt;a href=&quot;https://github.com/gulpjs/gulp/blob/4.0/CHANGELOG.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方升级日志&lt;/a&gt;）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;新的任务系统（基于 bach，替换掉了原先基于 orchestrator 的任务系统）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;移除 gulp.reset&lt;/li&gt;
&lt;li&gt;gulp.task 不再支持三个参数的用法&lt;/li&gt;
&lt;li&gt;gulp.task 用字符串注册的任务必须是直接在命令行中调用的任务&lt;/li&gt;
&lt;li&gt;gulp.task 可以接受单参数语法，这个参数必须是一个命名函数，函数名会被作为任务名&lt;/li&gt;
&lt;li&gt;添加了 gulp.series 和 gulp.parallel 方法用于组合任务&lt;/li&gt;
&lt;li&gt;添加了 gulp.tree 方法用于获取任务树，传入 { deep: true } 参数可以得到一个 archy 兼容的节点列表&lt;/li&gt;
&lt;li&gt;添加了 gulp.registry 方法以定制注册表。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;添加了 gulp.symlink 方法，功能和 gulp.dest 一致，不过是以软链接的方式&lt;/li&gt;
&lt;li&gt;gulp.dest 和 gulp.symlink 方法添加了 dirMode 参数允许对目标目录更好地控制&lt;/li&gt;
&lt;li&gt;gulp.src 接收的文件匹配字符串会顺序解释，所以你可以写成这样 gulp.src([‘&lt;em&gt;.js’, ‘!b&lt;/em&gt;.js’, ‘bad.js’])（排除所有以 b 开头的 JS 文件但是除了 bad.js）&lt;/li&gt;
&lt;li&gt;gulp.src 方法添加了 since 选项，筛选在特定时间点之后修改过的文件（用于增量编译）&lt;/li&gt;
&lt;li&gt;将命令行分离出来成为一个独立模块，以便节约带宽/空间。用 npm install gulp -g 或 npm install gulp-cli -g 都可以安装命令行，只是 gulp-cli 不包含模块代码所以比较小&lt;/li&gt;
&lt;li&gt;命令行添加了 –tasks-json 参数，可以导出整个任务树以供他用&lt;/li&gt;
&lt;li&gt;命令行添加了 –verify 参数用以检查 package.json 中是否包含黑名单插件（违背准则而被禁入官方插件列表的可怜娃们）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;安装gulp-4-0&quot;&gt;&lt;a href=&quot;#安装gulp-4-0&quot; class=&quot;headerlink&quot; title=&quot;安装gulp 4.0&quot;&gt;&lt;/a&gt;安装gulp 4.0&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;# 如果安装过全局的 gulp 的话先卸载之
$ npm uninstall gulp -g

# 安装全局的 gulp 4.0
$ npm install &amp;quot;gulpjs/gulp#4.0&amp;quot; -g

# 到项目目录里删掉本地的 gulp
$ npm rm gulp --save-dev

# 安装本地的 gulp 4.0
$ npm install &amp;quot;gulpjs/gulp#4.0&amp;quot; --save-dev
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;gulp-task&quot;&gt;&lt;a href=&quot;#gulp-task&quot; class=&quot;headerlink&quot; title=&quot;gulp.task&quot;&gt;&lt;/a&gt;gulp.task&lt;/h3&gt;&lt;p&gt;1、移除了gulp.task传递三参数的用法&lt;br&gt;即这种用法将报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gulp.task(&amp;apos;watch&amp;apos;, [&amp;apos;default&amp;apos;], function() {
    // TODO
    // watch file
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在gulp4.0之前，这种用法将会保证default任务先执行完再执行watch任务，gulp的任务流程控制就是这么实现的，流程控制另外增加api实现，详看后面。&lt;/p&gt;
&lt;p&gt;2、gulp.task又增加了一种用法，即传递一个具名函数作为参数，将自动注册以该函数名命名的任务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function clean(){}
function compile() {
    // do something...
}
gulp.task(clean);
gulp.task(compile);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;等同于&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gulp.task(&amp;apos;clean&amp;apos;, function() {
    // do something...
});
gulp.task(&amp;apos;compile&amp;apos;, function() {
    // do something...
});
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;任务流程控制&quot;&gt;&lt;a href=&quot;#任务流程控制&quot; class=&quot;headerlink&quot; title=&quot;任务流程控制&quot;&gt;&lt;/a&gt;任务流程控制&lt;/h3&gt;&lt;p&gt;增加了&lt;code&gt;gulp.series&lt;/code&gt; 串行任务和&lt;code&gt;gulp.parallel&lt;/code&gt; 并行任务， 比原来的三参数写法要更加清晰。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function clean(){}
function copy(){}
function compile() {
    // do something...
}
gulp.task(clean);
gulp.task(copy);
gulp.task(compile);
gulp.task(&amp;apos;clean-build&amp;apos;, gulp.series(&amp;apos;clean&amp;apos;, &amp;apos;copy&amp;apos;, &amp;apos;compile&amp;apos;)); //任务将按顺序执行
gulp.task(&amp;apos;build&amp;apos;, gulp.parallel(&amp;apos;copy&amp;apos;, &amp;apos;compile&amp;apos;)); //任务将并发执行
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;只要在gulpfile.js中没有使用gulp.task传三个参数的用法，gulp 4.0也是兼容老版本的gulpfile.js的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;升级日志&quot;&gt;&lt;a href=&quot;#升级日志&quot; class=&quot;headerlink&quot; title=&quot;升级日志&quot;&gt;&lt;/a&gt;升级日志&lt;/h3&gt;&lt;p&gt;先来看看新版有什么不同（&lt;a href=&quot;https://github.com/gulpjs/gulp/blob/4.0/CHANGELOG.md&quot;&gt;官方升级日志&lt;/a&gt;）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;新的任务系统（基于 bach，替换掉了原先基于 orchestrator 的任务系统）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;移除 gulp.reset&lt;/li&gt;
&lt;li&gt;gulp.task 不再支持三个参数的用法&lt;/li&gt;
&lt;li&gt;gulp.task 用字符串注册的任务必须是直接在命令行中调用的任务&lt;/li&gt;
&lt;li&gt;gulp.task 可以接受单参数语法，这个参数必须是一个命名函数，函数名会被作为任务名&lt;/li&gt;
&lt;li&gt;添加了 gulp.series 和 gulp.parallel 方法用于组合任务&lt;/li&gt;
&lt;li&gt;添加了 gulp.tree 方法用于获取任务树，传入 { deep: true } 参数可以得到一个 archy 兼容的节点列表&lt;/li&gt;
&lt;li&gt;添加了 gulp.registry 方法以定制注册表。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端构建" scheme="http://robin-front.github.io/categories/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA/"/>
    
    
      <category term="前端构建" scheme="http://robin-front.github.io/tags/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA/"/>
    
      <category term="gulp" scheme="http://robin-front.github.io/tags/gulp/"/>
    
  </entry>
  
</feed>
