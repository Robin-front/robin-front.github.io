<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>三寸稚笔</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://robin-front.github.io/"/>
  <updated>2017-07-18T07:25:02.000Z</updated>
  <id>http://robin-front.github.io/</id>
  
  <author>
    <name>robin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高性能 react：3种加快应用程序的新工具</title>
    <link href="http://robin-front.github.io/2017/07/18/make-react-fast-again-tools-and-techniques-for-speeding-up-your-react-app/"/>
    <id>http://robin-front.github.io/2017/07/18/make-react-fast-again-tools-and-techniques-for-speeding-up-your-react-app/</id>
    <published>2017-07-18T07:25:02.000Z</published>
    <updated>2017-07-18T07:25:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高性能-react：3种加快应用程序的新工具"><a href="#高性能-react：3种加快应用程序的新工具" class="headerlink" title="高性能 react：3种加快应用程序的新工具"></a>高性能 react：3种加快应用程序的新工具</h1><p><img src="https://cdn-images-1.medium.com/max/2000/1*mJFYp7LKVzZM3PPjFb0QXQ.png" alt="https://cdn-images-1.medium.com/max/2000/1*mJFYp7LKVzZM3PPjFb0QXQ.png"></p><p>react 通常很快，但很容易造成导致性能问题的小错误。缓慢的组件安装，深层组件树和不必要的渲染循环可以快速添加到一个感觉缓慢的应用程序。</p><p>幸运的是，有很多工具，有些甚至内置于 React，这有助于诊断性能问题。在这篇文章中，我将强调使 React 应用程序更快速的工具和技术。每个部分还有一个互动，（希望）有趣的演示！<a id="more"></a></p><h2 id="工具＃1：性能时间表"><a href="#工具＃1：性能时间表" class="headerlink" title="工具＃1：性能时间表"></a>工具＃1：性能时间表</h2><p>React 15.4.0引入了一个新的性能时间轴功能，可让您准确了解组件的挂载，更新和卸载。它还可以让您可视化相关的组件生命周期。</p><p>注意：现在，此功能仅适用于Chrome，Edge和IE，因为它利用了尚未在所有浏览器中实现的用户时间轴API（User Timing API）。</p><h3 id="怎么运行的"><a href="#怎么运行的" class="headerlink" title="怎么运行的"></a>怎么运行的</h3><ul><li>打开你的应用程序并附加查询参数：<code>react_perf</code>。例如，<code>http://localhost:3000?react_perf</code></li><li>打开Chrome DevTools 性能选项卡，然后按 <strong>记录（Record）</strong>。</li><li>执行您要分析的操作。</li><li>停止记录</li><li>在 <code>User Timing</code> 下检查可视化。</li></ul><p><img src="https://cdn-images-1.medium.com/max/1000/1*cOO5vUnbkdDUcqMW8ebJqA.png" alt="https://cdn-images-1.medium.com/max/1000/1*cOO5vUnbkdDUcqMW8ebJqA.png"></p><h3 id="了解输出"><a href="#了解输出" class="headerlink" title="了解输出"></a>了解输出</h3><p>每个彩色条显示组件正在做“工作”的时间。由于JavaScript是单线程的，每当组件正在加载或呈现时，它会阻止主线程，并阻止其他代码运行。</p><p>方括号中的文字<code>[update]</code>描述了组件生命周期的哪个部分正在发生。时间轴会分解每个步骤，因此您可以在<code>[componentDidMount]</code> <code>[componentWillReceiveProps]</code> <code>[ctor]</code>（构造函数）和 <code>[render]</code> 方法上看到细粒度的时序.</p><p>堆叠的条表示组件树。虽然在React中具有相当深的组件树是典型的，但如果要优化经常安装的组件，则可以帮助减少封装组件的数量，因为每个组件都会增加小的性能和内存损失。</p><p>这里有一点值得注意的是，时间表中的时间序列是用于开发构建React的，它比生产环境更慢。事实上，甚至性能时间表本身会减慢您的应用程序。虽然这些数字不应该被认为是真实表现的性能，但是不同组件之间的相对定时是准确的。此外，组件是否更新完全不依赖于生产环境上的构建。</p><h3 id="演示＃1"><a href="#演示＃1" class="headerlink" title="演示＃1"></a>演示＃1</h3><p>为了乐趣，我操纵了TodoMVC应用程序，出现一些严重的性能问题。你可以在<a href="https://perf-demo.firebaseapp.com/?react_perf" target="_blank" rel="external">这里试试看</a>。</p><p>要查看时间轴，请打开Chrome开发工具，转到“性能”选项卡，然后单击记录。然后在应用程序中添加一些TODO，停止录制并检查时间轴。看看是否可以发现哪些组件导致性能问题:)</p><h2 id="工具＃2：为什么更新"><a href="#工具＃2：为什么更新" class="headerlink" title="工具＃2：为什么更新"></a>工具＃2：为什么更新</h2><p>影响 React 中性能的最常见问题之一是不必要的渲染循环。默认情况下，即使他们的 props 没有改变，React 组件将在父级 render 时重新 render。</p><p>例如，如果我有一个这样的简单组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DumbComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> &#123;this.props.value&#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>加上父组件:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">      <span class="tag">&lt;<span class="name">DumbComponent</span> <span class="attr">value</span>=<span class="string">&#123;3&#125;</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>无论何时父组件 render，<code>DumbComponent</code> 都会重新 render，尽管其 <code>props</code> 没有改变。</p><p>通常，如果 render 运行，并且没有对虚拟DOM进行任何更改，则这是一个浪费的渲染循环，因为该 render 方法应该是纯的，并且没有任何副作用。在大规模的 React 应用程序中，检测发生这种情况的地方可能很棘手，但幸运的是，有一个可以帮助的工具！</p><h3 id="使用-why-did-you-update"><a href="#使用-why-did-you-update" class="headerlink" title="使用 why-did-you-update"></a>使用 why-did-you-update</h3><p><img src="https://cdn-images-1.medium.com/max/1000/1*Lb4nr_WLwnLt63jUoszrnQ.png" alt="https://cdn-images-1.medium.com/max/1000/1*Lb4nr_WLwnLt63jUoszrnQ.png"></p><p><code>why-did-you-update</code> 是一个挂接到 React 的库，并检测潜在的不必要的组件渲染。它检测组件的render方法何时被调用，尽管它的 <code>props</code> 没有改变。</p><h3 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h3><p>安装 <code>npm： npm i --save-dev why-did-you-update</code></p><p>在您的应用程序的任何地方添加此代码段：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">  <span class="keyword">const</span> &#123;whyDidYouUpdate&#125; = <span class="built_in">require</span>(<span class="string">'why-did-you-update'</span>)</div><div class="line">  whyDidYouUpdate(React)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>请注意，此工具在本地开发中非常出色，但确保在生产中已被禁用，因为它会减慢您的应用程序。</p><h3 id="了解输出-1"><a href="#了解输出-1" class="headerlink" title="了解输出"></a>了解输出</h3><p><code>why-did-you-update</code> 监视您的应用程序运行并记录可能会不必要地更改的组件。它允许您在渲染循环之前和之后看到 <code>props</code>，确定它可能是不必要的。</p><h3 id="演示＃2"><a href="#演示＃2" class="headerlink" title="演示＃2"></a>演示＃2</h3><p>为了演示<code>why-did-you-update</code>，我将库安装在 TodoMVC 应用程序的 Code Sandbox 上，这是一个在线 React 游戏场。打开浏览器控制台并添加一些 TODO 以查看输出。</p><p><a href="https://codesandbox.io/s/xGJP4QExn" target="_blank" rel="external">这是演示</a></p><blockquote><p>请注意，应用程序中的几个组件不必要地 render。尝试实现上述技术来防止不必要的渲染。如果正确完成，则<code>why-did-you-update</code>控制台中不应有输出。</p></blockquote><h2 id="工具＃3：反应开发工具"><a href="#工具＃3：反应开发工具" class="headerlink" title="工具＃3：反应开发工具"></a>工具＃3：反应开发工具</h2><p><img src="https://cdn-images-1.medium.com/max/1000/1*1Ih6h8djFyH13tfFK3D1sw.png" alt="https://cdn-images-1.medium.com/max/1000/1*1Ih6h8djFyH13tfFK3D1sw.png"></p><p>React 开发者工具 Chrome 扩展程序具有可视化组件更新的内置功能。这有助于检测不必要的渲染循环。要使用它，首先请确保在<a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=zh-CN" target="_blank" rel="external">此处安装扩展</a>。</p><p>然后，点击Chrome DevTools中的“React”标签打开扩展程序，然后选中“Highlight Updates”。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*GP4vXvW3WO0vTbggDfus4Q.png" alt="https://cdn-images-1.medium.com/max/800/1*GP4vXvW3WO0vTbggDfus4Q.png"></p><p>然后，只需使用你的应用程序。与各种组件交互，并观看 DevTools 工作的魔力。</p><h3 id="了解输出-2"><a href="#了解输出-2" class="headerlink" title="了解输出"></a>了解输出</h3><p>“react 开发人员工具”突出显示在给定时间点重新呈现的组件。根据更新的频率，使用不同的颜色。对于频繁更新的组件，蓝色显示不频繁更新，按更新频率依次为绿色，黄色和红色。</p><p>看到黄色或红色不一定是坏事。当调整滑块或触发频繁更新的其他UI元素时，可以预期。但是，如果您点击一个简单的按钮并看到红色，这可能意味着某些东西是错误的。该工具的目的是发现不必要的更新的组件。作为应用程序开发人员，您应该有一个一般的想法，哪些组件应该在给定的时间更新。</p><h3 id="演示＃3"><a href="#演示＃3" class="headerlink" title="演示＃3"></a>演示＃3</h3><p>为了演示组件突出显示，我安装了 TodoMVC 应用程序来不必要地更新某些组件。</p><p><a href="https://highlight-demo.firebaseapp.com/" target="_blank" rel="external">这是演示</a></p><p>打开上面的链接，然后打开 React Developer Tools 并启用更新突出显示。当您输入顶部文本输入时，您将看到所有 TODO 都不必要地突出显示。当您输入更快时，您将看到颜色更改以指示更频繁的更新。</p><h2 id="修复不必要的渲染"><a href="#修复不必要的渲染" class="headerlink" title="修复不必要的渲染"></a>修复不必要的渲染</h2><p>一旦识别出应用程序中不必要的重新渲染的组件，就会有一些简单的修复。</p><h3 id="使用PureComponent"><a href="#使用PureComponent" class="headerlink" title="使用PureComponent"></a>使用PureComponent</h3><p>在上面的例子中，<code>DumbComponent</code> 是它 props 的纯函数。也就是说，该组件只有在其 <code>props</code> 更改时才需要重新 render。React 有一种内置的特殊类型的组件，<code>PureComponent</code> 这个类型是为这个用例准备的。</p><p>而不是继承自 <code>React.Component</code>，请使用 <code>React.PureComponent</code>，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DumbComponent</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> &#123;this.props.value&#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后，该组件只有在其 <code>props</code> 实际更改时才会重新 render。而已！</p><p>请注意，<code>PureComponent</code>做一个 <code>props</code> 的浅比较，所以如果你使用复杂的数据结构，它可能会错过一些 <code>props</code> 更改，而不是更新您的组件。</p><h3 id="实现-shouldComponentUpdate"><a href="#实现-shouldComponentUpdate" class="headerlink" title="实现 shouldComponentUpdate"></a>实现 shouldComponentUpdate</h3><p><code>shouldComponentUpdate</code> 是 render 任何一个 <code>props</code> 或 <code>state</code> 更改之前调用的组件方法。如果 <code>shouldComponentUpdate</code> 返回 <code>true</code>，render 将被调用，如果它返回 <code>false</code>，没有任何反应。</p><p>通过实现此方法，您可以指示 React 避免重新渲染给定的组件，当其 <code>props</code> 不更改的时候。</p><p>例如，我们可以像下面这样，在一个组件中实现一个 <code>shouldComponentUpdate</code> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DumbComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  shouldComponentUpdate(nextProps) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.value !== nextProps.value) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">render() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="调试生产中的性能问题"><a href="#调试生产中的性能问题" class="headerlink" title="调试生产中的性能问题"></a>调试生产中的性能问题</h2><p>如果您在自己的机器上运行应用程序，“React Developer Tools”才能起作用。如果您有兴趣了解用户在生产中看到的性能问题，请尝试使用<a href="https://logrocket.com/" target="_blank" rel="external">LogRocket</a>。</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*s_rMyo6NbrAsP-XtvBaXFg.png" alt="https://cdn-images-1.medium.com/max/1000/1*s_rMyo6NbrAsP-XtvBaXFg.png"></p><p><a href="https://logrocket.com/" target="_blank" rel="external">LogRocket</a> 就像是网络应用程序，记录 DVR 字面上 的一切，您网站上发生的。您可以使用错误或性能问题重播会话，而不是猜测为什么会出现问题，以快速了解根本原因。</p><p>LogRocket 为您的应用程序记录性能数据，Redux actions/state，日志，错误，网络请求/响应与标题+主体和浏览器元数据。它还在页面上记录HTML和CSS，重新创建即使是最复杂的单页应用程序的像素视频。</p><blockquote><p>【翻译原文链接】：<a href="https://medium.freecodecamp.org/make-react-fast-again-tools-and-techniques-for-speeding-up-your-react-app-7ad39d3c1b82" target="_blank" rel="external">https://medium.freecodecamp.org/make-react-fast-again-tools-and-techniques-for-speeding-up-your-react-app-7ad39d3c1b82</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;高性能-react：3种加快应用程序的新工具&quot;&gt;&lt;a href=&quot;#高性能-react：3种加快应用程序的新工具&quot; class=&quot;headerlink&quot; title=&quot;高性能 react：3种加快应用程序的新工具&quot;&gt;&lt;/a&gt;高性能 react：3种加快应用程序的新工具&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*mJFYp7LKVzZM3PPjFb0QXQ.png&quot; alt=&quot;https://cdn-images-1.medium.com/max/2000/1*mJFYp7LKVzZM3PPjFb0QXQ.png&quot;&gt;&lt;/p&gt;&lt;p&gt;react 通常很快，但很容易造成导致性能问题的小错误。缓慢的组件安装，深层组件树和不必要的渲染循环可以快速添加到一个感觉缓慢的应用程序。&lt;/p&gt;&lt;p&gt;幸运的是，有很多工具，有些甚至内置于 React，这有助于诊断性能问题。在这篇文章中，我将强调使 React 应用程序更快速的工具和技术。每个部分还有一个互动，（希望）有趣的演示！
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="react" scheme="http://robin-front.github.io/tags/react/"/>
    
      <category term="tools" scheme="http://robin-front.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>Redux 并不慢，只是你使用姿势不对 —— 一份优化指南</title>
    <link href="http://robin-front.github.io/2017/07/17/react-redux-optimization/"/>
    <id>http://robin-front.github.io/2017/07/17/react-redux-optimization/</id>
    <published>2017-07-17T09:12:02.000Z</published>
    <updated>2017-07-17T09:12:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redux-并不慢，只是你使用姿势不对-——-一份优化指南"><a href="#Redux-并不慢，只是你使用姿势不对-——-一份优化指南" class="headerlink" title="Redux 并不慢，只是你使用姿势不对 —— 一份优化指南"></a>Redux 并不慢，只是你使用姿势不对 —— 一份优化指南</h1><p><em>如何优化使用了 Redux 的 react 应用程序并不是显而易见的。但实际上相当简单。这是一个简短的指南，以及一些例子。</em></p><p>当优化使用 Redux 的 react 应用程序时，我经常听到有人说 Redux 缓慢。在99％的情况下，性能不佳的原因（适用于任何其他框架）与不必要的渲染相关联，因为 DOM 更新是昂贵的！在本文中，您将学习如何在使用 Redux 绑定 react 时避免不必要的 <code>render</code>。</p><p>通常，我们使用<a href="https://github.com/reactjs/react-redux" target="_blank" rel="external">官方 react 绑定的 Redux</a> 的 <a href="https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options" target="_blank" rel="external">connect</a> 高阶组件， 当您的 Redux <code>store</code> 更新时，react 组件就会更新。这是一个将组件包装在另一个组件中的函数，该组件订阅了 Redux <code>store</code> 中的更改，并渲染 <code>store</code>，这就是它的子节点更新的原因。<a id="more"></a></p><h2 id="快速入坑-react-redux，官方-react-绑定-Redux"><a href="#快速入坑-react-redux，官方-react-绑定-Redux" class="headerlink" title="快速入坑 react-redux，官方 react 绑定 Redux"></a>快速入坑 react-redux，官方 react 绑定 Redux</h2><p>该 <code>connect</code> 高阶组件实际上是已经过优化。要了解如何最好地使用它，最好了解先它是如何工作的！</p><p>Redux 以及 react-redux 实际上是相当小的库，所以源代码并不费解。我鼓励大家阅读源代码，或至少其中的一些。如果你想进一步，编写自己的实现，它将让你深入了解为什么库的设计方式是这样的。</p><p>不用多说，我们来看看 react 绑定的工作原理。正如我们公认的那样，react 绑定的核心部分就是 <code>connect</code> 高阶组件，这是它的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"></span></span></div><div class="line">  mapStateToProps,</div><div class="line">  mapDispatchToProps,</div><div class="line">  mergeProps,</div><div class="line">  &#123;</div><div class="line">    pure = true,</div><div class="line">    areStatesEqual = strictEqual,</div><div class="line">    areOwnPropsEqual = shallowEqual,</div><div class="line">    areStatePropsEqual = shallowEqual,</div><div class="line">    areMergedPropsEqual = shallowEqual,</div><div class="line">    ...extraOptions</div><div class="line">  &#125; = &#123;&#125;</div><div class="line">) &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>作为附注 - 唯一的强制性参数是 <code>mapStateToProps</code>，在大多数情况下，您只需要前两个参数。但是，我在这里使用完整的写法来说明 <code>react bindings</code> 是如何工作的。</p><p>传递给 <code>connect</code> 函数的所有参数都用于生成一个对象，该对象作为 <code>props</code> 传递到封装的组件上。<code>mapStateToProps</code> 用于将状态从 Redux store 映射到一个对象，<code>mapDispatchToProps</code> 用于生成包含函数的对象 - 通常这些函数是 <code>actions</code> 创建者。最后，<code>mergeProps</code> 有三个参数 <code>stateProps</code>，<code>dispatchProps</code> 和 <code>ownProps</code>。第一个是 <code>mapStateToProps</code> 的结果，第二个参数是 <code>mapDispatchToProps</code> 的结果，第三个参数是从组件本身继承的 <code>props</code> 对象。默认情况下，<code>mergeProps</code> 将这些参数简单地组合到一个对象中，但是如果您传递一个函数作为 <code>mergeProps</code> 参数，<code>connect</code> 则将使用该函数生成封装组件的 <code>props</code>。</p><p><code>connect</code> 函数的第四个参数是一个 <code>options</code> 对象。这包含5个选项：<code>pure</code> 可以是 <code>true</code> 或 <code>false</code>，以及确定是否重新渲染组件的4个函数（应该返回一个布尔值）。<code>pure</code> 默认设置为<code>true</code>。如果设置为<code>false</code>，则<code>connect</code> 将跳过任何优化，并且<code>options</code>对象中的4个函数将不生效。我个人不能想到一个用例，但是如果您希望关闭优化，则将其设置为<code>false</code>。</p><p>我们的 <code>mergeProps</code> 函数产生的对象与最后一个 <code>props</code> 对象进行比较。如果我们的 <code>connect</code> 认为 <code>props</code> 对象已经改变了，那么这个组件就会重新渲染。要了解库如何决定是否有变更，我们可以查看该 <code>shallowEqual</code> 功能。如果函数返回 <code>true</code>，组件将不会重新渲染，如果返回 <code>false</code>，它将重新渲染。<code>shallowEqual</code> 执行此比较。下面你会看到 <code>shallowEqual</code> 方法的一部分，它告诉你所有你需要知道的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keysA.length; i++) &#123;</div><div class="line">  <span class="keyword">if</span> (!hasOwn.call(objB, keysA[i]) ||</div><div class="line">      !is(objA[keysA[i]], objB[keysA[i]])) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>总而言之，这是上面的代码：</p><p>它在 object a 中的 key 上循环，并检查 object B 是否拥有相同的属性。然后它检查 object A中的属性（具有相同名称）是否等于对象B的属性。如果只有一个比较返回false，那么对象将被视为不相等，并且会发生重新渲染。</p><p>这导致我们一个黄金法则：</p><h2 id="只给您的组件它需要呈现的数据"><a href="#只给您的组件它需要呈现的数据" class="headerlink" title="只给您的组件它需要呈现的数据"></a>只给您的组件它需要呈现的数据</h2><p>这说得很含糊，所以让我们用一些实际的例子来阐述。</p><h3 id="拆分连接的组件"><a href="#拆分连接的组件" class="headerlink" title="拆分连接的组件"></a>拆分连接的组件</h3><p>我看到人们这样做 订阅容器组件一系列状态，并通过 <code>props</code> 传递所有东西。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> BigComponent = <span class="function">(<span class="params">&#123; a, b, c, d &#125;</span>) =&gt;</span> (</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;CompA a=&#123;a&#125; /&gt;</div><div class="line">    &lt;CompB b=&#123;b&#125; /&gt;</div><div class="line">    &lt;CompC c=&#123;c&#125; /&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">);</div><div class="line"></div><div class="line">const ConnectedBigComponent = connect(</div><div class="line">  (&#123; a, b, c &#125;) =&gt; (&#123; a, b, c &#125;)</div><div class="line">);</div></pre></td></tr></table></figure><p>现在，每次要么a，b或c变化，BigComponent包括CompA，CompB并且CompC将重新呈现。</p><p>相反，拆分您的组件，不要害怕更多地使用 connect：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ConnectedA = connect(CompA, (&#123; a &#125;) =&gt; (&#123; a &#125;));</div><div class="line"><span class="keyword">const</span> ConnectedB = connect(CompB, (&#123; b &#125;) =&gt; (&#123; b &#125;));</div><div class="line"><span class="keyword">const</span> ConnectedC = connect(CompC, (&#123; c &#125;) =&gt; (&#123; c &#125;));</div><div class="line"></div><div class="line"><span class="keyword">const</span> BigComponent = <span class="function"><span class="params">()</span> =&gt;</span> (</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;ConnectedA a=&#123;a&#125; /&gt;</div><div class="line">    &lt;ConnectedB b=&#123;b&#125; /&gt;</div><div class="line">    &lt;ConnectedC c=&#123;c&#125; /&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">);</div></pre></td></tr></table></figure><p>通过此次更新，<code>CompA</code> 将只有当<code>a</code>已经改变才会重新渲染，<code>CompB</code>当<code>b</code>改变等。考虑这样一个场景，每一个值<code>a</code>，<code>b</code>并<code>c</code>分别经常更新。对于每次更新，我们现在重新渲染一个，而不是所有组件。这几乎没有什么明显的三个组件，但如果你有更多！</p><h3 id="改变你的状态，使其尽可能的最小"><a href="#改变你的状态，使其尽可能的最小" class="headerlink" title="改变你的状态，使其尽可能的最小"></a>改变你的状态，使其尽可能的最小</h3><p>这是一个假设（稍微设计过）的例子：</p><p>你有一个大的项目列表，我们假设有300或更多。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;List&gt;</div><div class="line">  &#123;<span class="keyword">this</span>.props.items.map(<span class="function">(<span class="params">&#123; content, itemId &#125;</span>) =&gt;</span> (</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ListItem</span></span></span></div><div class="line">      <span class="attr">onClick</span>=<span class="string">&#123;selectItem&#125;</span></div><div class="line">      <span class="attr">content</span>=<span class="string">&#123;content&#125;</span></div><div class="line">      <span class="attr">itemId</span>=<span class="string">&#123;itemId&#125;</span></div><div class="line">      <span class="attr">key</span>=<span class="string">&#123;itemId&#125;</span></div><div class="line">    /&gt;</div><div class="line">  ))&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">List</span>&gt;</span></div></pre></td></tr></table></figure><p>当我们点击一​​个列表项时，一个动作被触发，更新一个存储值 - <code>selectedItem</code>。每个列表项连接到 Redux 并获取<code>selectedItem</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ListItem = connect(</div><div class="line">  <span class="function">(<span class="params">&#123; selectedItem &#125;</span>) =&gt;</span> (&#123; selectedItem &#125;)</div><div class="line">)(SimpleListItem);</div></pre></td></tr></table></figure><p>我们正在做正确的事情，我们仅将组件连接到所需的状态。但是，当<code>selectedItem</code>更新时，所有<code>ListItem</code>组件都将重新渲染，因为我们返回的对象<code>selectedItem</code>已经更改。在此之前 <code>{ selectedItem: 123 }</code>，现在是 <code>{ selectedItem: 120 }</code>。</p><p>请记住，我们正在使用该 <code>selectedItem</code> 值来检查当前项目是否被选中。所以我们的组件真正需要知道的是它是否被选择 - 实质上是一个<code>Boolean</code>。<code>Boolean</code> 是伟大的，因为只有两个可能的值，<code>true</code> 或者 <code>false</code>。所以如果我们返回一个布尔值，而不是 <code>selectedItem</code> ，仅 <code>Boolean</code> 更改的两个项目将会重新渲染，这就是我们需要的。<code>mapStateToProps</code> 实际上 <code>props</code> 它是组件的第二个参数，我们可以用它来检查这是否实际上是选定的项目。以下是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ListItem = connect(</div><div class="line">  <span class="function">(<span class="params">&#123; selectedItem &#125;, &#123; itemId &#125;</span>) =&gt;</span> (&#123; <span class="attr">isSelected</span>: selectedItem === itemId &#125;)</div><div class="line">)(SimpleListItem);</div></pre></td></tr></table></figure><p>现在，只要我们的 <code>selectedItem</code> 值发生变化，只有两个组件重新呈现 - <code>ListItem</code> 现在已经被选择了，而且原来那个已经被取消选择了。</p><h3 id="保持数据扁平化"><a href="#保持数据扁平化" class="headerlink" title="保持数据扁平化"></a>保持数据扁平化</h3><p>在 <a href="http://redux.js.org/docs/recipes/reducers/NormalizingStateShape.html" target="_blank" rel="external">Redux文档提到</a> 这是一种最佳实践。保持您的store 扁平化是有益的一些原因。但是对于本文的主旨，嵌套会造成问题，因为为了让我们的应用程序尽可能的快，我们希望我们的更新尽可能的细微。假设我们有一个这样的嵌套形状：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">articles</span>: [&#123;</div><div class="line">    <span class="attr">comments</span>: [&#123;</div><div class="line">      <span class="attr">users</span>: [&#123;</div><div class="line">      &#125;]</div><div class="line">    &#125;]</div><div class="line">  &#125;],</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>为了优化我们的 <code>Article</code>，<code>Comment</code> 和 <code>User</code> 组件，我们现在需要所有的人订阅 <code>articles</code>，然后深深伸入这种结构只返回他们所需要的状态。相反地​​，如此设计你的形状更有意义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">articles</span>: [&#123;</div><div class="line">    ...</div><div class="line">  &#125;],</div><div class="line">  <span class="attr">comments</span>: [&#123;</div><div class="line">    <span class="attr">articleId</span>: ..,</div><div class="line">    <span class="attr">userId</span>: ...,</div><div class="line">    ...</div><div class="line">  &#125;],</div><div class="line">  <span class="attr">users</span>: [&#123;</div><div class="line">    ...</div><div class="line">  &#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后使用映射函数选择注释和用户信息。关于这一点的更多信息可以在 <a href="http://redux.js.org/docs/recipes/reducers/NormalizingStateShape.html" target="_blank" rel="external">Redux文档中阅读关于规范化状态的信息</a>。</p><h2 id="彩蛋：用于选择-Redux-state-的库"><a href="#彩蛋：用于选择-Redux-state-的库" class="headerlink" title="彩蛋：用于选择 Redux state 的库"></a>彩蛋：用于选择 Redux state 的库</h2><p>这是完全可选的，取决于您。通常所有以上的建议都足够深入地让你写出快速的 react 和 Redux 应用程序。但是有两个优秀的库使得选择状态更容易一些：</p><p><a href="https://github.com/reactjs/reselect" target="_blank" rel="external">Reselect</a> 是 <code>selectors</code> 为您的 Redux 应用程序编写的引人注目的工具。从重新选择文档：</p><ul><li>选择器可以计算派生数据，允许 Redux 存储尽可能小的状态。</li><li>选择器效率高。除非其中一个参数发生变化，否则不会重新计算选择器。</li><li>选择器是可组合的。它们可以用作其他选择器的输入。</li></ul><p>对于具有复杂接口，复杂状态 和/或 频繁更新的应用程序，重新选择可以帮助您轻松使您的应用程序更快！</p><p><a href="http://ramdajs.com/" target="_blank" rel="external">Ramda</a> 是一个功能强大的库，具有更高阶的函数。换句话说 - 用函数创建函数。由于我们的映射函数只是这个函数，所以我们可以很方便地使用 <code>Ramda</code> 创建我们的选择器。<code>Ramda</code> 可以有选择器的所有功能并做的更多。查看 <a href="https://github.com/ramda/ramda/wiki/Cookbook" target="_blank" rel="external">Ramda 食谱</a>的一些例子，您可以使用 Ramda 做什么。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redux-并不慢，只是你使用姿势不对-——-一份优化指南&quot;&gt;&lt;a href=&quot;#Redux-并不慢，只是你使用姿势不对-——-一份优化指南&quot; class=&quot;headerlink&quot; title=&quot;Redux 并不慢，只是你使用姿势不对 —— 一份优化指南&quot;&gt;&lt;/a&gt;Redux 并不慢，只是你使用姿势不对 —— 一份优化指南&lt;/h1&gt;&lt;p&gt;&lt;em&gt;如何优化使用了 Redux 的 react 应用程序并不是显而易见的。但实际上相当简单。这是一个简短的指南，以及一些例子。&lt;/em&gt;&lt;/p&gt;&lt;p&gt;当优化使用 Redux 的 react 应用程序时，我经常听到有人说 Redux 缓慢。在99％的情况下，性能不佳的原因（适用于任何其他框架）与不必要的渲染相关联，因为 DOM 更新是昂贵的！在本文中，您将学习如何在使用 Redux 绑定 react 时避免不必要的 &lt;code&gt;render&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;通常，我们使用&lt;a href=&quot;https://github.com/reactjs/react-redux&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方 react 绑定的 Redux&lt;/a&gt; 的 &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;connect&lt;/a&gt; 高阶组件， 当您的 Redux &lt;code&gt;store&lt;/code&gt; 更新时，react 组件就会更新。这是一个将组件包装在另一个组件中的函数，该组件订阅了 Redux &lt;code&gt;store&lt;/code&gt; 中的更改，并渲染 &lt;code&gt;store&lt;/code&gt;，这就是它的子节点更新的原因。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="react" scheme="http://robin-front.github.io/tags/react/"/>
    
      <category term="redux" scheme="http://robin-front.github.io/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>优化 react 让它快如闪电——你是电，你是光，你是唯一的神话</title>
    <link href="http://robin-front.github.io/2017/07/17/react-at-light-speed/"/>
    <id>http://robin-front.github.io/2017/07/17/react-at-light-speed/</id>
    <published>2017-07-17T07:23:17.000Z</published>
    <updated>2017-07-17T07:23:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="光速-React"><a href="#光速-React" class="headerlink" title="光速 React"></a>光速 React</h1><h2 id="Vixlet-团队优化性能的经验教训"><a href="#Vixlet-团队优化性能的经验教训" class="headerlink" title="Vixlet 团队优化性能的经验教训"></a>Vixlet 团队优化性能的经验教训</h2><p><img src="https://cdn-images-1.medium.com/max/1000/1*SJzLm3SW2IegLw0GzlaG-w.jpeg" alt=""></p><p>在过去一年多，我们 <a href="http://www.vixlet.com" target="_blank" rel="external">Vixlet</a> 的 web 团队已经着手于一个激动人心的项目：将我们的整个 web 应用迁移到 <code>React</code> + <code>Redux</code> 架构。对于整个团队来说，这是不断成长中的机会，在整个过程中，我们在这方面面临一些挑战。</p><p>因为我们的 web-app 可能有非常大的 feed 视图，包括成百上千的媒体、文本、视频、链接元素，我们花了相当多的时间寻找能充分利用 <code>React</code> 性能的方法。在这里，我们将分享我们这一路学到的一些经验教训。</p><p><strong>声明</strong>：<strong>下面讲的做法和方法更适用于我们具体应用的性能需求。然而，像所有的开发者建议的那样，最重要的是要考虑到你的应用程序和团队的实际需求。React 是一个开箱即用的框架，所以你可能不需要像我们一样细致地优化性能。话虽如此，我们还是希望你能在这篇文章里找到一些有用的信息。</strong><a id="more"></a></p><h3 id="基本优化"><a href="#基本优化" class="headerlink" title="基本优化"></a>基本优化</h3><p><img src="https://cdn-images-1.medium.com/max/800/1*UOGdUM1V_rGUbxLS-eaWdQ.gif" alt=""></p><p>向更大的世界迈出第一步。</p><h4 id="render-函数"><a href="#render-函数" class="headerlink" title="render() 函数"></a>render() 函数</h4><p>一般来说，要尽可能少地在 <code>render</code> 函数中做操作。如果非要做一些复杂操作或者计算，也许你可以考虑使用一个 <a href="https://en.wikipedia.org/wiki/Memoization" target="_blank" rel="external">memoized</a> 函数以便于缓存那些重复的结果。可以看看 <a href="https://lodash.com/docs#memoize" target="_blank" rel="external">Lodash.memoize</a>，这是一个开箱即用的记忆函数。</p><p>反过来讲，避免在组件的 <code>state</code> 上存储一些容易计算的值也很重要。举个例子，如果 <code>props</code> 同时包含 <code>firstName</code> 和 <code>lastName</code>，没必要在 <code>state</code> 上存一个 <code>fullName</code>，因为它可以很容易通过提供的 <code>props</code> 来获取。如果一个值可以通过简单的字符串拼接或基本的算数运算从 <code>props</code> 派生出来，那么没理由将这些值包含在组件的 <code>state</code> 上。</p><h4 id="Prop-和-Reconciliation"><a href="#Prop-和-Reconciliation" class="headerlink" title="Prop 和 Reconciliation"></a>Prop 和 Reconciliation</h4><p>重要的是要记住，只要 <code>props</code>（或 <code>state</code>）的值不等于之前的值，<code>React</code> 就会触发重新渲染。如果 <code>props</code> 或者 <code>state</code> 包含一个对象或者数组，嵌套值中的任何改变也会触发重新渲染。考虑到这一点，你需要注意在每次渲染的生命周期中，创建一个新的 <code>props</code> 或者 <code>state</code> 都可能无意中导致了性能下降。</p><p><strong>例子: 函数绑定的问题</strong></p><script src="https://gist.github.com/jacob-beltran/638dcc9978b498c82d68a19593266999.js"></script><p><strong>例子:</strong> <strong>对象或数组字面量</strong></p><script src="https://gist.github.com/jacob-beltran/7777a477942cbb2c9db65a1e3c312e88.js"></script><p><strong>例子</strong> <strong>: 注意字面量的回退值</strong></p><script src="https://gist.github.com/jacob-beltran/ae63069d95831fb49e59e74eb7ddbd11.js"></script><h4 id="尽可能的保持-Props（和-State）简单和精简"><a href="#尽可能的保持-Props（和-State）简单和精简" class="headerlink" title="尽可能的保持 Props（和 State）简单和精简"></a>尽可能的保持 Props（和 State）简单和精简</h4><p>理想情况下，传递给组件的 <code>props</code> 应该是它直接需要的。为了将值传给子组件而将一个大的、复杂的对象或者很多独立的 <code>props</code> 传递给一个组件会导致很多不必要的组件渲染（并且会增加开发复杂性）。</p><p>在 Vixlet，我们使用 Redux 作为状态容器，所以在我们看来，最理想的是方案在组件层次结构的每一个层级中使用 <a href="https://www.npmjs.com/package/react-redux" target="_blank" rel="external">react-redux</a> 的 <a href="https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options" target="_blank" rel="external">connect()</a> 函数直接从 <code>store</code> 上获取数据。<code>connect</code> 函数的性能很好，并且使用它的开销也非常小。</p><h4 id="组件方法"><a href="#组件方法" class="headerlink" title="组件方法"></a>组件方法</h4><p>由于组件方法是为组件的每个实例创建的，如果可能的话，使用 <code>helper/util</code> 模块的纯函数或者<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="external">静态类方法</a>。尤其在渲染大量组件的应用中会有明显的区别。</p><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p><img src="https://cdn-images-1.medium.com/max/800/1*9n2fdJB1gPYLFJAj5D5RqA.gif" alt=""></p><p>在我看来视图的变化是邪恶的！</p><h4 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate()"></a>shouldComponentUpdate()</h4><p>React 有一个生命周期函数 <a href="https://facebook.github.io/react/docs/react-component.html#shouldcomponentupdate" target="_blank" rel="external">shouldComponentUpdate()</a>。这个方法可以根据当前的和下一次的 <code>props</code> 和 <code>state</code> 来通知这个 React 组件是否应该被重新渲染。</p><p>然而使用这个方法有一个问题，开发者必须考虑到需要触发重新渲染的每一种情况。这会导致逻辑复杂，一般来说，会非常痛苦。如果非常需要，你可以使用一个自定义的 <code>shouldComponentUpdate()</code> 方法，但是很多情况下有更好的选择。</p><h4 id="React-PureComponent"><a href="#React-PureComponent" class="headerlink" title="React.PureComponent"></a>React.PureComponent</h4><p>React 从 <code>v15</code> 开始会包含一个 <code>PureComponent</code> 类，它可以被用来构建组件。<code>React.PureComponent</code> 声明了它自己的 <code>shouldComponentUpdate()</code> 方法，它自动对当前的和下一次的 <code>props</code> 和 <code>state</code> 做一次浅对比。有关浅对比的更多信息，请参考这个 Stack Overflow：</p><p><a href="http://stackoverflow.com/questions/36084515/how-does-shallow-compare-work-in-react" target="_blank" rel="external">http://stackoverflow.com/questions/36084515/how-does-shallow-compare-work-in-react</a></p><p>在大多数情况下，<code>React.PureComponent</code> 是比 <code>React.Component</code> 更好的选择。在创建新组件时，首先尝试将其构建为纯组件，只有组件需要更多功能时才使用 <code>React.Component</code>。</p><p>更多信息，请查阅相关文档 <a href="https://facebook.github.io/react/docs/react-api.html#react.purecomponent" target="_blank" rel="external">React.PureComponent</a>。</p><h4 id="组件性能分析（在-Chrome-里）"><a href="#组件性能分析（在-Chrome-里）" class="headerlink" title="组件性能分析（在 Chrome 里）"></a>组件性能分析（在 Chrome 里）</h4><p>在新版本的 Chrome <code>里，timeline</code> 工具里有一个额外的内置功能可以显示哪些 React 组件正在渲染以及他们花费的时间。要启用此功能，将 <code>?react_perf</code> 作为要测试的 URL 的查询字符串。React 渲染时间轴数据将位于 User Timing 部分。</p><p>更多相关信息，请查阅官方文档：<a href="https://facebook.github.io/react/docs/optimizing-performance.html#profiling-components-with-chrome-timeline" target="_blank" rel="external">Profiling Components with Chrome Timeline</a> 。</p><h4 id="有用的工具-why-did-you-update"><a href="#有用的工具-why-did-you-update" class="headerlink" title="有用的工具: why-did-you-update"></a>有用的工具: <a href="https://www.npmjs.com/package/why-did-you-update" target="_blank" rel="external">why-did-you-update</a></h4><p>这是一个很棒的 NPM 包，他们给 React 添加补丁，当一个组件触发了不必要的重新渲染时，它会在控制台输出一个 <code>console</code> 提示。</p><p><strong>注意</strong>: 这个模块在初始化时可以通过一个过滤器匹配特定的想要优化的组件，否则你的命令行可能会被垃圾信息填满，并且可能你的浏览器会因此而挂起或者崩溃，查阅 <a href="https://www.npmjs.com/package/why-did-you-update" target="_blank" rel="external">why-did-you-update 文档</a> 获取更多详细信息。</p><h3 id="常见性能陷阱"><a href="#常见性能陷阱" class="headerlink" title="常见性能陷阱"></a>常见性能陷阱</h3><p><img src="https://cdn-images-1.medium.com/max/800/1*GVteDSQnhXZCSui8JRp10A.gif" alt=""></p><h4 id="setTimeout-和-setInterval"><a href="#setTimeout-和-setInterval" class="headerlink" title="setTimeout() 和 setInterval()"></a>setTimeout() 和 setInterval()</h4><p>在 React 组件中使用 <code>setTimeout()</code> 或者 <code>setInterval()</code> 要十分小心。几乎总是有更好的选择，例如 ‘resize’ 和 ‘scroll’ 事件（注意：有关注意事项请参阅下一节）。</p><p>如果你需要使用 <code>setTimeout()</code> 和 <code>setInterval()</code>，你必须 <strong>遵守下面两条建议</strong></p><blockquote><p>不要设置过短的时间间隔。</p></blockquote><p>当心那些小于 100 ms 的定时器，他们很可能是没意义的。如果确实需要一个更短的时间，可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" target="_blank" rel="external">window.requestAnimationFrame()</a> 替代。</p><blockquote><p>保留对这些函数的引用，并且在 unmount 时取消或者销毁他们。</p></blockquote><p><code>setTimeout()</code> 和 <code>setInterval()</code> 都返回一个延迟函数的引用，并且需要的时候可以取消它们。由于这些函数是在全局作用域执行的，他们不在乎你的组件是否存在，这会导致报错甚至程序卡死。</p><p><strong>注意</strong>: 对 <code>window.requestAnimationFrame()</code> 来说也是如此</p><p>解决这个问题最简答的方法是使用 <a href="https://www.npmjs.com/package/react-timeout" target="_blank" rel="external">react-timeout</a> 这个 NPM 包，它提供了一个可以自动处理上述内容的高阶组件。它将 setTimeout/setInterval 等功能添加到包装组建的 <code>props</code> 上。(<strong>特别感谢 Vixlet 的开发人员 <a href="https://twitter.com/@carlpillot" target="_blank" rel="external"><em>Carl Pillot</em></a> 提供这个方法</strong>)</p><p>如果你不想引入这个依赖，并且希望自行解决此问题，你可以使用以下的方法：</p><script src="https://gist.github.com/jacob-beltran/910bd1d7ede863cd8178c0ecb40a075f.js"></script><p>如果你使用 requestAnimationFrame() 执行的一个动画循环，可以使用一个非常相似的解决方案，当前代码要有一点小的修改：</p><script src="https://gist.github.com/jacob-beltran/aa114af1b6fd5de866aa365e3763a90b.js"></script><h4 id="未-去抖-频繁触发的事件"><a href="#未-去抖-频繁触发的事件" class="headerlink" title="未 去抖 频繁触发的事件"></a>未 去抖 频繁触发的事件</h4><p>某些常见的事件可能会非常频繁的触发，例如 <code>scroll</code>，<code>resize</code>。去抖这些事件是明智的，特别是如果事件处理程序执行的不仅仅是基本功能。</p><p><code>Lodash</code> 有 <a href="https://lodash.com/docs/#debounce" target="_blank" rel="external">_.debounce</a> 方法。在 NPM 上还有一个独立的 <a href="https://www.npmjs.com/package/debounce" target="_blank" rel="external">debounce</a> 包.</p><blockquote><p>“但是我真的需要立即反馈 scroll/resize 或者别的事件”</p></blockquote><p>我发现一种可以处理这些事件并且以高性能的方式进行响应的方法，那就是在第一次事件触发时启动 <code>requestAnimationFrame()</code> 循环。然后可以使用 <code>[debounce()](https://lodash.com/docs#debounce)</code> 方法并且将 <code>trailing</code> 这个配置项设为 <code>true</code>（<strong>这意味着该功能只在频繁触发的事件流结束后触发</strong>）来取消对值的监听，看看下面这个例子。</p><script src="https://gist.github.com/jacob-beltran/84bd0aea2c1023743dda09172d30bc16.js"></script><h4 id="密集CPU任务线程阻塞"><a href="#密集CPU任务线程阻塞" class="headerlink" title="密集CPU任务线程阻塞"></a>密集CPU任务线程阻塞</h4><p>某些任务一直是 CPU 密集型的，因此可能会导致主渲染线程的阻塞。举几个例子，比如非常复杂的数学计算，迭代非常大的数组，使用 <code>File</code> api 进行文件读写，利用 <code>&lt;canvas&gt;</code> 对图片进行编码解码。</p><p>在这些情况下，如果有可能最好使用 <code>Web Worker</code> 将这些功能移到另一个线程上，这样我们的主渲染线程可以保持顺滑。</p><p><strong>相关阅读</strong></p><p>MDN 文章: <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="external">Using Web Workers</a></p><p>MDN 文档: <a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker" target="_blank" rel="external">Worker API</a></p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>我们希望上述建议对您能有所帮助。如果没有 Vixlet 团队的伟大工作和研究，上述的提示和编程技巧是不可能产出的。他们真的是我曾经合作过的最棒的团队之一。</p><p>在你的 React 的征途中保持学习和练习，愿原力与你同在！</p><blockquote><p>原文地址：<a href="https://blog.vixlet.com/react-at-light-speed-78cd172a6411" target="_blank" rel="external">React at Light Speed</a> <a href="https://blog.vixlet.com/@jacob_beltran" target="_blank" rel="external">@Jacob Beltran</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;光速-React&quot;&gt;&lt;a href=&quot;#光速-React&quot; class=&quot;headerlink&quot; title=&quot;光速 React&quot;&gt;&lt;/a&gt;光速 React&lt;/h1&gt;&lt;h2 id=&quot;Vixlet-团队优化性能的经验教训&quot;&gt;&lt;a href=&quot;#Vixlet-团队优化性能的经验教训&quot; class=&quot;headerlink&quot; title=&quot;Vixlet 团队优化性能的经验教训&quot;&gt;&lt;/a&gt;Vixlet 团队优化性能的经验教训&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1000/1*SJzLm3SW2IegLw0GzlaG-w.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;在过去一年多，我们 &lt;a href=&quot;http://www.vixlet.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Vixlet&lt;/a&gt; 的 web 团队已经着手于一个激动人心的项目：将我们的整个 web 应用迁移到 &lt;code&gt;React&lt;/code&gt; + &lt;code&gt;Redux&lt;/code&gt; 架构。对于整个团队来说，这是不断成长中的机会，在整个过程中，我们在这方面面临一些挑战。&lt;/p&gt;&lt;p&gt;因为我们的 web-app 可能有非常大的 feed 视图，包括成百上千的媒体、文本、视频、链接元素，我们花了相当多的时间寻找能充分利用 &lt;code&gt;React&lt;/code&gt; 性能的方法。在这里，我们将分享我们这一路学到的一些经验教训。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;声明&lt;/strong&gt;：&lt;strong&gt;下面讲的做法和方法更适用于我们具体应用的性能需求。然而，像所有的开发者建议的那样，最重要的是要考虑到你的应用程序和团队的实际需求。React 是一个开箱即用的框架，所以你可能不需要像我们一样细致地优化性能。话虽如此，我们还是希望你能在这篇文章里找到一些有用的信息。&lt;/strong&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="react" scheme="http://robin-front.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>npx是什么，为什么需要npx?</title>
    <link href="http://robin-front.github.io/2017/07/14/introducing-npx-an-npm-package-runner/"/>
    <id>http://robin-front.github.io/2017/07/14/introducing-npx-an-npm-package-runner/</id>
    <published>2017-07-14T09:31:57.000Z</published>
    <updated>2017-07-14T09:31:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍npx：一个npm包运行"><a href="#介绍npx：一个npm包运行" class="headerlink" title="介绍npx：一个npm包运行"></a>介绍npx：一个npm包运行</h1><p>NPM升级到最新版本，<a href="https://github.com/npm/npm/releases/tag/v5.2.0" target="_blank" rel="external">npm@5.2.0</a>，你可能会发现，它会安装一个新的二进制包跟着 <code>npm</code>：<a href="https://npm.im/npx" target="_blank" rel="external">npx</a>。</p><p><code>npx</code> 是一个工具，旨在帮助整理从npm注册软件包的体验 - 和 使得npm非常容易地安装和管理托管在注册表上的依赖关系是 同样的方式，<code>npx</code>使 npm 很方便使用CLI工具和其他被托管的可执行文件。它大大简化了一些事情，到目前为止，需要一些与普通的npm有关的步骤：</p><a id="more"></a><h1 id="使用本地化的安装工具而不用-npm-run-script"><a href="#使用本地化的安装工具而不用-npm-run-script" class="headerlink" title="使用本地化的安装工具而不用 npm run-script"></a>使用本地化的安装工具而不用 npm run-script</h1><p><img src="https://cdn-images-1.medium.com/max/800/1*A4HJT1FHQA_1_z3aMBc5mg.gif" alt="https://cdn-images-1.medium.com/max/800/1*A4HJT1FHQA_1_z3aMBc5mg.gif"></p><center><small>将cowsay作为本地devDependency进行安装，并以“$ npx cowsay”运行</small></center><p>在过去几年中，npm生态系统越来越多地将安装工具作为项目本地化<code>devDependencies</code>，而不是要求用户在全局安装。这意味着，像工具<code>mocha</code>，<code>grunt</code>和<code>bower</code>，曾经被要求安装在系统的全局目录上，现在可以在每个项目的基础上管理自己的版本。这也意味着，所有你需要做的就是基于NPM的项目运行起来，以确保您有<code>node + NPM</code>您的系统上，克隆github项目，并运行<code>npm it</code>去运行<code>install</code>和<code>test</code>。由于<code>npm run-script</code>添加本地二进制文件到路径，这个工作很好！</p><p>不利之处在于，它不会快速/方便地以交互方式调用本地二进制文件。有几种方法可以做到这一点，他们都对他们有一些烦恼：你可以添加这些工具到你<code>scripts</code>，但是你需要记住通过使用传递参数<code>--</code>，你可以通过<code>shell</code>技巧<code>alias npmx=PATH=$(npm bin):$PATH</code> 做到，或者你可以手动路径他们，使用 <code>./node_modules/.bin/mocha</code>。这些都是工作，但没有一个是非常理想的。</p><p><code>npx</code>给你我认为是最好的解决方案：您需要做的是使用<code>$ npx mocha</code>进行本地安装。如果你再进行一个额外的步骤并<a href="https://www.npmjs.com/package/npx#shell-auto-fallback" target="_blank" rel="external">配置shell自动回退</a>（更多内容在下面会提到），那么在一个项目目录中运行<code>$ mocha</code>将会成为你的技巧！</p><p>作为彩蛋，如果调用已经安装的二进制文件，<a href="https://twitter.com/maybekatz/status/877444832494596096" target="_blank" rel="external">npx基本上没有开销</a> - 这足以将该工具的代码直接加载到当前运行的node进程中！这种事情就像读取文件一样快，并且使它成为一个完全可以接受的脚本编写工具。</p><h1 id="执行一次性命令"><a href="#执行一次性命令" class="headerlink" title="执行一次性命令"></a>执行一次性命令</h1><p><img src="https://cdn-images-1.medium.com/max/800/1*OlIRsvVO5aK7ja9HmwXz_Q.gif" alt="https://cdn-images-1.medium.com/max/800/1*OlIRsvVO5aK7ja9HmwXz_Q.gif"></p><center><small><code>$ npx create-react-app my-cool-new-app</code>安装一个临时的创建应答程序并调用它，而不会污染全局安装或需要多个步骤！</small></center><p>你有没有遇到过 想要尝试一些CLI工具的情况，但是要安装一个全局只是为了运行一次，这很烦人？<code>npx</code>对这种情况也是很有用。调用的<code>npx &lt;command&gt;</code>当<code>&lt;command&gt;</code>不在你的<code>$PATH</code>意愿列表中，会自动从你的npm注册表中安装一个包含该名称的包，然后调用它。完成后，安装的软件包将不会储存在全球范围内任何地方，所以您不用担心长期的污染。</p><p>此功能也适用于<code>generators</code>等。像<code>yeoman</code>或<code>create-react-app</code>这样的工具只被调用一次。<strong>当你再次运行它们时，他们已经过时了，所以你最终不得不在每次想要使用它们时再次安装更新</strong>。</p><p>作为一种工具的维护者，我很喜欢这个功能，因为这意味着我可以把<code>$ npx my-tool</code>写进<code>README.md</code>的指令，而不是试图让人们在实际安装它的障碍。坦白说，说“哦，只需复制粘贴这一个命令，这是零成本的”更贴切，对于不确定是否使用这个工具的用户来说。</p><p>这里，你可能想用尝试一些其他有趣的包<code>npx</code>：<a href="https://npm.im/happy-birthday" target="_blank" rel="external">happy-birthday</a>，<a href="https://npm.im/benny-hill" target="_blank" rel="external">benny-hill</a>，<a href="https://npm.im/workin-hard" target="_blank" rel="external">workin-hard</a>，<a href="https://npm.im/cowsay" target="_blank" rel="external">cowsay</a>，<a href="https://npm.im/yo" target="_blank" rel="external">yo</a>，<a href="https://npm.im/create-react-app" target="_blank" rel="external">create-react-app</a>，<a href="https://npm.im/npm-check" target="_blank" rel="external">npm-check</a>。甚至有一个完整的<a href="https://github.com/js-n/awesome-npx" target="_blank" rel="external">awesome-npx</a><a href="https://github.com/js-n/awesome-npx" target="_blank" rel="external">入门</a>项目！来吧！获取一个<a href="https://twitter.com/maybekatz/status/878926190064668672" target="_blank" rel="external">足够小的完整的本地REST服务器运行的命令</a>以适应一个推文。</p><h1 id="使用不同Node-js版本运行命令"><a href="#使用不同Node-js版本运行命令" class="headerlink" title="使用不同Node.js版本运行命令"></a>使用不同Node.js版本运行命令</h1><p><img src="https://cdn-images-1.medium.com/max/800/1*cfjXl2hTKW7czetTfNGYbA.png" alt="https://cdn-images-1.medium.com/max/800/1*cfjXl2hTKW7czetTfNGYbA.png"></p><center><small><code>npx -p node-bin @ &lt;version&gt; node -v</code>可用于执行节点版本的一次性运行。</small></center><p>事实证明，在npm注册表中有一个很酷的包叫 <code>node-bin</code>。这意味着你可以使用不同的<code>node</code>版本，而不必使用node版本管理器,像<code>nvm</code>，<code>nave</code>或<code>n</code>。所有你需要的只是安装<code>npm@5.2.0</code>！</p><p><code>-pnpx</code> 选项允许您指定要安装并添加到正在运行的软件包<code>$PATH</code>，这意味着您可以进行有趣的操作，例如：<code>$ npx -p node-bin@6 npm it</code>安装并测试当前的npm软件包，就像在<code>node@6</code>全局运行一样。我一直使用这个 - 我甚至最近不得不在一个项目中经常使用它，由于我的一个测试库在<code>node@8</code>环境下无法运行。这是一个真正的救世主，我发现使用这种类型的用例比版本管理器更容易，我总是以某种方式找到<code>break</code>或错误配置的方法。</p><p>注意：<code>node-bin</code>仅适用于<code>* nix</code>平台。这是<a href="https://medium.com/@aredridel" target="_blank" rel="external">Aria Stewart</a>的出色工作。在将来，同样的软件包将可以简单地使用<code>node</code>，所以您可以<code>$ npx node@6 ...</code>直接执行，包括在Windows上。</p><h1 id="与-npm-run-script-互动发展"><a href="#与-npm-run-script-互动发展" class="headerlink" title="与 npm run-script 互动发展"></a>与 npm run-script 互动发展</h1><p><img src="https://cdn-images-1.medium.com/max/800/1*JqCC1irC-XxXAWiThpOUiw.gif" alt="https://cdn-images-1.medium.com/max/800/1*JqCC1irC-XxXAWiThpOUiw.gif"></p><center><small><code>$ npx -p cowsay -p lolcatjs -c&#39;echo“$ npm_package_name @ $ npm_package_version”| cowsay | lolcatjs&#39;s</code>将安装cowsay和lolcatjs，并使脚本从运行脚本访问一堆“$ npm_”变量。</small></center><p>很多<code>npm</code>的用户现在可以利用这个非常酷的<code>run-script</code>功能。他们不仅让您的<code>$PATH</code>本地二进制文件可访问，而且还添加了一大堆环境变量，您可以在这些脚本中访问。你可以看到这些额外的变量是什么<code>$ npm run env | grep npm_</code>。</p><p>这可以使开发和测试运行脚本变得棘手 - 这意味着即使使用诸如此类的技巧<code>$(npm bin)/some-bin</code>，在交互式工作的同时仍然无法访问这些神奇的<code>env var</code>。</p><p>可是等等！<code>npx</code>还有一个技巧：当你使用这个<code>-c</code>选项时，写入<code>string</code>参数内的脚本将能够像普通的运行脚本一样完全访问相同的<code>env</code>变量！您甚至可以使用管道和多个命令进行单次<code>npx</code>调用！</p><h1 id="与朋友以及你想要的任何人分享基于gist的脚本！"><a href="#与朋友以及你想要的任何人分享基于gist的脚本！" class="headerlink" title="与朋友以及你想要的任何人分享基于gist的脚本！"></a>与朋友以及你想要的任何人分享基于gist的脚本！</h1><p><img src="https://cdn-images-1.medium.com/max/800/1*Hdk5w080acQjABK3CQWh4Q.gif" alt="https://cdn-images-1.medium.com/max/800/1*Hdk5w080acQjABK3CQWh4Q.gif"></p><p>使用<code>gist.github.com</code>分享各种实用程序脚本变得很常见，而不是设置整个<code>git repos</code>，发布新工具等。</p><p>使用<code>npx</code>，您可以进一步：因为<code>npx</code>接受<code>npm</code>本身所做的任何说明符，您可以创建一个人们可以直接使用单个命令调用的要点！</p><p>尝试使用<a href="https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32" target="_blank" rel="external">https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32</a>！</p><blockquote><p>注意：保持安全！在执行这些时，始终确保通过 <code>gists</code> 网站读取和执行代码，就像运行 <code>.sh</code> 脚本时一样谨慎！</p></blockquote><h1 id="彩蛋：shell自动回退"><a href="#彩蛋：shell自动回退" class="headerlink" title="彩蛋：shell自动回退"></a>彩蛋：shell自动回退</h1><p><img src="https://cdn-images-1.medium.com/max/600/1*MXY3EyWrnjdrv6gjDLgznw.png" alt="https://cdn-images-1.medium.com/max/600/1*MXY3EyWrnjdrv6gjDLgznw.png"></p><center><small>将.zshrc中的npx自动回退意味着你可以在没有引用npx的情况下执行<code>$ ember-cli @ latest ...</code></small></center><p><code>FélixSaparelli</code>补充说，这个令人敬畏的功能意味着对于许多这些用例，您甚至不需要直接调用<code>npx</code>！常规的<code>npx</code>使用和回退之间的主要区别是，回退不会安装新软件包，除非您使用<code>pkg@version</code>语法：安全网来防止潜在的危险排序。</p><p>设置自动回退是很简单的：在<code>npx</code>文档中查看用于当前<code>shell</code>的命令，将其添加到 <code>.bashrc</code> / <code>.zshrc</code> / <code>.fishrc</code>，然后重新启动<code>shell</code>（或使用<code>source</code>或其他机制来刷新<code>shell</code>）。</p><p>现在，您可以做一些<code>$ standard@8 --version</code>尝试不同版本的东西，如果您在一个<code>npm</code>项目中，<code>$ mocha</code>则会自动回到本地安装的<code>mocha</code>版本，前提是它尚未在全局安装。</p><h1 id="现在就试试吧"><a href="#现在就试试吧" class="headerlink" title="现在就试试吧"></a>现在就试试吧</h1><p>你现在可以通过安装<code>npm@5.2.0</code>或更新来获得<code>npx</code> ，或者如果你不想使用<code>npm</code>，你可以安装独立版本的<code>npx</code>！它与其他软件包管理器完全兼容，因为任何<code>npm</code>使用仅适用于内部操作。哦，它有10种不同的语言，感谢来自世界各地的一大批早期采用者的贡献，<code>--help</code>以及所有的系统消息翻译，并可以根据系统区域设置自动提供！还有一个<code>awesome-npx</code><a href="https://github.com/js-n/awesome-npx" target="_blank" rel="external">repo</a>与<code>npx</code>工作地很好的例子！</p><p>你有最喜欢的功能吗？你有没有使用过？如果你有一些很酷炫的事，我没有在这里列出，请在评论中分享！我很想听听别人的意见！</p><p>PS人们不断地问这个，所以我只是会弹出它在这里：在这些GIF文件，我使用<a href="https://www.npmjs.com/package/hyperterm-monokai" target="_blank" rel="external">monokai</a>主题的<a href="https://hyper.is/" target="_blank" rel="external">Hyper</a>运行 <code>oh-my-zsh</code>中的<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes#spaceship" target="_blank" rel="external">spaceship主题</a>，再加上<a href="https://github.com/tonsky/FiraCode" target="_blank" rel="external">FiraCode</a>字体。</p><p>【翻译原文】: <a href="https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b" target="_blank" rel="external">https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍npx：一个npm包运行&quot;&gt;&lt;a href=&quot;#介绍npx：一个npm包运行&quot; class=&quot;headerlink&quot; title=&quot;介绍npx：一个npm包运行&quot;&gt;&lt;/a&gt;介绍npx：一个npm包运行&lt;/h1&gt;&lt;p&gt;NPM升级到最新版本，&lt;a href=&quot;https://github.com/npm/npm/releases/tag/v5.2.0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;npm@5.2.0&lt;/a&gt;，你可能会发现，它会安装一个新的二进制包跟着 &lt;code&gt;npm&lt;/code&gt;：&lt;a href=&quot;https://npm.im/npx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;npx&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;code&gt;npx&lt;/code&gt; 是一个工具，旨在帮助整理从npm注册软件包的体验 - 和 使得npm非常容易地安装和管理托管在注册表上的依赖关系是 同样的方式，&lt;code&gt;npx&lt;/code&gt;使 npm 很方便使用CLI工具和其他被托管的可执行文件。它大大简化了一些事情，到目前为止，需要一些与普通的npm有关的步骤：&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="npm" scheme="http://robin-front.github.io/tags/npm/"/>
    
      <category term="npx" scheme="http://robin-front.github.io/tags/npx/"/>
    
  </entry>
  
  <entry>
    <title>为什么我停止使用多个显示器</title>
    <link href="http://robin-front.github.io/2017/07/11/why-should-stopped-using-multiple-monitors/"/>
    <id>http://robin-front.github.io/2017/07/11/why-should-stopped-using-multiple-monitors/</id>
    <published>2017-07-11T08:02:47.000Z</published>
    <updated>2017-07-11T08:02:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>许多开发人员认为多个显示器可以提高生产力。研究证明是这样，对吧？那么，请记住，许多这些研究是由戴尔和NEC等监控制造商委托进行的。🤔</p><p>尽管多个显示器使您看起来像一个重度的计算机使用者，但我在几年前卖了我的多显示器，并切换到一个监视器。而且我并不是一个人。</p><p>下面就是为什么。<a id="more"></a></p><h1 id="专注"><a href="#专注" class="headerlink" title="专注"></a>专注</h1><p>人类一次只能关注一件事情。那么为什么我们花钱来同时显示多个东西呢？如果我的电子邮件或社交媒体资讯提供一目了然，我会经常检查。这不仅不是不必要的，反而是有效的。在一个无休止的分心的世界中，能够长期专注于单一任务是一项非常有价值的技能。</p><blockquote><p>深刻的工作在我们分心充实的经济中变得越来越困难，但也变得越来越重要和罕见。少数能够在深度工作上度过的日子将变得非常市场化和成功。</p><ul><li>Cal Newport在“ 深加工 ”</li></ul></blockquote><p>一个监视器意味着我的工作 - 只有我的工作 - 显示在前面和中央。分心停留在视线之外，所以眼不见，心不烦。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*gRNCnSRrV5JUxbMagFV0CA.jpeg" alt="这看起来像是专注一项任务吗"></p><center>这看起来像是专注一项任务吗</center><p>我们每天做的最有价值的工作之一就是要长期专注于一个单一的应用程序：<strong>阅读和写作</strong>。阅读和写作都受益于来自于屏幕上唯一的重点。一本带有移动微博的小本本在旁边将是一场灾难。但是很多人都愿意做这个。额外的显示经常导致潜在的持续分心。如果您的电子邮件，社交媒体等不可见，您更有可能继续工作。</p><p>作为开发人员，我每天都在编写代码。所以我经常阅读文档。但是我很少需要在读文档的 <strong>同时</strong> 编写代码。我读完相关的文档，然后再编码。我的工作流是模态的。</p><h1 id="减少窗口管理"><a href="#减少窗口管理" class="headerlink" title="减少窗口管理"></a>减少窗口管理</h1><p>我使用一个月的 34“LG超宽屏显示器，起初，我喜欢它。</p><p>不过，过了几天，我很惊讶地发现我出了个馊主意。我的桌面最大化，太宽了，所以我发现自己花了太多的时间摆弄桌面。“今天应该放在左边呢？”“现在有什么重要的事情呢？”</p><p>当然，屏幕足够宽，可以并排显示多个窗口，但是它非常宽，边缘感到不舒服。所以，我发现自己不断把我的工作转移到屏幕的中心，从而违背了买一个巨大的显示器的整个目的！Jeff Atwood很久以前在“<a href="https://blog.codinghorror.com/the-large-display-paradox/" target="_blank" rel="external">大型显示悖论</a>”中讨论了这个问题。他的解决方案，使用软件移动和调整大小的窗口更容易。我的解决方案，<strong>只需使用一个合理尺寸的显示器</strong>。</p><p>即使使用方便的窗口管理软件，多个显示器也会出现问题：如果我有两个显示器，内容不会直接在我的前面。我必须向右或向左转动我的头（特别烦在跑步机上行走的人，就像我经常看到的那样）。我可以把一个监视器直接放在我面前，但是第二个监视器甚至更远一些，这使得它显然是一个二等公民。这再次导致我从正在工作的中间屏幕移动。</p><p>正如巴里·施瓦茨（Barry Schwartz）在“<a href="https://www.amazon.com/Paradox-Choice-Why-More-Less/dp/0060005696" target="_blank" rel="external">选择的悖论</a>”中所探讨的那样，决策疲劳是一个真正的问题。有时候，少即是多。</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fembed.ted.com%2Ftalks%2Fbarry_schwartz_on_the_paradox_of_choice&amp;url=https%3A%2F%2Fwww.ted.com%2Ftalks%2Fbarry_schwartz_on_the_paradox_of_choice&amp;image=https%3A%2F%2Fpe.tedcdn.com%2Fimages%2Fted%2F8bdfbadbf8c620bfe3c5209c223a0f7b4316092a_240x180.jpg%3Flang%3Den&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=ted" allowfullscreen frameborder="0" scrolling="no"></iframe><blockquote><p>“选择使我们不是更自由，更瘫痪，不快乐，但更不满意。”</p></blockquote><p>只通过一个屏幕，我决定。我不会浪费时间决定在哪里拖曳窗口或摆放在给定窗口的位置。我最大化我正在使用的应用程序，以阻止所有其他分心…在上班的时候。</p><h1 id="虚拟桌面为赢"><a href="#虚拟桌面为赢" class="headerlink" title="虚拟桌面为赢"></a>虚拟桌面为赢</h1><p>Mac和Windows现在都支持虚拟桌面。在我的Mac上，我可以通过3个手指快速切换多个虚拟桌面。这需要不到一秒钟的时间，它不需要我转过头来重新聚焦我的眼睛在不同的地方的内容。我也不用浪费时间安排。最左边的虚拟桌面总是我的浏览器，右边是我的编辑器。<strong>所以我将虚拟桌面视为可靠呈现相同内容的物理屏幕</strong>。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*BLoFtdzKsyuBaysiMNMaBA.png" alt="顶部的三个框架表示三个虚拟桌面。三手指滑动可立即在它们之间切换 - 无需再花时间旋转我的头，看一个单独的显示器。"></p><center>顶部的三个框架表示三个虚拟桌面。三手指滑动可立即在它们之间切换 - 无需再花时间旋转我的头，看一个单独的显示器。</center><h1 id="我用于完成工作的首选监视器"><a href="#我用于完成工作的首选监视器" class="headerlink" title="我用于完成工作的首选监视器"></a>我用于完成工作的首选监视器</h1><p>我更喜欢使用一个24“4K，为什么24”？因为如果你想完成实际的工作，更大的不一定更好。24“足够大，可以全屏显示单个应用程序，它足够大，可以在罕见的情况下并排显示两个应用程序，我真的需要同时看到两件事情（我在Mac上使用BetterTouchTool，只需击中Win +箭头在Windows），但是24“足够小，您可以最大限度地利用所有应用程序，而无需移动您的头部或眼睛很多看到屏幕边缘。记住，最大化所有的事情。最大化=集中。</p><p>为什么是4K？高DPI降低疲劳。文字更加清晰。价格也慢慢合理了，所以如果你还没有高DPI显示器，买一个。而24“4K每4K英寸的点数要大于4K屏幕，所以它更加清晰。过去几年内建成的任何MacBook Pro都可以在DisplayPort上以60hz的速度推出4K显示器，许多最近的Windows笔记本电脑也可以这样做。</p><p>那么为什么这么多工作者需要多台显示器呢？我相信这是极端不合逻辑的诱惑。</p><blockquote><p>太多的东西变得相反。 - 蒂姆·弗里斯</p></blockquote><p>显示器太多会变得分心。所以说到监视器，我拥抱这些想法：</p><ul><li>少即是多</li><li>质量而不是数量</li><li>定力，定力，定力（Location, Location, Location）</li></ul><p>【翻译原文】:（有删减） <a href="https://hackernoon.com/why-i-stopped-using-multiple-monitors-bfd87efa2e5b" target="_blank" rel="external">https://hackernoon.com/why-i-stopped-using-multiple-monitors-bfd87efa2e5b</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;许多开发人员认为多个显示器可以提高生产力。研究证明是这样，对吧？那么，请记住，许多这些研究是由戴尔和NEC等监控制造商委托进行的。🤔&lt;/p&gt;&lt;p&gt;尽管多个显示器使您看起来像一个重度的计算机使用者，但我在几年前卖了我的多显示器，并切换到一个监视器。而且我并不是一个人。&lt;/p&gt;&lt;p&gt;下面就是为什么。
    
    </summary>
    
      <category term="workflow" scheme="http://robin-front.github.io/categories/workflow/"/>
    
    
      <category term="performance" scheme="http://robin-front.github.io/tags/performance/"/>
    
  </entry>
  
  <entry>
    <title>不要混用 import 和 require</title>
    <link href="http://robin-front.github.io/2017/07/10/dont-mixin-import-and-require/"/>
    <id>http://robin-front.github.io/2017/07/10/dont-mixin-import-and-require/</id>
    <published>2017-07-10T08:30:11.000Z</published>
    <updated>2017-07-10T08:30:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>import 是 ES6 规范语法之一。而 require 属于CommonJS规范的一部分。</p><p>目前来说，使用现代浏览器还无法支持 import，一般都会搭配 babel 使用，而 babel 会把 import 转换成 CommonJS 的 require.</p><p>但是，我们不能混用 import 和 require。有时候会看下如下代码：<a id="more"></a></p><p><img src="https://pbs.twimg.com/media/DESmTTXUMAAJcIW.jpg:large" alt="https://pbs.twimg.com/media/DESmTTXUMAAJcIW.jpg:large"></p><p>但实际执行顺序并不是你想象或看到的那样。import 具有声明提升效果，会首先执行。所以最好 <strong>不要混用</strong>。 import 是 ES6 标准，如果可能，首先使用 import, 如果不行，就用 require。</p><h2 id="ES6-import"><a href="#ES6-import" class="headerlink" title="ES6 import"></a>ES6 import</h2><ul><li>具有声明提升效果</li><li>您可以使用命名导入来选择性地加载所需的部分。这样可以节省内存， 如：<code>import { render } from react</code></li><li>导入可以是异步的</li><li>ES6 标准</li></ul><h2 id="require"><a href="#require" class="headerlink" title="require"></a>require</h2><ul><li>您可以在加载的模块名称不是预定义/静态的情况下进行动态加载，或者只有在真正需要的情况下才有条件地加载模块（取决于某些代码流）</li><li>CommonJS 规范加载是同步的。这意味着如果你有多个require，它们将逐个加载和处理（AMD规范是可以异步的）</li><li>只是约定的规范</li></ul><p>参考：<a href="https://twitter.com/dan_abramov/status/883375646357041152" target="_blank" rel="external">https://twitter.com/dan_abramov/status/883375646357041152</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;import 是 ES6 规范语法之一。而 require 属于CommonJS规范的一部分。&lt;/p&gt;&lt;p&gt;目前来说，使用现代浏览器还无法支持 import，一般都会搭配 babel 使用，而 babel 会把 import 转换成 CommonJS 的 require.&lt;/p&gt;&lt;p&gt;但是，我们不能混用 import 和 require。有时候会看下如下代码：
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="import" scheme="http://robin-front.github.io/tags/import/"/>
    
      <category term="require" scheme="http://robin-front.github.io/tags/require/"/>
    
  </entry>
  
  <entry>
    <title>react性能优化：提取子组件中额外的事件绑定</title>
    <link href="http://robin-front.github.io/2017/07/06/react-pattern-extract-child-components-to-avoid-binding/"/>
    <id>http://robin-front.github.io/2017/07/06/react-pattern-extract-child-components-to-avoid-binding/</id>
    <published>2017-07-06T08:24:53.000Z</published>
    <updated>2017-07-06T08:24:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn-images-1.medium.com/max/800/1*zISOb74W7PriWKX0y7biKg.jpeg" alt=""></p><p>我们经常在快要完成一个<code>react</code>中型应用时，发现页面并没有想象中那么流畅。 react 理论性能是不错的，但是对开发者要求也很高，一些不易注意的点很容易造成性能问题。正所谓“烂泥扶不上墙”。</p><p>下面看看子组件的事件绑定写法对性能的影响。<a id="more"></a></p><p>这是React中的常见情况：您正在映射数组，您需要每个项目调用点击处理程序和一些相关数据。</p><p>这是一个例子。我正在迭代一个用户列表，并将<code>userId</code>传递给第29行的<code>deleteUser</code>函数。</p><script src="https://gist.github.com/coryhouse/01339ce21024cfd7f5cd4c64d1fd26c4.js"></script><p>这是<a href="https://codesandbox.io/" target="_blank" rel="external">Codeandbox</a>上的一个<a href="https://codesandbox.io/s/0OP2Yq87" target="_blank" rel="external">工作示例</a>。（真棒）</p><h1 id="所以-有什么问题？"><a href="#所以-有什么问题？" class="headerlink" title="所以, 有什么问题？"></a>所以, 有什么问题？</h1><p>我在点击处理程序中使用箭头函数。这意味着每次渲染运行时，都会分配一个新函数。在许多情况下，这不是一件多大的事。但是，如果您有子组件，即使数据没有更改，它们也将重新渲染，因为每个渲染分配一个新的函数。</p><p>底线：避免在渲染中声明箭头函数或绑定以获得最佳性能。我的团队使用这个<a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-no-bind.md" target="_blank" rel="external">ESLint规则</a>帮助提醒我们这个问题。</p><h1 id="解决方案是什么？"><a href="#解决方案是什么？" class="headerlink" title="解决方案是什么？"></a>解决方案是什么？</h1><p>那么你如何在渲染中避免绑定和箭头函数呢？一个选项是提取一个子组件。在这里，我将列表项提取到<code>UserListItem.js</code>：</p><script src="https://gist.github.com/coryhouse/a002111d01fb7ee1862af55d4a26abfa.js"></script><p>然后，父组件的渲染变得更简单，不再需要包含箭头函数。它只是通过<code>props</code>传递每个列表项的相关上下文：</p><script src="https://gist.github.com/coryhouse/f5758f5355da5280fc0e3350453fef31.js"></script><p>这是一个<a href="https://codesandbox.io/s/Q1Jo3zB79" target="_blank" rel="external">重构的工作实例</a>。</p><h1 id="Yay-or-Yuck"><a href="#Yay-or-Yuck" class="headerlink" title="Yay or Yuck?"></a>Yay or Yuck?</h1><p>此模式通过消除冗余的函数分配来提高性能。所以当这种情况适用于您的组件时，它是最有用的：</p><ul><li>渲染频繁被调用</li><li>渲染子组件非常耗时</li></ul><p>诚然，我提取子组件也是我提到的一个额外的工作。它需要更多的移动部件和更多的代码。所以如果你没有出现性能问题，可以说这是一个过早的优化。</p><p>所以你有两个选择：允许箭头和绑定到任何地方（如果有性能问题再处理），或禁止他们获得最佳性能和一致性。</p><p>底线：我建议禁止箭头函数并在<code>render</code>中绑定。下面就是为什么：</p><ul><li>你必须禁用我上面建议的有用的<a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-no-bind.md" target="_blank" rel="external">ESLint规则</a>来允许它。</li><li>禁用linting规则后，人们可能会复制此模式，并开始禁用其他linting规则。一个处例外可以很快成为规范…</li></ul><p></p><blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">General rule for code reviews:<br><br>Each line of code should be worthy of copying.<br><br>Because people will.<a href="https://twitter.com/hashtag/cleancode?src=hash" target="_blank" rel="external">#cleancode</a></p>&mdash; Cory House 🏠 (@housecor) <a href="https://twitter.com/housecor/status/839511073279598594" target="_blank" rel="external">March 8, 2017</a></blockquote><p></p><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script><p>所以我发现提取子组件是一个有用的模式，以避免在渲染中绑定。</p><h1 id="其他的反例"><a href="#其他的反例" class="headerlink" title="其他的反例"></a>其他的反例</h1><p>还有些人会想要这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">deleteUser = id=<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line"> <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> &#123;</div><div class="line"> <span class="keyword">return</span> &#123; <span class="attr">users</span>: prevState.users.filter( <span class="function"><span class="params">user</span> =&gt;</span> user.id !== id)&#125;</div><div class="line"> &#125;)</div><div class="line">&#125;</div><div class="line"><span class="comment">// …</span></div><div class="line">onClick=&#123;<span class="keyword">this</span>.deleteUser(user.id)&#125;</div></pre></td></tr></table></figure><p>他们认为传递参数会比其他方式更加方便。但这和第一个糟糕的例子并无太大区别，子组件同样会再次渲染。</p><p>如果有相当多类似的输入框，像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;form&gt;</div><div class="line">Render = <span class="function"><span class="params">()</span> =&gt;</span></div><div class="line">Input1 value=<span class="keyword">this</span>.state.input1 onChange= update state <span class="keyword">for</span> field1</div><div class="line">Input2….</div><div class="line">Input3….</div></pre></td></tr></table></figure><p><a href="https://facebook.github.io/react/docs/forms.html#handling-multiple-inputs" target="_blank" rel="external">官方给出的方法</a>是给每个 input 添加 name 属性，进而获取参数。</p><p>当然也有人会想要在 html 上动文章，比如添加自定义属性 <code>data-id=${userId}</code>。这当然也能实现，但是 html不应该是数据源，这应该避免。</p><p>【翻译原文】:(有改动)<a href="https://medium.freecodecamp.org/react-pattern-extract-child-components-to-avoid-binding-e3ad8310725e" target="_blank" rel="external">https://medium.freecodecamp.org/react-pattern-extract-child-components-to-avoid-binding-e3ad8310725e</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*zISOb74W7PriWKX0y7biKg.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;我们经常在快要完成一个&lt;code&gt;react&lt;/code&gt;中型应用时，发现页面并没有想象中那么流畅。 react 理论性能是不错的，但是对开发者要求也很高，一些不易注意的点很容易造成性能问题。正所谓“烂泥扶不上墙”。&lt;/p&gt;&lt;p&gt;下面看看子组件的事件绑定写法对性能的影响。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="react" scheme="http://robin-front.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>如何使用Memoize来缓存JavaScript函数结果并加快代码的速度</title>
    <link href="http://robin-front.github.io/2017/07/04/understanding-memoize-in-javascript/"/>
    <id>http://robin-front.github.io/2017/07/04/understanding-memoize-in-javascript/</id>
    <published>2017-07-04T09:57:51.000Z</published>
    <updated>2017-07-04T09:57:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Function</code> 是编程的组成部分。它们有助于为我们的代码增加模块化和可重用性。</p><p>将程序划分为大块是很常见的功能，我们稍后可以使用这些功能来执行一些有用的操作。</p><p>有时，多次调用功能可能会变得昂贵（比如，计算一个数字的阶乘的函数）。但是有一种方法可以优化这些功能，使它们执行得更快：<strong>缓存</strong>。<a id="more"></a></p><p>例如，假设我们<code>function</code>要返回一个数字的阶乘：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">    <span class="comment">// Calculations: n * (n-1) * (n-2) * ... (2) * (1)</span></div><div class="line">    <span class="keyword">return</span> factorial</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>非常好，现在我们来看看<code>factorial(50)</code>。计算机会执行计算，并返回给我们最后的答案，不错！</p><p>完成后，让我们来看看<code>factorial(51)</code>。计算机再次执行一些计算并获得结果，但是您可能已经注意到我们已经重复了可以避免的一些步骤。优化的方式是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">factorial(<span class="number">51</span>) = factorial(<span class="number">50</span>) * <span class="number">51</span>;</div></pre></td></tr></table></figure><p>但是我们<code>function</code>每次调用时都会从头开始执行计算：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">factorial(<span class="number">51</span>) = <span class="number">51</span> * <span class="number">50</span> * <span class="number">49</span> * ... * <span class="number">2</span> * <span class="number">1</span></div></pre></td></tr></table></figure><p>如果我们的函数<code>factorial</code>能记住它之前运算的结果并用它来提交运行效率，那不是很酷吗？</p><p>谈到<code>Memoization</code>，一种让我们的<code>function</code>记住（缓存）结果的方式。既然您对我们要实现的目标有一个基本的了解，这里是一个正式的定义：</p><blockquote><p><a href="https://en.wikipedia.org/wiki/Memoization" target="_blank" rel="external">Memoization</a>是一种优化技术，主要用于通过 <strong>存储昂贵的函数调用的结果</strong> 来加速计算机程序，并在相同的输入再次发生时返回缓存的结果.</p></blockquote><p>记住简单的东西意味着记忆或存储在内存中。记忆函数通常更快，因为如果随后使用先前的值调用该函数，我们将从缓存中获取结果来代替执行该函数，。</p><p>这看起来像一个简单的记忆函数（如果你想进行测试它，这里是一个<a href="https://codepen.io/divyanshu013/pen/xdQPvp?editors=0011" target="_blank" rel="external">CodePen</a>）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a simple function to add something</span></div><div class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">n</span>) =&gt;</span> (n + <span class="number">10</span>);</div><div class="line">add(<span class="number">9</span>);</div><div class="line"><span class="comment">// a simple memoized function to add something</span></div><div class="line"><span class="keyword">const</span> memoizedAdd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">let</span> cache = &#123;&#125;;</div><div class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (n <span class="keyword">in</span> cache) &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'Fetching from cache'</span>);</div><div class="line">      <span class="keyword">return</span> cache[n];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'Calculating result'</span>);</div><div class="line">      <span class="keyword">let</span> result = n + <span class="number">10</span>;</div><div class="line">      cache[n] = result;</div><div class="line">      <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// returned function from memoizedAdd</span></div><div class="line"><span class="keyword">const</span> newAdd = memoizedAdd();</div><div class="line"><span class="built_in">console</span>.log(newAdd(<span class="number">9</span>)); <span class="comment">// calculated</span></div><div class="line"><span class="built_in">console</span>.log(newAdd(<span class="number">9</span>)); <span class="comment">// cached</span></div></pre></td></tr></table></figure><h1 id="Memoization-要点"><a href="#Memoization-要点" class="headerlink" title="Memoization 要点"></a>Memoization 要点</h1><p>以上代码的一些要点是：</p><p><code>memoizedAdd</code>返回一个<code>function</code>以便稍后调用的。这是可能的，因为在JavaScript中，函数是一等公民，它们可以将它们用作<a href="http://eloquentjavascript.net/05_higher_order.html#h_xxCc98lOBK" target="_blank" rel="external">高阶的函数</a>并返回另一个函数。</p><p><code>cache</code>可以记住它的值，因为返回的函数被<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Closures" target="_blank" rel="external">闭包</a>封装了。</p><p><code>memoized</code>功能纯粹<a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976" target="_blank" rel="external">(Pure)</a>是至关重要的。纯函数将为特定输入返回相同的输出，而不需要调用多少次，这使得<code>cache</code>按预期的工作。</p><h1 id="编写自己的-memoize-功能"><a href="#编写自己的-memoize-功能" class="headerlink" title="编写自己的 memoize 功能"></a>编写自己的 memoize 功能</h1><p>以前的代码工作正常，但如果我们想将任何函数转换为记忆函数呢？</p><p>以下是如何编写自己的<code>memoize</code>函数（<a href="https://codepen.io/divyanshu013/pen/zwMPdK?editors=0011#code-area" target="_blank" rel="external">codepen</a>）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a simple pure function to get a value adding 10</span></div><div class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">n</span>) =&gt;</span> (n + <span class="number">10</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Simple call'</span>, add(<span class="number">3</span>));</div><div class="line"><span class="comment">// a simple memoize function that takes in a function</span></div><div class="line"><span class="comment">// and returns a memoized function</span></div><div class="line"><span class="keyword">const</span> memoize = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">let</span> cache = &#123;&#125;;</div><div class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> n = args[<span class="number">0</span>];  <span class="comment">// just taking one argument here</span></div><div class="line">    <span class="keyword">if</span> (n <span class="keyword">in</span> cache) &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'Fetching from cache'</span>);</div><div class="line">      <span class="keyword">return</span> cache[n];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'Calculating result'</span>);</div><div class="line">      <span class="keyword">let</span> result = fn(n);</div><div class="line">      cache[n] = result;</div><div class="line">      <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// creating a memoized function for the 'add' pure function</span></div><div class="line"><span class="keyword">const</span> memoizedAdd = memoize(add);</div><div class="line"><span class="built_in">console</span>.log(memoizedAdd(<span class="number">3</span>));  <span class="comment">// calculated</span></div><div class="line"><span class="built_in">console</span>.log(memoizedAdd(<span class="number">3</span>));  <span class="comment">// cached</span></div><div class="line"><span class="built_in">console</span>.log(memoizedAdd(<span class="number">4</span>));  <span class="comment">// calculated</span></div><div class="line"><span class="built_in">console</span>.log(memoizedAdd(<span class="number">4</span>));  <span class="comment">// cached</span></div></pre></td></tr></table></figure><p>这很棒！这个简单的<code>memoize</code>功能将任何简单的<code>function</code>封装成一个有记忆性的等价物。该代码适用于简单的功能，可以根据您的需要轻松调整处理任意数量的<code>arguments</code>代码。另一个选择是利用一些的类库，如：</p><p><a href="https://lodash.com/docs/4.17.4#memoize" target="_blank" rel="external">Lodash</a>的<code>_.memoize(func, [resolver])</code></p><p>来自<a href="https://github.com/developit/decko#memoize" target="_blank" rel="external">decko</a>的 ES7 <code>@memoize</code> <a href="https://babeljs.io/docs/plugins/transform-decorators/" target="_blank" rel="external">装饰器</a></p><h1 id="记忆递归函数"><a href="#记忆递归函数" class="headerlink" title="记忆递归函数"></a>记忆递归函数</h1><p>如果您尝试将递归函数传递到<code>memoize</code>上面的函数或Lodash的<code>_.memoize</code>函数，结果将不会如预期的那样，因为其后续调用的递归函数将最终调用自身而不是记忆函数，从而不再使用<code>cache</code>。</p><p>只需确保递归函数调用记忆函数。这里是你如何调整教科书<a href="https://en.wikipedia.org/wiki/Factorial" target="_blank" rel="external">阶乘</a>例子（<a href="https://codepen.io/divyanshu013/pen/JNevOm" target="_blank" rel="external">codepen</a>）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// same memoize function from before</span></div><div class="line"><span class="keyword">const</span> memoize = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">let</span> cache = &#123;&#125;;</div><div class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> n = args[<span class="number">0</span>];</div><div class="line">    <span class="keyword">if</span> (n <span class="keyword">in</span> cache) &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'Fetching from cache'</span>, n);</div><div class="line">      <span class="keyword">return</span> cache[n];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'Calculating result'</span>, n);</div><div class="line">      <span class="keyword">let</span> result = fn(n);</div><div class="line">      cache[n] = result;</div><div class="line">      <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> factorial = memoize(</div><div class="line">  <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (x === <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> x * factorial(x - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">);</div><div class="line"><span class="built_in">console</span>.log(factorial(<span class="number">5</span>)); <span class="comment">// calculated</span></div><div class="line"><span class="built_in">console</span>.log(factorial(<span class="number">6</span>)); <span class="comment">// calculated for 6 and cached for 5</span></div></pre></td></tr></table></figure><p>从这段代码注意几点：</p><p>该<code>factorial</code>函数递归地调用自己的记忆版本。</p><p>记忆功能是缓存先前阶乘的值，从而可以重复使用，从而显着改善了计算 <code>factorial(6) = 6 * factorial(5)</code></p><h1 id="memoization-是否与-caching-相同？"><a href="#memoization-是否与-caching-相同？" class="headerlink" title="memoization 是否与 caching 相同？"></a>memoization 是否与 caching 相同？</h1><p>是的，有点。<code>Memoization</code>实际上是一种特定类型的缓存。虽然缓存通常可以引用任何存储技术（如HTTP缓存）以供将来使用，但是<code>memoizing</code>特指调用缓存的<code>function</code>返回值。</p><h1 id="什么时候记录你的-functions"><a href="#什么时候记录你的-functions" class="headerlink" title="什么时候记录你的 functions"></a>什么时候记录你的 functions</h1><p>虽然可能看起来 <code>memoize</code> 可以与所有函数一起使用，但它实际上有限制的用例：</p><ul><li>为了记忆一个函数，它应该是纯粹的（pure），所以每次返回值对于相同的输入是相同的</li><li>记忆是增加的空间和增加的速度之间的权衡，因此对于具有有限的输入范围的功能而言是重要的，以便可以更频繁地使用缓存的值</li><li>它可能看起来像您记住您的API调用，但这并不是必需的，因为浏览器会为您自动缓存它们。有关详细信息，请参阅<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching" target="_blank" rel="external">HTTP缓存</a></li><li>我发现用于记忆功能的最佳用例是 <strong>重度计算功能</strong>，可以显着提高性能（阶乘和斐波那契不是真正现实世界的例子）</li><li>如果您进入React / Redux，您可以检查重新选择哪个使用记忆选择器，以确保仅在状态树的相关部分发生更改时进行计算。</li></ul><h1 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h1><p>如果您想更详细地了解本文中的一些主题，以下链接可能很有用：</p><ul><li>JavaScript中的<a href="http://eloquentjavascript.net/05_higher_order.html#h_xxCc98lOBK" target="_blank" rel="external">高阶函数</a></li><li>JavaScript<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Closures" target="_blank" rel="external">闭包</a></li><li><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976" target="_blank" rel="external">纯函数</a></li><li>Lodash的<code>_.memoize</code> <a href="https://lodash.com/docs/4.17.4#memoize" target="_blank" rel="external">文档</a>和<a href="https://github.com/lodash/lodash/blob/4.17.4/lodash.js#L10554-L10572" target="_blank" rel="external">源代码</a></li><li>更多的<code>memoization</code>例子在<a href="https://www.sitepoint.com/implementing-memoization-in-javascript/" target="_blank" rel="external">这里</a>和<a href="http://inlehmansterms.net/2015/03/01/javascript-memoization/" target="_blank" rel="external">这里</a></li><li><a href="https://github.com/reactjs/reselect" target="_blank" rel="external">reactjs/reSelect</a></li></ul><p>【翻译原文】: <a href="https://medium.freecodecamp.org/understanding-memoize-in-javascript-51d07d19430e" target="_blank" rel="external">https://medium.freecodecamp.org/understanding-memoize-in-javascript-51d07d19430e</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Function&lt;/code&gt; 是编程的组成部分。它们有助于为我们的代码增加模块化和可重用性。&lt;/p&gt;&lt;p&gt;将程序划分为大块是很常见的功能，我们稍后可以使用这些功能来执行一些有用的操作。&lt;/p&gt;&lt;p&gt;有时，多次调用功能可能会变得昂贵（比如，计算一个数字的阶乘的函数）。但是有一种方法可以优化这些功能，使它们执行得更快：&lt;strong&gt;缓存&lt;/strong&gt;。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="Memoize" scheme="http://robin-front.github.io/tags/Memoize/"/>
    
  </entry>
  
  <entry>
    <title>css3中background-position的四值语法</title>
    <link href="http://robin-front.github.io/2017/07/04/background-position-of-css3-about-four-value-syntax/"/>
    <id>http://robin-front.github.io/2017/07/04/background-position-of-css3-about-four-value-syntax/</id>
    <published>2017-07-04T03:27:55.000Z</published>
    <updated>2017-07-04T03:27:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>刨根问底，每个css属性都要知道它的所有值实在不容易。今天看看 <code>background-position</code>.</p><p>background-positionCSS中的属性允许您在其容器内移动背景图像（或渐变）。<a id="more"></a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">html</span> &#123;</div><div class="line">  <span class="attribute">background-position</span>: <span class="number">100px</span> <span class="number">5px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>它有三种不同的取值：</p><ul><li>长度值（例如<code>100px 5px</code>）</li><li>百分比（例如<code>100% 5%</code>）</li><li>关键字（例如<code>top right</code>）</li></ul><p>默认值为<code>0 0</code>。这会将您的背景图像放在容器的左上角。</p><p>长度值很简单：第一个值是水平位置，第二个值是垂直位置。因此，<code>100px 5px</code>将图像向右移动100像素，向下移动五个像素。您可以设定长度值单位为<code>px</code>，<code>em</code>或<a href="http://www.w3.org/Style/Examples/007/units.en.html" target="_blank" rel="external">任何其他的CSS长度值</a>。</p><p>百分比有所不同。戴上你的数学帽子：用<code>x％</code>移动背景图像意味着 <strong>将图像中的<code>X％</code>点</strong> 与 <strong>容器中的<code>X％</code>点</strong> 对齐(PS：很多人解释的时候只会说向左向下移动了x%,这就无法解释50%)。例如，<code>50%</code>意味着它会将图像的中间与容器的中间对齐。<code>100%</code>意味着它会将图像的最后一个像素与容器的最后一个像素对齐，依此类推。</p><p>关键字只是百分比的捷径。这<code>top right</code>比记住和写作要容易得多<code>0 100%</code>，这就是关键字的意义。以下是所有五个关键字及其等价取值的列表：</p><ul><li><code>top</code>：垂直0％</li><li><code>right</code>：水平100％</li><li><code>bottom</code>：垂直100％</li><li><code>left</code>：水平0％</li><li><code>center</code>：如果水平尚未定义，则水平为50％。如果定义了则应用到垂直。</li></ul><p>有趣的是，您关键字使用的顺序并不重要：与之<code>top center</code>相同<code>center top</code>。只有当您使用单一关键字时，您才能做到这一点。<code>center 10%</code>是不一样的<code>10% center</code>。</p><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><p>此演示演示了<code>background-position</code>具有长度单位，百分比和关键字取值的集合示例。</p><iframe height="265" scrolling="no" title="background-position values" src="//codepen.io/team/css-tricks/embed/ogqrGw/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/team/css-tricks/pen/ogqrGw/" target="_blank" rel="external">background-position values</a> by CSS-Tricks (<a href="https://codepen.io/css-tricks" target="_blank" rel="external">@css-tricks</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><h1 id="声明值-Declaring-Values"><a href="#声明值-Declaring-Values" class="headerlink" title="声明值(Declaring Values)"></a>声明值(Declaring Values)</h1><p><code>background-position</code>现代浏览器中最多可以放置四个值（有关详细信息，请参阅<a href="#browser-support">浏览器支持列表</a>）。</p><p>如果您只声明 <strong>一个值</strong>，则该值是水平偏移量。浏览器将垂直偏移设置为<code>center</code>。</p><p>当您声明 <strong>两个值</strong> 时，第一个值是水平偏移量，第二个值是垂直偏移量。</p><p>当您开始使用三个或四个值时，事情会变得更加棘手，但您也可以更好地控制您的背景位置。</p><p>三或四值语法在关键字和长度或百分比单位之间进行交替。您可以在<code>background-position</code>的三值或四值中使用任何关键字值， <em>除</em> <code>center</code>之外。</p><p>当您指定 <strong>三个值</strong> 时，浏览器将“丢失”第四个值插入为<code>0.</code>以下是三值的示例<code>background-position</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#threevalues</span> &#123;</div><div class="line">  <span class="attribute">background-position</span>: right <span class="number">45px</span> bottom;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样就可以将背景图像定位在右侧的<code>45px</code>和容器底部的<code>0px</code>。</p><p>这是一个<code>background-position</code> <strong>四值</strong> 的例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#fourvalues</span> &#123;</div><div class="line">  <span class="attribute">background-position</span>: right <span class="number">45px</span> bottom <span class="number">20px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这将背景图片定位在右侧的<code>45px</code>和容器底部的<code>20px</code>。</p><p>注意上面示例中值的顺序：关键字后跟长度单位。三或四个值<code>background-position</code>必须遵循该格式，关键字在长度或百分比单位之前。</p><h1 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h1><p>此演示包括一个值，两个值，三个值和四个值的示例background-position。</p><iframe height="265" scrolling="no" title="background-position 1, 2, 3, and 4 value syntax" src="//codepen.io/team/css-tricks/embed/yyKdPB/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/team/css-tricks/pen/yyKdPB/" target="_blank" rel="external">background-position 1, 2, 3, and 4 value syntax</a> by CSS-Tricks (<a href="https://codepen.io/css-tricks" target="_blank" rel="external">@css-tricks</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><h1 id="更多参考"><a href="#更多参考" class="headerlink" title="更多参考"></a>更多参考</h1><ul><li><a href="http://www.w3.org/TR/css3-background/#the-background-position" target="_blank" rel="external">background-position 在CSS3规范</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/background-position" target="_blank" rel="external">background-position 在MDN</a></li><li><a href="http://css-tricks.com/positioning-offset-background-images/" target="_blank" rel="external">偏移背景图像</a></li></ul><h1 id="browser-support"><a href="#browser-support" class="headerlink" title="browser-support"></a>browser-support</h1><p>基本价值得到支持。四值语法具有此支持：</p><table><thead><tr><th style="text-align:center">Chrome</th><th style="text-align:center">Safari</th><th style="text-align:center">Firefox</th><th style="text-align:center">Opera</th><th style="text-align:center">IE</th><th style="text-align:center">Android</th><th style="text-align:center">iOS</th></tr></thead><tbody><tr><td style="text-align:center">25+</td><td style="text-align:center">7+</td><td style="text-align:center">13+</td><td style="text-align:center">10.5+</td><td style="text-align:center">9+</td><td style="text-align:center">4+</td><td style="text-align:center">7.1+</td></tr></tbody></table><p>【翻译原文：】<a href="https://css-tricks.com/almanac/properties/b/background-position/" target="_blank" rel="external">https://css-tricks.com/almanac/properties/b/background-position/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刨根问底，每个css属性都要知道它的所有值实在不容易。今天看看 &lt;code&gt;background-position&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;background-positionCSS中的属性允许您在其容器内移动背景图像（或渐变）。
    
    </summary>
    
      <category term="css" scheme="http://robin-front.github.io/categories/css/"/>
    
    
      <category term="background" scheme="http://robin-front.github.io/tags/background/"/>
    
      <category term="css3" scheme="http://robin-front.github.io/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>Array数组的indexOf、includes vs for-loop性能比较</title>
    <link href="http://robin-front.github.io/2017/07/03/arr-of-indexOf-vs-includes-and-for-loop/"/>
    <id>http://robin-front.github.io/2017/07/03/arr-of-indexOf-vs-includes-and-for-loop/</id>
    <published>2017-07-03T03:02:06.000Z</published>
    <updated>2017-07-03T03:02:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到一道算法题，然后有些人会使用 <code>includes</code>、<code>indexOf</code> 去判断是否存在另一个数。这让我不禁思考，这和 <code>for loop</code>有什么区别，能减少时间复杂度吗？我一开始也不是很清楚，但我可以找文档，找标准。我的第一判断是 <code>includes</code> 完全和 <code>for loop</code>没有区别的，只是es6 标准规范提供的语法糖，而 <code>indexOf</code> 还是有一定效率的。带着疑惑，查看 MDN 和 <a href="http://www.ecma-international.org/ecma-262" target="_blank" rel="external">ecma-262</a><a id="more"></a></p><h1 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h1><p><code>includes</code> 是 ES6 新增语法，返回 布尔值。最容易拿 <code>indexOf</code> 来比较， <code>indexOf</code> 不能判断 <code>NaN</code>, 而且不够语义，返回的是 匹配值的位置 或 <code>-1</code>。 <code>includes</code> 内部实现是这样的：</p><blockquote><ol><li>Let O be ? ToObject(this value).</li><li>Let len be ? ToLength(? Get(O, “length”)).</li><li>If len is 0, return false.</li><li>Let n be ? ToInteger(fromIndex). (If fromIndex is undefined, this step produces the value 0.)</li><li>If n ≥ 0, then<ol><li>Let k be n.</li></ol></li><li>Else n &lt; 0,<ol><li>Let k be len + n.</li><li>If k &lt; 0, let k be 0.</li></ol></li><li>Repeat, while k &lt; len<ol><li>Let elementK be the result of ? Get(O, ! ToString(k)).</li><li>If SameValueZero(searchElement, elementK) is true, return true.</li><li>Increase k by 1.</li></ol></li><li>Return false.</li></ol></blockquote><p>其中的 <code>SameValueZero</code> 内部实现是这样的：</p><blockquote><ol><li>If Type(x) is different from Type(y), return false.</li><li>If Type(x) is Number, then<ol><li>If x is NaN and y is NaN, return true.</li><li>If x is +0 and y is -0, return true.</li><li>If x is -0 and y is +0, return true.</li><li>If x is the same Number value as y, return true.</li></ol></li><li>Return false.</li><li>Return SameValueNonNumber(x, y).</li></ol></blockquote><p>从上面可以看出 <code>includes</code> 内部是使用 <code>while</code> 循环，并不能够降低时间复杂度。它能判断出 <code>NaN</code> 以及 <code>+0</code>等于<code>-0</code>。</p><p><strong>所以，返回值的语义化和 <code>NaN</code>的判断就是 <code>includes</code> 的场景。</strong></p><h1 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h1><p>好，<code>includes</code> 用来提升效率的幻想破灭了，那 <code>indexOf</code> 呢，规范是这么写的：</p><blockquote><ol><li>Let O be ? ToObject(this value).</li><li>Let len be ? ToLength(? Get(O, “length”)).</li><li>If len is 0, return -1.</li><li>Let n be ? ToInteger(fromIndex). (If fromIndex is undefined, this step produces the value 0.)</li><li>If n ≥ len, return -1.</li><li>If n ≥ 0, then<ol><li>If n is -0, let k be +0; else let k be n.</li></ol></li><li>Else n &lt; 0,<ol><li>Let k be len + n.</li><li>If k &lt; 0, let k be 0.</li></ol></li><li>Repeat, while k &lt; len<ol><li>Let kPresent be ? HasProperty(O, ! ToString(k)).</li><li>If kPresent is true, then<ol><li>Let elementK be ? Get(O, ! ToString(k)).</li><li>Let same be the result of performing Strict Equality Comparison searchElement === elementK.</li><li>If same is true, return k.</li></ol></li><li>Increase k by 1.</li></ol></li><li>Return -1.</li></ol></blockquote><p><code>Array</code>的 <code>indexOf</code> 也使用了 <code>while</code> 循环，并使用 <code>===</code> 全等比较。（<strong>注： 与 <code>String.prototype.indexOf</code> 并不同</strong>）</p><p><strong><code>indexOf</code> 使用场景是需要知道 匹配值的位置。</strong></p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>这是一个<a href="https://jsperf.com/includes-vs-indexof-vs-forloop/1" target="_blank" rel="external">性能测试比较</a></p><p><img src="https://raw.githubusercontent.com/Robin-front/blog/master/source/images/20170703/includes.vs.indexOf.png" alt="我的测试结果"></p><p>so? 如果单纯只是想比较，简单的才是最快的。 <code>includes</code>与<code>indexOf</code>效率相当，而<code>for Loop</code>最快，因为没有其他的前置判断和浏览器对它的优化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近遇到一道算法题，然后有些人会使用 &lt;code&gt;includes&lt;/code&gt;、&lt;code&gt;indexOf&lt;/code&gt; 去判断是否存在另一个数。这让我不禁思考，这和 &lt;code&gt;for loop&lt;/code&gt;有什么区别，能减少时间复杂度吗？我一开始也不是很清楚，但我可以找文档，找标准。我的第一判断是 &lt;code&gt;includes&lt;/code&gt; 完全和 &lt;code&gt;for loop&lt;/code&gt;没有区别的，只是es6 标准规范提供的语法糖，而 &lt;code&gt;indexOf&lt;/code&gt; 还是有一定效率的。带着疑惑，查看 MDN 和 &lt;a href=&quot;http://www.ecma-international.org/ecma-262&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ecma-262&lt;/a&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="Array" scheme="http://robin-front.github.io/tags/Array/"/>
    
      <category term="indexOf" scheme="http://robin-front.github.io/tags/indexOf/"/>
    
      <category term="includes" scheme="http://robin-front.github.io/tags/includes/"/>
    
      <category term="loop" scheme="http://robin-front.github.io/tags/loop/"/>
    
  </entry>
  
  <entry>
    <title>Web Animations API 入门教程总结回顾</title>
    <link href="http://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Conclusion/"/>
    <id>http://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Conclusion/</id>
    <published>2017-06-28T03:11:47.000Z</published>
    <updated>2017-06-28T03:11:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是 Web Animations API 入门教程系列的总结部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与<a href="https://twitter.com/dancwilson" target="_blank" rel="external">@dancwilson</a>联系。</p><p>我们已经涵盖了相当多的知识面，希望能够解决有关Web Animations API是什么（而不是什么）的问题。要总结这个系列，我们将回顾一下我们已经讨论过的内容，并看看尚未实现的内容。<a id="more"></a></p><h1 id="为什么要用API？"><a href="#为什么要用API？" class="headerlink" title="为什么要用API？"></a>为什么要用API？</h1><p>在介绍中，我们讨论了API是如何将CSS，JS和SVG中的各种方法结合起来进行动画处理，旨在充分利用它们。这意味着，例如，JavaScript可以锁定CSS多年来的硬件加速，并不限于CSS的声明性。API并不意味着替换像<a href="http://greensock.com/" target="_blank" rel="external">GSAP</a>这样的库，而只是为了在浏览器级别提供更多的选项。</p><p><a href="https://birtles.github.io/areweanimatedyet/" target="_blank" rel="external">Firefox</a>和<a href="https://www.chromestatus.com/features#animations" target="_blank" rel="external">Chrome</a>都已经开始实施，而Edge已经<a href="https://dev.modern.ie/platform/status/webanimationsjavascriptapi/" target="_blank" rel="external">积压了很多事没有做</a>。随着团队完成<a href="https://w3c.github.io/web-animations/" target="_blank" rel="external">规范</a>，<a href="https://github.com/web-animations/web-animations-js" target="_blank" rel="external">polyfill</a>可以让我们开始玩转它。</p><h1 id="动画基础"><a href="#动画基础" class="headerlink" title="动画基础"></a>动画基础</h1><p>要<a href="https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/">创建一个基本的动画</a>，我们通过提供关键帧和时序属性来跟踪类似于CSS的结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> player = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>).animate([</div><div class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(1)'</span>, <span class="attr">opacity</span>: <span class="number">1</span>, <span class="attr">offset</span>: <span class="number">0</span> &#125;,</div><div class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(.6)'</span>, <span class="attr">opacity</span>: <span class="number">.6</span>, <span class="attr">offset</span>: <span class="number">1</span> &#125;</div><div class="line">  ], &#123;</div><div class="line">    <span class="attr">duration</span>: <span class="number">700</span>,</div><div class="line">  &#125;);</div></pre></td></tr></table></figure><p><a href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/">时间轴控制</a>是当前CSS中明显不存在的部分。通过<code>playState</code>属性读取动画的状态，并改变状态，例如<code>play()</code>，<code>pause()</code>，和<code>finish()</code>。我们也可以通过读/写<code>playbackRate</code>属性将播放速度更改或更快。<code>currentTime</code>可读写，我们可以设置当动画与完成回调<code>onfinish</code>。</p><h1 id="多个动画和分组"><a href="#多个动画和分组" class="headerlink" title="多个动画和分组"></a>多个动画和分组</h1><p>Web Animations API允许对元素设置<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations/">多个动画</a>，创建单独的动画对象。<code>document</code>上默认的<code>timeline</code>可以使用<code>getAnimations()</code>方法让我们访问创建的所有动画。可以通过使用<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/">GroupEffects 和 SequenceEffects</a>（在polyfill中提供但不在Level 1规范中）将动画组合在一起或一个接一个地进行播放。</p><h1 id="运动路径与未来"><a href="#运动路径与未来" class="headerlink" title="运动路径与未来"></a>运动路径与未来</h1><p>在这个系列中，沿着<a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path/">一条路径运动</a>让我们看到了它在CSS中的第一个实现，但还有很多其他模块尚未实现。</p><h1 id="间距-Spacing"><a href="#间距-Spacing" class="headerlink" title="间距(Spacing)"></a>间距(Spacing)</h1><p>如果在关键帧中没有设置<code>offset</code>，则当前的实现使用默认的间隔，这意味着它们是均匀分布的（例如，三个帧将具有0,1,5和1的偏移量）。该规范还定义了一种基于属性来调整动画的方法，以使其具有恒定的变化率。当讨论<a href="http://w3c.github.io/web-animations/#spacing-keyframes" target="_blank" rel="external">Spacing keyframes</a>时，该规范描述了这一点。</p><h1 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h1><p>该规范已经演变成–包括<code>ready</code>在内的，每次动画取消或进入挂起状态（通常在更改为“运行”或“已暂停”）之前将会被新的<code>Promise</code>替换。除了<code>onfinish</code>, 我们在本系列中讨论的使用回调之外，我们还可使用<code>finished</code>返回的<code>Promise</code>在动画完成后运行其他功能。</p><h1 id="让我们继续谈论Web动画API"><a href="#让我们继续谈论Web动画API" class="headerlink" title="让我们继续谈论Web动画API"></a>让我们继续谈论Web动画API</h1><p>人们开始更多地谈论这个API，我希望这个讨论继续下去。规格，浏览器实现和polyfill已经持续了一段时间，他们准备好仔细检查。</p><p>有时CSS会有更多场景，有时候是<code>requestAnimationFrame</code>，有时使用类库会是最好的解决方案。知道什么时候使用什么是好的，这个API提供了不少以前我们以前没有的可用的东西，所以很有趣。</p><p>查看本系列的其余部分：</p><ul><li><a href="https://robin-front.github.io/2017/06/25/animations-intro/">介绍</a></li><li>第1部分：<a href="https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/">创建基本动画</a></li><li>第2部分：<a href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/">动画和时间线控制</a></li><li>第3部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations/">多个动画</a></li><li>第4部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/">GroupEffects和SequenceEffects</a></li><li>第5部分：<a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path/">运动路径</a></li><li><a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Conclusion/">总结与回顾</a></li></ul><p>【翻译原文】： <a href="http://danielcwilson.com/blog/2015/09/animations-conclusion/" target="_blank" rel="external">http://danielcwilson.com/blog/2015/09/animations-conclusion/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是 Web Animations API 入门教程系列的总结部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与&lt;a href=&quot;https://twitter.com/dancwilson&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@dancwilson&lt;/a&gt;联系。&lt;/p&gt;&lt;p&gt;我们已经涵盖了相当多的知识面，希望能够解决有关Web Animations API是什么（而不是什么）的问题。要总结这个系列，我们将回顾一下我们已经讨论过的内容，并看看尚未实现的内容。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="Web Animations" scheme="http://robin-front.github.io/tags/Web-Animations/"/>
    
  </entry>
  
  <entry>
    <title>Web Animations API 入门教程第5部分: 可爱的运动路径</title>
    <link href="http://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path/"/>
    <id>http://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path/</id>
    <published>2017-06-28T01:59:47.000Z</published>
    <updated>2017-06-28T01:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是 Web Animations API 入门教程系列的第5部分。</p><p>重要信息：自撰写本文以来，运动路径的规范（和Chromium实现）已经发生了重大变化。以下在概念上仍然有效，但是属性名称和更多内容已经改变。截至2016年10月，请查看<a href="https://codepen.io/danwilson/post/css-motion-paths-2016" target="_blank" rel="external">CSS运动路径</a>。</p><p>最后，沿着路径动画…不再仅仅是SVG的领域。<a id="more"></a></p><h1 id="运动路径：当前方向（Spec）"><a href="#运动路径：当前方向（Spec）" class="headerlink" title="运动路径：当前方向（Spec）"></a>运动路径：当前方向（Spec）</h1><iframe height="265" scrolling="no" title="Motion Path Infinity" src="//codepen.io/danwilson/embed/MwLmby/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/MwLmby/" target="_blank" rel="external">Motion Path Infinity</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><p>随着API规范的运用，运动路径出现了不同的形式。最初有可能的一个方向是一个形式的特效（如前面所讨论的<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/">GroupEffect</a>），但随后借助CSS模块的运动路径的气势一点点上升（<a href="https://www.w3.org/TR/motion-1/" target="_blank" rel="external">拥有它自己的规范</a>）。</p><p>因此，沿着路径动画将只是另一组CSS属性，可以动画化，正如<code>opacity</code>和<code>tranform</code>也可以。这样，CSS过渡和关键帧可以使用它,Web Animations API也是…这是伟大的，因为我们想要尽可能多的这些方法之间共享给我们更多的灵活性。Chrome和Opera已经发布了一个初步的实现，所以我们可以在今天开始玩它，尽管还没有在polyfill找到它的任何使用方式。</p><p>让我们分解这些属性，我们如何使用它们，现在还有什么事情可以阻碍我们。</p><h1 id="运动路径属性"><a href="#运动路径属性" class="headerlink" title="运动路径属性"></a>运动路径属性</h1><p>我们将讨论<code>motion</code>的三个属性。现在，要查看示例，您将需要运行Chrome 46或Opera 33。</p><h2 id="motion-path"><a href="#motion-path" class="headerlink" title="motion-path"></a>motion-path</h2><p>起始点是<code>motion-path</code>定义元素可以移动的路径，遵循SVG 1.1中的路径工作方式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#motioner</span> &#123;</div><div class="line">  <span class="attribute">motion-path</span>: <span class="built_in">path</span>(<span class="string">"M200 200 S 200.5 200.1 348.7 184.4z"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这也可以<code>fill-rule</code>在路径调用中作为可选的第一个参数。我建议您阅读<a href="http://svgpocketguide.com/book/#section-4" target="_blank" rel="external">Joni Trythall的“优秀口袋指南”</a>，就SVG进行讨论。</p><p>根据规范，您还可以使用基本形状，例如<code>circle</code>，<code>polygon</code>，<code>ellipse</code>，和<code>inset</code>。如果您尝试过使用<a href="http://alistapart.com/article/css-shapes-101" target="_blank" rel="external">CSS shape</a>，这些应该看起来很熟悉。</p><p>根据Blink的初始实现，我只看过这个<code>path()</code>方法可以工作，所以我一直没有正确使用形状或者还没到时候。</p><h2 id="motion-offset"><a href="#motion-offset" class="headerlink" title="motion-offset"></a>motion-offset</h2><p>驱动运动，并将元素放在我们使用的路径上的某个位置<code>motion-offset</code>。这可以是双倍长度值或百分比。因此，从路径的起点到最后，我们设置一个从0到100％的动画。使用我们拥有的Web Animations API</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> m = <span class="built_in">document</span>.getElementById(<span class="string">'motioner'</span>);</div><div class="line">m.animate([</div><div class="line">  &#123; <span class="attr">motionOffset</span>: <span class="number">0</span> &#125;,</div><div class="line">  &#123; <span class="attr">motionOffset</span>: <span class="string">'100%'</span> &#125;</div><div class="line">], <span class="number">1000</span>);</div></pre></td></tr></table></figure><p>以及CSS的写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#motioner</span> &#123;</div><div class="line">  <span class="attribute">animation</span>: path-animation <span class="number">1s</span>;</div><div class="line">&#125;</div><div class="line">@<span class="keyword">keyframes</span> path-animation &#123;</div><div class="line">  0% &#123;</div><div class="line">    <span class="attribute">motion-offset</span>: <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  100% &#123;</div><div class="line">    <span class="attribute">motion-offset</span>: <span class="string">'100%'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><iframe height="265" scrolling="no" title="CSS Motion Path Spiral" src="//codepen.io/danwilson/embed/ZGmeRO/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/ZGmeRO/" target="_blank" rel="external">CSS Motion Path Spiral</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><p>该CodePen演示显示了从外部到内部沿着螺旋路径移动的几个点。随着每个点接近中心，它变得越来越快，变得越来越透明。 <code>.animate()</code>在每个点被称为两次无限迭代和一个延迟，其中一个调用集中在运动偏移，另一个焦点在缩放和不透明度上。我分解了他们，指出了不同的解决方案，当然，他们也可以结合在一起。</p><p>这种方法还使用功能检测，您将会注意到，如果您在Safari，Firefox，Edge或旧版Chrome / Opera中查看，因为您将看到一条消息而不是动画。有几种方法可以做到这一点，比如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> m = <span class="built_in">document</span>.getElementById(<span class="string">'motioner'</span>);</div><div class="line"><span class="keyword">if</span> (m.style.motionOffset !== <span class="literal">undefined</span>) &#123; ... &#125;</div></pre></td></tr></table></figure><p>当然，我们不想在真正的网页中完全阻止用户，所以如果支持，我们可以有另一个动画（或者没有动画）切换到<code>Motion Path</code>动画。像往常一样，渐进增强(Progressive Enhancement)是我们的朋友。</p><h2 id="motion-rotation"><a href="#motion-rotation" class="headerlink" title="motion-rotation"></a>motion-rotation</h2><p>最后的属性是motion-rotation，它处理元素沿着路径移动时面向哪个方向。有四种主要方法可以指定这一点。</p><ul><li>auto 表示元素将随路径旋转。</li><li>reverse 元素也将随着路径旋转，但会增加180度，因此将向后。</li><li>auto Xdeg / reverse Xdeg 除了添加X度也会一样</li><li>Xdeg 将不再与路径一起旋转，元素将保持固定朝向相同的方向。</li></ul><iframe height="265" scrolling="no" title="CSS MotionPath" src="//codepen.io/danwilson/embed/qdLQjz/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/qdLQjz/" target="_blank" rel="external">CSS MotionPath</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><h1 id="少了点什么东西？"><a href="#少了点什么东西？" class="headerlink" title="少了点什么东西？"></a>少了点什么东西？</h1><p>这是第一个版本，当然，浏览器制造商和规范作者仍在讨论这一切。在尝试这一过程中，我注意到的最大的一件事就是缺少适应不同屏幕/容器尺寸的路径。</p><p>路径只是按照它们的定义出现。当使用SVG时，我们获得灵活性，因为我们在容器上具有不同的坐标系和属性，如 <a href="http://sarasoueidan.com/blog/svg-coordinate-systems/#svg-viewbox" target="_blank" rel="external">viewBox</a>。使用CSS中定义的运动路径，路径的大小不能被其他属性另外修改或约束。元素上定义的宽度和高度仅适用于元素，而不是其运动路径。您可以使用媒体查询或JavaScript来定义不同条件的不同路径，但是想通过<code>motion</code>属性灵活地设置它们是不可能的事。</p><h1 id="回顾和下一节"><a href="#回顾和下一节" class="headerlink" title="回顾和下一节"></a>回顾和下一节</h1><p>我们将看到规范的方向，但现在尝试这样做是很有趣的，看看它可能提供什么（和不提供什么）。我正在收集我在CodePen上找到的<a href="http://codepen.io/collection/AQWaem" target="_blank" rel="external">CSS Motion Path演示文稿</a>，而Eric Willigers（Chrome开发团队的相关实现任务的所有者）拥有一个<a href="https://docs.google.com/document/d/15nn0tc9meyahzSBAauYtIUpGFsuHaieZt403k1v9B90/edit" target="_blank" rel="external">Google Doc的例子</a>。</p><p>我们将在下次再次介绍我们所讨论的内容，并且再看几个目前唯一的规范主题。</p><p>查看本系列的其余部分：</p><ul><li><a href="https://robin-front.github.io/2017/06/25/animations-intro/">介绍</a></li><li>第1部分：<a href="https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/">创建基本动画</a></li><li>第2部分：<a href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/">动画和时间线控制</a></li><li>第3部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations/">多个动画</a></li><li>第4部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/">GroupEffects和SequenceEffects</a></li><li>第5部分：<a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path/">运动路径</a></li><li><a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Conclusion/">总结与回顾</a></li></ul><p>【翻译原文】： <a href="http://danielcwilson.com/blog/2015/09/animations-part-5/" target="_blank" rel="external">http://danielcwilson.com/blog/2015/09/animations-part-5/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是 Web Animations API 入门教程系列的第5部分。&lt;/p&gt;&lt;p&gt;重要信息：自撰写本文以来，运动路径的规范（和Chromium实现）已经发生了重大变化。以下在概念上仍然有效，但是属性名称和更多内容已经改变。截至2016年10月，请查看&lt;a href=&quot;https://codepen.io/danwilson/post/css-motion-paths-2016&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CSS运动路径&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;最后，沿着路径动画…不再仅仅是SVG的领域。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="Web Animations" scheme="http://robin-front.github.io/tags/Web-Animations/"/>
    
  </entry>
  
  <entry>
    <title>Web Animations API 入门教程第4部分: GroupEffects &amp; SequenceEffects</title>
    <link href="http://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/"/>
    <id>http://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/</id>
    <published>2017-06-27T03:24:55.000Z</published>
    <updated>2017-06-27T03:24:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是 Web Animations API 入门教程系列的第4部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与<a href="https://twitter.com/dancwilson" target="_blank" rel="external">@dancwilson</a>联系。</p><p>让我们继续讨论Web动画API中的多个动画，通过讨论今天在polyfill中提供的几个部分来提供分组和排序。<a id="more"></a></p><h1 id="KeyframeEffects"><a href="#KeyframeEffects" class="headerlink" title="KeyframeEffects"></a>KeyframeEffects</h1><p>A KeyframeEffect需要三个参数：动画元素(element)，关键帧数组(keyframes)和时间选项(timing options)。这些都是我们以前使用过的参数<code>element.animate()</code>。这个新对象本质上是单个动画的蓝图，当我们讨论分组(group)和队列(sequence)动画的方法时，我们会看到它。它不启动动画，它只是定义动画。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>);</div><div class="line"><span class="keyword">var</span> timings = &#123;</div><div class="line">  <span class="attr">duration</span>: <span class="number">1000</span>,</div><div class="line">  <span class="attr">fill</span>: <span class="string">'both'</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> keyframes = [</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">1</span> &#125;.</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">0</span> &#125;</div><div class="line">];</div><div class="line"></div><div class="line"><span class="keyword">var</span> effect = <span class="keyword">new</span> KeyframeEffect(elem, keyframes, timings);</div></pre></td></tr></table></figure><h1 id="GroupEffects"><a href="#GroupEffects" class="headerlink" title="GroupEffects"></a>GroupEffects</h1><p>虽然在任何浏览器中都没有实现此功能，甚至在Level 2规范中找不到，但是polyfill提供了一种组合动画并将其一起播放的方法。 <strong>GroupEffect</strong>（是的，它是未来将集成在Level 2规范）组合一个或多个KeyframeEffects同时播放。</p><iframe height="265" scrolling="no" title="Group Effects with WAAPI" src="//codepen.io/danwilson/embed/zGeVey/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/zGeVey/" target="_blank" rel="external">Group Effects with WAAPI</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><p>一个<code>GroupEffect</code>任务需要一个<code>Effects</code>参数，我们可以传递代表我们多个动画的<code>KeyframeEffect</code>数组。一旦定义，我们可以在准备好的时候在默认时间轴上播放动画组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>);</div><div class="line"><span class="keyword">var</span> elem2 = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate2'</span>);</div><div class="line"><span class="keyword">var</span> timings = &#123;</div><div class="line">  <span class="attr">duration</span>: <span class="number">1000</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> keyframes = [</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">1</span> &#125;.</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">0</span> &#125;</div><div class="line">];</div><div class="line"></div><div class="line"><span class="keyword">var</span> kEffects = [</div><div class="line">  <span class="keyword">new</span> KeyframeEffect(elem, keyframes, timings),</div><div class="line">  <span class="keyword">new</span> KeyframeEffect(elem2, keyframes, timings)</div><div class="line">];</div><div class="line"><span class="keyword">var</span> group = <span class="keyword">new</span> GroupEffect(kEffects);</div><div class="line"><span class="built_in">document</span>.timeline.play(group);</div></pre></td></tr></table></figure><h1 id="SequenceEffects"><a href="#SequenceEffects" class="headerlink" title="SequenceEffects"></a>SequenceEffects</h1><p>类似于<code>GroupEffect</code>，<code>SequenceEffect</code>允许我们将多个动画（由<code>KeyframeEffects</code> 指定）组合在一起…不是并行播放它们，而是一个接一个地播放它们。您也可以按照polyfill中的定义将<code>GroupEffect</code>和<code>SequenceEffect</code>一起使用（例如具有多个序列的分组）。</p><iframe height="265" scrolling="no" title="SequenceEffect with WAAPI" src="//codepen.io/danwilson/embed/vNYQLL/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/vNYQLL/" target="_blank" rel="external">SequenceEffect with WAAPI</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><p>队列提供给你一些我们必须用CSS或者我们在 animations API中看到的东西。我们必须根据早期动画的持续时间或使用 <strong>finish</strong> 回调来维持延迟。这些方法可能难以维护，或者不会如此精确。</p><p>使用先前在<code>GroupEffect</code>代码段中的变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sequence = <span class="keyword">new</span> SequenceEffect(kEffects);</div><div class="line"><span class="built_in">document</span>.timeline.play(sequence);</div></pre></td></tr></table></figure><h1 id="创建动画的备用方法"><a href="#创建动画的备用方法" class="headerlink" title="创建动画的备用方法"></a>创建动画的备用方法</h1><p>我们以前看过<code>element.animate()</code>创建动画的方式。这是创建动画的快捷方式，立即播放，并获取<code>Animation</code>对象的引用。我们专注于这一点，因为Chrome支持了一段时间了，polyfill也是。Firefox是第一个支持替代方式的：·构造函数。它向我们展示了另一种使用方法<code>KeyframeEffect</code>，而且它在Level 1规范中，所以我们应该很快会看到它的更多应用。</p><p>首先提醒一下如何<code>element.animate()</code>工作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>);</div><div class="line"><span class="keyword">var</span> timings = &#123;</div><div class="line">  <span class="attr">duration</span>: <span class="number">1000</span>,</div><div class="line">  <span class="attr">fill</span>: <span class="string">'both'</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> keyframes = [</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">1</span> &#125;.</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">0</span> &#125;</div><div class="line">];</div><div class="line"></div><div class="line">elem.animate(keyframes, timings);</div></pre></td></tr></table></figure><p>使用与上述相同的变量，以下是使用<code>Animation</code>构造函数的等价写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> kEffect = <span class="keyword">new</span> KeyframeEffect(elem, keyframes, timings);</div><div class="line"><span class="keyword">var</span> player = <span class="keyword">new</span> Animation(kEffect, elem.ownerDocument.timeline);</div><div class="line">player.play();</div></pre></td></tr></table></figure><p>这里的主要区别在于，动画不会立即开始播放，所以在提前创建动画以便稍后播放时，这将非常有用。</p><h1 id="回顾和下一节"><a href="#回顾和下一节" class="headerlink" title="回顾和下一节"></a>回顾和下一节</h1><p>当Level 2规范通过工作草案时，我们应该看到更多关于这些不同效果的定义。本系列中还有两个计划的章节。下一次我们将再次看看未来，还有什么我们可以期待看到。</p><p>查看本系列的其余部分：</p><ul><li><a href="https://robin-front.github.io/2017/06/25/animations-intro/">介绍</a></li><li>第1部分：<a href="https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/">创建基本动画</a></li><li>第2部分：<a href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/">动画和时间线控制</a></li><li>第3部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations/">多个动画</a></li><li>第4部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/">GroupEffects和SequenceEffects</a></li><li>第5部分：<a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path/">运动路径</a></li><li><a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Conclusion/">总结与回顾</a></li></ul><p>【翻译原文】：<a href="http://danielcwilson.com/blog/2015/09/animations-part-4/" target="_blank" rel="external">http://danielcwilson.com/blog/2015/09/animations-part-4/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是 Web Animations API 入门教程系列的第4部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与&lt;a href=&quot;https://twitter.com/dancwilson&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@dancwilson&lt;/a&gt;联系。&lt;/p&gt;&lt;p&gt;让我们继续讨论Web动画API中的多个动画，通过讨论今天在polyfill中提供的几个部分来提供分组和排序。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="Web Animations" scheme="http://robin-front.github.io/tags/Web-Animations/"/>
    
  </entry>
  
  <entry>
    <title>Web Animations API 入门教程第3部分: 多个Animations对象</title>
    <link href="http://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations/"/>
    <id>http://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations/</id>
    <published>2017-06-27T02:17:19.000Z</published>
    <updated>2017-06-27T02:17:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是 Web Animations API 入门教程系列的第3部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与<a href="https://twitter.com/dancwilson" target="_blank" rel="external">@dancwilson</a>联系。</p><p>在我们讨论<a href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/">动画和时间线控制</a>之后，让我们来讨论多个动画。<a id="more"></a></p><h1 id="每个元素的多个动画"><a href="#每个元素的多个动画" class="headerlink" title="每个元素的多个动画"></a>每个元素的多个动画</h1><iframe height="265" scrolling="no" title="Multiple animate calls" src="//codepen.io/danwilson/embed/PqxvJo/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/PqxvJo/" target="_blank" rel="external">Multiple animate calls</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><p>在这个例子中，每个矩形都有三个动画应用（涉及到transform，opacity和color）。您可以多次调用元素的<code>animate()</code>方法，类似于允许多个动画的CSS。</p><p>使用CSS：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#toAnimate</span> &#123;</div><div class="line">  <span class="attribute">animation</span>: pulse <span class="number">1s</span>, activate <span class="number">3000ms</span>, have-fun-with-it <span class="number">2.5s</span>;</div><div class="line">&#125;</div><div class="line">@<span class="keyword">keyframes</span> pulse &#123; <span class="comment">/* ... */</span> &#125;</div><div class="line">@<span class="keyword">keyframes</span> activate &#123; <span class="comment">/* ... */</span> &#125;</div><div class="line">@<span class="keyword">keyframes</span> have-fun-with-it &#123; <span class="comment">/* ... */</span> &#125;</div></pre></td></tr></table></figure><p>使用Web Animations API：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> animated = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>);</div><div class="line"><span class="keyword">var</span> pulseKeyframes, <span class="comment">//在这里定义 keyframes.</span></div><div class="line">    activateKeyframes,</div><div class="line">    haveFunKeyframes;</div><div class="line"><span class="keyword">var</span> pulse = animated.animate(pulseKeyframes, <span class="number">1000</span>); <span class="comment">// 第二个数值参数作为持续时间的缩写</span></div><div class="line"><span class="keyword">var</span> activate = animated.animate(activateKeyframes, <span class="number">3000</span>);</div><div class="line"><span class="keyword">var</span> haveFunWithIt = animated.animate(haveFunKeyframes, <span class="number">2500</span>);</div></pre></td></tr></table></figure><p>使用Web Animations API，这将创建三个Animation对象，每个对象可以通过时间轴(timeline)或播放速率(playback rate)进行暂停，播放，完成，取消的操作。</p><h1 id="获取-Animations，全部动画对象"><a href="#获取-Animations，全部动画对象" class="headerlink" title="获取 Animations，全部动画对象"></a>获取 Animations，全部动画对象</h1><p>所以你可以知道一个动画开始播放了，但是当你想在元素上调用<code>animate()</code>时你却还没有捕获到Animation的引用。那要怎么做？</p><iframe height="265" scrolling="no" title="Pause All those Random Dots!" src="//codepen.io/danwilson/embed/PqgKVK/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/PqgKVK/" target="_blank" rel="external">Pause All those Random Dots!</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><p>该规范允许<code>getAnimations()</code>在文档上的方法。在最新版本的规范中，它直接在<code>document（document.getAnimations()）</code>上，在Firefox 48+上它是这样实现的。然而，对于Chrome 52 和<a href="https://github.com/web-animations/web-animations-js" target="_blank" rel="external">polyfill</a>（如V2.2.0的），则根据该旧规范将其置于新的<code>timeline</code>对象上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如果引用了 polyfill ，你可以这样写</span></div><div class="line"><span class="keyword">var</span> animations = <span class="built_in">document</span>.getAnimations ? <span class="built_in">document</span>.getAnimations() : <span class="built_in">document</span>.timeline.getAnimations();</div><div class="line"><span class="comment">// 返回一个数组，包含所有正在进行的（除了已完成的和被取消的）动画</span></div></pre></td></tr></table></figure><p>在CodePen示例中，您将看到随机的持续时间，延迟和无限持续时间的变换移动的几个点。“暂停全部”按钮调用<code>getAnimations()</code>并遍历所有, 返回的玩家（每个动画对象）并暂停每一个。</p><h1 id="下一节…"><a href="#下一节…" class="headerlink" title="下一节…"></a>下一节…</h1><p>在下一部分中，我们将看看WAAPI动画可以创建的不同方式（因为它不仅仅是<code>element.animate</code>）。提示：<code>document.timeline</code>会出现更多的体现。</p><p>查看本系列的其余部分：</p><ul><li><a href="https://robin-front.github.io/2017/06/25/animations-intro/">介绍</a></li><li>第1部分：<a href="https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/">创建基本动画</a></li><li>第2部分：<a href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/">动画和时间线控制</a></li><li>第3部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations/">多个动画</a></li><li>第4部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/">GroupEffects和SequenceEffects</a></li><li>第5部分：<a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path/">运动路径</a></li><li><a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Conclusion/">总结与回顾</a></li></ul><p>【翻译原文】: <a href="http://danielcwilson.com/blog/2015/08/animations-part-3/" target="_blank" rel="external">http://danielcwilson.com/blog/2015/08/animations-part-3/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是 Web Animations API 入门教程系列的第3部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与&lt;a href=&quot;https://twitter.com/dancwilson&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@dancwilson&lt;/a&gt;联系。&lt;/p&gt;&lt;p&gt;在我们讨论&lt;a href=&quot;http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/&quot;&gt;动画和时间线控制&lt;/a&gt;之后，让我们来讨论多个动画。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="Web Animations" scheme="http://robin-front.github.io/tags/Web-Animations/"/>
    
  </entry>
  
  <entry>
    <title>Web Animations API入门教程第2部分：动画和时间线控制</title>
    <link href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/"/>
    <id>http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/</id>
    <published>2017-06-26T09:51:00.000Z</published>
    <updated>2017-06-26T09:51:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是 Web Animations API 入门教程系列的第2部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与<a href="https://twitter.com/dancwilson" target="_blank" rel="external">@dancwilson</a>联系。</p><p>现在我们了解如何使用Web Animations API <a href="https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/">创建基本动画</a>，让我们来谈谈状态（states），控制(controls)，回调(callback)和时间轴(timelines)。<a id="more"></a></p><h1 id="Animations-播放状态和控制"><a href="#Animations-播放状态和控制" class="headerlink" title="Animations 播放状态和控制"></a>Animations 播放状态和控制</h1><p>当你调用时<code>element.animate()</code>，返回一个<code>Animation</code>对象（以前称为<code>AnimationPlayerspec</code>），动画开始播放。要查看动画的当前状态，您可以检查<code>readonly</code>属性<code>playState</code>，该属性将返回五个字符串之一。我们也可以通过调用四种方法之一修改动画的当前状态：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> player = element.animate(<span class="comment">/* ... */</span>);</div><div class="line"><span class="built_in">console</span>.log(player.playState); <span class="comment">//"running"</span></div><div class="line"></div><div class="line">player.pause(); <span class="comment">//"paused"</span></div><div class="line">player.play();  <span class="comment">//"running"</span></div><div class="line">player.cancel(); <span class="comment">//"idle"... 跳到原始状态</span></div><div class="line">player.finish(); <span class="comment">//"finished"...跳到结束状态</span></div></pre></td></tr></table></figure><p>此外<code>running</code>，<code>paused</code>，<code>idle</code>，和<code>finished</code>播放状态有一个<code>pending</code>状态定义当播放或暂停任务正在等待批准即将发生。</p><p>这个“步行圆圈”示例显示六个圆缩放。您可以暂停或播放每个圈子，以查看上述播放状态的一部分。</p><iframe height="265" scrolling="no" title="Blob That Walks" src="//codepen.io/danwilson/embed/WvXRYg/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/WvXRYg/" target="_blank" rel="external">Blob That Walks</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><h1 id="播放速率"><a href="#播放速率" class="headerlink" title="播放速率"></a>播放速率</h1><p>在之前的CodePen示例中，还有一个“2x”按钮，您可以按更改动画的播放速度，将其切换到双倍速度。这是通过读/写<code>playbackRate</code>属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> player = element.animate(<span class="comment">/* ... */</span>);</div><div class="line"><span class="built_in">console</span>.log(player.playbackRate); <span class="comment">//1</span></div><div class="line"></div><div class="line">player.playbackRate = <span class="number">2</span>; <span class="comment">//双倍速度, 也可以使用十进制数字控制它降低速度.</span></div></pre></td></tr></table></figure><h1 id="动画完成后的回调"><a href="#动画完成后的回调" class="headerlink" title="动画完成后的回调"></a>动画完成后的回调</h1><p>使用CSS transitions，当转换结束时，通常会触发一个事件。类似地，<code>Animation</code>允许您指定一个<code>onfinish</code>函数，在动画完成或调用之前讨论过的<code>finish()</code>方法时调用它。请注意，根据规范，无法完成无限次迭代的动画集，也不能完成一个具有<code>playbackRate = 0</code> 的动画集。还有一个<code>oncancel</code>处理程序，以及在<code>Animation</code>完成时使用<code>Promises</code>的写法。</p><p>以下示例用于<code>onfinish</code>在动画完成后显示一些统计信息（并且它也很好地切换到下一次关于时间轴的讨论）。</p><iframe height="265" scrolling="no" title="Timer Countdown" src="//codepen.io/danwilson/embed/RPMVZJ/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/RPMVZJ/" target="_blank" rel="external">Timer Countdown</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><h1 id="时间轴"><a href="#时间轴" class="headerlink" title="时间轴"></a>时间轴</h1><p>每个<code>Animation</code>都公开两个读/写时间相关属性 - <code>currentTime</code>和<code>startTime</code>。现在，我们将重点关注前者。</p><p><code>currentTime</code>返回动画当前的毫秒数。最大值将为延迟时间 +（持续时间<em>迭代次数）（`delay + (duration </em>iterations)`），因此无限次迭代将不具有最大值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> player = element.animate([</div><div class="line">  &#123;<span class="attr">opacity</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">opacity</span>: <span class="number">0</span>&#125;</div><div class="line">], &#123;</div><div class="line">  <span class="attr">duration</span>: <span class="number">1000</span>,</div><div class="line">  <span class="attr">delay</span>: <span class="number">500</span>,</div><div class="line">  <span class="attr">iterations</span>: <span class="number">3</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">player.onfinish = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(player.currentTime); <span class="comment">// 3500</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>播放速率将影响时间轴的持续时间。如果您将播放速度设置为10，则您的最大时间保持不变，但您的时间轴会快10倍。这个概念也在之前的“计时器倒计时”示例中显示。</p><p>由于<code>currentTime</code>是可 读/写，我们也可以使用它来跳转到时间轴中的某一点。它也可以让我们同步两个动画，如下例所示。</p><iframe height="265" scrolling="no" title="Syncing Timelines - WAAPI" src="//codepen.io/danwilson/embed/YXYWKK/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/YXYWKK/" target="_blank" rel="external">Syncing Timelines - WAAPI</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><h1 id="还有一个选项：-reverse"><a href="#还有一个选项：-reverse" class="headerlink" title="还有一个选项： reverse()"></a>还有一个选项： reverse()</h1><p>你也可以使用<code>reverse()</code>反转一个与之非常相似的动画<code>play()</code>（比如它会有相同的playState），除了它将以相反的方式遍历时间轴。当动画完成时，<code>currentTime</code>将为0。</p><iframe height="265" scrolling="no" title="waRKOm" src="//codepen.io/danwilson/embed/waRKOm/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/waRKOm/" target="_blank" rel="external">waRKOm</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><h1 id="下一节…"><a href="#下一节…" class="headerlink" title="下一节…"></a>下一节…</h1><p>这包含了很多的信息，但仍然只是熟悉一下WAAPI有哪些可用的。下面我们来看一些更高级的用法。</p><p>查看本系列的其余部分：</p><ul><li><a href="https://robin-front.github.io/2017/06/25/animations-intro/">介绍</a></li><li>第1部分：<a href="https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/">创建基本动画</a></li><li>第2部分：<a href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/">动画和时间线控制</a></li><li>第3部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations/">多个动画</a></li><li>第4部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/">GroupEffects和SequenceEffects</a></li><li>第5部分：<a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path/">运动路径</a></li><li><a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Conclusion/">总结与回顾</a></li></ul><p>【翻译原文】: <a href="http://danielcwilson.com/blog/2015/07/animations-part-2/" target="_blank" rel="external">http://danielcwilson.com/blog/2015/07/animations-part-2/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是 Web Animations API 入门教程系列的第2部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与&lt;a href=&quot;https://twitter.com/dancwilson&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@dancwilson&lt;/a&gt;联系。&lt;/p&gt;&lt;p&gt;现在我们了解如何使用Web Animations API &lt;a href=&quot;https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/&quot;&gt;创建基本动画&lt;/a&gt;，让我们来谈谈状态（states），控制(controls)，回调(callback)和时间轴(timelines)。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="Web Animations" scheme="http://robin-front.github.io/tags/Web-Animations/"/>
    
  </entry>
  
  <entry>
    <title>Web Animations API 入门教程第1部分:创建一个基本的动画</title>
    <link href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/"/>
    <id>http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/</id>
    <published>2017-06-26T03:25:31.000Z</published>
    <updated>2017-06-26T03:25:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是 Web Animations API 入门教程系列的第1部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与<a href="https://twitter.com/dancwilson" target="_blank" rel="external">@dancwilson</a>联系。</p><p>我们之前初步看了下 Web Animations API，但是我们没有得到任何真正的细节，所以现在我们来看看。</p><p>WAAPI（Web Animations API, 以下均简称WAAPI）为您提供更多的控制比您可能已经习惯使用的CSS动画，但在我们进入这些演示之前，我们需要设置基本目标：如何通过此API创建基本动画？<a id="more"></a></p><h1 id="创建关键帧动画"><a href="#创建关键帧动画" class="headerlink" title="创建关键帧动画"></a>创建关键帧动画</h1><p>如果您熟悉CSS Transitions/ Animations，这将非常熟悉。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> player = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>).animate([</div><div class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(1)'</span>, <span class="attr">opacity</span>: <span class="number">1</span>, <span class="attr">offset</span>: <span class="number">0</span> &#125;,</div><div class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(.5)'</span>, <span class="attr">opacity</span>: <span class="number">.5</span>, <span class="attr">offset</span>: <span class="number">.3</span> &#125;,</div><div class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(.667)'</span>, <span class="attr">opacity</span>: <span class="number">.667</span>, <span class="attr">offset</span>: <span class="number">.7875</span> &#125;,</div><div class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(.6)'</span>, <span class="attr">opacity</span>: <span class="number">.6</span>, <span class="attr">offset</span>: <span class="number">1</span> &#125;</div><div class="line">  ], &#123;</div><div class="line">    <span class="attr">duration</span>: <span class="number">700</span>, <span class="comment">//毫秒</span></div><div class="line">    easing: <span class="string">'ease-in-out'</span>, <span class="comment">//'linear', a bezier curve等.</span></div><div class="line">    delay: <span class="number">10</span>, <span class="comment">//毫秒</span></div><div class="line">    iterations: <span class="literal">Infinity</span>, <span class="comment">//或其他数值</span></div><div class="line">    direction: <span class="string">'alternate'</span>, <span class="comment">//'normal', 'reverse', 等.</span></div><div class="line">    fill: <span class="string">'forwards'</span> <span class="comment">//'backwards', 'both', 'none', 'auto'</span></div><div class="line">  &#125;);</div></pre></td></tr></table></figure><p>为了对照，这里是一个等效的CSS关键帧动画</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> emphasis &#123;</div><div class="line">  0% &#123;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(1);</div><div class="line">    <span class="attribute">opacity</span>: <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  30% &#123;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(.5);</div><div class="line">    <span class="attribute">opacity</span>: .<span class="number">5</span>;</div><div class="line">  &#125;</div><div class="line">  78<span class="selector-class">.75</span>% &#123;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(.667);</div><div class="line">    <span class="attribute">opacity</span>: .<span class="number">667</span>;</div><div class="line">  &#125;</div><div class="line">  100% &#123;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(.6);</div><div class="line">    <span class="attribute">opacity</span>: .<span class="number">6</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="selector-id">#toAnimate</span> &#123;</div><div class="line">  <span class="attribute">animation</span>: emphasis <span class="number">700ms</span> ease-in-out <span class="number">10ms</span> infinite alternate forwards;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们将分解这一切，解释每一部会。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> player = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>).animate()</div></pre></td></tr></table></figure><p>动画将返回一个 <strong>Animation</strong>（以前在规范中称为 <strong>AnimationPlayer</strong>）对象，这将给我们做些有趣的事情，所以你可能想要设置一个变量来捕获这个引用。我们找到我们想要的动画元素（这里简单地使用document.getElementById）并调用该<code>animate</code>函数。此功能是新添加的特性，所以如果您必须要测试它的支持性/存在性，在使用它之前或者引用 <a href="https://github.com/web-animations/web-animations-js" target="_blank" rel="external">polyfill</a>。</p><p>该<code>animate</code>函数有两个参数，一个<code>KeyframeEffects</code>和一个<code>AnimationEffectTimingProperties</code>选项的数组。本质上，第一个参数映射到CSS中的内容<code>@keyframe</code>s，第二个参数是您在CSS规则中使用的<code>animation-*</code>属性（或<code>animation</code>简写，如我之前的示例）所指定的那样。这里的主要优点是我们可以使用变量或重用以前定义的<code>KeyframeEffects</code>，而使用CSS我们仅限于我们在前面声明的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> player = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>).animate([</div><div class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(1)'</span>, <span class="attr">opacity</span>: <span class="number">1</span> &#125;,</div><div class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(.5)'</span>, <span class="attr">opacity</span>: <span class="number">.5</span> &#125;,</div><div class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(.667)'</span>, <span class="attr">opacity</span>: <span class="number">.667</span> &#125;,</div><div class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(.6)'</span>, <span class="attr">opacity</span>: <span class="number">.6</span> &#125;</div><div class="line">  ]);</div></pre></td></tr></table></figure><p>对于每一个<code>KeyframeEffect</code>，我们将CSS中的百分比偏移量改为<code>offset</code>从0到1 的十进制值。它是可选的，如果没有指定，它们将均匀分布（因此，如果您有三个，则第一个具有偏移为0，第二个偏移量为.5，第三个偏移量为1）。您还可以指定<code>easing</code>与<code>animation-timing-functionCSS</code>中相同的属性。每个的其他属性<code>KeyframeEffect</code>都是动画的属性。每个属性的值应该符合在JavaScript的<code>element.style</code>中的用法，因此<code>opacity</code>将是一个数字，但<code>transform</code>会期望一个字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> player = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>).animate([], &#123;</div><div class="line">    <span class="attr">duration</span>: <span class="number">700</span>, <span class="comment">//milliseconds</span></div><div class="line">    easing: <span class="string">'ease-in-out'</span>, <span class="comment">//'linear', a bezier curve, etc.</span></div><div class="line">    delay: <span class="number">10</span>, <span class="comment">//milliseconds</span></div><div class="line">    iterations: <span class="literal">Infinity</span>, <span class="comment">//or a number</span></div><div class="line">    direction: <span class="string">'alternate'</span>, <span class="comment">//'normal', 'reverse', etc.</span></div><div class="line">    fill: <span class="string">'forwards'</span> <span class="comment">//'backwards', 'both', 'none', 'auto'</span></div><div class="line">  &#125;);</div></pre></td></tr></table></figure><p>时间属性将映射到CSS动画属性，尽管有时会使用不同的名称。较早的代码示例讨论了主要选项。</p><p>以下是使用<code>polyfill</code>的示例（但如果您正在Chrome 36+，Opera 23+或Firefox 48+中查看，则应使用实际的浏览器实现）。第一列灰色块使用WAAPI动画，第二列红色块使用CSS关键帧进行动画。</p><iframe height="265" scrolling="no" title="CSS Keyframes v. WAAPI" src="//codepen.io/danwilson/embed/QwrZwd/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/QwrZwd/" target="_blank" rel="external">CSS Keyframes v. WAAPI</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><h1 id="下一节…"><a href="#下一节…" class="headerlink" title="下一节…"></a>下一节…</h1><p>现在我们知道如何创建在CSS中熟知的等效动画，我们将开始查看<code>Animation</code> 的 <code>animate</code> 函数返回的对象。这是我们看到真正的功能和改进的地方。</p><p>查看本系列的其余部分：</p><ul><li><a href="https://robin-front.github.io/2017/06/25/animations-intro/">介绍</a></li><li>第1部分：<a href="https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/">创建基本动画</a></li><li>第2部分：<a href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/">动画和时间线控制</a></li><li>第3部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations/">多个动画</a></li><li>第4部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/">GroupEffects和SequenceEffects</a></li><li>第5部分：<a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path/">运动路径</a></li><li><a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Conclusion/">总结与回顾</a></li></ul><p>【翻译原文】： <a href="http://danielcwilson.com/blog/2015/07/animations-part-1/" target="_blank" rel="external">http://danielcwilson.com/blog/2015/07/animations-part-1/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是 Web Animations API 入门教程系列的第1部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与&lt;a href=&quot;https://twitter.com/dancwilson&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@dancwilson&lt;/a&gt;联系。&lt;/p&gt;&lt;p&gt;我们之前初步看了下 Web Animations API，但是我们没有得到任何真正的细节，所以现在我们来看看。&lt;/p&gt;&lt;p&gt;WAAPI（Web Animations API, 以下均简称WAAPI）为您提供更多的控制比您可能已经习惯使用的CSS动画，但在我们进入这些演示之前，我们需要设置基本目标：如何通过此API创建基本动画？
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="Web Animations" scheme="http://robin-front.github.io/tags/Web-Animations/"/>
    
  </entry>
  
  <entry>
    <title>让我们谈谈 Web Animations API</title>
    <link href="http://robin-front.github.io/2017/06/25/animations-intro/"/>
    <id>http://robin-front.github.io/2017/06/25/animations-intro/</id>
    <published>2017-06-25T03:53:30.000Z</published>
    <updated>2017-06-25T03:53:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是 Web Animations API 入门教程系列的总结部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与<a href="https://twitter.com/dancwilson" target="_blank" rel="external">@dancwilson</a>联系。</p><p>2014年夏天，Google宣布通过<a href="https://www.polymer-project.org/0.5/platform/web-animations.html" target="_blank" rel="external">Polymer</a>在网页中展示Material设计…使用polyfill技术支持即将推出的标准Web Animations API。</p><p>我没有听说过这个API，但是我很感兴趣，特别是因为它谈到了<code>MotionPath</code>(运动路径)效果。这还没有实现（你会在<a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path/">第5部分</a>发现这是什么），但是它的目标是提供一种组合CSS，JS和SVG的动画方式，让我感兴趣。一年以后，Chrome和Firefox开始实施，polyfill的进步是稳定的，现在是认真看待它的时候了。</p><p>但是很少有人在谈论WAAPI！我希望开始一系列突出浏览器（和polyfill）功能的帖子，探索为什么我们想要这个API，并找出细微差别。希望我们也能让更多的人讨论和使用这个API。<a id="more"></a></p><h1 id="什么是Web动画API？"><a href="#什么是Web动画API？" class="headerlink" title="什么是Web动画API？"></a>什么是Web动画API？</h1><p>我们将通过弄清楚它是什么，以及它正在努力完成的事情来开始这个探索。</p><p>动画在过去的十年中已经取得了很好的进展，并提供了很好的CSS支持和新增功能来改进JavaScript。但是，每种动画方法仍然对他们所提供的所有优点都有一些缺陷。</p><ul><li>CSS具有用于平滑过渡的硬件加速，并且浏览器内置了支持，但规则在CSS中声明，并且需要跳过JavaScript环节以获得动态更改的值。</li><li><code>requestAnimationFrame</code>有很好的支持，让浏览器在动画时进行优化，但如果还有很多其他JavaScript运行，它仍然可以挂起。它也经常需要更多的数学知识来获得定时。</li><li><code>setInterval</code>被很多开发人员用来做动画，但它是不精确的，可以导致动画卡顿。</li><li><code>jQuery.animate()</code> 被其他一些开发人员推荐制作动画，但往往有性能问题。</li><li>诸如<a href="http://julian.com/research/velocity/" target="_blank" rel="external">Velocity</a>和<a href="http://greensock.com/" target="_blank" rel="external">GreenSock（GSAP）</a>这样的类库可以提高JavaScript的性能，并且在许多情况下已经被测试成为最好的。然而，他们仍然需要维护和加载额外的库。</li></ul><p>一般来说，我们喜欢浏览器的支持尽可能多，直接被优化过的方式。现在浏览器有<code>document.querySelector</code>，因为我们看到jQuery提供选择DOM元素的值。理想情况下，我们可以在浏览器级别包装尽可能多的动画控件。这些库可以专注于提供更新的功能，并且可以持续迭代。</p><p>Web Animations API尝试这样做。它旨在带来CSS性能的强大，增加了JavaScript的好处和灵活性（以及SVG动画，我们将在以后的一篇文章中讨论），并将其留给浏览器使其运行良好。</p><h1 id="让我们通过添加新的东西来解决这个问题！"><a href="#让我们通过添加新的东西来解决这个问题！" class="headerlink" title="让我们通过添加新的东西来解决这个问题！"></a>让我们通过添加新的东西来解决这个问题！</h1><p>在以前的工作中，我们收到一封电子邮件，表示他们知道我们有太多的地方可以查看公司公告 - 电子邮件，办公室的监视器，Yammer，Google Chat和Intranet / wiki。所以要解决他们宣布的问题，他们正在添加一个博客。</p><p>我第一次听到有关Web Animations API 和我听到我公司新增博客的想法一样 - 这只会使事情变得更糟。果然，博客没有集中任何东西，它只是添加了一个地方，我们必须查看新闻，然后不了了之了。</p><p>这感觉不一样。 <a href="https://w3c.github.io/web-animations/" target="_blank" rel="external">审查规范</a>（第一次我在这个程度上真的做到这一点）显示了对此的关注。这并不意味着取代现有的行为（尽管有些浏览器似乎已经<a href="https://www.chromestatus.com/features/5371475380928512" target="_blank" rel="external">不赞成某些行为</a>），而是将各种方式联合起来，并允许他们进行交互。语法类似于CSS，但添加了变量，控制和完成回调的选项。</p><h1 id="下一节…"><a href="#下一节…" class="headerlink" title="下一节…"></a>下一节…</h1><p>因此，Web Animations API是新的，并且开始实现（目前在<a href="https://www.chromestatus.com/features#animations" target="_blank" rel="external">Chrome</a>和<a href="https://birtles.github.io/areweanimatedyet/" target="_blank" rel="external">Firefox</a>中），除了拥有一个polyfill。下次我们实际上会开始看看它为开发者提供了什么…有例子！</p><p>查看本系列的其余部分：</p><ul><li><a href="https://robin-front.github.io/2017/06/25/animations-intro/">介绍</a></li><li>第1部分：<a href="https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/">创建基本动画</a></li><li>第2部分：<a href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/">动画和时间线控制</a></li><li>第3部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations/">多个动画</a></li><li>第4部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/">GroupEffects和SequenceEffects</a></li><li>第5部分：<a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path/">运动路径</a></li><li><a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Conclusion/">总结与回顾</a></li></ul><p>【翻译原文】：<a href="http://danielcwilson.com/blog/2015/07/animations-intro/" target="_blank" rel="external">http://danielcwilson.com/blog/2015/07/animations-intro/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是 Web Animations API 入门教程系列的总结部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与&lt;a href=&quot;https://twitter.com/dancwilson&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@dancwilson&lt;/a&gt;联系。&lt;/p&gt;&lt;p&gt;2014年夏天，Google宣布通过&lt;a href=&quot;https://www.polymer-project.org/0.5/platform/web-animations.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Polymer&lt;/a&gt;在网页中展示Material设计…使用polyfill技术支持即将推出的标准Web Animations API。&lt;/p&gt;&lt;p&gt;我没有听说过这个API，但是我很感兴趣，特别是因为它谈到了&lt;code&gt;MotionPath&lt;/code&gt;(运动路径)效果。这还没有实现（你会在&lt;a href=&quot;https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path/&quot;&gt;第5部分&lt;/a&gt;发现这是什么），但是它的目标是提供一种组合CSS，JS和SVG的动画方式，让我感兴趣。一年以后，Chrome和Firefox开始实施，polyfill的进步是稳定的，现在是认真看待它的时候了。&lt;/p&gt;&lt;p&gt;但是很少有人在谈论WAAPI！我希望开始一系列突出浏览器（和polyfill）功能的帖子，探索为什么我们想要这个API，并找出细微差别。希望我们也能让更多的人讨论和使用这个API。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="Web Animations" scheme="http://robin-front.github.io/tags/Web-Animations/"/>
    
  </entry>
  
  <entry>
    <title>css 动画和 Web Animation API(WAAPI)对比</title>
    <link href="http://robin-front.github.io/2017/06/22/css-animations-vs-web-animations-api/"/>
    <id>http://robin-front.github.io/2017/06/22/css-animations-vs-web-animations-api/</id>
    <published>2017-06-22T09:48:00.000Z</published>
    <updated>2017-06-22T09:48:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>有一个JavaScript的动画原生API，称为<code>Web Animation API</code>。我们在这篇文章中称之为<code>WAAPI</code>。MDN有很好的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API" target="_blank" rel="external">文档</a>，Dan Wilson 有一个伟大的<a href="http://danielcwilson.com/blog/2015/07/animations-part-1/" target="_blank" rel="external">系列文章</a>。</p><p>在本文中，我们将比较WAAPI和CSS中完成的动画。<a id="more"></a></p><h1 id="关于浏览器支持的提示"><a href="#关于浏览器支持的提示" class="headerlink" title="关于浏览器支持的提示"></a>关于浏览器支持的提示</h1><p>尽管现在浏览器的支持很有限，但WAAPI有一个全面而强大的<a href="https://github.com/web-animations/web-animations-js/tree/master" target="_blank" rel="external">polyfill</a>工具，让它可以在当前的生产环境中使用。</p><p>一如既往，您可以检查<a href="http://caniuse.com/#feat=web-animation" target="_blank" rel="external">Can I Use</a> 的浏览器支持数据。然而，这并没有提供非常好的信息来支持WAAPI的所有子功能。这是一个检查器：</p><iframe height="265" scrolling="no" title="WAAPI Browser Support Test" src="//codepen.io/danwilson/embed/xGBKVq/?height=265&theme-id=0&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/xGBKVq/" target="_blank" rel="external">WAAPI Browser Support Test</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><p>想要不使用polyfill而体验所有功能，请使用Firefox Nightly。</p><h1 id="WAAPI的基础知识"><a href="#WAAPI的基础知识" class="headerlink" title="WAAPI的基础知识"></a>WAAPI的基础知识</h1><p>如果您曾经使用<code>jQuery.animate()</code>，WAAPI的基本语法应该看起来很熟悉。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.querySelector(<span class="string">'.animate-me'</span>);</div><div class="line">element.animate(keyframes, <span class="number">1000</span>);</div></pre></td></tr></table></figure><p>该<code>animate</code>方法接受两个参数：关键帧和持续时间。与jQuery不同的是，它不仅具有内置在浏览器中的优点，而且性能也更高。</p><p>第一个参数，关键帧应该是一个对象数组。每个对象都是我们动画中的一个关键帧。这是一个简单的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> keyframes = [</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">0</span> &#125;,</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">1</span> &#125;</div><div class="line">];</div></pre></td></tr></table></figure><p>第二个参数，持续时间，是我们想要动画持续多久。在上面的例子中是1000毫秒。我们来看一个更令人兴奋的例子。</p><h1 id="用WAAPI重新创建animista-CSS动画"><a href="#用WAAPI重新创建animista-CSS动画" class="headerlink" title="用WAAPI重新创建animista CSS动画"></a>用WAAPI重新创建animista CSS动画</h1><p>这里有一些CSS代码，从非常棒的<a href="http://animista.net/" target="_blank" rel="external">animista</a>中吸取了一些称为“幻灯片模糊的”入场动画的东西。看起来很可爱。</p><p><img src="https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_368,f_auto,q_auto/v1496792139/slide-down_ohemtx.gif" alt="实际[效果](http://animista.net/play/entrances/slide-in-blurred)要比这个 GIF 要棒很多"></p><p>以下是CSS中的关键帧：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">0% &#123;</div><div class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-1000px) <span class="built_in">scaleY</span>(2.5) <span class="built_in">scaleX</span>(.2);</div><div class="line">  <span class="attribute">transform-origin</span>: <span class="number">50%</span> <span class="number">0</span>;</div><div class="line">  <span class="attribute">filter</span>: <span class="built_in">blur</span>(40px);</div><div class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">100% &#123;</div><div class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(0) <span class="built_in">scaleY</span>(1) <span class="built_in">scaleX</span>(1);</div><div class="line">  <span class="attribute">transform-origin</span>: <span class="number">50%</span> <span class="number">50%</span>;</div><div class="line">  <span class="attribute">filter</span>: <span class="built_in">blur</span>(0);</div><div class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>WAAPI中的代码相同：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> keyframes = [</div><div class="line">  &#123;</div><div class="line">    <span class="attr">transform</span>: <span class="string">'translateY(-1000px) scaleY(2.5) scaleX(.2)'</span>,</div><div class="line">    <span class="attr">transformOrigin</span>: <span class="string">'50% 0'</span>, <span class="attr">filter</span>: <span class="string">'blur(40px)'</span>, <span class="attr">opacity</span>: <span class="number">0</span></div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="attr">transform</span>: <span class="string">'translateY(0) scaleY(1) scaleX(1)'</span>,</div><div class="line">    <span class="attr">transformOrigin</span>: <span class="string">'50% 50%'</span>,</div><div class="line">    <span class="attr">filter</span>: <span class="string">'blur(0)'</span>,</div><div class="line">    <span class="attr">opacity</span>: <span class="number">1</span></div><div class="line">  &#125;</div><div class="line">];</div></pre></td></tr></table></figure><p>我们已经看到，将关键帧应用到要运动的任何元素是多么容易的事：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">element.animate(keyframes, <span class="number">700</span>);</div></pre></td></tr></table></figure><p>为了简单起见，我只指定了持续时间。但是，我们可以使用这个第二个参数来传递更多的选项。至少我们也应该指定一个缓动函数。以下是可用选项的完整列表，其中包含一些示例值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> options = &#123;</div><div class="line">  <span class="attr">iterations</span>: <span class="literal">Infinity</span>,</div><div class="line">  <span class="attr">iterationStart</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">delay</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">endDelay</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">direction</span>: <span class="string">'alternate'</span>,</div><div class="line">  <span class="attr">duration</span>: <span class="number">700</span>,</div><div class="line">  <span class="attr">fill</span>: <span class="string">'forwards'</span>,</div><div class="line">  <span class="attr">easing</span>: <span class="string">'ease-out'</span>,</div><div class="line">&#125;</div><div class="line">element.animate(keyframes, options);</div></pre></td></tr></table></figure><p>有了这些选项，我们的动画将从头开始，没有任何延迟，永远循环在向前和向后播放。</p><iframe height="265" scrolling="no" title="motion blur waapi circle" src="//codepen.io/cssgrid/embed/EmBGxG/?height=265&theme-id=0&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/cssgrid/pen/EmBGxG/" target="_blank" rel="external">motion blur waapi circle</a> by CSS GRID (<a href="https://codepen.io/cssgrid" target="_blank" rel="external">@cssgrid</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><p>令人烦恼的是，对于我们熟悉CSS动画的人来说，一些术语与我们习惯的不同。虽然在积极的一面看，有些事情写起来更快一点！</p><ul><li>这里用<code>easing</code>而不是<code>animation-timing-function</code></li><li>使用<code>iterations</code>而不是<code>animation-iteration-count</code>。如果我们希望动画永远重复，用<code>Infinity</code>而不是<code>infinite</code>。有点混乱，<code>Infinity</code>不是引用。Infinity是一个JavaScript关键字，而其他值是字符串。</li><li>我们使用毫秒而不是秒，对于之前编写过许多JavaScript的人来说，这应该是熟悉的。（您可以在CSS动画中使用毫秒数，但很少有人使用。）</li></ul><p>我们来仔细看看一个选项：<code>iterationStart</code>。</p><p>当我第一次碰到<code>iterationStart</code>, 我被难住了。你为什么要指定迭代的开始，而不仅仅是减少迭代次数？当您使用十进制数时，此选项非常有用。例如，您可以将其设置为 <code>.5</code>，动画将开始一半。要做一整个动画需要两半，所以如果你的迭代次数设置为1，并且你的<code>iterationStart</code>设置为 <code>.5</code>，动画将从一半到动画结束播放，然后从动画开头开始，结束于中间！</p><p>值得注意的是，您也可以将迭代次数设置为小于1。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> option = &#123;</div><div class="line">  <span class="attr">iterations</span>: <span class="number">.5</span>,</div><div class="line">  <span class="attr">iterationStart</span>: <span class="number">.5</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这将从中间到最后播放动画。 <code>endDelay：endDelay</code>如果要将多个动画串在一起，但是希望在一个动画的结尾和任何后续动画的开始之间存在差距。这是一个有用的视频，Patrick Brosset 的解释。</p><div style="position:relative;height:0;padding-bottom:56.22%"><iframe src="https://www.youtube.com/embed/hWe-qukNrN8?ecver=2" style="position:absolute;width:100%;height:100%;left:0" width="640" height="360" frameborder="0" allowfullscreen></iframe></div><h1 id="缓动"><a href="#缓动" class="headerlink" title="缓动"></a>缓动</h1><p>缓动是任何动画中最重要的元素之一。WAAPI为我们提供了两种不同的方式设置缓动函数 - 在我们的关键帧阵列或我们的选项对象内。 在CSS中，如果你应用了，<code>animation-timing-function: ease-in-out</code>你可能会假设你的动画的开始会<code>ease in</code>，动画的结束将会<code>ease out</code>。实际上，这些缓动函数应用在关键帧之间，而不是整个动画。这可以对动画的感觉进行细粒度的控制。WAAPI还提供这种能力。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> keyframes = [</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">0</span>, <span class="attr">easing</span>: <span class="string">'ease-in'</span> &#125;,</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">0.5</span>, <span class="attr">easing</span>: <span class="string">'ease-out'</span> &#125;,</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">1</span> &#125;</div><div class="line">]</div></pre></td></tr></table></figure><p>值得注意的是，在CSS和WAAPI中，您不应该传入最后一帧的缓动值，因为这将不起作用。这是很多人犯的错误。 有时候，在整个动画中添加缓动效果更为直观。这在CSS是不可能的，但现在可以实现与WAAPI。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> options = &#123;</div><div class="line">  <span class="attr">duration</span>: <span class="number">1000</span>,</div><div class="line">  <span class="attr">easing</span>: <span class="string">'ease-in-out'</span>,</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>你可以看到这两种缓动在CodePen上的区别：</p><iframe height="265" scrolling="no" title="Same animation, different easing" src="//codepen.io/cssgrid/embed/OmrVeQ/?height=265&theme-id=0&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/cssgrid/pen/OmrVeQ/" target="_blank" rel="external">Same animation, different easing</a> by CSS GRID (<a href="https://codepen.io/cssgrid" target="_blank" rel="external">@cssgrid</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><h1 id="ease-vs-linear"><a href="#ease-vs-linear" class="headerlink" title="ease vs linear"></a>ease vs linear</h1><p>值得注意的是CSS动画和WAAPI之间的另一个区别：CSS ease的默认值是<code>ease</code>,WAAPI的默认值<code>linear</code>。 <code>Ease</code>实际上是一个版本，<code>ease-in-out</code>是一个非常好的选择，如果你感到懒惰。同时，<code>linear</code> 是沉闷的和无生机的 - 一致的速度看起来机械和不自然。它被选为默认值，可能因为它是最中立的选项。然而，在WAAPI中使用时，使用缓动比在CSS更重要，以免您的动画看起来很乏味和机械地。</p><h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>WAAPI提供与CSS动画相同的性能改进，尽管这并不意味着平滑的动画是不可避免的。</p><p>我希望这个API的性能优化意味着我们可以避免使用<code>will-change</code>和完全hack <code>translateZ</code> - 最终可能。但是，至少在目前的浏览器实现中，这些属性在处理闪烁问题（<code>jank issue</code>）方面仍然是有帮助和必要的。</p><p>但是，至少如果您的动画有延迟，则无需担心使用<code>will-change</code>。网络动画规范的主要作者对“<a href="https://damp-lake-50659.herokuapp.com/" target="_blank" rel="external">Animation for Work Slack community</a>”提出了一些有趣的建议，希望他不介意我在这里重复：</p><blockquote><p>如果您有一个积极的延迟，您不需要<code>will-change</code>因为浏览器将在延迟开始时进行分层，当动画启动时，它将准备就绪。</p></blockquote><h1 id="WAAPI对战CSS动画？"><a href="#WAAPI对战CSS动画？" class="headerlink" title="WAAPI对战CSS动画？"></a>WAAPI对战CSS动画？</h1><p>WAAPI为我们提供了一个在JavaScript中实现css中的语法。然而，他们不应该被视为对手。如果我们决定坚持使用CSS进行<code>animations</code>和<code>transitions</code>，那么我们可以与WAAPI进行动画交互。</p><h1 id="Animation-对象"><a href="#Animation-对象" class="headerlink" title="Animation 对象"></a>Animation 对象</h1><p>该<code>.animate()</code>方法不仅仅是动画我们的元素，它也返回一些东西。</p><p><img src="https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1000,f_auto,q_auto/v1496519294/animationobject_ujevsk.png" alt="在控制台中查看的动画对象"></p><p>如果我们看看控制台中的返回值，我们将看到它的一个动画对象。这为我们提供了各种各样的功能，其中一些是非常不言自明的<code>myAnimation.pause()</code>。通过更改<code>animation-play-state</code>属性，我们可以通过CSS动画实现类似的结果，但WAAPI语法比稍微简单<code>element.style.animationPlayState = &quot;paused&quot;</code>。我们也有权力轻松地扭转我们的动画<code>myAnimation.reverse()</code>，再次，<code>animation-direction</code>与使用我们的脚本更改CSS属性相比，稍微有点改进。</p><p>然而，到目前为止，<code>@keyframe</code>用JavaScript进行操作并不是世界上最简单的事情。即使像重新启动动画一样简单，就像Chris Coyier 先前<a href="https://css-tricks.com/restart-css-animation/" target="_blank" rel="external">写过的</a>那样，这个技巧也有<a href="https://css-tricks.com/restart-css-animation/" target="_blank" rel="external">一些技巧</a>。使用WAAPI，我们可以简单地使用<code>myAnimation.play()</code>，它从一开始就重播动画，如果它已经完成，或者如果我们暂停播放，则从中间迭代继续播放动画。</p><p>我们甚至可以轻松地改变动画的速度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myAnimation.playbackRate = <span class="number">2</span>; <span class="comment">// speed it up</span></div><div class="line">myAnimation.playbackRate = <span class="number">.4</span>; <span class="comment">// use a number less than one to slow it down</span></div></pre></td></tr></table></figure><h1 id="getAnimations（）"><a href="#getAnimations（）" class="headerlink" title="getAnimations（）"></a>getAnimations（）</h1><p>此方法将返回任何动画对象的数组，以便我们使用WAAPI定义的任何动画以及 <em>任何CSS <code>transitions</code>或<code>animations</code></em>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">element.getAnimations() <span class="comment">// returns any animations or transitions applied to our element using CSS or WAAPI</span></div></pre></td></tr></table></figure><p>如果您感觉使用CSS来定义和应用您的动画比较顺手，<code>getAnimations()</code>可以使用API​​与<code>@keyframes</code> 结合使用。您可以继续使用CSS进行大部分动画工作，并在需要API时获得API的优势。让我们看看这是多么简单。</p><p>即使一个DOM元素只有一个动画应用到它，<code>getAnimations()</code>也将始终返回一个数组。我们来抓住那个单一的动画对象来处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> h2 = <span class="built_in">document</span>.querySelector(<span class="string">"h2"</span>);</div><div class="line"><span class="keyword">var</span> myCSSAnimation = h2.getAnimations()[<span class="number">0</span>];</div></pre></td></tr></table></figure><p>现在我们可以在我们的CSS动画中使用web animation API :)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myCSSAnimation.playbackRate = <span class="number">4</span>;</div><div class="line">myCSSAnimation.reverse();</div></pre></td></tr></table></figure><h1 id="Promise和事件"><a href="#Promise和事件" class="headerlink" title="Promise和事件"></a>Promise和事件</h1><p>我们已经有多种通过CSS触发的事件，我们可以在我们的JavaScript代码利用的有：<code>animationstart</code>，<code>animationend</code>，<code>animationiteration</code>和<code>transitionend</code>。我经常需要收听<code>animations</code>或<code>transitions</code>的结束，以便从DOM中删除应用于它的元素。</p><p>在WAAPI 中使用<code>animationend</code>或<code>transitionend</code>为此目的相当于再次使用动画对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">myAnimation.onfinish = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  element.remove();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>WAAPI为我们提供了事件和Promise的选择。我们的动画的<code>.finished</code>属性对象将在动画结束时返回一个resolve 的 Promise。以下是上面的例子，就像使用Promise一样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myAnimation.finished.then(<span class="function"><span class="params">()</span> =&gt;</span></div><div class="line">  element.remove())</div></pre></td></tr></table></figure><p>我们来看看Mozilla开发人员网络中的一个稍微有点省略的例子。<code>Promise.all</code>接收一个Promise数组，一旦所有这些Promise得到解决，才会运行我们的回调函数。我们已经看到，<code>element.getAnimations()</code>返回一个动画对象数组。我们可以将数组中的所有动画对象映射到每个动画对象<code>.finished</code>上，为我们提供所需的Promise数组。</p><p>在这个例子中，只有在页面上的所有动画完成后，我们的函数才能运行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.all(<span class="built_in">document</span>.getAnimations().map(<span class="function"><span class="params">animation</span> =&gt;</span></div><div class="line">  animation.finished)).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;           </div><div class="line">    <span class="comment">// do something cool</span></div><div class="line">  &#125;);</div></pre></td></tr></table></figure><h1 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h1><p>本文中提到的功能只是开始。目前的规范和实践看起来是一件伟大的事情的开始。</p><p>「翻譯原文」：<a href="https://css-tricks.com/css-animations-vs-web-animations-api/?utm_source=frontendfocus" target="_blank" rel="external">https://css-tricks.com/css-animations-vs-web-animations-api/?utm_source=frontendfocus</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一个JavaScript的动画原生API，称为&lt;code&gt;Web Animation API&lt;/code&gt;。我们在这篇文章中称之为&lt;code&gt;WAAPI&lt;/code&gt;。MDN有很好的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文档&lt;/a&gt;，Dan Wilson 有一个伟大的&lt;a href=&quot;http://danielcwilson.com/blog/2015/07/animations-part-1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;系列文章&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;在本文中，我们将比较WAAPI和CSS中完成的动画。
    
    </summary>
    
      <category term="css" scheme="http://robin-front.github.io/categories/css/"/>
    
    
      <category term="Web Animations" scheme="http://robin-front.github.io/tags/Web-Animations/"/>
    
      <category term="css3" scheme="http://robin-front.github.io/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>webpack3官方正式发布,亮点:作用域提升，“魔法注释”，以及更多新特性！</title>
    <link href="http://robin-front.github.io/2017/06/21/webpack3-publish-scope-hoisting-magic-comments-and-more/"/>
    <id>http://robin-front.github.io/2017/06/21/webpack3-publish-scope-hoisting-magic-comments-and-more/</id>
    <published>2017-06-21T07:35:55.000Z</published>
    <updated>2017-06-22T07:35:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="作用域提升，“魔法注释”，以及更多新特性！"><a href="#作用域提升，“魔法注释”，以及更多新特性！" class="headerlink" title="作用域提升，“魔法注释”，以及更多新特性！"></a>作用域提升，“魔法注释”，以及更多新特性！</h1><p><a href="https://medium.com/webpack/webpack-3-official-release-15fd2dd8f07b" target="_blank" rel="external">原文</a></p><p>在我们发布了 webpack v2 之后，我们曾向社区做了一些承诺。 我们承诺，我们将提供用户投票的功能。 此外，我们承诺我们的发布周期会 <strong>更快，更稳定</strong>。</p><p>这次没有 beta 版本，完全向下兼容。我们承诺让你们、让 webpack 成长的社区更轻松的使用。webpack 团队自豪地宣布，今天我们已经发布了 webpack 3.0.0！ 现在就可以下载或升级！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install webpack@3.0.0 --save-dev</div></pre></td></tr></table></figure><p>或者使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yarn add webpack@3.0.0 --dev</div></pre></td></tr></table></figure><p><em>从 webpack 2 迁移到 3，只需要执行升级命令，在使用上没有任何差别。我们将这次升级标记为版本的重大升级，是因为内部的突破性变化可能会影响某些插件的使用。</em></p><p><strong>到目前为止，98%的升级的用户都没有遇到任何不兼容！</strong><a id="more"></a></p><h1 id="有哪些新特性"><a href="#有哪些新特性" class="headerlink" title="有哪些新特性?"></a>有哪些新特性?</h1><p>像上文提到的一样，我们发布了一些由用户投票选出的功能，感谢 Github，赞助商和我们的支持者，有了他们我们才能做出每一个改进。😍</p><h2 id="🔬作用域提升（Scope-Hoisting）🔬"><a href="#🔬作用域提升（Scope-Hoisting）🔬" class="headerlink" title="🔬作用域提升（Scope Hoisting）🔬"></a>🔬作用域提升（Scope Hoisting）🔬</h2><p>作用域提升是 webpack 3 的重点功能。之前 webpack 在打包时，您的 bundle 中的每个模块都将被包装在单独的函数闭包中。这些闭包会使您的 JavaScript 在浏览器中执行速度更慢。相比之下，像 Closure Compiler 和 RollupJS 这样的工具可以将所有模块包装在一个大的闭包内，从而使您的代码在浏览器中具有更快的执行速度。</p><p></p><blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">70K =&gt; 37K (gzip!) savings on our main bundle using <a href="https://twitter.com/hashtag/webpack?src=hash" target="_blank" rel="external">#webpack</a> 3 RC.2 + ModuleConcatenationPlugin 😲 🔥 Awesome work <a href="https://twitter.com/TheLarkInn" target="_blank" rel="external">@TheLarkInn</a> <a href="https://twitter.com/wSokra" target="_blank" rel="external">@wSokra</a> et al! <a href="https://t.co/zVfQoivT9d" target="_blank" rel="external">pic.twitter.com/zVfQoivT9d</a></p>&mdash; Jeremy Gayed 🤓 (@tizmagik) <a href="https://twitter.com/tizmagik/status/876128847682523138" target="_blank" rel="external">June 17, 2017</a></blockquote><p></p><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script><p>而现在，使用 webpack 3，您现在可以 <strong>在配置中添加下面的插件以启用作用域提升</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">  <span class="attr">plugins</span>: [</div><div class="line">    <span class="keyword">new</span> webpack.optimize.ModuleConcatenationPlugin()</div><div class="line">  ]</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>作用域提升是基于 ECMAScript Module 语法实现的一个特征。通过这个，webpack 可以根据你正在使用什么样的模块和<a href="https://medium.com/webpack/webpack-freelancing-log-book-week-5-7-4764be3266f5" target="_blank" rel="external">一些其他条件</a>来回退到正常的捆绑。</p><p>为了了解什么触发了这些回退，我们添加了一个 <code>--display-optimization-bailout</code>cli 标志，它将告诉你是什么导致的回退。</p><p></p><blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Total evaluation script time went from 2.52s to 2.06s, first meaningful paint from 3.43s to 2.70s and all initial event fired 20% earlier</p>&mdash; Jeremias Menichelli (@jeremenichelli) <a href="https://twitter.com/jeremenichelli/status/876527176606265344" target="_blank" rel="external">June 18, 2017</a></blockquote><p></p><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script><p>同时，由于作用域提升会移除模块外的函数包装，你可能会看到一些小的体积改进。然而，更显着的改进是JavaScript在浏览器中加载的速度。 如果您在比较使用之前和之后时发现加载速度取得了非常棒的改进，请随时回复一些数据，我们将很荣幸分享！</p><h2 id="🔮-魔法注释-”Magic-Comments”-🔮"><a href="#🔮-魔法注释-”Magic-Comments”-🔮" class="headerlink" title="🔮 魔法注释 ”Magic Comments” 🔮"></a>🔮 魔法注释 ”Magic Comments” 🔮</h2><p>当我们在webpack 2中引入使用动态导入语法（<code>import()</code>）时，用户表示，他们不能像使用 <code>require.ensure</code> 一样创建命名 chunk。我们现在介绍由社区创建的“魔法注释”，它可以传递 chunk 名称，还有<a href="https://medium.com/webpack/how-to-use-webpacks-new-magic-comment-feature-with-react-universal-component-ssr-a38fd3e296a" target="_blank" rel="external">更多功能</a>，例如可以添加更多的内联注释到 <code>import()</code> 语句中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "my-chunk-name" */</span> <span class="string">'module'</span>);</div></pre></td></tr></table></figure><p>通过使用注释，我们能够在使用动态导入语法的同时，对代码块进行命名。</p><p>尽管这是我们在 v2.4 和 v2.6 中发布的技术特性，但在 v3 中，我们修复了这些功能的一些错误，使其变得更稳定。 同时，现在允许动态导入语法具有与 <code>require.ensure</code> 相同的灵活性。</p><p></p><blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">TIL webpack /<em>chunkName</em>/ comments aren&#39;t just for nicer filenames—also great for organizing your chunks. Even interops w/ commonsChunk! <a href="https://t.co/wjdT9y6oTE" target="_blank" rel="external">pic.twitter.com/wjdT9y6oTE</a></p>&mdash; Adam Rackis (@AdamRackis) <a href="https://twitter.com/AdamRackis/status/872602076056088576" target="_blank" rel="external">June 7, 2017</a></blockquote><p></p><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script><p>要了解更多信息，请参阅我们<a href="https://webpack.js.org/guides/code-splitting-async" target="_blank" rel="external">最新文档的代码分割部分</a>，文档高亮了这些新功能！</p><h2 id="😍-接下来是什么？😍"><a href="#😍-接下来是什么？😍" class="headerlink" title="😍 接下来是什么？😍"></a>😍 接下来是什么？😍</h2><p>我们有很多功能和增强功能想要推出！但我们需要了解用户需求的优先级。所以访问我们的<a href="http://webpack.js.org/vote" target="_blank" rel="external">投票页面</a>，并提出你想看到的功能！</p><p>这些是我们希望带给您的一些功能：</p><ul><li>更好地构建缓存</li><li>更快的初始构建和增量构建</li><li>更好的TypeScript体验</li><li>改进长期缓存</li><li>WASM模块支持</li><li>改善用户体验</li></ul><h2 id="🙇-致谢-🙇"><a href="#🙇-致谢-🙇" class="headerlink" title="🙇 致谢 🙇"></a>🙇 致谢 🙇</h2><p>感谢我们所有的用户，贡献者，文档作者，博客，赞助商，支持者和维护者。是他们都帮助我们确保 webpack 在未来几年成功。</p><p>为此，我们感谢所有人。webpack 发展到现在与你的支持密不可分，我们迫不及待地想要与你分享未来 webpack 的新进展！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;作用域提升，“魔法注释”，以及更多新特性！&quot;&gt;&lt;a href=&quot;#作用域提升，“魔法注释”，以及更多新特性！&quot; class=&quot;headerlink&quot; title=&quot;作用域提升，“魔法注释”，以及更多新特性！&quot;&gt;&lt;/a&gt;作用域提升，“魔法注释”，以及更多新特性！&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://medium.com/webpack/webpack-3-official-release-15fd2dd8f07b&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;&lt;p&gt;在我们发布了 webpack v2 之后，我们曾向社区做了一些承诺。 我们承诺，我们将提供用户投票的功能。 此外，我们承诺我们的发布周期会 &lt;strong&gt;更快，更稳定&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;这次没有 beta 版本，完全向下兼容。我们承诺让你们、让 webpack 成长的社区更轻松的使用。webpack 团队自豪地宣布，今天我们已经发布了 webpack 3.0.0！ 现在就可以下载或升级！&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;npm install webpack@3.0.0 --save-dev&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;或者使用&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;yarn add webpack@3.0.0 --dev&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;em&gt;从 webpack 2 迁移到 3，只需要执行升级命令，在使用上没有任何差别。我们将这次升级标记为版本的重大升级，是因为内部的突破性变化可能会影响某些插件的使用。&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;到目前为止，98%的升级的用户都没有遇到任何不兼容！&lt;/strong&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="webpack" scheme="http://robin-front.github.io/tags/webpack/"/>
    
      <category term="前端构建" scheme="http://robin-front.github.io/tags/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Flow和TypeScript之间的区别和优劣</title>
    <link href="http://robin-front.github.io/2017/06/14/compare-with-Flow-and-TypeScript/"/>
    <id>http://robin-front.github.io/2017/06/14/compare-with-Flow-and-TypeScript/</id>
    <published>2017-06-14T15:28:54.000Z</published>
    <updated>2017-06-14T15:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>采用Flow＆TypeScript, 两者上手流程之间的比较。</p><p>让我们想象一下我们想要采用一种类型检查器的场景…</p><p>本文译自： <a href="http://thejameskyle.com/adopting-flow-and-typescript.html" target="_blank" rel="external">adopting flow and typescript</a><a id="more"></a></p><p>最近我们已经注意到了我们的应用程序中的很多NaN的出现。我们搜索源代码并找到以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// math.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n;</div><div class="line">&#125;</div><div class="line">square(<span class="string">"oops"</span>);</div></pre></td></tr></table></figure><p>我们对自己叹了口气，也许决定添加一个类型检查器。我们退后一步，查看我们的选项： <a href="https://flow.org/" target="_blank" rel="external">Flow</a> 或 <a href="http://www.typescriptlang.org/" target="_blank" rel="external">TypeScript</a>。</p><p>这两个工具都有相当简单的方法给逐个文件应用：</p><ul><li>Flow: <code>// @flow</code> 向文件顶部添加注释</li><li>TypeScript：将扩展名更改为<code>.js</code>扩展<code>.ts</code> 名</li></ul><p>但是让我们比较一下这里面发生了什么。</p><h3 id="采用TypeScript"><a href="#采用TypeScript" class="headerlink" title="采用TypeScript"></a>采用TypeScript</h3><p>要采用TypeScript，我们首先重命名<code>math.js</code>为 <code>math.ts</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// math.ts</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n;</div><div class="line">&#125;</div><div class="line">square(<span class="string">"oops"</span>);</div></pre></td></tr></table></figure><p>现在我们将运行typescript：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(no errors)</div></pre></td></tr></table></figure><p>没有错误，是因为TypeScript要求我们给函数键入注释，然后才会根据注释检查类型。如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n: number</span>): <span class="title">number</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n;</div><div class="line">&#125;</div><div class="line">square(<span class="string">"oops"</span>);</div></pre></td></tr></table></figure><p>如果没有这些类型，TypeScript将根据您的配置执行下面两件事情之一：</p><ul><li><ol><li>隐含地将每个未知类型转换为<code>any</code>。这种任何类型将让您退出所有类型检查。</li></ol></li><li><ol><li>或者如果您使用了<code>--noImplicitAny</code>选项，它会为任何未知类型抛出错误，指明需要添加类型注释。</li></ol></li></ul><p>这意味着TypeScript 覆盖的代码量与您所写的类型相关。写入类型时，类型coverage将线性上升。</p><h3 id="类型覆盖（type-coverage）"><a href="#类型覆盖（type-coverage）" class="headerlink" title="类型覆盖（type coverage）"></a>类型覆盖（type coverage）</h3><p>在我们进一步讲解之前，我应该解释一下什么是类型覆盖。</p><p><img src="http://thejameskyle.com/img/type-coverage.png" alt="未有类型覆盖的代码用红色显示"></p><p>未有类型覆盖的代码用红色显示</p><p>如果你看到你的代码中的值和表达式，并问类型检查器“你知道这是什么类型吗”。</p><p>如果类型检查器知道它类型，则覆盖该值或表达式。如果类型检查器不知道类型，那么它没有被覆盖。</p><p>您希望您的程序尽可能多地提供类型覆盖，因为这样可以在更多地方抛出错误时提前告诉您。</p><p>没有类型覆盖，类型检查器什么都不是。</p><h3 id="采用Flow"><a href="#采用Flow" class="headerlink" title="采用Flow"></a>采用Flow</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// @flow</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n;</div><div class="line">&#125;</div><div class="line">square(<span class="string">"oops"</span>);</div></pre></td></tr></table></figure><p>然后我们将运行Flow并查看结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n;</div><div class="line">         ^   ^</div><div class="line">         <span class="built_in">Error</span> (x2)</div><div class="line">&#125;</div><div class="line">square(<span class="string">"oops"</span>);</div><div class="line"></div><div class="line"><span class="built_in">Error</span> (x2)</div><div class="line">string. The operand <span class="keyword">of</span> an arithmetic operation must be a number.</div></pre></td></tr></table></figure><p>紧接着就抛出了类型错误，告诉我们代码出了问题。</p><p>Flow 只需要我们键入文件和外部模块的导出。可以推测出其他一切。</p><p>这使得类型覆盖率快得多。只需几种类型，您可以快速获取具有非常高类型覆盖率的文件。</p><p>根据我的经验，我可以在短短几分钟内将文件覆盖约70-90％。</p><p>这是一个非常科学的差异图：</p><p><img src="http://thejameskyle.com/img/adopting-flow-and-typescript-graph.png" alt=""></p><p>这不是我一家之言，你可以自己尝试一下，看看几种类型的区别。</p><p>要查看Flow中文件的类型覆盖，可以运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flow coverage path/to/file.js --color</div></pre></td></tr></table></figure><p>您还可以使用 <a href="https://github.com/rpl/flow-coverage-report" target="_blank" rel="external">流量报告</a> 来帮助您。</p><blockquote><p>注意：我没有注意到TypeScript 有任何的类型报告工具（如果您知道一个，请给我发送一个链接）。但是，您可以测试代码是否覆盖，以确定当您出现错误时是否会报告错误。</p></blockquote><h3 id="这个的工作原理是什么"><a href="#这个的工作原理是什么" class="headerlink" title="这个的工作原理是什么"></a>这个的工作原理是什么</h3><p>这两种工具具有不同行为的原因归结于其架构之间的区别。</p><h4 id="TypeScript体系结构：AST导向"><a href="#TypeScript体系结构：AST导向" class="headerlink" title="TypeScript体系结构：AST导向"></a>TypeScript体系结构：AST导向</h4><p>TypeScript将遍历您的程序并构建已知类型的表。当它发现值和表达式时，它会立即为其分配类型。当TypeScript发现一个未知的类型时，它必须立即作出决定，这意味着将其分配给<code>any</code>或抛出错误。</p><h4 id="Flow-架构：图形导向"><a href="#Flow-架构：图形导向" class="headerlink" title="Flow 架构：图形导向"></a>Flow 架构：图形导向</h4><p>Flow 将建立一个你所有的值和表达式及其彼此之间的关系的图表。然后，它将开始为每个值和表达式分配类型。如果它找到一个未知的类型，它将使它成为一个“开放”类型，稍后再回来判断。</p><p>一旦Flow具有您的程序的完整蓝图，它将开始连接所有点，从一个值连接到另一个值地跟踪类型。打开类型接受流入它们的所有值的类型 - 生成的类型称为 “推断类型”。</p><p>你可以看这个是怎么回事。来看看我们在之前的类型错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n;</div><div class="line">         ^   ^</div><div class="line">         <span class="built_in">Error</span> (x2)</div><div class="line">&#125;</div><div class="line">square(<span class="string">"oops"</span>);</div><div class="line"></div><div class="line"><span class="built_in">Error</span> (x2)</div><div class="line">string. The operand <span class="keyword">of</span> an arithmetic operation must be a number.</div></pre></td></tr></table></figure><p>注意错误是指向<code>n * n</code>而不是 <code>square(&quot;oops&quot;)</code>。因为我们没有写入一个类型为n的 “oops”字符串流入它，并且Flow开始检查n，就好像它是一个字符串。</p><p>添加类型注释我们可以看到错误点移动了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n: number</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n;</div><div class="line">&#125;</div><div class="line">square(<span class="string">"oops"</span>);</div><div class="line">       ^ <span class="built_in">Error</span></div><div class="line"></div><div class="line"><span class="built_in">Error</span>: string.</div><div class="line">This type is incompatible <span class="keyword">with</span> the expected param type <span class="keyword">of</span> number.</div></pre></td></tr></table></figure><p>这提出了一个重要的一点：Flow可以在任何地方自动推断类型并不意味着你不应该添加类型注释你的代码。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>TypeScript和Flow都有非常好的上手过程。一个个文件地尝试是一个很好的经历。</p><p>但是，如果使用Flow，你就会有更高以及更快的覆盖类型，你就可以安心睡觉。</p><p>使用Flow，您可以添加类型以使错误更友好，而不仅只是发现它们。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;采用Flow＆TypeScript, 两者上手流程之间的比较。&lt;/p&gt;&lt;p&gt;让我们想象一下我们想要采用一种类型检查器的场景…&lt;/p&gt;&lt;p&gt;本文译自： &lt;a href=&quot;http://thejameskyle.com/adopting-flow-and-typescript.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;adopting flow and typescript&lt;/a&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="Flow" scheme="http://robin-front.github.io/tags/Flow/"/>
    
      <category term="TypeScript" scheme="http://robin-front.github.io/tags/TypeScript/"/>
    
  </entry>
  
</feed>
