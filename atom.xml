<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>三寸稚笔</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://robin-front.github.io/"/>
  <updated>2017-06-27T03:24:55.000Z</updated>
  <id>http://robin-front.github.io/</id>
  
  <author>
    <name>robin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Web Animations API 入门教程第4部分: GroupEffects &amp; SequenceEffects</title>
    <link href="http://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/"/>
    <id>http://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/</id>
    <published>2017-06-27T03:24:55.000Z</published>
    <updated>2017-06-27T03:24:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是 Web Animations API 入门教程系列的第3部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与<a href="https://twitter.com/dancwilson" target="_blank" rel="external">@dancwilson</a>联系。</p>
<p>让我们继续讨论Web动画API中的多个动画，通过讨论今天在polyfill中提供的几个部分来提供分组和排序。
<a id="more"></a></p>
<h1 id="KeyframeEffects"><a href="#KeyframeEffects" class="headerlink" title="KeyframeEffects"></a>KeyframeEffects</h1><p>A KeyframeEffect需要三个参数：动画元素(element)，关键帧数组(keyframes)和时间选项(timing options)。这些都是我们以前使用过的参数<code>element.animate()</code>。这个新对象本质上是单个动画的蓝图，当我们讨论分组(group)和队列(sequence)动画的方法时，我们会看到它。它不启动动画，它只是定义动画。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>);</div><div class="line"><span class="keyword">var</span> timings = &#123;</div><div class="line">  <span class="attr">duration</span>: <span class="number">1000</span>,</div><div class="line">  <span class="attr">fill</span>: <span class="string">'both'</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> keyframes = [</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">1</span> &#125;.</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">0</span> &#125;</div><div class="line">];</div><div class="line"></div><div class="line"><span class="keyword">var</span> effect = <span class="keyword">new</span> KeyframeEffect(elem, keyframes, timings);</div></pre></td></tr></table></figure>
<h1 id="GroupEffects"><a href="#GroupEffects" class="headerlink" title="GroupEffects"></a>GroupEffects</h1><p>虽然在任何浏览器中都没有实现此功能，甚至在Level 2规范中找不到，但是polyfill提供了一种组合动画并将其一起播放的方法。 <strong>GroupEffect</strong>（是的，它是未来将集成在Level 2规范）组合一个或多个KeyframeEffects同时播放。</p>
<iframe height="265" scrolling="no" title="Group Effects with WAAPI" src="//codepen.io/danwilson/embed/zGeVey/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/danwilson/pen/zGeVey/" target="_blank" rel="external">Group Effects with WAAPI</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.
</iframe>

<p>一个<code>GroupEffect</code>任务需要一个<code>Effects</code>参数，我们可以传递代表我们多个动画的<code>KeyframeEffect</code>数组。一旦定义，我们可以在准备好的时候在默认时间轴上播放动画组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>);</div><div class="line"><span class="keyword">var</span> elem2 = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate2'</span>);</div><div class="line"><span class="keyword">var</span> timings = &#123;</div><div class="line">  <span class="attr">duration</span>: <span class="number">1000</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> keyframes = [</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">1</span> &#125;.</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">0</span> &#125;</div><div class="line">];</div><div class="line"></div><div class="line"><span class="keyword">var</span> kEffects = [</div><div class="line">  <span class="keyword">new</span> KeyframeEffect(elem, keyframes, timings),</div><div class="line">  <span class="keyword">new</span> KeyframeEffect(elem2, keyframes, timings)</div><div class="line">];</div><div class="line"><span class="keyword">var</span> group = <span class="keyword">new</span> GroupEffect(kEffects);</div><div class="line"><span class="built_in">document</span>.timeline.play(group);</div></pre></td></tr></table></figure>
<h1 id="SequenceEffects"><a href="#SequenceEffects" class="headerlink" title="SequenceEffects"></a>SequenceEffects</h1><p>类似于<code>GroupEffect</code>，<code>SequenceEffect</code>允许我们将多个动画（由<code>KeyframeEffects</code> 指定）组合在一起…不是并行播放它们，而是一个接一个地播放它们。您也可以按照polyfill中的定义将<code>GroupEffect</code>和<code>SequenceEffect</code>一起使用（例如具有多个序列的分组）。</p>
<iframe height="265" scrolling="no" title="SequenceEffect with WAAPI" src="//codepen.io/danwilson/embed/vNYQLL/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/danwilson/pen/vNYQLL/" target="_blank" rel="external">SequenceEffect with WAAPI</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.
</iframe>

<p>队列提供给你一些我们必须用CSS或者我们在 animations API中看到的东西。我们必须根据早期动画的持续时间或使用 <strong>finish</strong> 回调来维持延迟。这些方法可能难以维护，或者不会如此精确。</p>
<p>使用先前在<code>GroupEffect</code>代码段中的变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sequence = <span class="keyword">new</span> SequenceEffect(kEffects);</div><div class="line"><span class="built_in">document</span>.timeline.play(sequence);</div></pre></td></tr></table></figure>
<h1 id="创建动画的备用方法"><a href="#创建动画的备用方法" class="headerlink" title="创建动画的备用方法"></a>创建动画的备用方法</h1><p>我们以前看过<code>element.animate()</code>创建动画的方式。这是创建动画的快捷方式，立即播放，并获取<code>Animation</code>对象的引用。我们专注于这一点，因为Chrome支持了一段时间了，polyfill也是。Firefox是第一个支持替代方式的：·构造函数。它向我们展示了另一种使用方法<code>KeyframeEffect</code>，而且它在Level 1规范中，所以我们应该很快会看到它的更多应用。</p>
<p>首先提醒一下如何<code>element.animate()</code>工作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>);</div><div class="line"><span class="keyword">var</span> timings = &#123;</div><div class="line">  <span class="attr">duration</span>: <span class="number">1000</span>,</div><div class="line">  <span class="attr">fill</span>: <span class="string">'both'</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> keyframes = [</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">1</span> &#125;.</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">0</span> &#125;</div><div class="line">];</div><div class="line"></div><div class="line">elem.animate(keyframes, timings);</div></pre></td></tr></table></figure>
<p>使用与上述相同的变量，以下是使用<code>Animation</code>构造函数的等价写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> kEffect = <span class="keyword">new</span> KeyframeEffect(elem, keyframes, timings);</div><div class="line"><span class="keyword">var</span> player = <span class="keyword">new</span> Animation(kEffect, elem.ownerDocument.timeline);</div><div class="line">player.play();</div></pre></td></tr></table></figure>
<p>这里的主要区别在于，动画不会立即开始播放，所以在提前创建动画以便稍后播放时，这将非常有用。</p>
<h1 id="回顾和下一节"><a href="#回顾和下一节" class="headerlink" title="回顾和下一节"></a>回顾和下一节</h1><p>当Level 2规范通过工作草案时，我们应该看到更多关于这些不同效果的定义。本系列中还有两个计划的章节。下一次我们将再次看看未来，还有什么我们可以期待看到。</p>
<p>查看本系列的其余部分：</p>
<ul>
<li>介绍</li>
<li>第1部分：<a href="https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/">创建基本动画</a></li>
<li>第2部分：<a href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/">动画和时间线控制</a></li>
<li>第3部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations/">多个动画</a></li>
<li>第4部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/">GroupEffects和SequenceEffects</a></li>
<li>第5部分：运动路径</li>
<li>结论</li>
</ul>
<p>【翻译原文】：<a href="http://danielcwilson.com/blog/2015/09/animations-part-4/" target="_blank" rel="external">http://danielcwilson.com/blog/2015/09/animations-part-4/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是 Web Animations API 入门教程系列的第3部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与&lt;a href=&quot;https://twitter.com/dancwilson&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@dancwilson&lt;/a&gt;联系。&lt;/p&gt;
&lt;p&gt;让我们继续讨论Web动画API中的多个动画，通过讨论今天在polyfill中提供的几个部分来提供分组和排序。
    
    </summary>
    
      <category term="Web Animations" scheme="http://robin-front.github.io/categories/Web-Animations/"/>
    
    
      <category term="Web Animations" scheme="http://robin-front.github.io/tags/Web-Animations/"/>
    
  </entry>
  
  <entry>
    <title>Web Animations API 入门教程第3部分: 多个Animations对象</title>
    <link href="http://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations/"/>
    <id>http://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations/</id>
    <published>2017-06-27T02:17:19.000Z</published>
    <updated>2017-06-27T02:17:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是 Web Animations API 入门教程系列的第3部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与<a href="https://twitter.com/dancwilson" target="_blank" rel="external">@dancwilson</a>联系。</p>
<p>在我们讨论<a href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/">动画和时间线控制</a>之后，让我们来讨论多个动画。
<a id="more"></a></p>
<h1 id="每个元素的多个动画"><a href="#每个元素的多个动画" class="headerlink" title="每个元素的多个动画"></a>每个元素的多个动画</h1><iframe height="265" scrolling="no" title="Multiple animate calls" src="//codepen.io/danwilson/embed/PqxvJo/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/danwilson/pen/PqxvJo/" target="_blank" rel="external">Multiple animate calls</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.
</iframe>

<p>在这个例子中，每个矩形都有三个动画应用（涉及到transform，opacity和color）。您可以多次调用元素的<code>animate()</code>方法，类似于允许多个动画的CSS。</p>
<p>使用CSS：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#toAnimate</span> &#123;</div><div class="line">  <span class="attribute">animation</span>: pulse <span class="number">1s</span>, activate <span class="number">3000ms</span>, have-fun-with-it <span class="number">2.5s</span>;</div><div class="line">&#125;</div><div class="line">@<span class="keyword">keyframes</span> pulse &#123; <span class="comment">/* ... */</span> &#125;</div><div class="line">@<span class="keyword">keyframes</span> activate &#123; <span class="comment">/* ... */</span> &#125;</div><div class="line">@<span class="keyword">keyframes</span> have-fun-with-it &#123; <span class="comment">/* ... */</span> &#125;</div></pre></td></tr></table></figure>
<p>使用Web Animations API：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> animated = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>);</div><div class="line"><span class="keyword">var</span> pulseKeyframes, <span class="comment">//在这里定义 keyframes.</span></div><div class="line">    activateKeyframes,</div><div class="line">    haveFunKeyframes;</div><div class="line"><span class="keyword">var</span> pulse = animated.animate(pulseKeyframes, <span class="number">1000</span>); <span class="comment">// 第二个数值参数作为持续时间的缩写</span></div><div class="line"><span class="keyword">var</span> activate = animated.animate(activateKeyframes, <span class="number">3000</span>);</div><div class="line"><span class="keyword">var</span> haveFunWithIt = animated.animate(haveFunKeyframes, <span class="number">2500</span>);</div></pre></td></tr></table></figure>
<p>使用Web Animations API，这将创建三个Animation对象，每个对象可以通过时间轴(timeline)或播放速率(playback rate)进行暂停，播放，完成，取消的操作。</p>
<h1 id="获取-Animations，全部动画对象"><a href="#获取-Animations，全部动画对象" class="headerlink" title="获取 Animations，全部动画对象"></a>获取 Animations，全部动画对象</h1><p>所以你可以知道一个动画开始播放了，但是当你想在元素上调用<code>animate()</code>时你却还没有捕获到Animation的引用。那要怎么做？</p>
<iframe height="265" scrolling="no" title="Pause All those Random Dots!" src="//codepen.io/danwilson/embed/PqgKVK/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/danwilson/pen/PqgKVK/" target="_blank" rel="external">Pause All those Random Dots!</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.
</iframe>

<p>该规范允许<code>getAnimations()</code>在文档上的方法。在最新版本的规范中，它直接在<code>document（document.getAnimations()）</code>上，在Firefox 48+上它是这样实现的。然而，对于Chrome 52 和<a href="https://github.com/web-animations/web-animations-js" target="_blank" rel="external">polyfill</a>（如V2.2.0的），则根据该旧规范将其置于新的<code>timeline</code>对象上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如果引用了 polyfill ，你可以这样写</span></div><div class="line"><span class="keyword">var</span> animations = <span class="built_in">document</span>.getAnimations ? <span class="built_in">document</span>.getAnimations() : <span class="built_in">document</span>.timeline.getAnimations();</div><div class="line"><span class="comment">// 返回一个数组，包含所有正在进行的（除了已完成的和被取消的）动画</span></div></pre></td></tr></table></figure>
<p>在CodePen示例中，您将看到随机的持续时间，延迟和无限持续时间的变换移动的几个点。“暂停全部”按钮调用<code>getAnimations()</code>并遍历所有, 返回的玩家（每个动画对象）并暂停每一个。</p>
<h1 id="下一节…"><a href="#下一节…" class="headerlink" title="下一节…"></a>下一节…</h1><p>在下一部分中，我们将看看WAAPI动画可以创建的不同方式（因为它不仅仅是<code>element.animate</code>）。提示：<code>document.timeline</code>会出现更多的体现。</p>
<p>查看本系列的其余部分：</p>
<ul>
<li>介绍</li>
<li>第1部分：<a href="https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/">创建基本动画</a></li>
<li>第2部分：<a href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/">动画和时间线控制</a></li>
<li>第3部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations/">多个动画</a></li>
<li>第4部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/">GroupEffects和SequenceEffects</a></li>
<li>第5部分：运动路径</li>
<li>结论</li>
</ul>
<p>【翻译原文】: <a href="http://danielcwilson.com/blog/2015/08/animations-part-3/" target="_blank" rel="external">http://danielcwilson.com/blog/2015/08/animations-part-3/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是 Web Animations API 入门教程系列的第3部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与&lt;a href=&quot;https://twitter.com/dancwilson&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@dancwilson&lt;/a&gt;联系。&lt;/p&gt;
&lt;p&gt;在我们讨论&lt;a href=&quot;http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/&quot;&gt;动画和时间线控制&lt;/a&gt;之后，让我们来讨论多个动画。
    
    </summary>
    
      <category term="Web Animations" scheme="http://robin-front.github.io/categories/Web-Animations/"/>
    
    
      <category term="Web Animations" scheme="http://robin-front.github.io/tags/Web-Animations/"/>
    
  </entry>
  
  <entry>
    <title>Web Animations API入门教程第2部分：动画和时间线控制</title>
    <link href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/"/>
    <id>http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/</id>
    <published>2017-06-26T09:51:00.000Z</published>
    <updated>2017-06-26T09:51:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是 Web Animations API 入门教程系列的第2部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与<a href="https://twitter.com/dancwilson" target="_blank" rel="external">@dancwilson</a>联系。</p>
<p>现在我们了解如何使用Web Animations API <a href="https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/">创建基本动画</a>，让我们来谈谈状态（states），控制(controls)，回调(callback)和时间轴(timelines)。
<a id="more"></a></p>
<h1 id="Animations-播放状态和控制"><a href="#Animations-播放状态和控制" class="headerlink" title="Animations 播放状态和控制"></a>Animations 播放状态和控制</h1><p>当你调用时<code>element.animate()</code>，返回一个<code>Animation</code>对象（以前称为<code>AnimationPlayerspec</code>），动画开始播放。要查看动画的当前状态，您可以检查<code>readonly</code>属性<code>playState</code>，该属性将返回五个字符串之一。我们也可以通过调用四种方法之一修改动画的当前状态：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> player = element.animate(<span class="comment">/* ... */</span>);</div><div class="line"><span class="built_in">console</span>.log(player.playState); <span class="comment">//"running"</span></div><div class="line"></div><div class="line">player.pause(); <span class="comment">//"paused"</span></div><div class="line">player.play();  <span class="comment">//"running"</span></div><div class="line">player.cancel(); <span class="comment">//"idle"... 跳到原始状态</span></div><div class="line">player.finish(); <span class="comment">//"finished"...跳到结束状态</span></div></pre></td></tr></table></figure>
<p>此外<code>running</code>，<code>paused</code>，<code>idle</code>，和<code>finished</code>播放状态有一个<code>pending</code>状态定义当播放或暂停任务正在等待批准即将发生。</p>
<p>这个“步行圆圈”示例显示六个圆缩放。您可以暂停或播放每个圈子，以查看上述播放状态的一部分。</p>
<iframe height="265" scrolling="no" title="Blob That Walks" src="//codepen.io/danwilson/embed/WvXRYg/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/danwilson/pen/WvXRYg/" target="_blank" rel="external">Blob That Walks</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.
</iframe>

<h1 id="播放速率"><a href="#播放速率" class="headerlink" title="播放速率"></a>播放速率</h1><p>在之前的CodePen示例中，还有一个“2x”按钮，您可以按更改动画的播放速度，将其切换到双倍速度。这是通过读/写<code>playbackRate</code>属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> player = element.animate(<span class="comment">/* ... */</span>);</div><div class="line"><span class="built_in">console</span>.log(player.playbackRate); <span class="comment">//1</span></div><div class="line"></div><div class="line">player.playbackRate = <span class="number">2</span>; <span class="comment">//双倍速度, 也可以使用十进制数字控制它降低速度.</span></div></pre></td></tr></table></figure>
<h1 id="动画完成后的回调"><a href="#动画完成后的回调" class="headerlink" title="动画完成后的回调"></a>动画完成后的回调</h1><p>使用CSS transitions，当转换结束时，通常会触发一个事件。类似地，<code>Animation</code>允许您指定一个<code>onfinish</code>函数，在动画完成或调用之前讨论过的<code>finish()</code>方法时调用它。请注意，根据规范，无法完成无限次迭代的动画集，也不能完成一个具有<code>playbackRate = 0</code> 的动画集。还有一个<code>oncancel</code>处理程序，以及在<code>Animation</code>完成时使用<code>Promises</code>的写法。</p>
<p>以下示例用于<code>onfinish</code>在动画完成后显示一些统计信息（并且它也很好地切换到下一次关于时间轴的讨论）。</p>
<iframe height="265" scrolling="no" title="Timer Countdown" src="//codepen.io/danwilson/embed/RPMVZJ/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/danwilson/pen/RPMVZJ/" target="_blank" rel="external">Timer Countdown</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.
</iframe>

<h1 id="时间轴"><a href="#时间轴" class="headerlink" title="时间轴"></a>时间轴</h1><p>每个<code>Animation</code>都公开两个读/写时间相关属性 - <code>currentTime</code>和<code>startTime</code>。现在，我们将重点关注前者。</p>
<p><code>currentTime</code>返回动画当前的毫秒数。最大值将为延迟时间 +（持续时间<em>迭代次数）（`delay + (duration </em> iterations)`），因此无限次迭代将不具有最大值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> player = element.animate([</div><div class="line">  &#123;<span class="attr">opacity</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">opacity</span>: <span class="number">0</span>&#125;</div><div class="line">], &#123;</div><div class="line">  <span class="attr">duration</span>: <span class="number">1000</span>,</div><div class="line">  <span class="attr">delay</span>: <span class="number">500</span>,</div><div class="line">  <span class="attr">iterations</span>: <span class="number">3</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">player.onfinish = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(player.currentTime); <span class="comment">// 3500</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>播放速率将影响时间轴的持续时间。如果您将播放速度设置为10，则您的最大时间保持不变，但您的时间轴会快10倍。这个概念也在之前的“计时器倒计时”示例中显示。</p>
<p>由于<code>currentTime</code>是可 读/写，我们也可以使用它来跳转到时间轴中的某一点。它也可以让我们同步两个动画，如下例所示。</p>
<iframe height="265" scrolling="no" title="Syncing Timelines - WAAPI" src="//codepen.io/danwilson/embed/YXYWKK/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/danwilson/pen/YXYWKK/" target="_blank" rel="external">Syncing Timelines - WAAPI</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.
</iframe>

<h1 id="还有一个选项：-reverse"><a href="#还有一个选项：-reverse" class="headerlink" title="还有一个选项： reverse()"></a>还有一个选项： reverse()</h1><p>你也可以使用<code>reverse()</code>反转一个与之非常相似的动画<code>play()</code>（比如它会有相同的playState），除了它将以相反的方式遍历时间轴。当动画完成时，<code>currentTime</code>将为0。</p>
<iframe height="265" scrolling="no" title="waRKOm" src="//codepen.io/danwilson/embed/waRKOm/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/danwilson/pen/waRKOm/" target="_blank" rel="external">waRKOm</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.
</iframe>

<h1 id="下一节…"><a href="#下一节…" class="headerlink" title="下一节…"></a>下一节…</h1><p>这包含了很多的信息，但仍然只是熟悉一下WAAPI有哪些可用的。下面我们来看一些更高级的用法。</p>
<p>查看本系列的其余部分：</p>
<ul>
<li>介绍</li>
<li>第1部分：<a href="https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/">创建基本动画</a></li>
<li>第2部分：<a href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/">动画和时间线控制</a></li>
<li>第3部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations/">多个动画</a></li>
<li>第4部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/">GroupEffects和SequenceEffects</a></li>
<li>第5部分：运动路径</li>
<li>结论</li>
</ul>
<p>【翻译原文】: <a href="http://danielcwilson.com/blog/2015/07/animations-part-2/" target="_blank" rel="external">http://danielcwilson.com/blog/2015/07/animations-part-2/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是 Web Animations API 入门教程系列的第2部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与&lt;a href=&quot;https://twitter.com/dancwilson&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@dancwilson&lt;/a&gt;联系。&lt;/p&gt;
&lt;p&gt;现在我们了解如何使用Web Animations API &lt;a href=&quot;https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/&quot;&gt;创建基本动画&lt;/a&gt;，让我们来谈谈状态（states），控制(controls)，回调(callback)和时间轴(timelines)。
    
    </summary>
    
      <category term="Web Animations" scheme="http://robin-front.github.io/categories/Web-Animations/"/>
    
    
      <category term="Web Animations" scheme="http://robin-front.github.io/tags/Web-Animations/"/>
    
  </entry>
  
  <entry>
    <title>Web Animations API 入门教程第1部分:创建一个基本的动画</title>
    <link href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/"/>
    <id>http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/</id>
    <published>2017-06-26T03:25:31.000Z</published>
    <updated>2017-06-26T03:25:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是 Web Animations API 入门教程系列的第1部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与<a href="https://twitter.com/dancwilson" target="_blank" rel="external">@dancwilson</a>联系。</p>
<p>我们之前初步看了下 Web Animations API，但是我们没有得到任何真正的细节，所以现在我们来看看。</p>
<p>WAAPI（Web Animations API, 以下均简称WAAPI）为您提供更多的控制比您可能已经习惯使用的CSS动画，但在我们进入这些演示之前，我们需要设置基本目标：如何通过此API创建基本动画？
<a id="more"></a></p>
<h1 id="创建关键帧动画"><a href="#创建关键帧动画" class="headerlink" title="创建关键帧动画"></a>创建关键帧动画</h1><p>如果您熟悉CSS Transitions/ Animations，这将非常熟悉。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> player = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>).animate([</div><div class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(1)'</span>, <span class="attr">opacity</span>: <span class="number">1</span>, <span class="attr">offset</span>: <span class="number">0</span> &#125;,</div><div class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(.5)'</span>, <span class="attr">opacity</span>: <span class="number">.5</span>, <span class="attr">offset</span>: <span class="number">.3</span> &#125;,</div><div class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(.667)'</span>, <span class="attr">opacity</span>: <span class="number">.667</span>, <span class="attr">offset</span>: <span class="number">.7875</span> &#125;,</div><div class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(.6)'</span>, <span class="attr">opacity</span>: <span class="number">.6</span>, <span class="attr">offset</span>: <span class="number">1</span> &#125;</div><div class="line">  ], &#123;</div><div class="line">    <span class="attr">duration</span>: <span class="number">700</span>, <span class="comment">//毫秒</span></div><div class="line">    easing: <span class="string">'ease-in-out'</span>, <span class="comment">//'linear', a bezier curve等.</span></div><div class="line">    delay: <span class="number">10</span>, <span class="comment">//毫秒</span></div><div class="line">    iterations: <span class="literal">Infinity</span>, <span class="comment">//或其他数值</span></div><div class="line">    direction: <span class="string">'alternate'</span>, <span class="comment">//'normal', 'reverse', 等.</span></div><div class="line">    fill: <span class="string">'forwards'</span> <span class="comment">//'backwards', 'both', 'none', 'auto'</span></div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<p>为了对照，这里是一个等效的CSS关键帧动画</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> emphasis &#123;</div><div class="line">  0% &#123;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(1);</div><div class="line">    <span class="attribute">opacity</span>: <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  30% &#123;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(.5);</div><div class="line">    <span class="attribute">opacity</span>: .<span class="number">5</span>;</div><div class="line">  &#125;</div><div class="line">  78<span class="selector-class">.75</span>% &#123;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(.667);</div><div class="line">    <span class="attribute">opacity</span>: .<span class="number">667</span>;</div><div class="line">  &#125;</div><div class="line">  100% &#123;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(.6);</div><div class="line">    <span class="attribute">opacity</span>: .<span class="number">6</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="selector-id">#toAnimate</span> &#123;</div><div class="line">  <span class="attribute">animation</span>: emphasis <span class="number">700ms</span> ease-in-out <span class="number">10ms</span> infinite alternate forwards;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们将分解这一切，解释每一部会。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> player = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>).animate()</div></pre></td></tr></table></figure>
<p>动画将返回一个 <strong>Animation</strong>（以前在规范中称为 <strong>AnimationPlayer</strong>）对象，这将给我们做些有趣的事情，所以你可能想要设置一个变量来捕获这个引用。我们找到我们想要的动画元素（这里简单地使用document.getElementById）并调用该<code>animate</code>函数。此功能是新添加的特性，所以如果您必须要测试它的支持性/存在性，在使用它之前或者引用 <a href="https://github.com/web-animations/web-animations-js" target="_blank" rel="external">polyfill</a>。</p>
<p>该<code>animate</code>函数有两个参数，一个<code>KeyframeEffects</code>和一个<code>AnimationEffectTimingProperties</code>选项的数组。本质上，第一个参数映射到CSS中的内容<code>@keyframe</code>s，第二个参数是您在CSS规则中使用的<code>animation-*</code>属性（或<code>animation</code>简写，如我之前的示例）所指定的那样。这里的主要优点是我们可以使用变量或重用以前定义的<code>KeyframeEffects</code>，而使用CSS我们仅限于我们在前面声明的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> player = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>).animate([</div><div class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(1)'</span>, <span class="attr">opacity</span>: <span class="number">1</span> &#125;,</div><div class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(.5)'</span>, <span class="attr">opacity</span>: <span class="number">.5</span> &#125;,</div><div class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(.667)'</span>, <span class="attr">opacity</span>: <span class="number">.667</span> &#125;,</div><div class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(.6)'</span>, <span class="attr">opacity</span>: <span class="number">.6</span> &#125;</div><div class="line">  ]);</div></pre></td></tr></table></figure>
<p>对于每一个<code>KeyframeEffect</code>，我们将CSS中的百分比偏移量改为<code>offset</code>从0到1 的十进制值。它是可选的，如果没有指定，它们将均匀分布（因此，如果您有三个，则第一个具有偏移为0，第二个偏移量为.5，第三个偏移量为1）。您还可以指定<code>easing</code>与<code>animation-timing-functionCSS</code>中相同的属性。每个的其他属性<code>KeyframeEffect</code>都是动画的属性。每个属性的值应该符合在JavaScript的<code>element.style</code>中的用法，因此<code>opacity</code>将是一个数字，但<code>transform</code>会期望一个字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> player = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>).animate([], &#123;</div><div class="line">    <span class="attr">duration</span>: <span class="number">700</span>, <span class="comment">//milliseconds</span></div><div class="line">    easing: <span class="string">'ease-in-out'</span>, <span class="comment">//'linear', a bezier curve, etc.</span></div><div class="line">    delay: <span class="number">10</span>, <span class="comment">//milliseconds</span></div><div class="line">    iterations: <span class="literal">Infinity</span>, <span class="comment">//or a number</span></div><div class="line">    direction: <span class="string">'alternate'</span>, <span class="comment">//'normal', 'reverse', etc.</span></div><div class="line">    fill: <span class="string">'forwards'</span> <span class="comment">//'backwards', 'both', 'none', 'auto'</span></div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<p>时间属性将映射到CSS动画属性，尽管有时会使用不同的名称。较早的代码示例讨论了主要选项。</p>
<p>以下是使用<code>polyfill</code>的示例（但如果您正在Chrome 36+，Opera 23+或Firefox 48+中查看，则应使用实际的浏览器实现）。第一列灰色块使用WAAPI动画，第二列红色块使用CSS关键帧进行动画。</p>
<iframe height="265" scrolling="no" title="CSS Keyframes v. WAAPI" src="//codepen.io/danwilson/embed/QwrZwd/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/danwilson/pen/QwrZwd/" target="_blank" rel="external">CSS Keyframes v. WAAPI</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.
</iframe>


<h1 id="下一节…"><a href="#下一节…" class="headerlink" title="下一节…"></a>下一节…</h1><p>现在我们知道如何创建在CSS中熟知的等效动画，我们将开始查看<code>Animation</code> 的 <code>animate</code> 函数返回的对象。这是我们看到真正的功能和改进的地方。</p>
<p>查看本系列的其余部分：</p>
<ul>
<li>介绍</li>
<li>第1部分：<a href="https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/">创建基本动画</a></li>
<li>第2部分：<a href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/">动画和时间线控制</a></li>
<li>第3部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations/">多个动画</a></li>
<li>第4部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/">GroupEffects和SequenceEffects</a></li>
<li>第5部分：运动路径</li>
<li>结论</li>
</ul>
<p>【翻译原文】： <a href="http://danielcwilson.com/blog/2015/07/animations-part-1/" target="_blank" rel="external">http://danielcwilson.com/blog/2015/07/animations-part-1/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是 Web Animations API 入门教程系列的第1部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与&lt;a href=&quot;https://twitter.com/dancwilson&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@dancwilson&lt;/a&gt;联系。&lt;/p&gt;
&lt;p&gt;我们之前初步看了下 Web Animations API，但是我们没有得到任何真正的细节，所以现在我们来看看。&lt;/p&gt;
&lt;p&gt;WAAPI（Web Animations API, 以下均简称WAAPI）为您提供更多的控制比您可能已经习惯使用的CSS动画，但在我们进入这些演示之前，我们需要设置基本目标：如何通过此API创建基本动画？
    
    </summary>
    
      <category term="Web Animations" scheme="http://robin-front.github.io/categories/Web-Animations/"/>
    
    
      <category term="Web Animations" scheme="http://robin-front.github.io/tags/Web-Animations/"/>
    
  </entry>
  
  <entry>
    <title>css 动画和 Web Animation API(WAAPI)对比</title>
    <link href="http://robin-front.github.io/2017/06/22/css-animations-vs-web-animations-api/"/>
    <id>http://robin-front.github.io/2017/06/22/css-animations-vs-web-animations-api/</id>
    <published>2017-06-22T09:48:00.000Z</published>
    <updated>2017-06-22T09:48:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>有一个JavaScript的动画原生API，称为<code>Web Animation API</code>。我们在这篇文章中称之为<code>WAAPI</code>。MDN有很好的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API" target="_blank" rel="external">文档</a>，Dan Wilson 有一个伟大的<a href="http://danielcwilson.com/blog/2015/07/animations-part-1/" target="_blank" rel="external">系列文章</a>。</p>
<p>在本文中，我们将比较WAAPI和CSS中完成的动画。
<a id="more"></a></p>
<h1 id="关于浏览器支持的提示"><a href="#关于浏览器支持的提示" class="headerlink" title="关于浏览器支持的提示"></a>关于浏览器支持的提示</h1><p>尽管现在浏览器的支持很有限，但WAAPI有一个全面而强大的<a href="https://github.com/web-animations/web-animations-js/tree/master" target="_blank" rel="external">polyfill</a>工具，让它可以在当前的生产环境中使用。</p>
<p>一如既往，您可以检查<a href="http://caniuse.com/#feat=web-animation" target="_blank" rel="external">Can I Use</a> 的浏览器支持数据。然而，这并没有提供非常好的信息来支持WAAPI的所有子功能。这是一个检查器：</p>
<iframe height="265" scrolling="no" title="WAAPI Browser Support Test" src="//codepen.io/danwilson/embed/xGBKVq/?height=265&theme-id=0&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/danwilson/pen/xGBKVq/" target="_blank" rel="external">WAAPI Browser Support Test</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.
</iframe>

<p>想要不使用polyfill而体验所有功能，请使用Firefox Nightly。</p>
<h1 id="WAAPI的基础知识"><a href="#WAAPI的基础知识" class="headerlink" title="WAAPI的基础知识"></a>WAAPI的基础知识</h1><p>如果您曾经使用<code>jQuery.animate()</code>，WAAPI的基本语法应该看起来很熟悉。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.querySelector(<span class="string">'.animate-me'</span>);</div><div class="line">element.animate(keyframes, <span class="number">1000</span>);</div></pre></td></tr></table></figure>
<p>该<code>animate</code>方法接受两个参数：关键帧和持续时间。与jQuery不同的是，它不仅具有内置在浏览器中的优点，而且性能也更高。</p>
<p>第一个参数，关键帧应该是一个对象数组。每个对象都是我们动画中的一个关键帧。这是一个简单的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> keyframes = [</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">0</span> &#125;,</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">1</span> &#125;</div><div class="line">];</div></pre></td></tr></table></figure>
<p>第二个参数，持续时间，是我们想要动画持续多久。在上面的例子中是1000毫秒。我们来看一个更令人兴奋的例子。</p>
<h1 id="用WAAPI重新创建animista-CSS动画"><a href="#用WAAPI重新创建animista-CSS动画" class="headerlink" title="用WAAPI重新创建animista CSS动画"></a>用WAAPI重新创建animista CSS动画</h1><p>这里有一些CSS代码，从非常棒的<a href="http://animista.net/" target="_blank" rel="external">animista</a>中吸取了一些称为“幻灯片模糊的”入场动画的东西。看起来很可爱。</p>
<p><img src="https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_368,f_auto,q_auto/v1496792139/slide-down_ohemtx.gif" alt="实际[效果](http://animista.net/play/entrances/slide-in-blurred)要比这个 GIF 要棒很多"></p>
<p>以下是CSS中的关键帧：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">0% &#123;</div><div class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-1000px) <span class="built_in">scaleY</span>(2.5) <span class="built_in">scaleX</span>(.2);</div><div class="line">  <span class="attribute">transform-origin</span>: <span class="number">50%</span> <span class="number">0</span>;</div><div class="line">  <span class="attribute">filter</span>: <span class="built_in">blur</span>(40px);</div><div class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">100% &#123;</div><div class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(0) <span class="built_in">scaleY</span>(1) <span class="built_in">scaleX</span>(1);</div><div class="line">  <span class="attribute">transform-origin</span>: <span class="number">50%</span> <span class="number">50%</span>;</div><div class="line">  <span class="attribute">filter</span>: <span class="built_in">blur</span>(0);</div><div class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>WAAPI中的代码相同：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> keyframes = [</div><div class="line">  &#123;</div><div class="line">    <span class="attr">transform</span>: <span class="string">'translateY(-1000px) scaleY(2.5) scaleX(.2)'</span>,</div><div class="line">    <span class="attr">transformOrigin</span>: <span class="string">'50% 0'</span>, <span class="attr">filter</span>: <span class="string">'blur(40px)'</span>, <span class="attr">opacity</span>: <span class="number">0</span></div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="attr">transform</span>: <span class="string">'translateY(0) scaleY(1) scaleX(1)'</span>,</div><div class="line">    <span class="attr">transformOrigin</span>: <span class="string">'50% 50%'</span>,</div><div class="line">    <span class="attr">filter</span>: <span class="string">'blur(0)'</span>,</div><div class="line">    <span class="attr">opacity</span>: <span class="number">1</span></div><div class="line">  &#125;</div><div class="line">];</div></pre></td></tr></table></figure>
<p>我们已经看到，将关键帧应用到要运动的任何元素是多么容易的事：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">element.animate(keyframes, <span class="number">700</span>);</div></pre></td></tr></table></figure>
<p>为了简单起见，我只指定了持续时间。但是，我们可以使用这个第二个参数来传递更多的选项。至少我们也应该指定一个缓动函数。以下是可用选项的完整列表，其中包含一些示例值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> options = &#123;</div><div class="line">  <span class="attr">iterations</span>: <span class="literal">Infinity</span>,</div><div class="line">  <span class="attr">iterationStart</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">delay</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">endDelay</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">direction</span>: <span class="string">'alternate'</span>,</div><div class="line">  <span class="attr">duration</span>: <span class="number">700</span>,</div><div class="line">  <span class="attr">fill</span>: <span class="string">'forwards'</span>,</div><div class="line">  <span class="attr">easing</span>: <span class="string">'ease-out'</span>,</div><div class="line">&#125;</div><div class="line">element.animate(keyframes, options);</div></pre></td></tr></table></figure>
<p>有了这些选项，我们的动画将从头开始，没有任何延迟，永远循环在向前和向后播放。</p>
<iframe height="265" scrolling="no" title="motion blur waapi circle" src="//codepen.io/cssgrid/embed/EmBGxG/?height=265&theme-id=0&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/cssgrid/pen/EmBGxG/" target="_blank" rel="external">motion blur waapi circle</a> by CSS GRID (<a href="https://codepen.io/cssgrid" target="_blank" rel="external">@cssgrid</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.
</iframe>

<p>令人烦恼的是，对于我们熟悉CSS动画的人来说，一些术语与我们习惯的不同。虽然在积极的一面看，有些事情写起来更快一点！</p>
<ul>
<li>这里用<code>easing</code>而不是<code>animation-timing-function</code></li>
<li>使用<code>iterations</code>而不是<code>animation-iteration-count</code>。如果我们希望动画永远重复，用<code>Infinity</code>而不是<code>infinite</code>。有点混乱，<code>Infinity</code>不是引用。Infinity是一个JavaScript关键字，而其他值是字符串。</li>
<li>我们使用毫秒而不是秒，对于之前编写过许多JavaScript的人来说，这应该是熟悉的。（您可以在CSS动画中使用毫秒数，但很少有人使用。）</li>
</ul>
<p>我们来仔细看看一个选项：<code>iterationStart</code>。</p>
<p>当我第一次碰到<code>iterationStart</code>, 我被难住了。你为什么要指定迭代的开始，而不仅仅是减少迭代次数？当您使用十进制数时，此选项非常有用。例如，您可以将其设置为 <code>.5</code>，动画将开始一半。要做一整个动画需要两半，所以如果你的迭代次数设置为1，并且你的<code>iterationStart</code>设置为 <code>.5</code>，动画将从一半到动画结束播放，然后从动画开头开始，结束于中间！</p>
<p>值得注意的是，您也可以将迭代次数设置为小于1。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> option = &#123;</div><div class="line">  <span class="attr">iterations</span>: <span class="number">.5</span>,</div><div class="line">  <span class="attr">iterationStart</span>: <span class="number">.5</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这将从中间到最后播放动画。
<code>endDelay：endDelay</code>如果要将多个动画串在一起，但是希望在一个动画的结尾和任何后续动画的开始之间存在差距。这是一个有用的视频，Patrick Brosset 的解释。</p>
<div style="position:relative;height:0;padding-bottom:56.22%"><iframe src="https://www.youtube.com/embed/hWe-qukNrN8?ecver=2" style="position:absolute;width:100%;height:100%;left:0" width="640" height="360" frameborder="0" allowfullscreen></iframe></div>

<h1 id="缓动"><a href="#缓动" class="headerlink" title="缓动"></a>缓动</h1><p>缓动是任何动画中最重要的元素之一。WAAPI为我们提供了两种不同的方式设置缓动函数 - 在我们的关键帧阵列或我们的选项对象内。
在CSS中，如果你应用了，<code>animation-timing-function: ease-in-out</code>你可能会假设你的动画的开始会<code>ease in</code>，动画的结束将会<code>ease out</code>。实际上，这些缓动函数应用在关键帧之间，而不是整个动画。这可以对动画的感觉进行细粒度的控制。WAAPI还提供这种能力。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> keyframes = [</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">0</span>, <span class="attr">easing</span>: <span class="string">'ease-in'</span> &#125;,</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">0.5</span>, <span class="attr">easing</span>: <span class="string">'ease-out'</span> &#125;,</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">1</span> &#125;</div><div class="line">]</div></pre></td></tr></table></figure>
<p>值得注意的是，在CSS和WAAPI中，您不应该传入最后一帧的缓动值，因为这将不起作用。这是很多人犯的错误。
有时候，在整个动画中添加缓动效果更为直观。这在CSS是不可能的，但现在可以实现与WAAPI。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> options = &#123;</div><div class="line">  <span class="attr">duration</span>: <span class="number">1000</span>,</div><div class="line">  <span class="attr">easing</span>: <span class="string">'ease-in-out'</span>,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你可以看到这两种缓动在CodePen上的区别：</p>
<iframe height="265" scrolling="no" title="Same animation, different easing" src="//codepen.io/cssgrid/embed/OmrVeQ/?height=265&theme-id=0&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/cssgrid/pen/OmrVeQ/" target="_blank" rel="external">Same animation, different easing</a> by CSS GRID (<a href="https://codepen.io/cssgrid" target="_blank" rel="external">@cssgrid</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.
</iframe>

<h1 id="ease-vs-linear"><a href="#ease-vs-linear" class="headerlink" title="ease vs linear"></a>ease vs linear</h1><p>值得注意的是CSS动画和WAAPI之间的另一个区别：CSS ease的默认值是<code>ease</code>,WAAPI的默认值<code>linear</code>。 <code>Ease</code>实际上是一个版本，<code>ease-in-out</code>是一个非常好的选择，如果你感到懒惰。同时，<code>linear</code> 是沉闷的和无生机的 - 一致的速度看起来机械和不自然。它被选为默认值，可能因为它是最中立的选项。然而，在WAAPI中使用时，使用缓动比在CSS更重要，以免您的动画看起来很乏味和机械地。</p>
<h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>WAAPI提供与CSS动画相同的性能改进，尽管这并不意味着平滑的动画是不可避免的。</p>
<p>我希望这个API的性能优化意味着我们可以避免使用<code>will-change</code>和完全hack <code>translateZ</code> - 最终可能。但是，至少在目前的浏览器实现中，这些属性在处理闪烁问题（<code>jank issue</code>）方面仍然是有帮助和必要的。</p>
<p>但是，至少如果您的动画有延迟，则无需担心使用<code>will-change</code>。网络动画规范的主要作者对“<a href="https://damp-lake-50659.herokuapp.com/" target="_blank" rel="external">Animation for Work Slack community</a>”提出了一些有趣的建议，希望他不介意我在这里重复：</p>
<blockquote>
<p>如果您有一个积极的延迟，您不需要<code>will-change</code>因为浏览器将在延迟开始时进行分层，当动画启动时，它将准备就绪。</p>
</blockquote>
<h1 id="WAAPI对战CSS动画？"><a href="#WAAPI对战CSS动画？" class="headerlink" title="WAAPI对战CSS动画？"></a>WAAPI对战CSS动画？</h1><p>WAAPI为我们提供了一个在JavaScript中实现css中的语法。然而，他们不应该被视为对手。如果我们决定坚持使用CSS进行<code>animations</code>和<code>transitions</code>，那么我们可以与WAAPI进行动画交互。</p>
<h1 id="Animation-对象"><a href="#Animation-对象" class="headerlink" title="Animation 对象"></a>Animation 对象</h1><p>该<code>.animate()</code>方法不仅仅是动画我们的元素，它也返回一些东西。</p>
<p><img src="https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1000,f_auto,q_auto/v1496519294/animationobject_ujevsk.png" alt="在控制台中查看的动画对象"></p>
<p>如果我们看看控制台中的返回值，我们将看到它的一个动画对象。这为我们提供了各种各样的功能，其中一些是非常不言自明的<code>myAnimation.pause()</code>。通过更改<code>animation-play-state</code>属性，我们可以通过CSS动画实现类似的结果，但WAAPI语法比稍微简单<code>element.style.animationPlayState = &quot;paused&quot;</code>。我们也有权力轻松地扭转我们的动画<code>myAnimation.reverse()</code>，再次，<code>animation-direction</code>与使用我们的脚本更改CSS属性相比，稍微有点改进。</p>
<p>然而，到目前为止，<code>@keyframe</code>用JavaScript进行操作并不是世界上最简单的事情。即使像重新启动动画一样简单，就像Chris Coyier 先前<a href="https://css-tricks.com/restart-css-animation/" target="_blank" rel="external">写过的</a>那样，这个技巧也有<a href="https://css-tricks.com/restart-css-animation/" target="_blank" rel="external">一些技巧</a>。使用WAAPI，我们可以简单地使用<code>myAnimation.play()</code>，它从一开始就重播动画，如果它已经完成，或者如果我们暂停播放，则从中间迭代继续播放动画。</p>
<p>我们甚至可以轻松地改变动画的速度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myAnimation.playbackRate = <span class="number">2</span>; <span class="comment">// speed it up</span></div><div class="line">myAnimation.playbackRate = <span class="number">.4</span>; <span class="comment">// use a number less than one to slow it down</span></div></pre></td></tr></table></figure>
<h1 id="getAnimations（）"><a href="#getAnimations（）" class="headerlink" title="getAnimations（）"></a>getAnimations（）</h1><p>此方法将返回任何动画对象的数组，以便我们使用WAAPI定义的任何动画以及 <em>任何CSS <code>transitions</code>或<code>animations</code></em>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">element.getAnimations() <span class="comment">// returns any animations or transitions applied to our element using CSS or WAAPI</span></div></pre></td></tr></table></figure>
<p>如果您感觉使用CSS来定义和应用您的动画比较顺手，<code>getAnimations()</code>可以使用API​​与<code>@keyframes</code> 结合使用。您可以继续使用CSS进行大部分动画工作，并在需要API时获得API的优势。让我们看看这是多么简单。</p>
<p>即使一个DOM元素只有一个动画应用到它，<code>getAnimations()</code>也将始终返回一个数组。我们来抓住那个单一的动画对象来处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> h2 = <span class="built_in">document</span>.querySelector(<span class="string">"h2"</span>);</div><div class="line"><span class="keyword">var</span> myCSSAnimation = h2.getAnimations()[<span class="number">0</span>];</div></pre></td></tr></table></figure>
<p>现在我们可以在我们的CSS动画中使用web animation API :)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myCSSAnimation.playbackRate = <span class="number">4</span>;</div><div class="line">myCSSAnimation.reverse();</div></pre></td></tr></table></figure>
<h1 id="Promise和事件"><a href="#Promise和事件" class="headerlink" title="Promise和事件"></a>Promise和事件</h1><p>我们已经有多种通过CSS触发的事件，我们可以在我们的JavaScript代码利用的有：<code>animationstart</code>，<code>animationend</code>，<code>animationiteration</code>和<code>transitionend</code>。我经常需要收听<code>animations</code>或<code>transitions</code>的结束，以便从DOM中删除应用于它的元素。</p>
<p>在WAAPI 中使用<code>animationend</code>或<code>transitionend</code>为此目的相当于再次使用动画对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">myAnimation.onfinish = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  element.remove();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>WAAPI为我们提供了事件和Promise的选择。我们的动画的<code>.finished</code>属性对象将在动画结束时返回一个resolve 的 Promise。以下是上面的例子，就像使用Promise一样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myAnimation.finished.then(<span class="function"><span class="params">()</span> =&gt;</span></div><div class="line">  element.remove())</div></pre></td></tr></table></figure>
<p>我们来看看Mozilla开发人员网络中的一个稍微有点省略的例子。<code>Promise.all</code>接收一个Promise数组，一旦所有这些Promise得到解决，才会运行我们的回调函数。我们已经看到，<code>element.getAnimations()</code>返回一个动画对象数组。我们可以将数组中的所有动画对象映射到每个动画对象<code>.finished</code>上，为我们提供所需的Promise数组。</p>
<p>在这个例子中，只有在页面上的所有动画完成后，我们的函数才能运行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.all(<span class="built_in">document</span>.getAnimations().map(<span class="function"><span class="params">animation</span> =&gt;</span></div><div class="line">  animation.finished)).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;           </div><div class="line">    <span class="comment">// do something cool</span></div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<h1 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h1><p>本文中提到的功能只是开始。目前的规范和实践看起来是一件伟大的事情的开始。</p>
<p>「翻譯原文」：<a href="https://css-tricks.com/css-animations-vs-web-animations-api/?utm_source=frontendfocus" target="_blank" rel="external">https://css-tricks.com/css-animations-vs-web-animations-api/?utm_source=frontendfocus</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一个JavaScript的动画原生API，称为&lt;code&gt;Web Animation API&lt;/code&gt;。我们在这篇文章中称之为&lt;code&gt;WAAPI&lt;/code&gt;。MDN有很好的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文档&lt;/a&gt;，Dan Wilson 有一个伟大的&lt;a href=&quot;http://danielcwilson.com/blog/2015/07/animations-part-1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;系列文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在本文中，我们将比较WAAPI和CSS中完成的动画。
    
    </summary>
    
      <category term="css3" scheme="http://robin-front.github.io/categories/css3/"/>
    
      <category term="animation" scheme="http://robin-front.github.io/categories/css3/animation/"/>
    
      <category term="web Animation" scheme="http://robin-front.github.io/categories/css3/animation/web-Animation/"/>
    
    
      <category term="css3" scheme="http://robin-front.github.io/tags/css3/"/>
    
      <category term="animation" scheme="http://robin-front.github.io/tags/animation/"/>
    
      <category term="web Animation" scheme="http://robin-front.github.io/tags/web-Animation/"/>
    
  </entry>
  
  <entry>
    <title>webpack3官方正式发布,亮点:作用域提升，“魔法注释”，以及更多新特性！</title>
    <link href="http://robin-front.github.io/2017/06/21/webpack3%E5%AE%98%E6%96%B9%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83-%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%90%E5%8D%87%EF%BC%8C%E2%80%9C%E9%AD%94%E6%B3%95%E6%B3%A8%E9%87%8A%E2%80%9D%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%9B%B4%E5%A4%9A%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%81/"/>
    <id>http://robin-front.github.io/2017/06/21/webpack3官方正式发布-作用域提升，“魔法注释”，以及更多新特性！/</id>
    <published>2017-06-21T07:35:55.000Z</published>
    <updated>2017-06-22T07:35:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="作用域提升，“魔法注释”，以及更多新特性！"><a href="#作用域提升，“魔法注释”，以及更多新特性！" class="headerlink" title="作用域提升，“魔法注释”，以及更多新特性！"></a>作用域提升，“魔法注释”，以及更多新特性！</h1><p><a href="https://medium.com/webpack/webpack-3-official-release-15fd2dd8f07b" target="_blank" rel="external">原文</a></p>
<p>在我们发布了 webpack v2 之后，我们曾向社区做了一些承诺。 我们承诺，我们将提供用户投票的功能。 此外，我们承诺我们的发布周期会 <strong>更快，更稳定</strong>。</p>
<p>这次没有 beta 版本，完全向下兼容。我们承诺让你们、让 webpack 成长的社区更轻松的使用。webpack 团队自豪地宣布，今天我们已经发布了 webpack 3.0.0！ 现在就可以下载或升级！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install webpack@3.0.0 --save-dev</div></pre></td></tr></table></figure>
<p>或者使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yarn add webpack@3.0.0 --dev</div></pre></td></tr></table></figure>
<p><em>从 webpack 2 迁移到 3，只需要执行升级命令，在使用上没有任何差别。我们将这次升级标记为版本的重大升级，是因为内部的突破性变化可能会影响某些插件的使用。</em></p>
<p><strong>到目前为止，98%的升级的用户都没有遇到任何不兼容！</strong>
<a id="more"></a></p>
<h1 id="有哪些新特性"><a href="#有哪些新特性" class="headerlink" title="有哪些新特性?"></a>有哪些新特性?</h1><p>像上文提到的一样，我们发布了一些由用户投票选出的功能，感谢 Github，赞助商和我们的支持者，有了他们我们才能做出每一个改进。😍</p>
<h2 id="🔬作用域提升（Scope-Hoisting）🔬"><a href="#🔬作用域提升（Scope-Hoisting）🔬" class="headerlink" title="🔬作用域提升（Scope Hoisting）🔬"></a>🔬作用域提升（Scope Hoisting）🔬</h2><p>作用域提升是 webpack 3 的重点功能。之前 webpack 在打包时，您的 bundle 中的每个模块都将被包装在单独的函数闭包中。这些闭包会使您的 JavaScript 在浏览器中执行速度更慢。相比之下，像 Closure Compiler 和 RollupJS 这样的工具可以将所有模块包装在一个大的闭包内，从而使您的代码在浏览器中具有更快的执行速度。</p>
<p><blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">70K =&gt; 37K (gzip!) savings on our main bundle using <a href="https://twitter.com/hashtag/Webpack?src=hash" target="_blank" rel="external">#Webpack</a> 3 RC.2 + ModuleConcatenationPlugin 😲 🔥 Awesome work <a href="https://twitter.com/TheLarkInn" target="_blank" rel="external">@TheLarkInn</a> <a href="https://twitter.com/wSokra" target="_blank" rel="external">@wSokra</a> et al! <a href="https://t.co/zVfQoivT9d" target="_blank" rel="external">pic.twitter.com/zVfQoivT9d</a></p>&mdash; Jeremy Gayed 🤓 (@tizmagik) <a href="https://twitter.com/tizmagik/status/876128847682523138" target="_blank" rel="external">June 17, 2017</a></blockquote></p>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>而现在，使用 webpack 3，您现在可以 <strong>在配置中添加下面的插件以启用作用域提升</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">  <span class="attr">plugins</span>: [</div><div class="line">    <span class="keyword">new</span> webpack.optimize.ModuleConcatenationPlugin()</div><div class="line">  ]</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>作用域提升是基于 ECMAScript Module 语法实现的一个特征。通过这个，webpack 可以根据你正在使用什么样的模块和<a href="https://medium.com/webpack/webpack-freelancing-log-book-week-5-7-4764be3266f5" target="_blank" rel="external">一些其他条件</a>来回退到正常的捆绑。</p>
<p>为了了解什么触发了这些回退，我们添加了一个 <code>--display-optimization-bailout</code>cli 标志，它将告诉你是什么导致的回退。</p>
<p><blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Total evaluation script time went from 2.52s to 2.06s, first meaningful paint from 3.43s to 2.70s and all initial event fired 20% earlier</p>&mdash; Jeremias Menichelli (@jeremenichelli) <a href="https://twitter.com/jeremenichelli/status/876527176606265344" target="_blank" rel="external">June 18, 2017</a></blockquote></p>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>同时，由于作用域提升会移除模块外的函数包装，你可能会看到一些小的体积改进。然而，更显着的改进是JavaScript在浏览器中加载的速度。 如果您在比较使用之前和之后时发现加载速度取得了非常棒的改进，请随时回复一些数据，我们将很荣幸分享！</p>
<h2 id="🔮-魔法注释-”Magic-Comments”-🔮"><a href="#🔮-魔法注释-”Magic-Comments”-🔮" class="headerlink" title="🔮 魔法注释 ”Magic Comments” 🔮"></a>🔮 魔法注释 ”Magic Comments” 🔮</h2><p>当我们在webpack 2中引入使用动态导入语法（<code>import()</code>）时，用户表示，他们不能像使用 <code>require.ensure</code> 一样创建命名 chunk。我们现在介绍由社区创建的“魔法注释”，它可以传递 chunk 名称，还有<a href="https://medium.com/webpack/how-to-use-webpacks-new-magic-comment-feature-with-react-universal-component-ssr-a38fd3e296a" target="_blank" rel="external">更多功能</a>，例如可以添加更多的内联注释到 <code>import()</code> 语句中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "my-chunk-name" */</span> <span class="string">'module'</span>);</div></pre></td></tr></table></figure>
<p>通过使用注释，我们能够在使用动态导入语法的同时，对代码块进行命名。</p>
<p>尽管这是我们在 v2.4 和 v2.6 中发布的技术特性，但在 v3 中，我们修复了这些功能的一些错误，使其变得更稳定。 同时，现在允许动态导入语法具有与 <code>require.ensure</code> 相同的灵活性。</p>
<p><blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">TIL webpack /<em>chunkName</em>/ comments aren&#39;t just for nicer filenames—also great for organizing your chunks. Even interops w/ commonsChunk! <a href="https://t.co/wjdT9y6oTE" target="_blank" rel="external">pic.twitter.com/wjdT9y6oTE</a></p>&mdash; Adam Rackis (@AdamRackis) <a href="https://twitter.com/AdamRackis/status/872602076056088576" target="_blank" rel="external">June 7, 2017</a></blockquote></p>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>要了解更多信息，请参阅我们<a href="https://webpack.js.org/guides/code-splitting-async" target="_blank" rel="external">最新文档的代码分割部分</a>，文档高亮了这些新功能！</p>
<h2 id="😍-接下来是什么？😍"><a href="#😍-接下来是什么？😍" class="headerlink" title="😍 接下来是什么？😍"></a>😍 接下来是什么？😍</h2><p>我们有很多功能和增强功能想要推出！但我们需要了解用户需求的优先级。所以访问我们的<a href="http://webpack.js.org/vote" target="_blank" rel="external">投票页面</a>，并提出你想看到的功能！</p>
<p>这些是我们希望带给您的一些功能：</p>
<ul>
<li>更好地构建缓存</li>
<li>更快的初始构建和增量构建</li>
<li>更好的TypeScript体验</li>
<li>改进长期缓存</li>
<li>WASM模块支持</li>
<li>改善用户体验</li>
</ul>
<h2 id="🙇-致谢-🙇"><a href="#🙇-致谢-🙇" class="headerlink" title="🙇 致谢 🙇"></a>🙇 致谢 🙇</h2><p>感谢我们所有的用户，贡献者，文档作者，博客，赞助商，支持者和维护者。是他们都帮助我们确保 webpack 在未来几年成功。</p>
<p>为此，我们感谢所有人。webpack 发展到现在与你的支持密不可分，我们迫不及待地想要与你分享未来 webpack 的新进展！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;作用域提升，“魔法注释”，以及更多新特性！&quot;&gt;&lt;a href=&quot;#作用域提升，“魔法注释”，以及更多新特性！&quot; class=&quot;headerlink&quot; title=&quot;作用域提升，“魔法注释”，以及更多新特性！&quot;&gt;&lt;/a&gt;作用域提升，“魔法注释”，以及更多新特性！&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://medium.com/webpack/webpack-3-official-release-15fd2dd8f07b&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在我们发布了 webpack v2 之后，我们曾向社区做了一些承诺。 我们承诺，我们将提供用户投票的功能。 此外，我们承诺我们的发布周期会 &lt;strong&gt;更快，更稳定&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这次没有 beta 版本，完全向下兼容。我们承诺让你们、让 webpack 成长的社区更轻松的使用。webpack 团队自豪地宣布，今天我们已经发布了 webpack 3.0.0！ 现在就可以下载或升级！&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;npm install webpack@3.0.0 --save-dev&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;或者使用&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;yarn add webpack@3.0.0 --dev&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;从 webpack 2 迁移到 3，只需要执行升级命令，在使用上没有任何差别。我们将这次升级标记为版本的重大升级，是因为内部的突破性变化可能会影响某些插件的使用。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;到目前为止，98%的升级的用户都没有遇到任何不兼容！&lt;/strong&gt;
    
    </summary>
    
      <category term="webpack" scheme="http://robin-front.github.io/categories/webpack/"/>
    
    
      <category term="webpack" scheme="http://robin-front.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Flow和TypeScript之间的区别和优劣</title>
    <link href="http://robin-front.github.io/2017/06/14/Flow%E5%92%8CTypeScript%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BC%98%E5%8A%A3/"/>
    <id>http://robin-front.github.io/2017/06/14/Flow和TypeScript之间的区别和优劣/</id>
    <published>2017-06-14T15:28:54.000Z</published>
    <updated>2017-06-14T15:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>采用Flow＆TypeScript, 两者上手流程之间的比较。</p>
<p>让我们想象一下我们想要采用一种类型检查器的场景…</p>
<p>本文译自： <a href="http://thejameskyle.com/adopting-flow-and-typescript.html" target="_blank" rel="external">adopting flow and typescript</a>
<a id="more"></a></p>
<p>最近我们已经注意到了我们的应用程序中的很多NaN的出现。我们搜索源代码并找到以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// math.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n;</div><div class="line">&#125;</div><div class="line">square(<span class="string">"oops"</span>);</div></pre></td></tr></table></figure>
<p>我们对自己叹了口气，也许决定添加一个类型检查器。我们退后一步，查看我们的选项： <a href="https://flow.org/" target="_blank" rel="external">Flow</a> 或 <a href="http://www.typescriptlang.org/" target="_blank" rel="external">TypeScript</a>。</p>
<p>这两个工具都有相当简单的方法给逐个文件应用：</p>
<ul>
<li>Flow: <code>// @flow</code> 向文件顶部添加注释</li>
<li>TypeScript：将扩展名更改为<code>.js</code>扩展<code>.ts</code> 名</li>
</ul>
<p>但是让我们比较一下这里面发生了什么。</p>
<h3 id="采用TypeScript"><a href="#采用TypeScript" class="headerlink" title="采用TypeScript"></a>采用TypeScript</h3><p>要采用TypeScript，我们首先重命名<code>math.js</code>为 <code>math.ts</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// math.ts</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n;</div><div class="line">&#125;</div><div class="line">square(<span class="string">"oops"</span>);</div></pre></td></tr></table></figure>
<p>现在我们将运行typescript：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(no errors)</div></pre></td></tr></table></figure>
<p>没有错误，是因为TypeScript要求我们给函数键入注释，然后才会根据注释检查类型。如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n: number</span>): <span class="title">number</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n;</div><div class="line">&#125;</div><div class="line">square(<span class="string">"oops"</span>);</div></pre></td></tr></table></figure>
<p>如果没有这些类型，TypeScript将根据您的配置执行下面两件事情之一：</p>
<ul>
<li><ol>
<li>隐含地将每个未知类型转换为<code>any</code>。这种任何类型将让您退出所有类型检查。</li>
</ol>
</li>
<li><ol>
<li>或者如果您使用了<code>--noImplicitAny</code>选项，它会为任何未知类型抛出错误，指明需要添加类型注释。</li>
</ol>
</li>
</ul>
<p>这意味着TypeScript 覆盖的代码量与您所写的类型相关。写入类型时，类型coverage将线性上升。</p>
<h3 id="类型覆盖（type-coverage）"><a href="#类型覆盖（type-coverage）" class="headerlink" title="类型覆盖（type coverage）"></a>类型覆盖（type coverage）</h3><p>在我们进一步讲解之前，我应该解释一下什么是类型覆盖。</p>
<p><img src="http://thejameskyle.com/img/type-coverage.png" alt="未有类型覆盖的代码用红色显示"></p>
<p>未有类型覆盖的代码用红色显示</p>
<p>如果你看到你的代码中的值和表达式，并问类型检查器“你知道这是什么类型吗”。</p>
<p>如果类型检查器知道它类型，则覆盖该值或表达式。如果类型检查器不知道类型，那么它没有被覆盖。</p>
<p>您希望您的程序尽可能多地提供类型覆盖，因为这样可以在更多地方抛出错误时提前告诉您。</p>
<p>没有类型覆盖，类型检查器什么都不是。</p>
<h3 id="采用Flow"><a href="#采用Flow" class="headerlink" title="采用Flow"></a>采用Flow</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// @flow</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n;</div><div class="line">&#125;</div><div class="line">square(<span class="string">"oops"</span>);</div></pre></td></tr></table></figure>
<p>然后我们将运行Flow并查看结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n;</div><div class="line">         ^   ^</div><div class="line">         <span class="built_in">Error</span> (x2)</div><div class="line">&#125;</div><div class="line">square(<span class="string">"oops"</span>);</div><div class="line"></div><div class="line"><span class="built_in">Error</span> (x2)</div><div class="line">string. The operand <span class="keyword">of</span> an arithmetic operation must be a number.</div></pre></td></tr></table></figure>
<p>紧接着就抛出了类型错误，告诉我们代码出了问题。</p>
<p>Flow 只需要我们键入文件和外部模块的导出。可以推测出其他一切。</p>
<p>这使得类型覆盖率快得多。只需几种类型，您可以快速获取具有非常高类型覆盖率的文件。</p>
<p>根据我的经验，我可以在短短几分钟内将文件覆盖约70-90％。</p>
<p>这是一个非常科学的差异图：</p>
<p><img src="http://thejameskyle.com/img/adopting-flow-and-typescript-graph.png" alt=""></p>
<p>这不是我一家之言，你可以自己尝试一下，看看几种类型的区别。</p>
<p>要查看Flow中文件的类型覆盖，可以运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flow coverage path/to/file.js --color</div></pre></td></tr></table></figure>
<p>您还可以使用 <a href="https://github.com/rpl/flow-coverage-report" target="_blank" rel="external">流量报告</a> 来帮助您。</p>
<blockquote>
<p>注意：我没有注意到TypeScript 有任何的类型报告工具（如果您知道一个，请给我发送一个链接）。但是，您可以测试代码是否覆盖，以确定当您出现错误时是否会报告错误。</p>
</blockquote>
<h3 id="这个的工作原理是什么"><a href="#这个的工作原理是什么" class="headerlink" title="这个的工作原理是什么"></a>这个的工作原理是什么</h3><p>这两种工具具有不同行为的原因归结于其架构之间的区别。</p>
<h4 id="TypeScript体系结构：AST导向"><a href="#TypeScript体系结构：AST导向" class="headerlink" title="TypeScript体系结构：AST导向"></a>TypeScript体系结构：AST导向</h4><p>TypeScript将遍历您的程序并构建已知类型的表。当它发现值和表达式时，它会立即为其分配类型。当TypeScript发现一个未知的类型时，它必须立即作出决定，这意味着将其分配给<code>any</code>或抛出错误。</p>
<h4 id="Flow-架构：图形导向"><a href="#Flow-架构：图形导向" class="headerlink" title="Flow 架构：图形导向"></a>Flow 架构：图形导向</h4><p>Flow 将建立一个你所有的值和表达式及其彼此之间的关系的图表。然后，它将开始为每个值和表达式分配类型。如果它找到一个未知的类型，它将使它成为一个“开放”类型，稍后再回来判断。</p>
<p>一旦Flow具有您的程序的完整蓝图，它将开始连接所有点，从一个值连接到另一个值地跟踪类型。打开类型接受流入它们的所有值的类型 - 生成的类型称为 “推断类型”。</p>
<p>你可以看这个是怎么回事。来看看我们在之前的类型错误：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n;</div><div class="line">         ^   ^</div><div class="line">         <span class="built_in">Error</span> (x2)</div><div class="line">&#125;</div><div class="line">square(<span class="string">"oops"</span>);</div><div class="line"></div><div class="line"><span class="built_in">Error</span> (x2)</div><div class="line">string. The operand <span class="keyword">of</span> an arithmetic operation must be a number.</div></pre></td></tr></table></figure>
<p>注意错误是指向<code>n * n</code>而不是 <code>square(&quot;oops&quot;)</code>。因为我们没有写入一个类型为n的 “oops”字符串流入它，并且Flow开始检查n，就好像它是一个字符串。</p>
<p>添加类型注释我们可以看到错误点移动了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n: number</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n;</div><div class="line">&#125;</div><div class="line">square(<span class="string">"oops"</span>);</div><div class="line">       ^ <span class="built_in">Error</span></div><div class="line"></div><div class="line"><span class="built_in">Error</span>: string.</div><div class="line">This type is incompatible <span class="keyword">with</span> the expected param type <span class="keyword">of</span> number.</div></pre></td></tr></table></figure>
<p>这提出了一个重要的一点：Flow可以在任何地方自动推断类型并不意味着你不应该添加类型注释你的代码。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>TypeScript和Flow都有非常好的上手过程。一个个文件地尝试是一个很好的经历。</p>
<p>但是，如果使用Flow，你就会有更高以及更快的覆盖类型，你就可以安心睡觉。</p>
<p>使用Flow，您可以添加类型以使错误更友好，而不仅只是发现它们。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;采用Flow＆TypeScript, 两者上手流程之间的比较。&lt;/p&gt;
&lt;p&gt;让我们想象一下我们想要采用一种类型检查器的场景…&lt;/p&gt;
&lt;p&gt;本文译自： &lt;a href=&quot;http://thejameskyle.com/adopting-flow-and-typescript.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;adopting flow and typescript&lt;/a&gt;
    
    </summary>
    
      <category term="Flow" scheme="http://robin-front.github.io/categories/Flow/"/>
    
      <category term="TypeScript" scheme="http://robin-front.github.io/categories/Flow/TypeScript/"/>
    
    
      <category term="Flow" scheme="http://robin-front.github.io/tags/Flow/"/>
    
      <category term="TypeScript" scheme="http://robin-front.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>使用RXJS组合、过滤和映射数据流的值</title>
    <link href="http://robin-front.github.io/2017/06/05/%E4%BD%BF%E7%94%A8RXJS%E7%BB%84%E5%90%88%E3%80%81%E8%BF%87%E6%BB%A4%E5%92%8C%E6%98%A0%E5%B0%84%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E5%80%BC/"/>
    <id>http://robin-front.github.io/2017/06/05/使用RXJS组合、过滤和映射数据流的值/</id>
    <published>2017-06-05T08:24:16.000Z</published>
    <updated>2017-06-05T08:24:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查询可观测序列"><a href="#查询可观测序列" class="headerlink" title="查询可观测序列"></a>查询可观测序列</h1><p>在<a href="https://robin-front.github.io/RxJS-doc-chinese/content/getting_started_with_rxjs/creating_and_querying_observable_sequences/bridging_to_events.md">事件桥接</a> 一文中，我们将现有的DOM和Node.js事件转换成可观察的序列以订阅它们。在本主题中，我们将把可观察序列的父级class视为IObservable对象，其中Rx组件提供通用LINQ操作符来操作这些对象。大多数操作符获取可观察的序列并对其执行一些逻辑并输出另一个可观测序列。另外，从代码示例可以看出，甚至可以在源序列上使用多个运算符，最终将结果序列调整到您的确切需求。
<a id="more"></a></p>
<p>本文翻译在： <a href="https://robin-front.github.io/RxJS-doc-chinese/content/getting_started_with_rxjs/creating_and_querying_observable_sequences/querying_observable_sequences.html">RXJS中文文档</a></p>
<h2 id="使用不同的运算符"><a href="#使用不同的运算符" class="headerlink" title="使用不同的运算符"></a>使用不同的运算符</h2><p>我们已经在以前的主题中使用<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservablecreatesubscribe" target="_blank" rel="external"><code>create</code></a>和<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservablerangestart-count-scheduler" target="_blank" rel="external"><code>range</code></a>运算符来创建和返回简单的序列。我们还使用<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservablefromeventelement-eventname" target="_blank" rel="external"><code>fromEvent</code></a>和<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservablefromeventpatternaddhandler-removehandler" target="_blank" rel="external"><code>fromEventPattern</code></a>运算符将现有事件转换成可观察的序列。在本主题中，我们将使用其他<code>Observable</code>类型的运算符，以便可以过滤，分组和转换数据。这些运算符将可观察到的序列作为输入，并生成输出另一个可观察序列。</p>
<h2 id="组合不同序列"><a href="#组合不同序列" class="headerlink" title="组合不同序列"></a>组合不同序列</h2><p>在本节中，我们会研究将各种可观察序列组合成单个可观察序列的操作符。请注意，当我们组合序列时，数据不会被转换。在以下示例中，我们使用Concat运算符将两个序列组合成一个序列并订阅它。为了说明的目的，我们将使用非常简单的<code>range(x, y)</code>运算符创建一个从x开始的整数序列，然后产生y个序列数字。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> source1 = Rx.Observable.range(<span class="number">1</span>, <span class="number">3</span>);</div><div class="line"><span class="keyword">var</span> source2 = Rx.Observable.range(<span class="number">1</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line">source1.concat(source2)</div><div class="line">   .subscribe(<span class="built_in">console</span>.log.bind(<span class="built_in">console</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; 1</span></div><div class="line"><span class="comment">// =&gt; 2</span></div><div class="line"><span class="comment">// =&gt; 3</span></div><div class="line"><span class="comment">// =&gt; 1</span></div><div class="line"><span class="comment">// =&gt; 2</span></div><div class="line"><span class="comment">// =&gt; 3</span></div></pre></td></tr></table></figure>
<p>注意，结果序列是1,2,3,1,2,3。这是因为当您使用<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypeconcatargs" target="_blank" rel="external"><code>concat</code></a>运算符时，第二个序列（source2）将在第一个序列（source1）完成推送其所有值之后才会激活。只有在source1完成之后，source2才会将值推送到最后的序列。然后，订阅者将从得到的序列中获取所有值。</p>
<p>与<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypemergemaxconcurrent--other" target="_blank" rel="external"><code>merge</code></a> 操作符进行比较。如果运行以下示例代码，您将获得1,1,2,2,3,3。这是因为两个序列同时处于活动状态，并且值在数据源中发生时被推出。结果序列仅在最后一个数据源完成推送值时完成。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> source1 = Rx.Observable.range(<span class="number">1</span>, <span class="number">3</span>);</div><div class="line"><span class="keyword">var</span> source2 = Rx.Observable.range(<span class="number">1</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line">source1.merge(source2)</div><div class="line">   .subscribe(<span class="built_in">console</span>.log.bind(<span class="built_in">console</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; 1</span></div><div class="line"><span class="comment">// =&gt; 1</span></div><div class="line"><span class="comment">// =&gt; 2</span></div><div class="line"><span class="comment">// =&gt; 2</span></div><div class="line"><span class="comment">// =&gt; 3</span></div><div class="line"><span class="comment">// =&gt; 3</span></div></pre></td></tr></table></figure>
<p><a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypecatchsecond--handler" target="_blank" rel="external"><code>catch</code></a> 操作符可以进行另一个比较。在这种情况下，如果source1完成没有任何错误，那么source2将不会启动。因此，如果运行以下示例代码，则获得1,2,3因为source2（产生4,5,6））被忽略。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> source1 = Rx.Observable.range(<span class="number">1</span>, <span class="number">3</span>);</div><div class="line"><span class="keyword">var</span> source2 = Rx.Observable.range(<span class="number">4</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line">source1.catch(source2)</div><div class="line">   .subscribe(<span class="built_in">console</span>.log.bind(<span class="built_in">console</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; 1</span></div><div class="line"><span class="comment">// =&gt; 2</span></div><div class="line"><span class="comment">// =&gt; 3</span></div></pre></td></tr></table></figure>
<p>最后，我们来看看<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypeonerrorresumenextsecond" target="_blank" rel="external"><code>onErrorResumeNext</code></a>。即使由于错误导致source1无法完成，该操作符也将移动到source2。在以下示例中，即使source1表示通过使用<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservablethrowexception-scheduler" target="_blank" rel="external"><code>throw</code></a>运算符终止异常的序列，用户将接收source2发布的值（1,2,3）。因此，如果您预期到任何一个源序列产生任何错误，那么使用它<code>onErrorResumeNext</code>来保证用户仍然会收到一些值是更安全的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> source1 = Rx.Observable.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'An error has occurred.'</span>));</div><div class="line"><span class="keyword">var</span> source2 = Rx.Observable.range(<span class="number">1</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line">source1.onErrorResumeNext(source2)</div><div class="line">   .subscribe(<span class="built_in">console</span>.log.bind(<span class="built_in">console</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; 1</span></div><div class="line"><span class="comment">// =&gt; 2</span></div><div class="line"><span class="comment">// =&gt; 3</span></div></pre></td></tr></table></figure>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p><a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypeselectselector-thisarg" target="_blank" rel="external"><code>select</code></a>或 <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypemapselector-thisarg" target="_blank" rel="external"><code>map</code></a> 操作符将可观察到的一个序列的每个元素转换成另一种形式。</p>
<p>在下面的示例中，我们将一系列字符串映射到一系列表示长度的整数中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> array = [<span class="string">'Reactive'</span>, <span class="string">'Extensions'</span>, <span class="string">'RxJS'</span>];</div><div class="line"></div><div class="line"><span class="keyword">var</span> seqString = Rx.Observable.from(array);</div><div class="line"></div><div class="line"><span class="keyword">var</span> seqNum = seqString.map(<span class="function"><span class="params">x</span> =&gt;</span> x.length);</div><div class="line"></div><div class="line">seqNum</div><div class="line">   .subscribe(<span class="built_in">console</span>.log.bind(<span class="built_in">console</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; 8</span></div><div class="line"><span class="comment">// =&gt; 10</span></div><div class="line"><span class="comment">// =&gt; 4</span></div></pre></td></tr></table></figure>
<p>在以下示例中，我们在“<a href="https://robin-front.github.io/RxJS-doc-chinese/content/getting_started_with_rxjs/creating_and_querying_observable_sequences/bridging_to_events.md">桥接现有事件</a>”主题中看到的事件转换示例的扩展，我们使用<code>select</code>或<code>map</code>运算符将事件参数投影到x和y点。这样，我们将鼠标移动事件序列转换为可以进一步解析和操作的数据类型，如下一个“过滤”部分所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> move = Rx.Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'mousemove'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> points = move.map(<span class="function"><span class="params">e</span> =&gt;</span> (&#123;<span class="attr">x</span>: e.clientX, <span class="attr">y</span>: e.clientY &#125;));</div><div class="line"></div><div class="line">points.subscribe(</div><div class="line">	<span class="function"><span class="params">pos</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Mouse at point '</span> + pos.x + <span class="string">', '</span> + pos.y));</div></pre></td></tr></table></figure>
<p>最后，我们来看看<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypeselectmanyselector-resultselector" target="_blank" rel="external"><code>selectMany</code></a> or <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypeflatmapselector-resultselector" target="_blank" rel="external"><code>flatMap</code></a>运算符。<code>selectMany</code>或<code>flatMap</code>操作符具有许多重载，其中一个就是需要选择器函数作为参数。这个选择器函数是由数据源推出的每个值去调用的。对于每一个值，选择器将其映射成一个迷你的可观察序列。最后，<code>selectMany</code>或者<code>flatMap</code>操作符将所有这些迷你序列扁平化成单个结果序列，然后将其推送到用户。</p>
<p>在数据源和由选择器函数产生的所有迷你可观察序列都已经完成之后，源序列返回<code>selectMany</code>或<code>flatMap</code>发布的<code>onCompleted</code>。当发生源数据流中的错误时触发<code>onError</code>，当一个异常被选择函数抛出，或者当在任何迷你观察序列的发生了错误。</p>
<p>在下面的例子中，我们首先创建一个数据源序列，每5秒产生一个整数，并决定使用生成的前两个值（使用<code>take</code>运算符）。然后，我们使用<code>selectMany</code>或者<code>flatMap</code>对另一个序列{100,101,102}这些整数进行映射。通过这样做，产生两个迷你观察序列{100,101,102}和{100,101,102}。它们最终平坦化成{100,101,102,100,101,102}的单个整数流，并被推送到观察者。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> source1 = Rx.Observable.interval(<span class="number">5000</span>).take(<span class="number">2</span>);</div><div class="line"><span class="keyword">var</span> proj = Rx.Observable.range(<span class="number">100</span>, <span class="number">3</span>);</div><div class="line"><span class="keyword">var</span> resultSeq = source1.flatMap(proj);</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription = resultSeq.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onNext: %s'</span>, x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'onError: %s'</span>, e.message),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; onNext: 100</span></div><div class="line"><span class="comment">// =&gt; onNext: 101</span></div><div class="line"><span class="comment">// =&gt; onNext: 102</span></div><div class="line"><span class="comment">// =&gt; onNext: 100</span></div><div class="line"><span class="comment">// =&gt; onNext: 101</span></div><div class="line"><span class="comment">// =&gt; onNext: 102</span></div><div class="line"><span class="comment">// =&gt; onCompleted</span></div></pre></td></tr></table></figure>
<h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><p>在下面的例子中，我们使用<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservablegenerateinitialstate-condition-iterate-resultselector-scheduler" target="_blank" rel="external"><code>generate</code></a> 运算符创建一个简单的可观察数字序列。该<code>generate</code>操作符有几个版本，包括有相对和绝对时间调度。在我们的示例中，它需要初始状态（在我们的示例中为0），一个条件函数终止（少于10次），迭代器（+1），结果选择器（当前值的平方函数））和打印只使用小于5的那些使用<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypefilterpredicate-thisarg" target="_blank" rel="external"><code>filter</code></a>或<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypewherepredicate-thisarg" target="_blank" rel="external"><code>where</code></a>运算符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> seq = Rx.Observable.generate(</div><div class="line">	<span class="number">0</span>,</div><div class="line">	i =&gt; i &lt; <span class="number">10</span>,</div><div class="line">	i =&gt; i + <span class="number">1</span>,</div><div class="line">	i =&gt; i * i);</div><div class="line"></div><div class="line"><span class="keyword">var</span> source = seq.filter(<span class="function"><span class="params">n</span> =&gt;</span> n &lt; <span class="number">5</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onNext: %s'</span>, x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'onError: %s'</span>, e.message),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; onNext: 0</span></div><div class="line"><span class="comment">// =&gt; onNext: 1</span></div><div class="line"><span class="comment">// =&gt; onNext: 4</span></div><div class="line"><span class="comment">// =&gt; onCompleted</span></div></pre></td></tr></table></figure>
<p>以下示例是本主题前面已经看到的映射示例的扩展。在该示例中，我们使用<code>select</code>或<code>map</code>运算符将事件参数投影到具有x和y的点。在下面的例子中，我们使用<code>filter</code>或<code>where</code>和<code>select</code>或<code>map</code>操作符只挑选那些鼠标移动，我们感兴趣的是，在这种情况下，我们鼠标移动过滤，以找出在第一平分线（其中x和y坐标是相等的）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> move = Rx.Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'mousemove'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> points = move.map(<span class="function"><span class="params">e</span> =&gt;</span> (&#123; <span class="attr">x</span>: e.clientX, <span class="attr">y</span>: e.clientY &#125;));</div><div class="line"></div><div class="line"><span class="keyword">var</span> overfirstbisector = points.filter(<span class="function"><span class="params">pos</span> =&gt;</span> pos.x === pos.y);</div><div class="line"></div><div class="line"><span class="keyword">var</span> movesub = overfirstbisector.subscribe(<span class="function"><span class="params">pos</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'mouse at '</span> + pos.x + <span class="string">', '</span> pos.y));</div></pre></td></tr></table></figure>
<h2 id="基于时间的操作"><a href="#基于时间的操作" class="headerlink" title="基于时间的操作"></a>基于时间的操作</h2><p>您可以使用缓冲区运算符执行基于时间的操作。</p>
<p>缓冲可观察序列意味着可观测序列的值基于指定的时间段或计数阈值被放入缓冲区。这在您预期有大量数据被序列推出的情况下特别有用，并且订阅者没有资源来处理这些值。通过基于时间或计数缓冲结果，并且只有在超过条件时才返回值序列（或者源序列完成时），用户可以按照自己的速度处理<code>OnNext</code>调用。</p>
<p>在下面的例子中，我们首先创建一个以每秒为时间单位的简单的整数序列。然后我们使用<code>bufferWithCount</code>运算符，并指定每个缓冲区将保存序列中的5个项目。在<code>onNext</code>当缓冲区已满被调用。然后我们使用缓冲区的总和<code>Array.reduce</code>。缓冲区自动刷新，另一个循环开始。打印输出将为10,35,60 …，其中10 = 0 + 1 + 2 + 3 + 4,35 = 5 + 6 + 7 + 8 + 9等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> seq = Rx.Observable.interval(<span class="number">1000</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> bufSeq = seq.bufferWithCount(<span class="number">5</span>);</div><div class="line"></div><div class="line">bufSeq</div><div class="line">	.map(<span class="function"><span class="params">arr</span> =&gt;</span> arr.reduce(<span class="function">(<span class="params">acc, x</span>) =&gt;</span> acc + x, <span class="number">0</span>))</div><div class="line">	.subscribe(<span class="built_in">console</span>.log.bind(<span class="built_in">console</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; 10</span></div><div class="line"><span class="comment">// =&gt; 35</span></div><div class="line"><span class="comment">// =&gt; 60</span></div><div class="line">...</div></pre></td></tr></table></figure>
<p>我们还可以创建一个指定时间跨度（以毫秒为单位）的缓冲区。在以下示例中，缓冲区将保存累积3秒钟的项目。打印输出将为3,12,21 …其中3 = 0 + 1 + 2,12 = 3 + 4 + 5，依此类推。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> seq = Rx.Observable.interval(<span class="number">1000</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> bufSeq = seq.bufferWithTime(<span class="number">3000</span>);</div><div class="line"></div><div class="line">bufSeq</div><div class="line">	.map(<span class="function"><span class="params">arr</span> =&gt;</span> arr.reduce(<span class="function">(<span class="params">acc, x</span>) =&gt;</span> acc + x, <span class="number">0</span>))</div><div class="line">	.subscribe(<span class="built_in">console</span>.log.bind(<span class="built_in">console</span>));</div></pre></td></tr></table></figure>
<p>请注意，如果您使用任何一个<code>buffer*</code>或<code>window*</code>运算符，则必须确保序列不为空，然后再过滤。</p>
<h2 id="按类别操作"><a href="#按类别操作" class="headerlink" title="按类别操作"></a>按类别操作</h2><p>按<a href="https://robin-front.github.io/RxJS-doc-chinese/content/getting_started_with_rxjs/creating_and_querying_observable_sequences/operators_by_category.md">类别划分的操作符</a>主题列出了按类别实施的<code>Observable</code>的所有主要操作符; 具体来说：创建，转换，合并，功能，数学，时间，异常，杂项，选择和原值。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;查询可观测序列&quot;&gt;&lt;a href=&quot;#查询可观测序列&quot; class=&quot;headerlink&quot; title=&quot;查询可观测序列&quot;&gt;&lt;/a&gt;查询可观测序列&lt;/h1&gt;&lt;p&gt;在&lt;a href=&quot;https://robin-front.github.io/RxJS-doc-chinese/content/getting_started_with_rxjs/creating_and_querying_observable_sequences/bridging_to_events.md&quot;&gt;事件桥接&lt;/a&gt; 一文中，我们将现有的DOM和Node.js事件转换成可观察的序列以订阅它们。在本主题中，我们将把可观察序列的父级class视为IObservable对象，其中Rx组件提供通用LINQ操作符来操作这些对象。大多数操作符获取可观察的序列并对其执行一些逻辑并输出另一个可观测序列。另外，从代码示例可以看出，甚至可以在源序列上使用多个运算符，最终将结果序列调整到您的确切需求。
    
    </summary>
    
      <category term="RXJS" scheme="http://robin-front.github.io/categories/RXJS/"/>
    
    
      <category term="RXJS" scheme="http://robin-front.github.io/tags/RXJS/"/>
    
  </entry>
  
  <entry>
    <title>如何调试Node.js|使用谷歌chrome浏览器调试Node.js</title>
    <link href="http://robin-front.github.io/2017/06/02/%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95Node-js%E4%BD%BF%E7%94%A8%E8%B0%B7%E6%AD%8Cchrome%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95Node-js/"/>
    <id>http://robin-front.github.io/2017/06/02/如何调试Node-js使用谷歌chrome浏览器调试Node-js/</id>
    <published>2017-06-02T09:46:03.000Z</published>
    <updated>2017-06-02T09:46:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>如何调试 Node.js, 还在使用 console.log 来调试 Node.js 吗，可以像调试前端页面一样调试 Node.js!
<a id="more"></a></p>
<p>译文：<a href="https://medium.com/the-node-js-collection/debugging-node-js-with-google-chrome-4965b5f910f4" target="_blank" rel="external">Debugging Node.js with Google Chrome</a></p>
<p>调试是从软件应用程序中识别和删除错误的任务，而不仅仅是打印代码中的值。本文介绍如何使用最新的Google Chrome DevTools高效地调试Node.js程序。</p>
<h2 id="为什么console-log不是最好的选择？"><a href="#为什么console-log不是最好的选择？" class="headerlink" title="为什么console.log不是最好的选择？"></a>为什么console.log不是最好的选择？</h2><p>使用<code>console.log</code>来调试你的代码，通常你会无限重复地做 “停止你的应用程序，添加一个console.log，并再次启动你的应用程序” 这样的操作。除了减缓您的应用程序的开发外，它还使您的书写变得脏乱并创建不必要的代码。最后，尝试注销变量以及其他可能的日志记录操作的噪点时，可能会在尝试找到正在调试的值时使调试变得困难。</p>
<h2 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h2><p>调试工具为用户提供的是几个重要的功能<code>console.log</code>无法提供。特别是，它们允许您在代码中的特定点暂停执行应用程序，并在程序仍在运行时检查和修改变量的值。</p>
<h2 id="设置Chrome-for-Node-js调试"><a href="#设置Chrome-for-Node-js调试" class="headerlink" title="设置Chrome for Node.js调试"></a>设置Chrome for Node.js调试</h2><p>使用<code>Chrome 57+</code>，<code>Node.js</code>调试功能是默认启用的，不需要像以前的版本那样从“实验功能”面板手动启用它。</p>
<p>如果您还没有完成，请将Google Chrome更新到最新版本，并确保使用<code>Node.js 6.4+</code>。</p>
<p>要开始调试，请使用 <code>- inspect</code>标志运行<code>Node.js</code>应用程序。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ node --inspect &lt;your_file&gt; .js</div></pre></td></tr></table></figure>
<p><img src="https://cdn-images-1.medium.com/max/800/1*NIVrIoEiniOt6cP-d-0LFQ.png" alt="在调试模式下运行Node.js应用程序"></p>
<p>接下来，忽略从终端中显示的“<code>chrome-devtools://</code>”开头的URL ，而是在Google Chrome中打开“ <code>about:inspect</code> ”。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*QAmWRyPtdfF5X7VuvDN1zg.png" alt="chrome DevTools"></p>
<p>最后点击“ Open dedicated DevTools for Node” 开始调试应用程序的代码。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*zQ1uLl_qiRIAJ7Lxw_LFAQ.png" alt="deloper tools for Node"></p>
<p>此外，关于调试<a href="https://nodejs.org/en/docs/guides/debugging-getting-started/" target="_blank" rel="external">Node.js App</a>的官方文档还提供了所有其他检查器工具和客户端选项的详细列表。</p>
<h2 id="Chrome-DevTools的应用"><a href="#Chrome-DevTools的应用" class="headerlink" title="Chrome DevTools的应用"></a>Chrome DevTools的应用</h2><p>要结束本文，我想说明一下<code>Chrome DevTools</code>在以下<code>Express</code>应用程序中的应用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</div><div class="line"><span class="keyword">const</span> app = express()</div><div class="line"></div><div class="line"><span class="keyword">const</span> PORT = process.env.PORT || <span class="number">3000</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">capitalize</span> (<span class="params">str</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> firstLetter = str.charAt(<span class="number">0</span>) <span class="comment">// we can check what's inside here</span></div><div class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;firstLetter.toUpperCase()&#125;</span><span class="subst">$&#123;str.slice(<span class="number">1</span>)&#125;</span>`</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">app.get(<span class="string">'/:name?'</span>, (req, res) =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> name = req.params.name ? capitalize(req.params.name) : <span class="string">'World'</span></div><div class="line">  res.send(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>!`</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">app.listen(PORT, () =&gt; <span class="built_in">console</span>.log(<span class="string">`App listening on *:<span class="subst">$&#123;PORT&#125;</span>`</span>))</div></pre></td></tr></table></figure>
<p>让我们从运行<code>- inspect</code>标志，并打开专用<code>DevTools for Node</code>如前所述。</p>
<p>此时，您将可以访问您可能已经熟悉的所有功能：断点(<code>breakpoints</code>)，压缩代码的源映射(<code>source map for transpiled code</code>)，堆快照检查(<code>heap snapshot inspection</code>)，分配分析(<code>allocation profiling</code>)，JavaScript值热插拔(<code>JavaScript values hot-swapping</code>)等。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*jTzAaK_zRNynCMvlDbx2rA.png" alt="使用断点来调试Express应用程序"></p>
<p>具体来说，如下图所示，您可以插入断点来停止执行程序，检查和“热交换”变量的值。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*URHvZNuF7RksLoDZRbYnpQ.png" alt="JavaScript值热拔插"></p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*mk2Ro3VX6iAw7YLWJzlmtw.png" alt="JavaScript值热拔插2"></p>
<p>使用Chrome作为调试工具的另外一件好事是您可以使用相同的界面🚀调试前端和后端JavaScript代码。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何调试 Node.js, 还在使用 console.log 来调试 Node.js 吗，可以像调试前端页面一样调试 Node.js!
    
    </summary>
    
      <category term="Node.js" scheme="http://robin-front.github.io/categories/Node-js/"/>
    
    
      <category term="debug" scheme="http://robin-front.github.io/tags/debug/"/>
    
      <category term="Node.js" scheme="http://robin-front.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>RXJS我该选用哪个操作符之-创建篇</title>
    <link href="http://robin-front.github.io/2017/06/01/RXJS%E6%88%91%E8%AF%A5%E9%80%89%E7%94%A8%E5%93%AA%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8B-%E5%88%9B%E5%BB%BA%E7%AF%87/"/>
    <id>http://robin-front.github.io/2017/06/01/RXJS我该选用哪个操作符之-创建篇/</id>
    <published>2017-06-01T10:16:43.000Z</published>
    <updated>2017-06-01T10:16:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>RXJS该怎么上手？这么多操作符该用哪个？RXJS比较强大，操作符众多，想熟悉需要比较长时间的运用，所以大部分新手都比较疑惑应该使用哪些操作符去实现自己的数据流的操作。</p>
<p>更多详情请翻阅 <a href="https://robin-front.github.io/RxJS-doc-chinese">RXJS中文翻译文档</a></p>
<h1 id="我该选用哪个操作符-创建操作符"><a href="#我该选用哪个操作符-创建操作符" class="headerlink" title="我该选用哪个操作符? - 创建操作符"></a>我该选用哪个操作符? - 创建操作符</h1><p>使用此页面查找<a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/index.html"><code>Observable</code></a>符合您需求的类型创建操作：
<a id="more"></a></p>
<table style="display: table">
<thead>静态方法</thead>
<tbody>
    <!-- Observable factories -->
    <tr>
        <td rowspan="26">我想创建一个新的序列</td>
        <td rowspan="4">使用自定义逻辑</td>
        <td colspan="2"></td>
        <td>
            <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/create.html">Observable.create</a>
        </td>
    </tr>
    <tr>
        <td rowspan="3">像一个for循环</td>
        <td></td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/generate.html">Observable.generate</a></td>
    </tr>
    <tr>
        <td rowspan="2">并随时间发射值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/generatewithrelativetime.html">Observable.generateWithRelativeTime</a></td>
    </tr>
    <tr>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/generatewithabsolutetime.html">Observable.generateWithAbsoluteTime</a></td>
    </tr>
    <tr>
        <td rowspan="2">它返回一个值</td>
        <td colspan="2"></td>
        <td>
            <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/return.html">Observable.return/just</a>
        </td>
    </tr>
    <tr>
        <td colspan="2">多次</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/repeat.html">Observable.repeat</a></td>
    </tr>
    <tr>
        <td colspan="3">这会抛出错误</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/throw.html">Observable.throw</a></td>
    </tr>
    <tr>
        <td colspan="3">完成了</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/empty.html">Observable.empty</a></td>
    </tr>
    <tr>
        <td colspan="3">从来没有做任何事情</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/never.html">Observable.never</a></td>
    </tr>
    <tr>
        <td rowspan="2">从事件</td>
        <td colspan="2"></td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/fromevent.html">Observable.fromEvent</a></td>
    </tr>
    <tr>
        <td colspan="2">它使用自定义函数来添加和删除事件处理程序</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/fromeventpattern.html">Observable.fromEventPattern</a></td>
    </tr>
    <tr>
        <td colspan="3">来自一个<a title="ES6 Promise" href="https://www.promisejs.org" target="_blank" rel="external">ES6 Promise</a></td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/frompromise.html">Observable.fromPromise</a></td>
    </tr>
    <tr>
        <td rowspan="6">它可迭代</td>
        <td rowspan="2">覆盖到数组中的值</td>
        <td></td>
        <td>
            <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/fromarray.html">Observable.fromArray</a><br>
        </td>
    </tr>
    <tr>
      <td>对象键/值对</td>
      <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/pairs.html">Observable.pairs</a></td>
    </tr>
    <tr>
        <td colspan="2">异步元素</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/for.html">Observable.for</a></td>
    </tr>
    <tr>
        <td colspan="2">数值范围内的值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/range.html">Observable.range</a></td>
    </tr>
    <tr>
        <td colspan="2">来自一个可迭代的数组或类似数组的对象的值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/from.html">Observable.from</a></td>
    </tr>
    <tr>
        <td colspan="2">来自参数</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/of.html">Observable.of</a></td>
    </tr>
    <tr>
        <td rowspan="2">根据定时器发出值</td>
        <td colspan="2"></td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/interval.html">Observable.interval</a></td>
    </tr>
    <tr>
        <td colspan="2">具有可选的初始延迟</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/timer.html">Observable.timer</a></td>
    </tr>
    <tr>
        <td rowspan="2" colspan="2">不传参调用函数</td>
        <td>在特定的调度程序</td>
        <td>
            <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/start.html">Observable.start</a>
        </td>
    </tr>
    <tr>
        <td>异步</td>
        <td>
            <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/startasync.html">Observable.startAsync</a>
        </td>
    </tr>
    <tr>
        <td rowspan="4">取决于订阅时</td>
        <td colspan="2">基于布尔条件</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/if.html">Observable.if</a></td>
    </tr>
    <tr>
        <td colspan="2">f从一组预先设定的序列</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/case.html">Observable.case</a></td>
    </tr>
    <tr>
        <td colspan="1" rowspan="2">使用自定义逻辑</td>
        <td></td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/defer.html">Observable.defer</a></td>
    </tr>
    <tr>
        <td>它取决于资源</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/using.html">Observable.using</a></td>
    </tr>
    <!-- Function factories -->
    <tr>
        <td rowspan="3">我想包装一个函数</td>
        <td colspan="2"></td>
        <td rowspan="3">并产生一个序列的结果</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/toasync.html">Observable.toAsync</a></td>
    </tr>
        <td colspan="2">它接受回调</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/fromcallback.html">Observable.fromCallback</a></td>
    
    <tr>
        <td colspan="2">它接受Node.js回调</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/fromnodecallback.html">Observable.fromNodeCallback</a></td>
    </tr>
    <!-- Flatteners -->
    <tr>
        <td rowspan="30">我想结合多个序列</td>
        <td colspan="3">并且仅从产生值的序列中接收值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/amb.html">Observable.amb</a></td>
    </tr>
    <tr>
        <td colspan="3">所有人都已经完成通知</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/forkjoin.html">Observable.forkJoin</a></td>
    </tr>
    <tr>
        <td colspan="3">并输出所有这些值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/merge.html">Observable.merge</a></td>
    </tr>
    <tr>
        <td rowspan="2">为了</td>
        <td colspan="2">不改变时重复使用最新值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/operators/combinelatest.html">Observable.combineLatest</a></td>
    </tr>
    <tr>
        <td colspan="2">每个值只使用一次</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/zip.html">Observable.zip</a></td>
    </tr>
    <tr>
        <td rowspan="3">通过订阅每个序列为了</td>
        <td colspan="2">当前一个序列完成时</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/concat.html">Observable.concat</a></td>
    </tr>
    <tr>
        <td colspan="2">当另一个序列抛出错误时</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/catch.html">Observable.catch</a></td>
    </tr>
    <tr>
        <td colspan="2">不管先前的序列是完成还是抛出错误</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/onerrorresumenext.html">Observable.onErrorResumeNext</a></td>
    </tr>
    <tr>
        <td colspan="3">通过响应不同的值组合<a href="http://en.wikipedia.org/wiki/Join-calculus" target="_blank" rel="external">（连接微积分）</a></td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/when.html">Observable.when</a></td>
    </tr>
</tbody></table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RXJS该怎么上手？这么多操作符该用哪个？RXJS比较强大，操作符众多，想熟悉需要比较长时间的运用，所以大部分新手都比较疑惑应该使用哪些操作符去实现自己的数据流的操作。&lt;/p&gt;
&lt;p&gt;更多详情请翻阅 &lt;a href=&quot;https://robin-front.github.io/RxJS-doc-chinese&quot;&gt;RXJS中文翻译文档&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;我该选用哪个操作符-创建操作符&quot;&gt;&lt;a href=&quot;#我该选用哪个操作符-创建操作符&quot; class=&quot;headerlink&quot; title=&quot;我该选用哪个操作符? - 创建操作符&quot;&gt;&lt;/a&gt;我该选用哪个操作符? - 创建操作符&lt;/h1&gt;&lt;p&gt;使用此页面查找&lt;a href=&quot;https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/index.html&quot;&gt;&lt;code&gt;Observable&lt;/code&gt;&lt;/a&gt;符合您需求的类型创建操作：
    
    </summary>
    
      <category term="RXJS" scheme="http://robin-front.github.io/categories/RXJS/"/>
    
    
      <category term="RXJS" scheme="http://robin-front.github.io/tags/RXJS/"/>
    
  </entry>
  
  <entry>
    <title>RXJS我该选用哪个操作符之-实例操作符篇</title>
    <link href="http://robin-front.github.io/2017/06/01/RXJS%E6%88%91%E8%AF%A5%E9%80%89%E7%94%A8%E5%93%AA%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8B-%E5%AE%9E%E4%BE%8B%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%AF%87/"/>
    <id>http://robin-front.github.io/2017/06/01/RXJS我该选用哪个操作符之-实例操作符篇/</id>
    <published>2017-06-01T09:54:53.000Z</published>
    <updated>2017-06-01T09:54:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>RXJS比较强大，操作符众多，想熟悉需要比较长时间的运用，所以大部分新手都比较疑惑应该使用哪些操作符去实现自己的数据流的操作。</p>
<p>更多详情请翻阅 <a href="https://robin-front.github.io/RxJS-doc-chinese">RXJS中文翻译文档</a></p>
<h1 id="我该选用哪个操作符-实例操作符"><a href="#我该选用哪个操作符-实例操作符" class="headerlink" title="我该选用哪个操作符? - 实例操作符"></a>我该选用哪个操作符? - 实例操作符</h1><p>使用此页面通过类型查找<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md" target="_blank" rel="external"><code>Observable</code></a> 适合您需要的实例运算符：
<a id="more"></a></p>
<table style="display: table">
<thead>实例操作符</thead>
<tbody>
    <!-- Observable operators -->
    <tr>
        <td rowspan="71">使用现有的序列</td>
        <td colspan="3">我想改变每个值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/select.html">map/select</a></td>
    </tr>
    <tr>
        <td colspan="3">我想从每个值拉一个属性</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/pluck.html">pluck</a></td>
    </tr>
    <tr>
        <td colspan="3">我想在不影响值的情况下被通知值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/do.html">do/tap</a><br>
            <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/doonnext.html">doOnNext/tapOnNext</a><br>
            <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/doonerror.html">doOnError/tapOnError</a><br>
            <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/dooncompleted.html">doOnCompleted/tapOnCompleted</a></td>
    </tr>
    <tr>
        <td rowspan="6">我想包含值</td>
        <td colspan="2">基于自定义逻辑</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/where.html">filter/where</a></td>
    </tr>
    <tr>
        <td rowspan="2">从序列开头</td>
        <td></td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/take.html">take</a></td>
    </tr>
    <tr>
        <td>基于自定义逻辑</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/takewhile.html">takeWhile</a></td>
    </tr>
    <tr>
    </tr>
    <tr>
        <td colspan="2">从序列的末尾</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/takelast.html">takeLast</a></td>
    </tr>
    <tr>
        <td colspan="2">直到另一个序列发射一个值或完成</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/takeuntil.html">takeUntil</a></td>
    </tr>
    <tr>
        <td rowspan="7">我想忽略值</td>
        <td colspan="2">全部</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/ignoreelements.html">ignoreElements</a></td>
    </tr>
    <tr>
        <td rowspan="2">从序列的开头</td>
        <td></td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/skip.html">skip</a></td>
    </tr>
    <tr>
        <td>基于自定义逻辑</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/skipwhile.html">skipWhile</a></td>
    </tr>
    <tr>
        <td colspan="2">从序列的末尾</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/skiplast.html">skipLast</a></td>
    </tr>
    <tr>
        <td colspan="2">直到另一个序列发出一个值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/skipuntil.html">skipUntil</a></td>
    </tr>
    <tr>
        <td colspan="2">与以前的值相同</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/distinctuntilchanged.html">distinctUntilChanged</a></td>
    </tr>
    <tr>
        <td colspan="2">这（触发）太频繁</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/throttle.html">throttle</a></td>
    </tr>
    <tr>
        <td rowspan="4">我想计算</td>
        <td>总和</td>
        <td rowspan="2">这些值的</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/sum.html">sum</a></td>
    </tr>
    <tr>
        <td>平均值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/average.html">average</a></td>
    </tr>
    <tr>
        <td rowspan="2">使用自定义逻辑</td>
        <td>并且只输出最终值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/aggregate.html">aggregate</a><br>
            <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/reduce.html">reduce</a>
        </td>
    </tr>
    <tr>
        <td>并在计算出值时输出（每一步的）值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/scan.html">scan</a></td>
    </tr>
    <tr>
        <td rowspan="3">我想用元数据包装它的消息</td>
        <td colspan="2">描述每个消息</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/materialize.html">materialize</a></td>
    </tr>
    <tr>
        <td colspan="2">包括从最后一个价值以来的时间</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/timeinterval.html">timeInterval</a></td>
    </tr>
    <tr>
        <td colspan="2">包括时间戳</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/timestamp.html">timestamp</a></td>
    </tr>
    <tr>
        <td rowspan="2">经过一段时间的不活动</td>
        <td colspan="2">我想抛出一个错误</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/timeout.html">timeout</a></td>
    </tr>
    <tr>
        <td colspan="2">我想切换到另一个序列</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/timeout.html">timeout</a></td>
    </tr>
    <tr>
        <td rowspan="2">我想确保只有一个值</td>
        <td colspan="2">并且如果存在多于或少于一个值则抛出错误</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/single.html">single</a></td>
    </tr>
    <tr>
        <td colspan="2">并且如果没有值，则使用默认值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/singleordefault.html">singleOrDefault</a></td>
    </tr>
    <tr>
        <td rowspan="3">我只想取第一个值</td>
        <td colspan="2">并且如果没有值，则抛出错误</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/first.html">first</a></td>
    </tr>
    <tr>
        <td colspan="2">并且如果没有值，则使用默认值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/firstordefault.html">firstOrDefault</a></td>
    </tr>
    <tr>
        <td colspan="2">在一段时间内</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/sample.html">sample</a></td>
    </tr>
    <tr>
        <td rowspan="2">我只想取最后的值</td>
        <td colspan="2">如果没有值，则报错</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/last.html">last</a></td>
    </tr>
    <tr>
        <td colspan="2">并且如果没有值，则使用默认值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/lastordefault.html">lastOrDefault</a></td>
    </tr>
    <tr>
        <td colspan="3">我想知道它包含多少值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/count.html">count</a></td>
    </tr>
    <tr>
        <td colspan="3">我想知道它是否包含一个指定的值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/includes.html">contains</a></td>
    </tr>
    <tr>
        <td rowspan="2">我想知道条件是否满足</td>
        <td colspan="2">只需要任一值满足</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/any.html">any/some</a></td>
    </tr>
    <tr>
        <td colspan="2">需要所有值都满足</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/every.html">all/every</a></td>
    </tr>
    <tr>
        <td rowspan="2" colspan="2">我想把消息延迟一段特定的时间</td>
        <td></td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/delay.html">delay</a></td>
    </tr>
    <tr>
        <td>基于自定义逻辑</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/delaywithselector.html">delayWithSelector</a></td>
    </tr>
    <tr>
        <td rowspan="11">我想给值分组</td>
        <td colspan="2">直到序列完成</td>
        <td>
          <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/toarray.html">toArray</a><br>
          <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/tomap.html">toMap</a><br>
          <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/toset.html">toSet</a>
        </td>
    </tr>
    <tr>
        <td rowspan="2">使用自定义逻辑</td>
        <td>作为数组</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/buffer.html">buffer</a></td>
    </tr>
    <tr>
        <td>作为序列</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/window.html">window</a></td>
    </tr>
    <tr>
        <td rowspan="2">根据特定大小分批</td>
        <td>作为数组</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/bufferwithcount.html">bufferWithCount</a></td>
    </tr>
    <tr>
        <td>作为序列</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/windowwithcount.html">windowWithCount</a></td>
    </tr>
    <tr>
        <td rowspan="2">基于时间</td>
        <td>作为数组</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/bufferwithtime.html">bufferWithTime</a></td>
    </tr>
    <tr>
        <td>作为序列</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/windowwithtime.html">windowWithTime</a></td>
    </tr>
    <tr>
        <td rowspan="2">基于时间或计数，以先发生者为准</td>
        <td>作为数组</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/bufferwithtimeorcount.html">bufferWithTimeOrCount</a></td>
    </tr>
    <tr>
        <td>作为序列</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/windowwithtimeorcount.html">windowWithTimeOrCount</a></td>
    </tr>
    <tr>
        <td rowspan="2">基于一个指定的key</td>
        <td>直到序列完成</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/groupby.html">groupBy</a></td>
    </tr>
    <tr>
        <td>并控制每组的生命周期</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/groupbyuntil.html">groupByUntil</a></td>
    </tr>
    <tr>
        <td rowspan="6">我想为每个值开始一个新的序列</td>
        <td colspan="2">并且并行地从所有序列中发出值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/selectmany.html">flatMap/selectMany</a></td>
    </tr>
    <tr>
        <td colspan="2">并按顺序从每个序列中输出值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/concatmap.html">concatMap/selectConcat</a></td>
    </tr>
    <tr>
        <td colspan="2">并在新值到达时取消先前的序列</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/flatmaplatest.html">flatMapLatest/selectSwitch</a></td>
    </tr>
    <tr>
        <td colspan="2">并递归地为每个新值启动一个新的序列</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/expand.html">expand</a></td>
    </tr>
    <tr>
        <td colspan="2">并根据onNext，onError和onCompleted并行地从所有序列发出值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/flatmapobserver.html">flatMapObserver/selectManyObserver</a></td>
    </tr>
    <tr>
        <td colspan="2">并根据onNext，onError和onCompleted顺序地从所有序列发出值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/flatmapobserver.html">concatMapObserver/selectConcatObserver</a></td>
    </tr>
    <tr>
        <td>我想把它与另一个结合起来</td>
        <td colspan="2">两者都完成时发出通知</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/forkjoin.html">forkJoin</a></td>
    </tr>
    <tr>
        <td colspan="3">我想执行复杂的操作，而不会打破流畅的调用</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/let.html">let</a></td>
    </tr>
    <tr>
        <td rowspan="5">我想在多个订阅者之间共享订阅</td>
        <td colspan="2">使用特定的<code>subject</code>实现</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/multicast.html">multicast</a></td>
    </tr>
    <tr>
        <td colspan="2"></td>
        <td>
          <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/publish.html">publish</a><br>
          <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/share.html">share</a>
        </td>
    </tr>
    <tr>
        <td colspan="2">并向未来订阅者提供最后的值</td>
        <td>
          <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/publishlast.html">publishLast</a><br>
          <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/sharelast.html">shareLast</a>
        </td>
    </tr>
    <tr>
        <td colspan="2">并向未来订阅者重播默认值或最新值</td>
        <td>
          <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/publishvalue.html">publishValue</a><br>
          <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/sharevalue.html">shareValue</a>
        </td>
    </tr>
    <tr>
        <td colspan="2">并向未来的订阅者重播n个值</td>
        <td>
          <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/publish.html">replay</a><br>
          <a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/share.html">shareReplay</a>
        </td>
    </tr>
    <tr>
        <td rowspan="3">发生错误时</td>
        <td colspan="2">我想重新订阅</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/retry.html">retry</a></td>
    </tr>
    <tr>
        <td rowspan="2">我想开始一个新序列</td>
        <td></td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/catch.html">catch</a></td>
    </tr>
    <tr>
        <td>取决于错误</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/catch.html">catch</a></td>
    </tr>
    <tr>
        <td rowspan="2">当完成时</td>
        <td colspan="2">我想重新订阅</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/repeat.html">repeat</a></td>
    </tr>
    <tr>
        <td colspan="2">我想开始一个新序列</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/concat.html">concat</a></td>
    </tr>
    <tr>
        <td>当完成或抛出错误时</td>
        <td colspan="2">我想开始一个新序列</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/onerrorresumenext.html">onErrorResumeNext</a></td>
    </tr>
    <tr>
        <td>当完成，抛出错误或退订时</td>
        <td colspan="2">我想执行一个函数</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/finally.html">finally</a></td>
    </tr>
    <tr>
        <td rowspan="2">我想改变路由的调度程序</td>
        <td colspan="2">调用<code>subscribe</code>（订阅）</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/subscribeon.html">subscribeOn</a></td>
    </tr>
    <tr>
        <td colspan="2">消息</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/observeon.html">observeOn</a></td>
    </tr>
    <tr>
        <td rowspan="9">使用两个序列</td>
        <td>我想决定从哪个接收值</td>
        <td colspan="2">取决于哪个序列先发出值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/amb.html">amb</a></td>
    </tr>
    <tr>
        <td colspan="3">我想确定它们的值是否相等</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/sequenceequal.html">sequenceEqual</a></td>
    </tr>
    <tr>
        <td rowspan="5">我想合并它们的值</td>
        <td colspan="2">只有当第一个序列发射时，使用每个序列的最新值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/withlatestfrom.html">withLatestFrom</a></td>
    </tr>
    <tr>
        <td rowspan="2">为了</td>
        <td>不改变时重复使用最新值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/combinelatest.html">combineLatest</a></td>
    </tr>
    <tr>
        <td>每个值只使用一次</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/zip.html">zip</a></td>
    </tr>
    <tr>
        <td rowspan="2">重复分享我选择的“生命周期”</td>
        <td>并通知每个组合</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/join.html">join</a></td>
    </tr>
    <tr>
        <td>并给每个“左”的序列的值给“右”的序列</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/groupjoin.html">groupJoin</a></td>
    </tr>
    <tr>
        <td colspan="3">我想包含两者的值</td>
        <td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/merge.html">merge</a></td>
    </tr>
</tbody></table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RXJS比较强大，操作符众多，想熟悉需要比较长时间的运用，所以大部分新手都比较疑惑应该使用哪些操作符去实现自己的数据流的操作。&lt;/p&gt;
&lt;p&gt;更多详情请翻阅 &lt;a href=&quot;https://robin-front.github.io/RxJS-doc-chinese&quot;&gt;RXJS中文翻译文档&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;我该选用哪个操作符-实例操作符&quot;&gt;&lt;a href=&quot;#我该选用哪个操作符-实例操作符&quot; class=&quot;headerlink&quot; title=&quot;我该选用哪个操作符? - 实例操作符&quot;&gt;&lt;/a&gt;我该选用哪个操作符? - 实例操作符&lt;/h1&gt;&lt;p&gt;使用此页面通过类型查找&lt;a href=&quot;https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;Observable&lt;/code&gt;&lt;/a&gt; 适合您需要的实例运算符：
    
    </summary>
    
      <category term="RXJS" scheme="http://robin-front.github.io/categories/RXJS/"/>
    
    
      <category term="RXJS" scheme="http://robin-front.github.io/tags/RXJS/"/>
    
  </entry>
  
  <entry>
    <title>Marko和react,preact,vue相比快在哪里</title>
    <link href="http://robin-front.github.io/2017/06/01/Marko%E5%92%8Creact-preact-vue%E7%9B%B8%E6%AF%94%E5%BF%AB%E5%9C%A8%E5%93%AA%E9%87%8C/"/>
    <id>http://robin-front.github.io/2017/06/01/Marko和react-preact-vue相比快在哪里/</id>
    <published>2017-06-01T02:48:00.000Z</published>
    <updated>2017-06-01T02:48:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://hackernoon.com/why-is-marko-fast-a20796cb8ae3" target="_blank" rel="external">译文：why-is-marko-fast</a></p>
<p>在eBay，我们正在使用<code>[Marko](http://markojs.com/)</code>每天处理超过十亿的请求，这就要求我们精简我们的开源UI库Marko。我们大大优化了Marko ，以实现快速渲染，<a href="http://www.ebaytechblog.com/2014/12/08/async-fragments-rediscovering-progressive-html-rendering-with-marko/" target="_blank" rel="external">高级性能技术</a>，并实现了最小的页面重量（〜10kb gzipped）。性能只是一个方面，因为我们还必须扩展Marko以支持数百个团队的开发，从而允许开发人员有效地创建可维护和强大的Web应用程序。</p>
<p>我们已经创建了我们自己的<a href="https://github.com/marko-js/isomorphic-ui-benchmarks" target="_blank" rel="external">benchMarks</a>进行比较，也已经将Marko添加到<a href="https://github.com/raxjs/server-side-rendering-comparison/pull/11" target="_blank" rel="external">其他基准测试</a>中，但是基准测试并不总是值得信赖的。尽管我们尽可能公平地对待我们的基准，但最重要的是在现实世界的应用中的表现，而不是专注于微观基准。这就是V8团队转而采用新的方法来衡量和理解现实JavaScript性能的一个原因。</p>
<p>同样，我们已经观察过我们的开发人员实际开发中如何编写他们的Marko组件，并且发现了可以进一步优化的模式。而不是关注本文中的基准测试，我想关注我们应用于Marko的优化细节。
<a id="more"></a></p>
<h2 id="多个编译输出"><a href="#多个编译输出" class="headerlink" title="多个编译输出"></a>多个编译输出</h2><p>Marko是一个在服务器和浏览器中运行的同构UI库。正如<a href="https://medium.com/@mlrawlings" target="_blank" rel="external">Michael Rawlings</a>在“ <a href="https://hackernoon.com/server-side-rendering-shootout-with-marko-preact-rax-react-and-vue-25e1ae17800f" target="_blank" rel="external">服务器端渲染染</a> ”中提到的，当在服务器上呈现时，Marko直接呈现可以作为HTTP响应发送的文档（HTML）的字符串表示形式。</p>
<p>在浏览器中呈现时，必须解析HTML字符串才能更新DOM。因此，Marko通过程序将视图编译为直接呈现到虚拟文档（VDOM）树，这可以针对浏览器有效地更新真实的DOM。</p>
<p>给出以下模板：</p>
<p><a href="https://gist.github.com/anonymous/5ccdaadcb42dc0f5a4b2e6a956111562/raw/fa23a13e458bf8bb79dfbdc659f1248c012a799a/template.marko" target="_blank" rel="external"></a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;Hello $&#123;input.name&#125;!<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div></pre></td></tr></table></figure>
<h3 id="编译为服务器"><a href="#编译为服务器" class="headerlink" title="编译为服务器"></a>编译为服务器</h3><p>编译输出针对服务器上的HTML输出进行了优化：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> marko_template = <span class="built_in">require</span>(<span class="string">"marko/html"</span>).t(__filename),</div><div class="line">    marko_helpers = <span class="built_in">require</span>(<span class="string">"marko/runtime/html/helpers"</span>),</div><div class="line">    marko_escapeXml = marko_helpers.x;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">input, out</span>) </span>&#123;</div><div class="line">  out.w(<span class="string">"&lt;div&gt;Hello "</span> +</div><div class="line">    marko_escapeXml(input.name) +</div><div class="line">    <span class="string">"!&lt;/div&gt;"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="编译为浏览器"><a href="#编译为浏览器" class="headerlink" title="编译为浏览器"></a>编译为浏览器</h3><p>编译输出针对浏览器中的虚拟DOM渲染进行了优化：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> marko_template = <span class="built_in">require</span>(<span class="string">"marko/vdom"</span>).t(__filename);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">input, out</span>) </span>&#123;</div><div class="line">  out.e(<span class="string">"DIV"</span>, <span class="literal">null</span>, <span class="number">3</span>)</div><div class="line">    .t(<span class="string">"Hello "</span>)</div><div class="line">    .t(input.name)</div><div class="line">    .t(<span class="string">"!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="模块化运行时"><a href="#模块化运行时" class="headerlink" title="模块化运行时"></a>模块化运行时</h3><p>Marko运行时并不作为单个JavaScript文件分发。相反，Marko编译器会生成一个JavaScript模块，该模块仅导入实际需要的运行时部分。这允许我们向Marko添加新功能，而不会使现有应用程序膨胀。例如，给出以下模板：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">var</span> color = <span class="string">'red'</span>;</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;backgroundColor:</span> <span class="attr">color</span>&#125;&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>在上面的示例中，需要额外的运行时代码来根据所提供<code>style</code>的JavaScript对象呈现属性。导入<code>styleAttr</code>助手的编译代码如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> marko_styleAttr = <span class="built_in">require</span>(<span class="string">"marko/runtime/vdom/helper-styleAttr"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">input, out</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> color = <span class="string">'red'</span>;</div><div class="line">  out.e(<span class="string">"DIV"</span>, &#123;</div><div class="line">      <span class="attr">style</span>: marko_styleAttr(&#123;</div><div class="line">          <span class="attr">backgroundColor</span>: color</div><div class="line">        &#125;)</div><div class="line">    &#125;, <span class="number">0</span>, <span class="number">4</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="高性能的服务器端渲染"><a href="#高性能的服务器端渲染" class="headerlink" title="高性能的服务器端渲染"></a>高性能的服务器端渲染</h3><p>与基于专门进行虚拟DOM渲染的JSX的解决方案相比，Marko在服务器端渲染方面具有巨大的优势。当渲染到服务器上的虚拟DOM树时，它是一个两步的过程来呈现HTML：</p>
<ul>
<li>首先在内存中生成一个完整的虚拟DOM树</li>
<li>第二遍将虚拟DOM树序列化为可以通过线路发送的HTML字符串（这需要遍历整个树结构）</li>
</ul>
<p>相比之下，Marko直接一次性渲染一整个HTML流。没有中间树数据结构。</p>
<h3 id="静态子树的编译时优化"><a href="#静态子树的编译时优化" class="headerlink" title="静态子树的编译时优化"></a>静态子树的编译时优化</h3><p>给出以下模板：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;This is a &lt;strong&gt;<span class="keyword">static</span>&lt;<span class="regexp">/strong&gt; node&lt;/</span>div&gt;</div></pre></td></tr></table></figure>
<p>Marko将会认识到，模板片段每次都会产生相同的输出，因此会像以下编译输出一样创建一个虚拟DOM节点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> marko_node0 = marko_createElement(<span class="string">"DIV"</span>, <span class="literal">null</span>, <span class="number">3</span>, ...)</div><div class="line">  .t(<span class="string">"This is a "</span>)</div><div class="line">  .e(<span class="string">"STRONG"</span>, <span class="literal">null</span>, <span class="number">1</span>)</div><div class="line">    .t(<span class="string">"static"</span>)</div><div class="line">  .t(<span class="string">" node"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">input, out</span>) </span>&#123;</div><div class="line">  out.n(marko_node0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>渲染静态子树几乎是零成本。此外，Marko将跳过对比/修补静态子树。</p>
<p>同样，在服务器上，Marko会将模板的静态部分合并成一个字符串：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">input, out</span>) </span>&#123;</div><div class="line">  out.w(<span class="string">"&lt;div&gt;This is a &lt;strong&gt;static&lt;/strong&gt; node&lt;/div&gt;"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="静态属性的编译时优化"><a href="#静态属性的编译时优化" class="headerlink" title="静态属性的编译时优化"></a>静态属性的编译时优化</h3><p>Marko还将优化动态元素的静态属性。</p>
<p>给出以下模板：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div.hello&gt;Hello $&#123;input.name&#125;!<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>Marko将产生以下编译输出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> marko_attrs0 = &#123;</div><div class="line">        <span class="string">"class"</span>: <span class="string">"hello"</span></div><div class="line">      &#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">input, out</span>) </span>&#123;</div><div class="line">  out.e(<span class="string">"DIV"</span>, marko_attrs0, <span class="number">3</span>)</div><div class="line">    .t(<span class="string">"Hello "</span>)</div><div class="line">    .t(input.name)</div><div class="line">    .t(<span class="string">"!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>请注意，属性对象只创建一次，它用于每个渲染。另外，静态属性不会发生 <code>diffing</code>/<code>patching</code>。</p>
<h3 id="智能编译器"><a href="#智能编译器" class="headerlink" title="智能编译器"></a>智能编译器</h3><p>使用Marko，我们倾向于在编译时尽可能多地执行。这使我们的编译器更加复杂，但它在运行时给我们带来了很大的收获。我们有〜90％的代码覆盖率和超过2000个测试，以确保编译器正常工作。此外，在许多情况下，Marko编译器为给定的模板提供运行时提示，以便运行时可以针对特定模式进行优化。例如，识别的Marko如果HTML元素仅具有<code>class</code>/<code>id</code>/<code>style</code>定义和做版本比较时/修补运行时优化了这些虚拟DOM节点（Marko编译器生成的代码，标记简单的虚拟DOM节点用于针对 <code>diffing</code>/<code>patching</code> 逻辑）。</p>
<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>如果你正在建立一个UI组件，您将很可能需要编写代码来处理不同的DOM事件（<code>click</code>，<code>submit</code>，等）。开发人员常常编写使用<code>el.addEventListener(...)</code>或使用诸如jQuery的库来添加DOM事件监听器的代码。当您使用Marko构建UI组件时，您仍然可以执行此操作，但是在初始化大量组件时，在附加侦听器时会出现开销。相反，Marko建议使用声明式事件绑定，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;button type=<span class="string">"button"</span> on-click(<span class="string">"handleClick"</span>)&gt;</div><div class="line">  Click Me</div><div class="line">&lt;<span class="regexp">/button&gt;</span></div></pre></td></tr></table></figure>
<p>当使用声明性事件绑定时，事实上没有附加任何DOM事件侦听器。相反，Marko会为每个DOM事件（在启动时完成）为页面的根DOM元素附加一个监听器。当Marko在根节点处收到事件时，它将把事件委托给该事件的相应组件。这是通过查看<code>event.target</code>属性来查看事件发生的位置，然后向上遍历树来查找需要通知的组件。因此，当根目录捕获DOM事件时，会做更多的工作，但这种方法使用的内存少得多，并减少了初始化时需要完成的。将事件委派给组件的额外开销并不明显，因此这是一个非常有益的优化。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://hackernoon.com/why-is-marko-fast-a20796cb8ae3&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;译文：why-is-marko-fast&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在eBay，我们正在使用&lt;code&gt;[Marko](http://markojs.com/)&lt;/code&gt;每天处理超过十亿的请求，这就要求我们精简我们的开源UI库Marko。我们大大优化了Marko ，以实现快速渲染，&lt;a href=&quot;http://www.ebaytechblog.com/2014/12/08/async-fragments-rediscovering-progressive-html-rendering-with-marko/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;高级性能技术&lt;/a&gt;，并实现了最小的页面重量（〜10kb gzipped）。性能只是一个方面，因为我们还必须扩展Marko以支持数百个团队的开发，从而允许开发人员有效地创建可维护和强大的Web应用程序。&lt;/p&gt;
&lt;p&gt;我们已经创建了我们自己的&lt;a href=&quot;https://github.com/marko-js/isomorphic-ui-benchmarks&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;benchMarks&lt;/a&gt;进行比较，也已经将Marko添加到&lt;a href=&quot;https://github.com/raxjs/server-side-rendering-comparison/pull/11&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;其他基准测试&lt;/a&gt;中，但是基准测试并不总是值得信赖的。尽管我们尽可能公平地对待我们的基准，但最重要的是在现实世界的应用中的表现，而不是专注于微观基准。这就是V8团队转而采用新的方法来衡量和理解现实JavaScript性能的一个原因。&lt;/p&gt;
&lt;p&gt;同样，我们已经观察过我们的开发人员实际开发中如何编写他们的Marko组件，并且发现了可以进一步优化的模式。而不是关注本文中的基准测试，我想关注我们应用于Marko的优化细节。
    
    </summary>
    
      <category term="Marko" scheme="http://robin-front.github.io/categories/Marko/"/>
    
    
      <category term="Marko" scheme="http://robin-front.github.io/tags/Marko/"/>
    
  </entry>
  
  <entry>
    <title>npm@5发布有哪些改进</title>
    <link href="http://robin-front.github.io/2017/06/01/npm-5%E5%8F%91%E5%B8%83%E6%9C%89%E5%93%AA%E4%BA%9B%E6%94%B9%E8%BF%9B/"/>
    <id>http://robin-front.github.io/2017/06/01/npm-5发布有哪些改进/</id>
    <published>2017-06-01T02:15:45.000Z</published>
    <updated>2017-06-01T02:15:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn-images-1.medium.com/max/800/1*9nI6dL1Z-8cqFpCX96zVFA.gif" alt="npm@5 is now latest"></p>
<p>从今天开始，如果您输入“<code>npm install npm@latest -g</code>”，那么您将被更新为npm版本5。另外，在所有<a href="https://medium.com/@nodejs/node-js-8-big-improvements-for-the-debugging-and-native-module-ecosystem-58454861f2fc" target="_blank" rel="external">Node.js 8</a>的新安装中都捆绑了<code>npm@5</code> ，它已经替代了<code>Node.js 7</code>在Node Project的当前版本中。</p>
<p>在过去一年半的时间里，我们一直在努力解决大量的痛点，其中有些是创建npm以来就已经存在的。今天的发布是对npm速度，一致性和用户体验的最大改进。</p>
<p>发布说明中有什么新内容和更改内容的明确列表，但这里有一些亮点：
<a id="more"></a></p>
<h2 id="速度很快"><a href="#速度很快" class="headerlink" title="速度很快"></a>速度很快</h2><p>重新编排了包元数据，软件包下载和软件包缓存，这大大加快了工作。一般来说，期望性能提升20-100％; 我们还看到一些安装和版本冲突的运行速度提高了5倍。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/0*K1Wb1ERhtAHLRG0m." alt="speed improvements in npm@5"></p>
<p>由于npm最初的设计，开发人员已经改变了他们如何使用npm。npm生态系统不仅呈指数级增长，而且从2014年起，平均npm软件包中的依赖关系数量增加了250％。现在，更多的开发人员现在可以在本地安装Babel，Webpack和Tap等有用工具，而不是全局。这是一个最佳实践，但这意味着“<code>npm install</code>”可以做更多的工作。</p>
<p>鉴于我们社区的规模，任何速度上升都会为数百万用户带来巨大的节省，更不用说我们的所有组织和npm企业客户。使npm @ 5变快成为一个很显然的目标。</p>
<h2 id="目标一致"><a href="#目标一致" class="headerlink" title="目标一致"></a>目标一致</h2><h3 id="默认锁文件"><a href="#默认锁文件" class="headerlink" title="默认锁文件"></a>默认锁文件</h3><p><code>Shrinkwrap</code>很早就已经是npm的一部分，但<code>npm@5</code>使<code>lockfiles</code>成为默认，所以所有的npm安装现在都是可重现的。在安装给定版本的软件包时，每次安装它您获得的文件将是相同的。</p>
<p>我们发现无数常见且耗时的问题可能与不同开发人员环境利用不同软件包版本时发生的“漂移”相关。使用默认锁文件，这不再是问题。你不会浪费时间，试图找出一个错误，只是为了了解它来自运行不同版本的图书馆的人。</p>
<h3 id="SHA-512哈希"><a href="#SHA-512哈希" class="headerlink" title="SHA-512哈希"></a>SHA-512哈希</h3><p><code>npm@5</code>增加了对<code>Node.js</code>支持的任何tarball Hash功能的支持，并以SHA-512 hash发布。通过检查所有下载的软件包，您可以防止数据损坏和恶意攻击，并且您可以相信您从npm下载的代码是一致和安全的。</p>
<h3 id="自愈缓存"><a href="#自愈缓存" class="headerlink" title="自愈缓存"></a>自愈缓存</h3><p>我们的新缓存很容易损坏，但也更具弹性。多个npm进程不会破坏共享缓存，<code>npm@5</code>将检查插入和提取的数据，以防止安装损坏的数据。如果缓存项失败完整性检查，<code>npm@5</code>将自动删除它并重新获取。</p>
<h3 id="更易使用"><a href="#更易使用" class="headerlink" title="更易使用"></a>更易使用</h3><p>根据您的反馈，我们通过<code>npm @ 5</code>中的优化改进了用户体验。其中很大一部分是输出更多的有用的提示信息。最好的例子是，npm不再显示<code>package</code>上的整个树; 相反，您将看到有关安装内容的摘要报告。由于平均每个<code>package</code>中的依赖关系较大，因此我们进行了此更改。逐个文件读出结果是超过一定数量就会显得非常笨重。</p>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>有一个项目使用 <code>benchmark</code> 比较了 <code>yarn</code>, <code>pnpm</code>, <code>npm</code> 的效率, <a href="https://github.com/JamieMason/npm-cache-benchmark" target="_blank" rel="external">传送门</a></p>
<p>下面是比较结果：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Installer</th>
<th style="text-align:right">Average over 5 runs</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">yarn –offline</td>
<td style="text-align:right">5.88</td>
</tr>
<tr>
<td style="text-align:left">pnpm –offline</td>
<td style="text-align:right">6.72</td>
</tr>
<tr>
<td style="text-align:left">pnpm (cached)</td>
<td style="text-align:right">6.86</td>
</tr>
<tr>
<td style="text-align:left">npm 5.x (shrinkpacked, compressed)</td>
<td style="text-align:right">8.35</td>
</tr>
<tr>
<td style="text-align:left">npm 5.x (shrinkpacked)</td>
<td style="text-align:right">8.94</td>
</tr>
<tr>
<td style="text-align:left">npm 5.x (cached)</td>
<td style="text-align:right">11.36</td>
</tr>
<tr>
<td style="text-align:left">npm 4.x (cached)</td>
<td style="text-align:right">13.47</td>
</tr>
<tr>
<td style="text-align:left">yarn</td>
<td style="text-align:right">13.71</td>
</tr>
<tr>
<td style="text-align:left">npm 5.x</td>
<td style="text-align:right">14.93</td>
</tr>
<tr>
<td style="text-align:left">pnpm</td>
<td style="text-align:right">17.57</td>
</tr>
<tr>
<td style="text-align:left">npm 4.x (shrinkpacked, compressed)</td>
<td style="text-align:right">18.73</td>
</tr>
<tr>
<td style="text-align:left">npm 4.x (shrinkpacked)</td>
<td style="text-align:right">18.78</td>
</tr>
<tr>
<td style="text-align:left">npm 4.x</td>
<td style="text-align:right">29.73</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*9nI6dL1Z-8cqFpCX96zVFA.gif&quot; alt=&quot;npm@5 is now latest&quot;&gt;&lt;/p&gt;
&lt;p&gt;从今天开始，如果您输入“&lt;code&gt;npm install npm@latest -g&lt;/code&gt;”，那么您将被更新为npm版本5。另外，在所有&lt;a href=&quot;https://medium.com/@nodejs/node-js-8-big-improvements-for-the-debugging-and-native-module-ecosystem-58454861f2fc&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Node.js 8&lt;/a&gt;的新安装中都捆绑了&lt;code&gt;npm@5&lt;/code&gt; ，它已经替代了&lt;code&gt;Node.js 7&lt;/code&gt;在Node Project的当前版本中。&lt;/p&gt;
&lt;p&gt;在过去一年半的时间里，我们一直在努力解决大量的痛点，其中有些是创建npm以来就已经存在的。今天的发布是对npm速度，一致性和用户体验的最大改进。&lt;/p&gt;
&lt;p&gt;发布说明中有什么新内容和更改内容的明确列表，但这里有一些亮点：
    
    </summary>
    
      <category term="npm" scheme="http://robin-front.github.io/categories/npm/"/>
    
    
      <category term="npm" scheme="http://robin-front.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>JSX是什么鬼(WTF is JSX)</title>
    <link href="http://robin-front.github.io/2017/05/30/JSX%E6%98%AF%E4%BB%80%E4%B9%88%E9%AC%BC/"/>
    <id>http://robin-front.github.io/2017/05/30/JSX是什么鬼/</id>
    <published>2017-05-30T01:52:45.000Z</published>
    <updated>2017-05-30T01:52:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>JSX实际上很简单：只需要花1分钟阅读这个，你会明白有关这个有趣的替代模板的一切。
<a id="more"></a></p>
<p>替换标题：“融入JSX”</p>
<h2 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h2><p>您可以声明每个文件或每个函数来告诉您的<code>transpiler</code>（例如：<code>Babel</code>）每个节点在运行时应调用的函数的名称（请参阅“<a href="https://jasonformat.com/wtf-is-jsx/#Transpilation" target="_blank" rel="external">Transpilation</a>”）。</p>
<p>在下面的例子中，我们说的是“ <code>h()</code>为每个节点注入一个函数”：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** @jsx h */</span></div></pre></td></tr></table></figure>
<h2 id="Transpilation"><a href="#Transpilation" class="headerlink" title="Transpilation"></a>Transpilation</h2><p>如果你还没有使用解析器，你应该是尝试一下。使用ES6 / ES2015 编写，调试，测试和运行JavaScript时更为高效。<code>Babel</code>是最受欢迎和推荐的透析器，所以我会假设你正在使用它。</p>
<p>除了将ES6 / ES7 +语法转换为 ES5 以外，Babel还包括对JSX 开箱即用的转换支持。您不需要添加或更改任何内容以使用此功能。</p>
<p>通过查看一个非常简单的例子来了解它的工作原理是最简单的：</p>
<p><em>转换前</em> :( 你写的代码）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** @jsx h */</span></div><div class="line"><span class="keyword">let</span> foo = <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"foo"</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div></pre></td></tr></table></figure>
<p><em>转换后</em> :(你运行的代码）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = h(<span class="string">'div'</span>, &#123;<span class="attr">id</span>:<span class="string">"foo"</span>&#125;, <span class="string">'Hello!'</span>);</div></pre></td></tr></table></figure>
<p>你可能看第二个代码片段的时候，认为使用函数构建UI不会那么糟糕</p>
<p>这就是为什么我坐上了 <code>JSX</code> 的车：如果它从地球上消失了，用手写的输出依然会很舒服。</p>
<blockquote>
<p>JSX只是一种已经相当不错的语法的糖。</p>
</blockquote>
<p>人们甚至把它用于整个项目：<a href="https://github.com/dominictarr/hyperscript" target="_blank" rel="external">hyperscript</a></p>
<h2 id="我们来构建一个JSX渲染器"><a href="#我们来构建一个JSX渲染器" class="headerlink" title="我们来构建一个JSX渲染器"></a>我们来构建一个JSX渲染器</h2><p>首先，我们需要定义转换代码后调用的 <code>h()</code> 函数。</p>
<p>你调用任何你想要的，我使用<code>h()</code>，因为这种类型的“构建器”功能的原始想法被称为hyperscript (“hyper<del>text</del>“ + “<del>java</del>script”).。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">nodeName, attributes, ...args</span>) </span>&#123;  </div><div class="line">      <span class="keyword">let</span> children = args.length ? [].concat(...args) : <span class="literal">null</span>;</div><div class="line">      <span class="keyword">return</span> &#123; nodeName, attributes, children &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好的，这看起来很简单（ps: 只处理了 children）</p>
<blockquote>
<p>不熟悉ES6 / ES2015？</p>
<ul>
<li>这…在参数列表是一个rest param。它将“其余”的参数收集到数组中。</li>
<li>该concat(…args)位是一个扩展运算符：它需要该数组并将其扩展为参数concat()。这里使用的concat()是将子节点推入数组。</li>
</ul>
</blockquote>
<p>现在我们有这些嵌套的JSON对象我们的<code>h()</code>函数吐出来，所以我们最终得到一个这样的“树”：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">nodeName</span>: <span class="string">"div"</span>,</div><div class="line">  <span class="attr">attributes</span>: &#123;</div><div class="line">    <span class="string">"id"</span>: <span class="string">"foo"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">children</span>: [<span class="string">"Hello!"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以我们只需要一个接受该格式并抛出实际DOM节点的函数：(即沉染vdom)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode</span>) </span>&#123;  </div><div class="line">    <span class="comment">// 字符串只转换成 文本节点：</span></div><div class="line">    <span class="keyword">if</span> (vnode.split) <span class="keyword">return</span> <span class="built_in">document</span>.createTextNode(vnode);</div><div class="line"></div><div class="line">    <span class="comment">// 使用 VDOM 的 nodeName 创建一个DOM 标签</span></div><div class="line">    <span class="keyword">let</span> n = <span class="built_in">document</span>.createElement(vnode.nodeName);</div><div class="line"></div><div class="line">    <span class="comment">// 拷贝所有属性到新节点上</span></div><div class="line">    <span class="keyword">let</span> a = vnode.attributes || &#123;&#125;;</div><div class="line">    <span class="built_in">Object</span>.keys(a).forEach( <span class="function"><span class="params">k</span> =&gt;</span> n.setAttribute(k, a[k]) );</div><div class="line"></div><div class="line">    <span class="comment">// 渲染并添加子节点</span></div><div class="line">    (vnode.children || []).forEach( <span class="function"><span class="params">c</span> =&gt;</span> n.appendChild(render(c)) );</div><div class="line"></div><div class="line">    <span class="keyword">return</span> n;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>：） 不难理解这是如何工作的。
如果有帮助，您可以将“虚拟DOM”视为一个非常简单的配置，用于构建给定的DOM结构。</p>
<blockquote>
<p>虚拟DOM的好处是它非常轻巧。小对象引用其他小对象，一个由易于优化的应用程序逻辑构成的结构。</p>
<p>这也意味着它不受任何渲染逻辑或缓慢的DOM方法的束缚。</p>
</blockquote>
<h2 id="使用JSX"><a href="#使用JSX" class="headerlink" title="使用JSX"></a>使用JSX</h2><p>我们知道<code>JSX</code>被转换成<code>h()</code>函数调用。
那些函数调用创建一个简单的“虚拟”DOM树。
我们可以使用该<code>render()</code>函数来制作一个匹配的“真实”DOM树。
这就是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// JSX -&gt; VDOM:</span></div><div class="line"><span class="keyword">let</span> vdom = <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"foo"</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// VDOM -&gt; DOM:</span></div><div class="line"><span class="keyword">let</span> dom = render(vdom);</div><div class="line"></div><div class="line"><span class="comment">// add the tree to &lt;body&gt;:</span></div><div class="line"><span class="built_in">document</span>.body.appendChild(dom);</div></pre></td></tr></table></figure>
<h4 id="Partials，迭代与逻辑：没有新的语法"><a href="#Partials，迭代与逻辑：没有新的语法" class="headerlink" title="Partials，迭代与逻辑：没有新的语法"></a>Partials，迭代与逻辑：没有新的语法</h4><blockquote>
<p>我们拥有所有的JavaScript语法，而不是模板语言引入的有限概念。（PS:这是JSX胜过模板语言的地方）</p>
</blockquote>
<p>“Partials”是由无逻辑/有限逻辑模板引擎引入的概念，用于在不同的上下文中重复使用视图块。</p>
<p>迭代似乎是每个新的模板语言都重新发明的东西（我和任何人一样有罪）。使用JSX，没有新的语法来学习：迭代您在JavaScript程序中的其他任何地方。您选择最适合给定任务迭代式的：<code>[].forEach()</code>，<code>[].map()</code>，<code>for</code>和<code>while</code>循环等</p>
<p>逻辑，像迭代，是模板语言喜欢重新发明的东西。一方面，无逻辑模板在将逻辑嵌入到视图方法非常弱：有限的结构，如<code>\{\{ \#if value}}</code>将逻辑推入控制器层，鼓励膨胀。这规避了构建语言来描述更复杂的逻辑，避免可预见性和安全隐患。</p>
<p>在另一方面，使用代码生成（一种从粗略到不可原谅的技术）的引擎通常具有执行逻辑或甚至迭代任意JavaScript表达式的能力。这是一个很好的理由，不惜一切代价避免这种情况：您的代码被从原始位置（也许是一个模块，闭包或标记内）中剥离出来，并对“别的地方”评估。这对我来说是不可预测的或足够安全的。</p>
<blockquote>
<p>JSX允许所有 JavaScript的语言功能，而不依赖于在构建步骤中生成奇怪的代码，没有eval()和扩展。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将数组中的字符串以列表的形式展示</span></div><div class="line"><span class="keyword">let</span> items = [<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>];</div><div class="line"></div><div class="line"><span class="comment">// 创建列表li</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">item</span>(<span class="params">text</span>) </span>&#123;  </div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;text&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 一个使用迭代和复用的视图</span></div><div class="line"><span class="keyword">let</span> list = render(  </div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></div><div class="line">    &#123; items.map(item) &#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">);</div></pre></td></tr></table></figure>
<p><code>render()</code>返回一个DOM节点（在上述情况下是返回<ul>列表），所以我们只需要把它放到DOM中：</ul></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.body.appendChild(list);</div></pre></td></tr></table></figure>
<h2 id="把它放在一起"><a href="#把它放在一起" class="headerlink" title="把它放在一起"></a>把它放在一起</h2><p>以下是小型虚拟DOM渲染器和使用它的视图的完整源码。
具有一些样式的CodePen可在下面获得。</p>
<blockquote>
<p>同样，我也写了一个例子：<a href="https://github.com/Robin-front/code-code-hut/tree/master/jsx" target="_blank" rel="external">在任何地方使用JSX渲染DOM</a></p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">const ITEMS = 'hello there people'.split(' ');</div><div class="line"></div><div class="line">// turn an Array into list items:</div><div class="line">let list = items =&gt; items.map( p =&gt; &lt;li&gt; &#123;p&#125; &lt;/li&gt; );</div><div class="line"></div><div class="line">// view with a call out ("partial") to generate a list from an Array:</div><div class="line">let vdom = (  </div><div class="line">    &lt;div id="foo"&gt;</div><div class="line">        &lt;p&gt;Look, a simple JSX DOM renderer!&lt;/p&gt;</div><div class="line">        &lt;ul&gt;&#123; list(ITEMS) &#125;&lt;/ul&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">);</div><div class="line"></div><div class="line">// render() converts our "virtual DOM" (see below) to a real DOM tree:</div><div class="line">let dom = render(vdom);</div><div class="line"></div><div class="line">// append the new nodes somewhere:</div><div class="line">document.body.appendChild(dom);</div><div class="line"></div><div class="line">// Remember that "virtual DOM"? It's just JSON - each "VNode" is an object with 3 properties.</div><div class="line">let json = JSON.stringify(vdom, null, '  ');</div><div class="line"></div><div class="line">// The whole process (JSX -&gt; VDOM -&gt; DOM) in one step:</div><div class="line">document.body.appendChild(  </div><div class="line">    render( &lt;pre id="vdom"&gt;&#123; json &#125;&lt;/pre&gt; )</div><div class="line">);</div></pre></td></tr></table></figure>
<h2 id="Codepen演示"><a href="#Codepen演示" class="headerlink" title="Codepen演示"></a><a href="https://codepen.io/developit/embed/aOYywe/" target="_blank" rel="external">Codepen演示</a></h2><iframe src="https://codepen.io/developit/embed/aOYywe/?height=600&theme-id=16424&default-tab=result" frameborder="no" crolling="no" width="100%" height="600"></iframe>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JSX实际上很简单：只需要花1分钟阅读这个，你会明白有关这个有趣的替代模板的一切。
    
    </summary>
    
      <category term="JSX" scheme="http://robin-front.github.io/categories/JSX/"/>
    
      <category term="react" scheme="http://robin-front.github.io/categories/JSX/react/"/>
    
    
      <category term="JSX" scheme="http://robin-front.github.io/tags/JSX/"/>
    
      <category term="react" scheme="http://robin-front.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>RxJS事件桥接</title>
    <link href="http://robin-front.github.io/2017/05/05/RxJS%E4%BA%8B%E4%BB%B6%E6%A1%A5%E6%8E%A5/"/>
    <id>http://robin-front.github.io/2017/05/05/RxJS事件桥接/</id>
    <published>2017-05-05T08:51:51.000Z</published>
    <updated>2017-05-05T08:51:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事件桥接"><a href="#事件桥接" class="headerlink" title="事件桥接"></a>事件桥接</h1><p>RxJS 提供工厂方法来桥接 DOM 或 Node.js 中已存在的异步数据源，所以，你可以使用丰富的创作、过滤和资源管理功能对RxJS提供的任何类型的数据流进行操作。这篇文章探讨 <a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/fromevent.md" target="_blank" rel="external"><code>fromEvent</code></a> 和 <a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/fromeventpattern.md" target="_blank" rel="external"><code>fromEventPattern</code></a>操作符，它允许导入一个 DOM 或者普通事件到 RxJS 的数据流。每次引发事件时，一个 <code>OnNext</code> 消息将传递到数据流。然后，可以像其他任何数据流一样操作事件数据流。</p>
<p>RxJS 不打算取代现有的异步编程模型如 <code>Promises</code> 或 <code>callbacks</code>。但是，当你尝试组合事件， RxJS的工厂方法会提供简便的方法给你，你完全感受不到当前使用了何种编程模式。这真的很方便维护（比如取消订阅）和筛选（比如选择合适的数据）数据源。在本节和下节中，你可以尝试 RxJS 的这些特性如何协助你完成异步编程。</p>
<p>自然，RxJS 支持一批库和他们的勾子函数去使用他们的事件系统，比如 <a href="http://jquery.com/" target="_blank" rel="external">jQuery</a>, <a href="http://zeptojs.com/" target="_blank" rel="external">Zepto.js</a>, <a href="https://angularjs.org/" target="_blank" rel="external">AngularJS</a>, <a href="http://emberjs.com/" target="_blank" rel="external">Ember.js</a> 和 <a href="http://backbonejs.org" target="_blank" rel="external">Backbone.js</a>。这种行为，不管怎样只能重写本地绑定。默认情况下， RxJS 也支持 <a href="http://nodejs.org" target="_blank" rel="external">Node.js</a> <code>EventEmitter</code> 的事件勾子。
<a id="more"></a></p>
<h2 id="将一个-DOM-事件转换成-RxJS-数据流"><a href="#将一个-DOM-事件转换成-RxJS-数据流" class="headerlink" title="将一个 DOM 事件转换成 RxJS 数据流"></a>将一个 DOM 事件转换成 RxJS 数据流</h2><p>接下来这个例子为鼠标移动事件创建了一个 DOM 事件操作，并且在页面上打印出鼠标的坐标。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = <span class="built_in">document</span>.getElementById(<span class="string">'result'</span>);</div><div class="line"></div><div class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'mousemove'</span>, e =&gt; result.innerHTML = e.clientX + <span class="string">', '</span> + e.clientY, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<p>导入一个事件到 RxJS, 你可以使用 <a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/fromevent.md" target="_blank" rel="external"><code>fromEvent</code></a> 操作符，并且传入被桥接的事件参数。然后它会将事件转换成数据流。</p>
<p>下面这个例子，我们将 DOM 的 <code>mousemove</code> 事件流转换成事件流（可观察对象）。每次鼠标移动事件被触发时，订阅都会接收到一个 <code>onNext</code> 事件。然后我们可以检查这种通知的事件参数并获得鼠标的坐标。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = <span class="built_in">document</span>.getElementById(<span class="string">'result'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'mousemove'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(<span class="function"><span class="params">e</span> =&gt;</span> result.innerHTML = e.clientX + <span class="string">', '</span> + e.clientY);</div></pre></td></tr></table></figure>
<p>在这个例子中要注意，（鼠标）移动变成一个数据流以便我们进一步操作。 <a href="querying.md">Querying Observable Sequences</a> 这篇文章将会展示如何将该序列投射到点类型集合中并筛选其内容，以便应用程序只接收满足一定条件的值。</p>
<p>事件处理程序的销毁由 <code>subscribe</code> 方法返回的 <code>Disposable</code> 对象处理。调用 <code>dispose</code> 将会释放由该序列所使用的所有资源，包括底层事件处理程序。这本质上是取消订阅事件。</p>
<p><code>fromEvent</code> 方法还支持向多个项目添加事件处理程序，比如一整个 DOM 节点列表。下面这个例子将会给列表中的每个元素添加 ‘click’ 事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = <span class="built_in">document</span>.getElementById(<span class="string">'result'</span>);</div><div class="line"><span class="keyword">var</span> sources = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.fromEvent(sources, <span class="string">'click'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(<span class="function"><span class="params">e</span> =&gt;</span> result.innerHTML = e.clientX + <span class="string">', '</span> + e.clientY);</div></pre></td></tr></table></figure>
<p>另外，<code>fromEvent</code> 也支持类库，像 <a href="http://jquery.com/" target="_blank" rel="external">jQuery</a>, <a href="http://zeptojs.com/" target="_blank" rel="external">Zepto.js</a>, <a href="https://angularjs.org/" target="_blank" rel="external">AngularJS</a>, <a href="http://emberjs.com/" target="_blank" rel="external">Ember.js</a> and <a href="http://backbonejs.org" target="_blank" rel="external">Backbone.js</a>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $result = $(<span class="string">'#result'</span>);</div><div class="line"><span class="keyword">var</span> $sources = $(<span class="string">'div'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.fromEvent($sources, <span class="string">'click'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(<span class="function"><span class="params">e</span> =&gt;</span> $result.html(e.clientX + <span class="string">', '</span> + e.clientY));</div></pre></td></tr></table></figure>
<p>如果表现不如预期，你可以通过设置 <code>Rx.config.useNativeEvents</code> 为 <code>true</code> 去重写它，这会无视任何类库。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 只使用原生事件，尽管引用了 jQuery</span></div><div class="line">Rx.config.useNativeEvents = <span class="literal">true</span>;</div><div class="line"></div><div class="line"><span class="comment">// 只使用原生事件</span></div><div class="line"><span class="keyword">var</span> result = <span class="built_in">document</span>.getElementById(<span class="string">'result'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'mousemove'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(<span class="function"><span class="params">e</span> =&gt;</span> result.innerHTML = e.clientX + <span class="string">', '</span> + e.clientY);</div></pre></td></tr></table></figure>
<p>另外，您可以轻松地给事件系统的事件添加许多快捷方式，比如 <code>mousemove</code>， 甚至是 <a href="http://www.w3.org/TR/pointerevents/" target="_blank" rel="external">Pointer</a> and <a href="http://www.w3.org/TR/touch-events/" target="_blank" rel="external">Touch</a> 事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Rx.dom = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> events = <span class="string">"blur focus focusin focusout load resize scroll unload click dblclick "</span> +</div><div class="line">  <span class="string">"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave "</span> +</div><div class="line">  <span class="string">"change select submit keydown keypress keyup error contextmenu"</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (root.PointerEvent) &#123;</div><div class="line">  events += <span class="string">" pointerdown pointerup pointermove pointerover pointerout pointerenter pointerleave"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (root.TouchEvent) &#123;</div><div class="line">  events += <span class="string">" touchstart touchend touchmove touchcancel"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">events.split(<span class="string">' '</span>).forEach(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</div><div class="line">  Rx.dom[e] = <span class="function">(<span class="params">element, selector</span>) =&gt;</span> Rx.Observable.fromEvent(element, e, selector)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>现在我们可以重写单个鼠标拖拽事件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> draggable = <span class="built_in">document</span>.getElementById(<span class="string">'draggable'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> mousedrag = Rx.dom.mousedown(draggable).flatMap(<span class="function"><span class="params">md</span> =&gt;</span> &#123;</div><div class="line">  md.preventDefault();</div><div class="line"></div><div class="line">  <span class="keyword">var</span> start = getLocation(md);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> Rx.dom.mousemove(<span class="built_in">document</span>)</div><div class="line">    .map(<span class="function"><span class="params">mm</span> =&gt;</span> getDelta(start, mm))</div><div class="line">    .takeUntil(Rx.dom.mouseup(draggable));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>注意这在 <a href="https://github.com/Reactive-Extensions/RxJS-DOM" target="_blank" rel="external">RxJS-DOM</a> 项目中已经可用，但你自己实现也只需要很少量的代码。</p>
<h2 id="将-Node-js-事件转换成-RxJS-数据流"><a href="#将-Node-js-事件转换成-RxJS-数据流" class="headerlink" title="将 Node.js 事件转换成 RxJS 数据流"></a>将 Node.js 事件转换成 RxJS 数据流</h2><p>Node.js 也支持类似 <a href="http://nodejs.org/api/events.html#events_class_events_eventemitter" target="_blank" rel="external"><code>EventEmitter</code></a>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Rx = <span class="built_in">require</span>(<span class="string">'rx'</span>),</div><div class="line">  EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter;</div><div class="line"></div><div class="line"><span class="keyword">var</span> eventEmitter = <span class="keyword">new</span> EventEmitter();</div><div class="line"></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.fromEvent(eventEmitter, <span class="string">'data'</span>)</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'data: '</span> + data));</div><div class="line"></div><div class="line">eventEmitter.emit(<span class="string">'data'</span>, <span class="string">'foo'</span>);</div><div class="line"><span class="comment">// =&gt; data: foo</span></div></pre></td></tr></table></figure>
<h2 id="使用-FromEventPattern-桥接自定义事件"><a href="#使用-FromEventPattern-桥接自定义事件" class="headerlink" title="使用 FromEventPattern 桥接自定义事件"></a>使用 FromEventPattern 桥接自定义事件</h2><p>下面有一个使用类库实现事件订阅和退订的实例。<a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/fromeventpattern.md" target="_blank" rel="external"><code>fromEventPattern</code></a> 方法就是为了这个目的而创建的，用来桥接这些自定义事件。</p>
<p>举个例子，你可以想使用 jQuery <a href="http://api.jquery.com/on/" target="_blank" rel="external"><code>on</code></a> 方法去桥接。我们可以将下列代码转换为基于表格行单击的 alert。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$( <span class="string">"#dataTable tbody"</span> ).on(<span class="string">'click'</span>, <span class="string">'tr'</span>, e =&gt; alert($( e.target ).text()));</div></pre></td></tr></table></figure>
<p>使用 <code>fromEventPattern</code> 方法转换后的代码看起来像下面这样。每个函数在处理函数中传递，允许您调用 <code>on</code> 和 <code>off</code> 方法来正确处理事件的处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $tbody = $(<span class="string">'#dataTable tbody'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.fromEventPattern(</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">addHandler</span> (<span class="params">h</span>) </span>&#123; $tbody.on(<span class="string">'click'</span>, <span class="string">'tr'</span>, h); &#125;,</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">delHandler</span> (<span class="params">h</span>) </span>&#123; $tbody.off(<span class="string">'click'</span>, <span class="string">'tr'</span>, h); &#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(<span class="function"><span class="params">e</span> =&gt;</span> alert($( e.target ).text()));</div></pre></td></tr></table></figure>
<p>除了这种常用的支持外，我们也支持 <code>addHandler</code> 返回一个对象，它可以通过 <code>removeHandler</code> 去完全退订。在这个例子中，我们将使用 <a href="http://dojotoolkit.org" target="_blank" rel="external">Dojo Toolkit</a> 和 <a href="http://dojotoolkit.org/api/1.9/dojo/on.html" target="_blank" rel="external"><code>on</code></a> 模块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">'dojo/on'</span>, <span class="string">'dojo/dom'</span>, <span class="string">'rx'</span>, <span class="string">'rx.async'</span>, <span class="string">'rx.binding'</span>], (on, dom, rx) =&gt; &#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> input = dom.byId(<span class="string">'input'</span>);</div><div class="line"></div><div class="line">    <span class="keyword">var</span> source = Rx.Observable.fromEventPattern(</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">addHandler</span> (<span class="params">h</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> on(input, <span class="string">'click'</span>, h);</div><div class="line">        &#125;,</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">delHandler</span> (<span class="params">_, signal</span>) </span>&#123;</div><div class="line">            signal.remove();</div><div class="line">        &#125;</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="keyword">var</span> subscription = source.subscribe(</div><div class="line">        <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Next: Clicked!'</span>),</div><div class="line">        err =&gt; <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + err),</div><div class="line">        () =&gt; <span class="built_in">console</span>.log(<span class="string">'Completed'</span>));</div><div class="line"></div><div class="line">    on.emit(input, <span class="string">'click'</span>);</div><div class="line">    <span class="comment">// =&gt; Next: Clicked!</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h2><p>概念</p>
<ul>
<li><a href="querying_observable_sequences.md">Querying Observable Sequences</a></li>
</ul>
<p><a href="https://robin-front.github.io/RxJS-doc-chinese/content/getting_started_with_rxjs/creating_and_querying_observable_sequences/bridging_to_events.html">本文翻译在: RxJS中文文档</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;事件桥接&quot;&gt;&lt;a href=&quot;#事件桥接&quot; class=&quot;headerlink&quot; title=&quot;事件桥接&quot;&gt;&lt;/a&gt;事件桥接&lt;/h1&gt;&lt;p&gt;RxJS 提供工厂方法来桥接 DOM 或 Node.js 中已存在的异步数据源，所以，你可以使用丰富的创作、过滤和资源管理功能对RxJS提供的任何类型的数据流进行操作。这篇文章探讨 &lt;a href=&quot;https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/fromevent.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;fromEvent&lt;/code&gt;&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/fromeventpattern.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;fromEventPattern&lt;/code&gt;&lt;/a&gt;操作符，它允许导入一个 DOM 或者普通事件到 RxJS 的数据流。每次引发事件时，一个 &lt;code&gt;OnNext&lt;/code&gt; 消息将传递到数据流。然后，可以像其他任何数据流一样操作事件数据流。&lt;/p&gt;
&lt;p&gt;RxJS 不打算取代现有的异步编程模型如 &lt;code&gt;Promises&lt;/code&gt; 或 &lt;code&gt;callbacks&lt;/code&gt;。但是，当你尝试组合事件， RxJS的工厂方法会提供简便的方法给你，你完全感受不到当前使用了何种编程模式。这真的很方便维护（比如取消订阅）和筛选（比如选择合适的数据）数据源。在本节和下节中，你可以尝试 RxJS 的这些特性如何协助你完成异步编程。&lt;/p&gt;
&lt;p&gt;自然，RxJS 支持一批库和他们的勾子函数去使用他们的事件系统，比如 &lt;a href=&quot;http://jquery.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;jQuery&lt;/a&gt;, &lt;a href=&quot;http://zeptojs.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Zepto.js&lt;/a&gt;, &lt;a href=&quot;https://angularjs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AngularJS&lt;/a&gt;, &lt;a href=&quot;http://emberjs.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Ember.js&lt;/a&gt; 和 &lt;a href=&quot;http://backbonejs.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Backbone.js&lt;/a&gt;。这种行为，不管怎样只能重写本地绑定。默认情况下， RxJS 也支持 &lt;a href=&quot;http://nodejs.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Node.js&lt;/a&gt; &lt;code&gt;EventEmitter&lt;/code&gt; 的事件勾子。
    
    </summary>
    
      <category term="RxJS" scheme="http://robin-front.github.io/categories/RxJS/"/>
    
    
      <category term="RxJS" scheme="http://robin-front.github.io/tags/RxJS/"/>
    
      <category term="bridging" scheme="http://robin-front.github.io/tags/bridging/"/>
    
      <category term="event" scheme="http://robin-front.github.io/tags/event/"/>
    
  </entry>
  
  <entry>
    <title>使用RxJS创建和订阅单一数据流</title>
    <link href="http://robin-front.github.io/2017/05/04/%E5%88%9B%E5%BB%BA%E5%92%8C%E8%AE%A2%E9%98%85%E5%8D%95%E4%B8%80%E6%95%B0%E6%8D%AE%E6%B5%81/"/>
    <id>http://robin-front.github.io/2017/05/04/创建和订阅单一数据流/</id>
    <published>2017-05-04T10:06:14.000Z</published>
    <updated>2017-05-04T10:06:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://robin-front.gitbooks.io/rxjs-doc-chinese/content/content/getting_started_with_rxjs/creating_and_querying_observable_sequences/creating_and_subscribing_to_simple_observable_sequences.html" target="_blank" rel="external">来自</a></p>
<h1 id="创建和订阅单一可观察序列"><a href="#创建和订阅单一可观察序列" class="headerlink" title="创建和订阅单一可观察序列"></a>创建和订阅单一可观察序列</h1><p>你不需要去实现 <code>Observable</code> 类去创建一个可观察序列。 同样的，你也不需要去实现 <code>Observer</code> 去订阅数据流。通过安装 Rx 库，你可以利用 <code>Observable</code>类型，它提供了许多操作符来根据零个，一个或多个元素去创建一个数据流。另外， RxJS 还提供 <code>subscribe</code> 方法允许你使用 <code>onNext</code>, <code>onError</code> 和 <code>onCompleted</code> 函数。</p>
<a id="more"></a>
<h2 id="从零创建一个数据流"><a href="#从零创建一个数据流" class="headerlink" title="从零创建一个数据流"></a>从零创建一个数据流</h2><p>在使用操作符之前，让我们看一看怎样使用 <a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/create.md" target="_blank" rel="external"><code>Rx.Observable.create</code></a> 方法从零创建 <code>Observable</code> 。</p>
<p>首先， 我们需要确认引用了 <code>rx.js</code> 核心文件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"rx.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如果我们使用 <a href="http://node.js" target="_blank" rel="external">Node.js</a>， 我们可以这样引入:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Rx = <span class="built_in">require</span>(<span class="string">'rx'</span>);</div></pre></td></tr></table></figure>
<p>在这个例子中， 我们将只产生一个单一值42，然后标记为完成。 如果不需要清除，返回值是完全可选的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> source = Rx.Observable.create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// 产生一个单一值然后完成。</span></div><div class="line">  observer.onNext(<span class="number">42</span>);</div><div class="line">  observer.onCompleted();</div><div class="line"></div><div class="line">  <span class="comment">// 任何清除的逻辑写在这里</span></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'disposed'</span>)</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onNext: %s'</span>, x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'onError: %s'</span>, e),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; onNext: 42</span></div><div class="line"><span class="comment">// =&gt; onCompleted</span></div><div class="line"></div><div class="line">subscription.dispose();</div><div class="line"><span class="comment">// =&gt; disposed</span></div></pre></td></tr></table></figure>
<p>对于大多数操作， 这完全是多余的，但这展示了非常基础的大部分 RxJS 操作符是如何工作的。</p>
<h2 id="创建及订阅单一数据流"><a href="#创建及订阅单一数据流" class="headerlink" title="创建及订阅单一数据流"></a>创建及订阅单一数据流</h2><p>接下来的例子使用 <code>Observable</code> 类的 <a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/range.md" target="_blank" rel="external"><code>range</code></a> 操作符来创建一个包含一些数字的单一数据流。观察者使用 <code>Observable</code> 类的 <code>Subscribe</code> 订阅这个数据流集合， 并且处理回调 <code>onNext</code>, <code>onError</code> and <code>onCompleted</code>。在我们的例子中，创建了一个从 x 开始的整数序列，然后接下来产生 y 个。</p>
<p>只要订阅了数据流，数据就会发送给观察者。<code>onNext</code>函数会打印出这个值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个从 1 开始，包含 5 个整数的数据流</span></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.range(<span class="number">1</span>, <span class="number">5</span>);</div><div class="line"></div><div class="line"><span class="comment">// 打印每个值</span></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onNext: %s'</span>, x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'onError: %s'</span>, e),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; onNext: 1</span></div><div class="line"><span class="comment">// =&gt; onNext: 2</span></div><div class="line"><span class="comment">// =&gt; onNext: 3</span></div><div class="line"><span class="comment">// =&gt; onNext: 4</span></div><div class="line"><span class="comment">// =&gt; onNext: 5</span></div><div class="line"><span class="comment">// =&gt; onCompleted</span></div></pre></td></tr></table></figure>
<p>当一个观察者订阅了一个数据流， <code>subscribe</code> 方法背后使用的异步操作取决于操作符。因些， <code>subscribe</code> 的调用是异步的，因为调用者在完成序列观察之前不会被阻塞。这篇文章 <a href="schedulers.md">Using Schedulers</a> 提供了更多信息。</p>
<p>注意 <a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/susbcribe.md" target="_blank" rel="external"><code>subscribe</code></a> 方法返回一个 <code>Disposable</code>，所以你可以很容易地退订和销毁它。当你在可观察对象上调用 <code>dispose</code> 方法时，观察者将会停止监听数据流。正常来说，你不需要精确地调用 <code>dispose</code> 除非你需要提前退订，或者当数据流的生命周期比观察者的还长。 Rx 的订阅被设计成 <code>触发-丢弃</code> 的场景，并不需要终结者。注意到，可观察对象的操作符的默认表现是 只要有可能（比如，<code>onCompleted</code> 或 <code>onError</code> 消息被发送时），订阅就会被销毁。举个例子，下面的代码将会订阅 a 和 b 两个数据流。如果 a 抛出一个错误， x 会立即退订 b 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = Rx.Observable.zip(a, b, (a1, b1) =&gt; a1 + b1).subscribe();</div></pre></td></tr></table></figure>
<p>还可以调整代码示例以使用观察者的 <code>Create</code> 运算符，创建并从指定的 <code>OnNext</code>, <code>OnError</code>, 和 <code>OnCompleted</code> 回调返回一个观察者。然后你可以传递 <code>observer</code> 给 <code>observable</code> 的 <code>subscribe</code> 方法。下面的例子展示了这种写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建包含 5个整数的数据流，从 1 开始</span></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.range(<span class="number">1</span>, <span class="number">5</span>);</div><div class="line"></div><div class="line"><span class="comment">// 创建观察者</span></div><div class="line"><span class="keyword">var</span> observer = Rx.Observer.create(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onNext: %s'</span>, x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'onError: %s'</span>, e),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="comment">// 打印每个结果</span></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(observer);</div><div class="line"></div><div class="line"><span class="comment">// =&gt; onNext: 1</span></div><div class="line"><span class="comment">// =&gt; onNext: 2</span></div><div class="line"><span class="comment">// =&gt; onNext: 3</span></div><div class="line"><span class="comment">// =&gt; onNext: 4</span></div><div class="line"><span class="comment">// =&gt; onNext: 5</span></div><div class="line"><span class="comment">// =&gt; onCompleted</span></div></pre></td></tr></table></figure>
<p>另外，从零创建一个数据流，你也可以将已存在的 数据， 事件，回调以及 <code>promise</code> 转换成数据流。下一节的主题将会教你怎么做。</p>
<p>注意，这一节只展示了可以从零创建数据流的很少一部分操作符。学习更多其他的  <code>LINQ</code> 操作符， 可以查看 <a href="querying_observable_squences.md">Querying Observable Sequences</a>.</p>
<h2 id="使用定时器"><a href="#使用定时器" class="headerlink" title="使用定时器"></a>使用定时器</h2><p>接下来的例子使用 <a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/timer.md" target="_blank" rel="external"><code>timer</code></a> 操作符去创建一个数据流。 这个数据流将在5秒后输出第一个值，接着每1秒输出后面的值。为了说明， 我们配合 <a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/timestamp.md" target="_blank" rel="external"><code>timestamp</code></a> 操作符去查询，使每一个被推出来的值将在发布时追加时间戳。这样，当我们订阅这个数据源时，我们可以接收到值和时间戳。</p>
<p>首先，我们需要确认我们是否在浏览器引入了相关的文件。注意 RxJS NPM 包已经默认包含了所有操作符。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"rx.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"rx.time.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>下面是我们的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'Current time: '</span> + <span class="built_in">Date</span>.now());</div><div class="line"></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.timer(</div><div class="line">  <span class="number">5000</span>, <span class="comment">/* 5 秒 */</span></div><div class="line">  <span class="number">1000</span> <span class="comment">/* 1 秒 */</span>)</div><div class="line">   .timestamp();</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x.value + <span class="string">': '</span> + x.timestamp));</div><div class="line"></div><div class="line"><span class="comment">/* 输出可能像这样子 */</span></div><div class="line"><span class="comment">// Current time: 1382560697820</span></div><div class="line"><span class="comment">// 0: 1382560702820</span></div><div class="line"><span class="comment">// 1: 1382560703820</span></div><div class="line"><span class="comment">// 2: 1382560704820</span></div></pre></td></tr></table></figure>
<p>通过使用 <code>timestamp</code> 操作符，我们可以证实，第一个值确实是开始5秒后输出，然后每1秒输出一个值。</p>
<h2 id="将数组和可迭代对象转换为数据流"><a href="#将数组和可迭代对象转换为数据流" class="headerlink" title="将数组和可迭代对象转换为数据流"></a>将数组和可迭代对象转换为数据流</h2><p>使用 <a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/from.md" target="_blank" rel="external"><code>Rx.Observable.from</code></a> 操作符，你可以将一个数组转换为数据流。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"></div><div class="line"><span class="comment">// 将数组转换为数据流</span></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.from(array);</div><div class="line"></div><div class="line"><span class="comment">// 输出每个值</span></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onNext: %s'</span>, x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'onError: %s'</span>, e),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; onNext: 1</span></div><div class="line"><span class="comment">// =&gt; onNext: 2</span></div><div class="line"><span class="comment">// =&gt; onNext: 3</span></div><div class="line"><span class="comment">// =&gt; onNext: 4</span></div><div class="line"><span class="comment">// =&gt; onNext: 5</span></div><div class="line"><span class="comment">// =&gt; onCompleted</span></div></pre></td></tr></table></figure>
<p>你也可以转换类数组结构，比如包含 <code>length</code> 属性和数字索引的对象。这种情况下，我们只简单有一个包含长度为5的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arrayLike = &#123; <span class="attr">length</span>: <span class="number">5</span> &#125;;</div><div class="line"></div><div class="line"><span class="comment">// 转换数组为数据流</span></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.from(arrayLike, (v, k) =&gt; k);</div><div class="line"></div><div class="line"><span class="comment">// 输出每个值</span></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onNext: %s'</span>, x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'onError: %s'</span>, e),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; onNext: 1</span></div><div class="line"><span class="comment">// =&gt; onNext: 2</span></div><div class="line"><span class="comment">// =&gt; onNext: 3</span></div><div class="line"><span class="comment">// =&gt; onNext: 4</span></div><div class="line"><span class="comment">// =&gt; onNext: 5</span></div><div class="line"><span class="comment">// =&gt; onCompleted</span></div></pre></td></tr></table></figure>
<p>另外，我们也可以使用 ES6 可迭代对象，如 <code>Map</code> 和 <code>Set</code> 使用 <code>from</code> 转换成数据流。下面这个例子，我们将获取一个 <code>Set</code> 对象，并且将它转换成数据流。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</div><div class="line"></div><div class="line"><span class="comment">// 转换 Set 为数据流</span></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.from(set);</div><div class="line"></div><div class="line"><span class="comment">// 转出每个值</span></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onNext: %s'</span>, x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'onError: %s'</span>, e),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; onNext: 1</span></div><div class="line"><span class="comment">// =&gt; onNext: 2</span></div><div class="line"><span class="comment">// =&gt; onNext: 3</span></div><div class="line"><span class="comment">// =&gt; onNext: 4</span></div><div class="line"><span class="comment">// =&gt; onNext: 5</span></div><div class="line"><span class="comment">// =&gt; onCompleted</span></div></pre></td></tr></table></figure>
<p>我们也可以将它应用在 <code>Map</code> 对象上面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'key1'</span>, <span class="number">1</span>], [<span class="string">'key2'</span>, <span class="number">2</span>]]);</div><div class="line"></div><div class="line"><span class="comment">// 将 Map 转换成数据流</span></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.from(map);</div><div class="line"></div><div class="line"><span class="comment">// 打印每个值</span></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onNext: %s'</span>, x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'onError: %s'</span>, e),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; onNext: key1, 1</span></div><div class="line"><span class="comment">// =&gt; onNext: key2, 2</span></div><div class="line"><span class="comment">// =&gt; onCompleted</span></div></pre></td></tr></table></figure>
<p><code>from</code> 方法也支持 ES6 generators，可以你的浏览器已经支持，或将要支持。这允许我们实现一些像 <code>斐波那契序列</code> 等，并将它们转换成数据流。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibonacci</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> fn1 = <span class="number">1</span>;</div><div class="line">  <span class="keyword">var</span> fn2 = <span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span> (<span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">var</span> current = fn2;</div><div class="line">    fn2 = fn1;</div><div class="line">    fn1 = fn1 + current;</div><div class="line">    <span class="keyword">yield</span> current;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 将 generator 转换成数据流</span></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.from(fibonacci()).take(<span class="number">5</span>);</div><div class="line"></div><div class="line"><span class="comment">// 打印每个值</span></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onNext: %s'</span>, x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'onError: %s'</span>, e),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; onNext: 1</span></div><div class="line"><span class="comment">// =&gt; onNext: 1</span></div><div class="line"><span class="comment">// =&gt; onNext: 2</span></div><div class="line"><span class="comment">// =&gt; onNext: 3</span></div><div class="line"><span class="comment">// =&gt; onNext: 5</span></div><div class="line"><span class="comment">// =&gt; onCompleted</span></div></pre></td></tr></table></figure>
<h2 id="冷（惰性）-vs-热（非惰性）-数据流"><a href="#冷（惰性）-vs-热（非惰性）-数据流" class="headerlink" title="冷（惰性） vs. 热（非惰性） 数据流"></a>冷（惰性） vs. 热（非惰性） 数据流</h2><p>冷数据流的开始运行取决于订阅，比如，数据流只有当 <code>subscribe</code> 调用的时候才开始输出值。用户之间也没有共享值。这些是与热数据流的不同之处，热数据像流鼠标移动事件或股票代码这样的订阅时就已经不断输出值。当观察者订阅热数据流时，它将会获取流的实时值。热数据流是与所有订阅者共享的，每个订阅者按顺序推送下一个值。举个例子，就算没有人订阅一个特定的股票，股票市场也将继续根据市场动向更新其价值。当有注册者对这支股票感兴趣时，它会自动获得股票的最新值。</p>
<p>下面的示例演示了一个冷数据流。这个例子中，我们使用了 <code>Interval</code> 操作符去创建一个单一数据流并在特定的时间间隔输出值，这个例子中是间隔1秒。</p>
<p>两个观察者订阅这个数据流并打印输出值。你会注意到数据流会为每个订阅者重置，第二个订阅者也是从第1个值开始的。</p>
<p>首先，我们需要确保在浏览器中引入了相关文件。注意 RxJS NPM 包已经默认包含了所有操作符。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"rx.lite.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后是例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">1000</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription1 = source.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Observer 1: onNext: '</span> + x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'Observer 1: onError: '</span> + e.message),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'Observer 1: onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription2 = source.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Observer 2: onNext: '</span> + x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'Observer 2: onError: '</span> + e.message),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'Observer 2: onCompleted'</span>));</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  subscription1.dispose();</div><div class="line">  subscription2.dispose();</div><div class="line">&#125;, <span class="number">5000</span>);</div><div class="line"></div><div class="line"><span class="comment">// =&gt; Observer 1: onNext: 0</span></div><div class="line"><span class="comment">// =&gt; Observer 2: onNext: 0</span></div><div class="line"><span class="comment">// =&gt; Observer 1: onNext: 1</span></div><div class="line"><span class="comment">// =&gt; Observer 2: onNext: 1</span></div><div class="line"><span class="comment">// =&gt; Observer 1: onNext: 2</span></div><div class="line"><span class="comment">// =&gt; Observer 2: onNext: 2</span></div><div class="line"><span class="comment">// =&gt; Observer 1: onNext: 3</span></div><div class="line"><span class="comment">// =&gt; Observer 2: onNext: 3</span></div></pre></td></tr></table></figure>
<p>接下来的例子中，我们使用 <a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/publish.md" target="_blank" rel="external"><code>publish</code></a> 操作符将前面的冷数据源转换成热数据源，返回一个 <code>ConnectableObservable</code> 实例，我们称为 <code>hot</code>。<a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/publish.md" target="_blank" rel="external"><code>publish</code></a> 操作符通过向多个订阅服务器广播单个订阅来提供共享订阅的机制。<code>hot</code>变量作为代理订阅 <code>source</code>，因为它从 <code>source</code> 接收值，推到自己的用户. 我们使用 <a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/connect.md" target="_blank" rel="external"><code>ConnectableObservable.prototype.connect</code></a> 建立订阅的备份源，并开始接收值。因为 <code>ConnectableObservable</code> 继承自 <code>Observable</code>， 我们可以在它运行之前使用 <code>subscribe</code> 去订阅这个热数据流。 在这个例子中要注意，当 <code>subscription1</code>订阅它的时候热数据流还没有开始。因些，没有值输出给订阅者。只有调用 <code>Connect</code> 之后，输出值才会推送给 <code>subscription1</code>。3秒的延迟之后，<code>subscription2</code> 订阅了热数据流，并且立即开始接收当前输出值（当前值是3），一直到最后。输出结果看起来像这样：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// =&gt; Current <span class="built_in">time</span>: <span class="number">1382562433256</span></div><div class="line">// =&gt; Current <span class="keyword">Time</span> <span class="built_in">after</span> <span class="number">1</span>st subscription: <span class="number">1382562433260</span></div><div class="line">// =&gt; Current <span class="keyword">Time</span> <span class="built_in">after</span> connect: <span class="number">1382562436261</span></div><div class="line">// =&gt; Observer <span class="number">1</span>: onNext: <span class="number">0</span></div><div class="line">// =&gt; Observer <span class="number">1</span>: onNext: <span class="number">1</span></div><div class="line">// =&gt; Current <span class="keyword">Time</span> <span class="built_in">after</span> <span class="number">2</span>nd subscription: <span class="number">1382562439262</span></div><div class="line">// =&gt; Observer <span class="number">1</span>: onNext: <span class="number">2</span></div><div class="line">// =&gt; Observer <span class="number">2</span>: onNext: <span class="number">2</span></div><div class="line">// =&gt; Observer <span class="number">1</span>: onNext: <span class="number">3</span></div><div class="line">// =&gt; Observer <span class="number">2</span>: onNext: <span class="number">3</span></div><div class="line">// =&gt; Observer <span class="number">1</span>: onNext: <span class="number">4</span></div><div class="line">// =&gt; Observer <span class="number">2</span>: onNext: <span class="number">4</span></div></pre></td></tr></table></figure>
<p>首先，我们需要确认我们引入了相关文件。注意 RxJS NPM包已经默认包含了所有操作符。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"rx.lite.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>接下来是例子！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'Current time: '</span> + <span class="built_in">Date</span>.now());</div><div class="line"></div><div class="line"><span class="comment">// 创建一个数据流</span></div><div class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">1000</span>);</div><div class="line"></div><div class="line"><span class="comment">// 将数据流转换成热数据流</span></div><div class="line"><span class="keyword">var</span> hot = source.publish();</div><div class="line"></div><div class="line"><span class="comment">// 第一个订阅时没有值输出</span></div><div class="line"><span class="keyword">var</span> subscription1 = hot.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Observer 1: onNext: %s'</span>, x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'Observer 1: onError: %s'</span>, e),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'Observer 1: onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Current Time after 1st subscription: '</span> + <span class="built_in">Date</span>.now());</div><div class="line"></div><div class="line"><span class="comment">// 空闲 3 秒</span></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line"></div><div class="line">  <span class="comment">// 热数据源连接并开始输出值给订阅者</span></div><div class="line">  hot.connect();</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Current Time after connect: '</span> + <span class="built_in">Date</span>.now());</div><div class="line"></div><div class="line">  <span class="comment">// 又空闲 3 秒</span></div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Current Time after 2nd subscription: '</span> + <span class="built_in">Date</span>.now());</div><div class="line"></div><div class="line">    <span class="keyword">var</span> subscription2 = hot.subscribe(</div><div class="line">      <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Observer 2: onNext: %s'</span>, x),</div><div class="line">      e =&gt; <span class="built_in">console</span>.log(<span class="string">'Observer 2: onError: %s'</span>, e),</div><div class="line">      () =&gt; <span class="built_in">console</span>.log(<span class="string">'Observer 2: onCompleted'</span>));</div><div class="line"></div><div class="line">  &#125;, <span class="number">3000</span>);</div><div class="line">&#125;, <span class="number">3000</span>);</div><div class="line"></div><div class="line"><span class="comment">// =&gt; Current Time after connect: 1431197578426</span></div><div class="line"><span class="comment">// =&gt; Observer 1: onNext: 0</span></div><div class="line"><span class="comment">// =&gt; Observer 1: onNext: 1</span></div><div class="line"><span class="comment">// =&gt; Observer 1: onNext: 2</span></div><div class="line"><span class="comment">// =&gt; Current Time after 2nd subscription: 1431197581434</span></div><div class="line"><span class="comment">// =&gt; Observer 1: onNext: 3</span></div><div class="line"><span class="comment">// =&gt; Observer 2: onNext: 3</span></div><div class="line"><span class="comment">// =&gt; Observer 1: onNext: 4</span></div><div class="line"><span class="comment">// =&gt; Observer 2: onNext: 4</span></div><div class="line"><span class="comment">// =&gt; Observer 1: onNext: 5</span></div><div class="line"><span class="comment">// =&gt; Observer 2: onNext: 5</span></div><div class="line"><span class="comment">// =&gt; ...</span></div></pre></td></tr></table></figure>
<p><strong>类推</strong></p>
<p>这有助于思考冷热数据源的关系，就像一个人看（<code>subscribe</code>）电影和表演。</p>
<ul>
<li>冷数据流：电影。</li>
<li>热数据流：现场演出</li>
<li>重播热数据流：录播现场演出</li>
</ul>
<p>你管你何时观看电影，你看电影和别人看都是独立的，尽管所有观看者看的都是相同的内容。另一方面，一个表演是与多个观看都一起分享的。如果你迟到了，你将会错过一部分。不管怎样，如果记录下来了（在 RxJS中可以使用 <code>BehaviorSubject</code> 或 <code>ReplaySubject</code>），你也可像看电影一样看现场演出。<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/refcount.md" target="_blank" rel="external"><code>.publish().refCount()</code></a> 现场表演是艺术家在没有人观看的情况下退出比赛，当观众中至少有一人出现时，他会重新开始演奏。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://robin-front.gitbooks.io/rxjs-doc-chinese/content/content/getting_started_with_rxjs/creating_and_querying_observable_sequences/creating_and_subscribing_to_simple_observable_sequences.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;来自&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;创建和订阅单一可观察序列&quot;&gt;&lt;a href=&quot;#创建和订阅单一可观察序列&quot; class=&quot;headerlink&quot; title=&quot;创建和订阅单一可观察序列&quot;&gt;&lt;/a&gt;创建和订阅单一可观察序列&lt;/h1&gt;&lt;p&gt;你不需要去实现 &lt;code&gt;Observable&lt;/code&gt; 类去创建一个可观察序列。 同样的，你也不需要去实现 &lt;code&gt;Observer&lt;/code&gt; 去订阅数据流。通过安装 Rx 库，你可以利用 &lt;code&gt;Observable&lt;/code&gt;类型，它提供了许多操作符来根据零个，一个或多个元素去创建一个数据流。另外， RxJS 还提供 &lt;code&gt;subscribe&lt;/code&gt; 方法允许你使用 &lt;code&gt;onNext&lt;/code&gt;, &lt;code&gt;onError&lt;/code&gt; 和 &lt;code&gt;onCompleted&lt;/code&gt; 函数。&lt;/p&gt;
    
    </summary>
    
      <category term="RxJS" scheme="http://robin-front.github.io/categories/RxJS/"/>
    
    
      <category term="RxJS" scheme="http://robin-front.github.io/tags/RxJS/"/>
    
      <category term="Observable" scheme="http://robin-front.github.io/tags/Observable/"/>
    
  </entry>
  
  <entry>
    <title>Coverage针对js和css的代码覆盖检测-Chrome_devtools的新功能</title>
    <link href="http://robin-front.github.io/2017/04/06/Coverage%E9%92%88%E5%AF%B9js%E5%92%8Ccss%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E6%A3%80%E6%B5%8B-Chrome-devtools%E7%9A%84%E6%96%B0%E5%8A%9F%E8%83%BD/"/>
    <id>http://robin-front.github.io/2017/04/06/Coverage针对js和css的代码覆盖检测-Chrome-devtools的新功能/</id>
    <published>2017-04-06T03:21:26.000Z</published>
    <updated>2017-04-06T03:21:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>也许你之前用过一些像 <code>css usage</code>、<code>css used</code> 这样的浏览器插件去检测代码覆盖率。但现在，Chrome的实验版本<a href="https://www.google.com/chrome/browser/canary.html" target="_blank" rel="external">Canary</a>终于实现了代码覆盖率检测，这意味着它将很快普及到正式版本。这是一个令人兴奋的功能，在使用JavaScript和CSS时非常有用，所以我会做一个快速的演示，并探索它如何使用。</p>
<a id="more"></a>
<h2 id="它做了些什么事情"><a href="#它做了些什么事情" class="headerlink" title="它做了些什么事情"></a>它做了些什么事情</h2><p>代码覆盖可以在您运行您的Web应用程序的时候，遍历每个JS / CSS文件，看看哪些代码行运行，哪些代码没有运行。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*gD8lX40PSemDOZgvT695Mg.png" alt="coverage"></p>
<p>在这里，我做了一个简单的静态网页，Chrome生成了页面上存在的CSS和JS文件的问题汇总。右侧的栏显示每个文件的相对大小，红色表示未使用的代码，绿色显示运行的代码。</p>
<p>记录代码覆盖范围与devtools时间轴类似，您点击开始记录，然后在您的站点进行正常的交互。完成后，Chrome会进行一些计算并生成读数。在这里，我很好奇网站上有多少未使用的CSS，所以我导航到各个子页面，以确保我触及到每个css。果然，这里有很多改进的空间，因为我的网站上的css的97％没有使用！</p>
<p><img src="https://cdn-images-1.medium.com/max/1200/1*1SUTeKlhRee3MyKdxkUGtQ.png" alt="coverage"></p>
<p>Chrome还可让您深入研究单个文件的代码范围。在这里，左边的红色/绿色条显示哪一行执行了，哪一行没有。请注意，当检查最小化的文件时，可以按文件左下角的按钮来“<code>prettify</code>”代码。</p>
<h2 id="这有什么用"><a href="#这有什么用" class="headerlink" title="这有什么用"></a>这有什么用</h2><p>在一个复杂的或长期的项目上工作时，很容易积累冗余代码。如果你使用 <code>webpack</code> 或另一个JS构建系统，可以防止大多数无用的JS代码。但是对于CSS来说，这样做可能会有点棘手。有了这个覆盖工具，在Chrome是一个伟大的方式来快速了解多少冗余的代码在运行，哪些文件需要优化。</p>
<h2 id="如何才能使用它"><a href="#如何才能使用它" class="headerlink" title="如何才能使用它"></a>如何才能使用它</h2><p>下载Chrome的实验版本<a href="https://www.google.com/chrome/browser/canary.html" target="_blank" rel="external">Canary</a>或等待此功能更新到正式版本。</p>
<p>【译文参考】：<a href="https://blog.logrocket.com/using-the-chrome-devtools-new-code-coverage-feature-ca96c3dddcaf" target="_blank" rel="external">https://blog.logrocket.com/using-the-chrome-devtools-new-code-coverage-feature-ca96c3dddcaf</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;也许你之前用过一些像 &lt;code&gt;css usage&lt;/code&gt;、&lt;code&gt;css used&lt;/code&gt; 这样的浏览器插件去检测代码覆盖率。但现在，Chrome的实验版本&lt;a href=&quot;https://www.google.com/chrome/browser/canary.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Canary&lt;/a&gt;终于实现了代码覆盖率检测，这意味着它将很快普及到正式版本。这是一个令人兴奋的功能，在使用JavaScript和CSS时非常有用，所以我会做一个快速的演示，并探索它如何使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Chrome_devtools" scheme="http://robin-front.github.io/categories/Chrome-devtools/"/>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/Chrome-devtools/javascript/"/>
    
    
      <category term="coverage" scheme="http://robin-front.github.io/tags/coverage/"/>
    
      <category term="Chrome_devtools" scheme="http://robin-front.github.io/tags/Chrome-devtools/"/>
    
  </entry>
  
  <entry>
    <title>学习RxJS需要知道的奇淫技巧</title>
    <link href="http://robin-front.github.io/2017/04/05/%E5%AD%A6%E4%B9%A0RxJS%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7/"/>
    <id>http://robin-front.github.io/2017/04/05/学习RxJS需要知道的奇淫技巧/</id>
    <published>2017-04-05T09:06:03.000Z</published>
    <updated>2017-04-05T09:06:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-Rx-的奇淫技巧"><a href="#使用-Rx-的奇淫技巧" class="headerlink" title="使用 Rx 的奇淫技巧"></a>使用 Rx 的奇淫技巧</h1><h3 id="尝试画珠宝图"><a href="#尝试画珠宝图" class="headerlink" title="尝试画珠宝图"></a>尝试画珠宝图</h3><p>为你想创建的流画一个珠宝图。 通过画珠宝图，你将会很清楚你应该使用哪些操作符。</p>
<p>珠宝图就是每个珠宝表示当前的一个事件或状态。珠宝图需要包含输入和输出流。</p>
<p><img src="https://raw.githubusercontent.com/Reactive-Extensions/RxJS/master/doc/designguidelines/images/throttleWithTimeout.png" alt="throttleWithSelector"></p>
<a id="more"></a>
<p>通过画珠宝图，我们可以看到，我们在异步调用事件回调之前，需要延迟检测用户的输入。在这个例图里展示的是<code>throttle</code>操作符的延迟。从一个流创建另一个流，我们会使用 <code>flatMap</code> 或 <code>selectMany</code> 操作符。然后就有了下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dictionarySuggest = userInput.throttle(<span class="number">250</span>).flatMap(<span class="function"><span class="params">input</span> =&gt;</span> serverCall(input));</div></pre></td></tr></table></figure>
<h4 id="何时忽略这条指南"><a href="#何时忽略这条指南" class="headerlink" title="何时忽略这条指南"></a>何时忽略这条指南</h4><p>如果你感觉你已经可以很熟练地编写出你想要的流，你可以省去画珠宝图这一步。不管怎样，就算是 Rx 团队的成员在写代码的时候也仍然会先画一画珠宝图。</p>
<h3 id="调用-subscribe-时传递多个参数"><a href="#调用-subscribe-时传递多个参数" class="headerlink" title="调用 subscribe 时传递多个参数"></a>调用 <code>subscribe</code> 时传递多个参数</h3><p>为了方便， Rx 提供一个<code>subscribe</code>方法来加载观察者的回调函数。</p>
<p>观察者只需要实现这三个方法（<code>onNext</code>, <code>onError</code> &amp; <code>onCompleted</code>）。 <code>subscribe</code>方法的扩展允许开发人员使用这些方法的默认选项。</p>
<p>比如： 当调用<code>subscribe</code>方法时只有一个<code>onNext</code>参数，<code>onError</code>将捕获来自事件流的异常。<code>onCompleted</code>在这里什么也不会做。</p>
<p>大部分情况下，处理异常是很重要的（不管是对于恢复还是中断应用程序）。</p>
<p>知道事件流是否完成也经常是很重要的。举个例子，告诉用户他的操作是否完成了。</p>
<p>所以，最好提供完整的三个参数给 <code>subscribe</code> 操作符。</p>
<p>RxJS还提供了三种方便的方法，其仅订阅所期望的序列的一部分。其他的处理程序会默认为原来的行为。有三个这样的功能：</p>
<ul>
<li><code>subscribeOnNext</code>: 只对应 <code>onNext</code> 消息</li>
<li><code>subscribeOnError</code>: 只对应 <code>onError</code> 消息</li>
<li><code>subscribeOnCompleted</code>: 只对应 <code>onCompleted</code> 消息.</li>
</ul>
<h4 id="何时忽略这条指南-1"><a href="#何时忽略这条指南-1" class="headerlink" title="何时忽略这条指南"></a>何时忽略这条指南</h4><ul>
<li>当流确定不会有完成状态，比如 <code>keyup</code>事件。</li>
<li>当流确定不会抛出异常，比如一个事件，一个完全确定的流。</li>
<li>当默认行为是符合预期的时候。</li>
</ul>
<h3 id="考虑通过特定的调度程序并发引入操作符"><a href="#考虑通过特定的调度程序并发引入操作符" class="headerlink" title="考虑通过特定的调度程序并发引入操作符"></a>考虑通过特定的调度程序并发引入操作符</h3><p>相比使用<code>observeon</code>操作符来改变可观察序列产生消息的执行上下文，更好的做法是在正确的地方开始创建并发。 通过正确的调度器将会减少 <code>ObserveOn</code>操作符的使用。</p>
<h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Rx.Observable.range(<span class="number">0</span>, <span class="number">90000</span>, Rx.Scheduler.requestAnimationFrame).subscribe(draw);</div></pre></td></tr></table></figure>
<p>在这个例子中，来自<code>range</code>操作符的回调将会通过<code>window.requestAnimationFrame</code>传递。在这个例子中， <code>range</code>操作符的回调将被调用。默认情况下，当递归调用立即执行时，<code>range</code>过载将会代替 <code>onNext</code>在<code>Rx.Scheduler.currentThread</code>上的调用。 通过提供<code>Rx.Scheduler.requestAnimationFrame</code>调度程序， 所有来自observable的消息都将会在 <code>window.requestAnimationFrame</code>回调中产生。</p>
<h4 id="何时忽略这条指南-2"><a href="#何时忽略这条指南-2" class="headerlink" title="何时忽略这条指南"></a>何时忽略这条指南</h4><p>当结合来自不同执行上下文的几个事件时，使用指南4.4将所有消息尽可能晚地放在特定的执行上下文。</p>
<h3 id="尽可能少且尽可能迟地调用observeOn-操作符"><a href="#尽可能少且尽可能迟地调用observeOn-操作符" class="headerlink" title="尽可能少且尽可能迟地调用observeOn 操作符"></a>尽可能少且尽可能迟地调用<code>observeOn</code> 操作符</h3><p>通过使用 <code>observeOn</code> 操作符， 一个预定的功能是通过原始的消息流来获取信息。这可能会改变时序信息以及对系统施加额外的压力。在查询中延迟使用这个操作符可以改善这两个问题。</p>
<h4 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = xs.throttle(<span class="number">1000</span>)</div><div class="line">  .flatMap(<span class="function"><span class="params">x</span> =&gt;</span> ys.takeUntil(zs).sample(<span class="number">250</span>).map(<span class="function"><span class="params">y</span> =&gt;</span> x + y))</div><div class="line">  .merge(ws)</div><div class="line">  .filter(<span class="function"><span class="params">x</span> =&gt;</span> x &lt; <span class="number">10</span>)</div><div class="line">  .observeOn(Rx.Scheduler.requestAnimationFrame);</div></pre></td></tr></table></figure>
<p>这个例子合并了多个 运行在不同上下文的 observable 。这个查询筛选掉了大部分信息。将<code>observeOn</code>操作符放在查询中的前面会对筛选出来的消息做额外的工作。最后才调用 <code>observeOn</code> 将会最大限度地提高性能。</p>
<h4 id="何时忽略这条指南-3"><a href="#何时忽略这条指南-3" class="headerlink" title="何时忽略这条指南"></a>何时忽略这条指南</h4><p>如果你使用的 observable 并没有指定不同的上下文环境。这种情况下可以不必使用 <code>observeOn</code> 操作符。</p>
<h3 id="关注内存限制"><a href="#关注内存限制" class="headerlink" title="关注内存限制"></a>关注内存限制</h3><p>RxJS 有很多操作符和类可以在内存中创建 observable, 比如：<code>replay</code> 操作符。当这些内存存储着 observable 时，这些缓存的大小将取决于 observable 的操作。如果缓存过大，将会造成内存溢出。有许多缓冲操作符提供策略来限制缓冲区，不管是从时间方面还是大小。提供这个限制将解决内存压力问题。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = xs.replay(<span class="literal">null</span>, <span class="number">10000</span>, <span class="number">1000</span> * <span class="number">60</span> <span class="comment">/* 1 hr */</span>).refCount();</div></pre></td></tr></table></figure>
<p>这个例子中，<code>replay</code> 操作符创建了一个 buffer. 我们有限制这个 buffer 最多包含 10,000 条信息以及最多保留这些信息1小时。</p>
<h4 id="何时忽略这条指南-4"><a href="#何时忽略这条指南-4" class="headerlink" title="何时忽略这条指南"></a>何时忽略这条指南</h4><p>当 observable 创建了大量的信息只填充了一小块 buffer， 或者当 buffer本身有大小限制。</p>
<h3 id="使用-do-tap-操作符的副作用很明显"><a href="#使用-do-tap-操作符的副作用很明显" class="headerlink" title="使用 do/tap 操作符的副作用很明显"></a>使用 <code>do</code>/<code>tap</code> 操作符的副作用很明显</h3><p>有很多 Rx 操作符使用函数作为参数，这可以在这些参数中传递任何有效的用户代码。这些代码可以改变全局状态（比如改变全局变量，读写硬盘等等）。</p>
<p>Rx 是通过每个操作符组合起来运行的（除了共享操作符，例如“publish”）。这将使副作用发生在每个订阅。</p>
<p>如果这种表现是期望的行为，最好弄清楚在 <code>do</code>/<code>tap</code> 操作符中有副作用的这部分代码。这些方法会过载，只能调用指定的方法，比如 <code>doOnNext</code>/<code>tapOnNext</code>，<code>doOnError</code>/<code>tapOnError</code>,<code>doOnCompleted</code>/<code>tapOnCompleted</code></p>
<h4 id="例-1"><a href="#例-1" class="headerlink" title="例"></a>例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = xs.filter(<span class="function"><span class="params">x</span> =&gt;</span> x.failed).tap(<span class="function"><span class="params">x</span> =&gt;</span> log(x));</div></pre></td></tr></table></figure>
<p>这个例子中，过滤失败的消息。将它们分发到订阅observable的代码之前记录该消息。此记录有一个副作用（比如：将消息放置在计算机的事件日志中）并明确地通过调用<code>do</code>/<code>tap</code>操作符。</p>
<h3 id="假设消息可以传达，直到退订完成"><a href="#假设消息可以传达，直到退订完成" class="headerlink" title="假设消息可以传达，直到退订完成"></a>假设消息可以传达，直到退订完成</h3><p>由于RxJS 使用推模式，消息可以通过不同的上下文环境发送。 当退订的时候，消息可能还在路上。当退订还没有完成的时候，这些消息仍然可以被传达。当控制权被返回时，消息将不能再传达。退订过程可以是在一个不同的上下文环境中进行。</p>
<h4 id="何时忽略这条指南-5"><a href="#何时忽略这条指南-5" class="headerlink" title="何时忽略这条指南"></a>何时忽略这条指南</h4><p>一旦 <code>onCompleted</code> 或 <code>onError</code> 方法被调用，RxJS语法可以保证订阅已结束。</p>
<h3 id="使用-publish-操作符分享副作用"><a href="#使用-publish-操作符分享副作用" class="headerlink" title="使用 publish 操作符分享副作用"></a>使用 <code>publish</code> 操作符分享副作用</h3><p>因为许多 observable是冷门的<a href="http://channel9.msdn.com/Blogs/J.Van.Gogh/Rx-API-in-depth-Hot-and-Cold-observables" target="_blank" rel="external">(see cold vs. hot on Channel 9)</a>, 每个订阅都有单独的副作用。 某些情况下，这些副作用只发生一次。<code>publish</code> 操作符通过向多个用户广播单个订阅来提供共享订阅的机制。</p>
<p>有几个过载<code>publish</code>运算符。最方便的过载是那些提供了一个函数封装 observable 共享的副作用的参数。</p>
<h4 id="例-2"><a href="#例-2" class="headerlink" title="例"></a>例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xs = Rx.Observable.create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Side effect'</span>);</div><div class="line">  observer.onNext(<span class="string">'hi!'</span>);</div><div class="line">  observer.onCompleted();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">xs.publish(<span class="function"><span class="params">sharedXs</span> =&gt;</span> &#123;</div><div class="line">  sharedXs.subscribe(<span class="built_in">console</span>.log);</div><div class="line">  sharedXs.subscribe(<span class="built_in">console</span>.log);</div><div class="line">  <span class="keyword">return</span> sharedXs;</div><div class="line">&#125;).subscribe();</div></pre></td></tr></table></figure>
<p>这个例子中，<code>xs</code> 是一个有副作用的（写入console） observable。正常情况下，每个单独的订阅都会触发这些副作用。 <code>publish</code> 操作符使用<code>xs</code>单独给所有订阅者 <code>sharedXs</code> 变量去订阅。</p>
<h4 id="何时忽略这条指南-6"><a href="#何时忽略这条指南-6" class="headerlink" title="何时忽略这条指南"></a>何时忽略这条指南</h4><p>只有当 <code>publish</code> 操作符需要共享副作用时才使用这条指南。在大多数情况下，您可以创建单独的订阅，没有任何问题：不管是订阅没有副作用的或是副作用可以执行多次没有任何问题的。</p>
<p><a href="https://github.com/Reactive-Extensions/RxJS/tree/master/doc/designguidelines#4-using-rx" target="_blank" rel="external">参考</a>
<a href="https://robin-front.gitbooks.io/rxjs-doc-chinese/content/content/guidelines/using.html" target="_blank" rel="external">同步翻译至RxJS中文文档</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用-Rx-的奇淫技巧&quot;&gt;&lt;a href=&quot;#使用-Rx-的奇淫技巧&quot; class=&quot;headerlink&quot; title=&quot;使用 Rx 的奇淫技巧&quot;&gt;&lt;/a&gt;使用 Rx 的奇淫技巧&lt;/h1&gt;&lt;h3 id=&quot;尝试画珠宝图&quot;&gt;&lt;a href=&quot;#尝试画珠宝图&quot; class=&quot;headerlink&quot; title=&quot;尝试画珠宝图&quot;&gt;&lt;/a&gt;尝试画珠宝图&lt;/h3&gt;&lt;p&gt;为你想创建的流画一个珠宝图。 通过画珠宝图，你将会很清楚你应该使用哪些操作符。&lt;/p&gt;
&lt;p&gt;珠宝图就是每个珠宝表示当前的一个事件或状态。珠宝图需要包含输入和输出流。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Reactive-Extensions/RxJS/master/doc/designguidelines/images/throttleWithTimeout.png&quot; alt=&quot;throttleWithSelector&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="RxJS" scheme="http://robin-front.github.io/categories/RxJS/"/>
    
    
      <category term="RxJS" scheme="http://robin-front.github.io/tags/RxJS/"/>
    
  </entry>
  
  <entry>
    <title>为什么选择 RxJS?</title>
    <link href="http://robin-front.github.io/2017/04/04/why-rxjs/"/>
    <id>http://robin-front.github.io/2017/04/04/why-rxjs/</id>
    <published>2017-04-04T09:48:15.000Z</published>
    <updated>2017-04-04T09:48:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Why-RxJS"><a href="#Why-RxJS" class="headerlink" title="Why RxJS?"></a>Why RxJS?</h2><p>你可能会问，为什么选择 RxJS?  为什么不是 Promises? Promises 可以很好地解决异步操作，像使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" target="_blank" rel="external">XMLHttpRequest</a> 去查询服务器, 它预期会返回值并且最终完成请求。  <code>The Reactive Extensions</code> 统一了 <code>JavaScript</code> 中的 <code>Promises</code>, <code>callbacks</code> 以及事件数据，比如 DOM输入, <code>Web Workers</code>, <code>Web Sockets</code>. 一旦我们统一了这些概念，就可以进行各种各样的组合.</p>
<a id="more"></a>
<p>为了让您了解丰富的组合，我们可以创建一个自动完成功能，它从文本输入中接收用户输入，然后查询服务，确保不会对每个键盘输入的进行泛滥地调用，而是以一种更自然的方式调用。</p>
<p>首先，我们将引用JavaScript文件，包括jQuery，尽管RxJS没有依赖于jQuery …
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://code.jquery.com/jquery.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"rx.lite.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>接下来，我们将从输入框获取用户输入，使用<a href="content/observable/observable_methods/fromevent.html"><code>Rx.Observable.fromEvent</code></a> 方法监听 <code>keyup</code> 事件.  如果 <a href="http://jquery.com" target="_blank" rel="external">jQuery</a>, <a href="http://zeptojs.com/" target="_blank" rel="external">Zepto</a>, <a href="https://angularjs.org/" target="_blank" rel="external">AngularJS</a> and <a href="http://emberjs.com/" target="_blank" rel="external">Ember.js</a> 可用，将会使用它们来绑定事件, 否则将使用原生事件绑定. 这跟您的框架思考事件的一致方式，因此没有任何惊喜。
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $input = $(<span class="string">'#input'</span>),</div><div class="line">    $results = $(<span class="string">'#results'</span>);</div><div class="line"></div><div class="line"><span class="comment">/* 只从 keyup 事件获得输入值 */</span></div><div class="line"><span class="keyword">var</span> keyups = Rx.Observable.fromEvent($input, <span class="string">'keyup'</span>)</div><div class="line">    .map(<span class="function"><span class="params">e</span> =&gt;</span> e.target.value)</div><div class="line">    .filter(<span class="function"><span class="params">text</span> =&gt;</span> text.length &gt; <span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="comment">/* 函数节流输出设置为 500ms */</span></div><div class="line"><span class="keyword">var</span> throttled = keyups.throttle(<span class="number">500</span> <span class="comment">/* ms */</span>);</div><div class="line"></div><div class="line"><span class="comment">/* 现在判断值是否有改变，只获取不同的值 */</span></div><div class="line"><span class="keyword">var</span> distinct = throttled.distinctUntilChanged();</div></pre></td></tr></table></figure></p>
<p>现在，让我们来查询维基百科！在RxJS中，我们可以立即通过<code>Rx.Observable.fromPromise</code>方法绑定到任何<a href="https://github.com/promises-aplus/promises-spec" target="_blank" rel="external">Promises A+</a>的实现上，或者直接返回它，并将其封装。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">searchWikipedia</span> (<span class="params">term</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> $.ajax(&#123;</div><div class="line">        <span class="attr">url</span>: <span class="string">'http://en.wikipedia.org/w/api.php'</span>,</div><div class="line">        <span class="attr">dataType</span>: <span class="string">'jsonp'</span>,</div><div class="line">        <span class="attr">data</span>: &#123;</div><div class="line">            <span class="attr">action</span>: <span class="string">'opensearch'</span>,</div><div class="line">            <span class="attr">format</span>: <span class="string">'json'</span>,</div><div class="line">            <span class="attr">search</span>: term</div><div class="line">        &#125;</div><div class="line">    &#125;).promise();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一旦创建，现在我们可以将不同的节流输入绑定在一起，然后查询服务。在这种情况下，我们将调用<code>flatMapLatest</code>获取该值，并确保我们不会有任何混乱的调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> suggestions = distinct.flatMapLatest(searchWikipedia);</div></pre></td></tr></table></figure>
<p>最后，我们将在可观察对象上调用<code>subscribe</code>方法开始拉数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">suggestions.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">var</span> res = data[<span class="number">1</span>];</div><div class="line"></div><div class="line">    <span class="comment">/* Do something 像数据绑定 */</span></div><div class="line">    $results.empty();</div><div class="line"></div><div class="line">    $.each(res, (_, value) =&gt; $(<span class="string">'&lt;li&gt;'</span> + value + <span class="string">'&lt;/li&gt;'</span>).appendTo($results));</div><div class="line">&#125;, error =&gt; &#123;</div><div class="line">    <span class="comment">/* handle any errors */</span></div><div class="line">    $results.empty();</div><div class="line"></div><div class="line">    $(<span class="string">'&lt;li&gt;Error: '</span> + error + <span class="string">'&lt;/li&gt;'</span>).appendTo($results);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><a href="https://github.com/Reactive-Extensions/RxJS#why-rxjs" target="_blank" rel="external">翻译参考</a>
<a href="https://robin-front.gitbooks.io/rxjs-doc-chinese/content/why_rxjs.html" target="_blank" rel="external">同步发布RxJS中文文档</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Why-RxJS&quot;&gt;&lt;a href=&quot;#Why-RxJS&quot; class=&quot;headerlink&quot; title=&quot;Why RxJS?&quot;&gt;&lt;/a&gt;Why RxJS?&lt;/h2&gt;&lt;p&gt;你可能会问，为什么选择 RxJS?  为什么不是 Promises? Promises 可以很好地解决异步操作，像使用 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;XMLHttpRequest&lt;/a&gt; 去查询服务器, 它预期会返回值并且最终完成请求。  &lt;code&gt;The Reactive Extensions&lt;/code&gt; 统一了 &lt;code&gt;JavaScript&lt;/code&gt; 中的 &lt;code&gt;Promises&lt;/code&gt;, &lt;code&gt;callbacks&lt;/code&gt; 以及事件数据，比如 DOM输入, &lt;code&gt;Web Workers&lt;/code&gt;, &lt;code&gt;Web Sockets&lt;/code&gt;. 一旦我们统一了这些概念，就可以进行各种各样的组合.&lt;/p&gt;
    
    </summary>
    
      <category term="RxJS" scheme="http://robin-front.github.io/categories/RxJS/"/>
    
    
      <category term="RxJS" scheme="http://robin-front.github.io/tags/RxJS/"/>
    
  </entry>
  
  <entry>
    <title>Lerp的应用-利用简单线性插值来平滑动画效果</title>
    <link href="http://robin-front.github.io/2017/03/20/Lerp%E7%9A%84%E5%BA%94%E7%94%A8-%E5%88%A9%E7%94%A8%E7%AE%80%E5%8D%95%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC%E6%9D%A5%E5%B9%B3%E6%BB%91%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C/"/>
    <id>http://robin-front.github.io/2017/03/20/Lerp的应用-利用简单线性插值来平滑动画效果/</id>
    <published>2017-03-20T03:04:39.000Z</published>
    <updated>2017-03-20T03:04:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇的 <a href="https://robin-front.github.io/2017/03/19/RxJS%E7%9A%84%E5%8A%A8%E7%94%BB%E7%AE%80%E4%BB%8B/">RxJS的动画简介</a> 里提到一个动画平滑的小技巧, 这里展示几个例子，它真的很简单却很有用。</p>
<p><code>Lerp</code>是两点之间的线性插值的别称。这是一个实现起来相当简单的效果，但可以真正改善你的动画的外观，如果你将一个对象从点A移动到点B.
<a id="more"></a></p>
<h1 id="它是如何工作的？"><a href="#它是如何工作的？" class="headerlink" title="它是如何工作的？"></a>它是如何工作的？</h1><p>如果您有一个对象的当前位置和目标的位置，您可以线性内插这些点之间的距离的百分比，并在每个动画帧上更新该位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">lerp</span>(<span class="params">position, targetPosition</span>) </span>&#123;</div><div class="line"><span class="comment">// 计算当前位置与目标位置差值的 20%</span></div><div class="line">  position.x += (targetPosition.x - position.x)*<span class="number">0.2</span>;</div><div class="line">  position.y += (targetPosition.y - position.y)*<span class="number">0.2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过这样做，对象移动的量随着位置和目标之间的距离减小而变小。这意味着对象将越来越接近它的目标，速度将减慢，这创造一个很好的缓和效果。</p>
<h1 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h1><p>这里有一个球跟随用户的鼠标或触摸运动的例子。如果我们使球移动到鼠标移动的地方，球的移动可以非常快但看起来有点脱节。如果我们快速移动鼠标，我们也可以看到单独的“球影”。</p>
<iframe width="100%" height="300" src="//codepen.io/anon/embed/avXmyV?slug-hash=avXmyV&default-tab=result&height=300&theme-id=1970&user=anon"></iframe>

<p>这里是同样的演示，除了这次我们使用lerp。不是将球立即向右移动到鼠标位置，我们每次将它移动10％的距离。</p>
<iframe width="100%" height="300" src="//codepen.io/anon/embed/yYZapV?slug-hash=yYZapV&default-tab=result&height=300&theme-id=1970&user=anon"></iframe>

<p>注意球的运动很平滑，整体更令人愉快的效果。</p>
<p>这里是使用lerp的另一个例子。这次我们有一个滚动指示器，当您向下滚动“页面”时更新。</p>
<iframe width="100%" height="300" src="//codepen.io/anon/embed/rOPMvz?slug-hash=rOPMvz&default-tab=result&height=300&theme-id=1970&user=anon"></iframe>

<iframe width="100%" height="300" src="//codepen.io/anon/embed/epxdxe?slug-hash=epxdxe&default-tab=result&height=300&theme-id=1970&user=anon"></iframe>

<p>所以，lerp“把戏”是一个伟大的工具，我们的网络动画套路，以对抗线性或锯齿状的运动。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇的 &lt;a href=&quot;https://robin-front.github.io/2017/03/19/RxJS%E7%9A%84%E5%8A%A8%E7%94%BB%E7%AE%80%E4%BB%8B/&quot;&gt;RxJS的动画简介&lt;/a&gt; 里提到一个动画平滑的小技巧, 这里展示几个例子，它真的很简单却很有用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Lerp&lt;/code&gt;是两点之间的线性插值的别称。这是一个实现起来相当简单的效果，但可以真正改善你的动画的外观，如果你将一个对象从点A移动到点B.
    
    </summary>
    
      <category term="animate" scheme="http://robin-front.github.io/categories/animate/"/>
    
    
      <category term="animate" scheme="http://robin-front.github.io/tags/animate/"/>
    
  </entry>
  
</feed>
