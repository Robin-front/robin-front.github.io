<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>三寸稚笔</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://robin-front.github.io/"/>
  <updated>2017-07-11T08:02:47.000Z</updated>
  <id>http://robin-front.github.io/</id>
  
  <author>
    <name>robin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>为什么我停止使用多个显示器</title>
    <link href="http://robin-front.github.io/2017/07/11/why-should-stopped-using-multiple-monitors/"/>
    <id>http://robin-front.github.io/2017/07/11/why-should-stopped-using-multiple-monitors/</id>
    <published>2017-07-11T08:02:47.000Z</published>
    <updated>2017-07-11T08:02:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>许多开发人员认为多个显示器可以提高生产力。研究证明是这样，对吧？那么，请记住，许多这些研究是由戴尔和NEC等监控制造商委托进行的。🤔</p><p>尽管多个显示器使您看起来像一个重度的计算机使用者，但我在几年前卖了我的多显示器，并切换到一个监视器。而且我并不是一个人。</p><p>下面就是为什么。<a id="more"></a></p><h1 id="专注"><a href="#专注" class="headerlink" title="专注"></a>专注</h1><p>人类一次只能关注一件事情。那么为什么我们花钱来同时显示多个东西呢？如果我的电子邮件或社交媒体资讯提供一目了然，我会经常检查。这不仅不是不必要的，反而是有效的。在一个无休止的分心的世界中，能够长期专注于单一任务是一项非常有价值的技能。</p><blockquote><p>深刻的工作在我们分心充实的经济中变得越来越困难，但也变得越来越重要和罕见。少数能够在深度工作上度过的日子将变得非常市场化和成功。</p><ul><li>Cal Newport在“ 深加工 ”</li></ul></blockquote><p>一个监视器意味着我的工作 - 只有我的工作 - 显示在前面和中央。分心停留在视线之外，所以眼不见，心不烦。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*gRNCnSRrV5JUxbMagFV0CA.jpeg" alt="这看起来像是专注一项任务吗"></p><center>这看起来像是专注一项任务吗</center><p>我们每天做的最有价值的工作之一就是要长期专注于一个单一的应用程序：<strong>阅读和写作</strong>。阅读和写作都受益于来自于屏幕上唯一的重点。一本带有移动微博的小本本在旁边将是一场灾难。但是很多人都愿意做这个。额外的显示经常导致潜在的持续分心。如果您的电子邮件，社交媒体等不可见，您更有可能继续工作。</p><p>作为开发人员，我每天都在编写代码。所以我经常阅读文档。但是我很少需要在读文档的 <strong>同时</strong> 编写代码。我读完相关的文档，然后再编码。我的工作流是模态的。</p><h1 id="减少窗口管理"><a href="#减少窗口管理" class="headerlink" title="减少窗口管理"></a>减少窗口管理</h1><p>我使用一个月的 34“LG超宽屏显示器，起初，我喜欢它。</p><p>不过，过了几天，我很惊讶地发现我出了个馊主意。我的桌面最大化，太宽了，所以我发现自己花了太多的时间摆弄桌面。“今天应该放在左边呢？”“现在有什么重要的事情呢？”</p><p>当然，屏幕足够宽，可以并排显示多个窗口，但是它非常宽，边缘感到不舒服。所以，我发现自己不断把我的工作转移到屏幕的中心，从而违背了买一个巨大的显示器的整个目的！Jeff Atwood很久以前在“<a href="https://blog.codinghorror.com/the-large-display-paradox/" target="_blank" rel="external">大型显示悖论</a>”中讨论了这个问题。他的解决方案，使用软件移动和调整大小的窗口更容易。我的解决方案，<strong>只需使用一个合理尺寸的显示器</strong>。</p><p>即使使用方便的窗口管理软件，多个显示器也会出现问题：如果我有两个显示器，内容不会直接在我的前面。我必须向右或向左转动我的头（特别烦在跑步机上行走的人，就像我经常看到的那样）。我可以把一个监视器直接放在我面前，但是第二个监视器甚至更远一些，这使得它显然是一个二等公民。这再次导致我从正在工作的中间屏幕移动。</p><p>正如巴里·施瓦茨（Barry Schwartz）在“<a href="https://www.amazon.com/Paradox-Choice-Why-More-Less/dp/0060005696" target="_blank" rel="external">选择的悖论</a>”中所探讨的那样，决策疲劳是一个真正的问题。有时候，少即是多。</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fembed.ted.com%2Ftalks%2Fbarry_schwartz_on_the_paradox_of_choice&amp;url=https%3A%2F%2Fwww.ted.com%2Ftalks%2Fbarry_schwartz_on_the_paradox_of_choice&amp;image=https%3A%2F%2Fpe.tedcdn.com%2Fimages%2Fted%2F8bdfbadbf8c620bfe3c5209c223a0f7b4316092a_240x180.jpg%3Flang%3Den&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=ted" allowfullscreen frameborder="0" scrolling="no"></iframe><blockquote><p>“选择使我们不是更自由，更瘫痪，不快乐，但更不满意。”</p></blockquote><p>只通过一个屏幕，我决定。我不会浪费时间决定在哪里拖曳窗口或摆放在给定窗口的位置。我最大化我正在使用的应用程序，以阻止所有其他分心…在上班的时候。</p><h1 id="虚拟桌面为赢"><a href="#虚拟桌面为赢" class="headerlink" title="虚拟桌面为赢"></a>虚拟桌面为赢</h1><p>Mac和Windows现在都支持虚拟桌面。在我的Mac上，我可以通过3个手指快速切换多个虚拟桌面。这需要不到一秒钟的时间，它不需要我转过头来重新聚焦我的眼睛在不同的地方的内容。我也不用浪费时间安排。最左边的虚拟桌面总是我的浏览器，右边是我的编辑器。<strong>所以我将虚拟桌面视为可靠呈现相同内容的物理屏幕</strong>。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*BLoFtdzKsyuBaysiMNMaBA.png" alt="顶部的三个框架表示三个虚拟桌面。三手指滑动可立即在它们之间切换 - 无需再花时间旋转我的头，看一个单独的显示器。"></p><center>顶部的三个框架表示三个虚拟桌面。三手指滑动可立即在它们之间切换 - 无需再花时间旋转我的头，看一个单独的显示器。</center><h1 id="我用于完成工作的首选监视器"><a href="#我用于完成工作的首选监视器" class="headerlink" title="我用于完成工作的首选监视器"></a>我用于完成工作的首选监视器</h1><p>我更喜欢使用一个24“4K，为什么24”？因为如果你想完成实际的工作，更大的不一定更好。24“足够大，可以全屏显示单个应用程序，它足够大，可以在罕见的情况下并排显示两个应用程序，我真的需要同时看到两件事情（我在Mac上使用BetterTouchTool，只需击中Win +箭头在Windows），但是24“足够小，您可以最大限度地利用所有应用程序，而无需移动您的头部或眼睛很多看到屏幕边缘。记住，最大化所有的事情。最大化=集中。</p><p>为什么是4K？高DPI降低疲劳。文字更加清晰。价格也慢慢合理了，所以如果你还没有高DPI显示器，买一个。而24“4K每4K英寸的点数要大于4K屏幕，所以它更加清晰。过去几年内建成的任何MacBook Pro都可以在DisplayPort上以60hz的速度推出4K显示器，许多最近的Windows笔记本电脑也可以这样做。</p><p>那么为什么这么多工作者需要多台显示器呢？我相信这是极端不合逻辑的诱惑。</p><blockquote><p>太多的东西变得相反。 - 蒂姆·弗里斯</p></blockquote><p>显示器太多会变得分心。所以说到监视器，我拥抱这些想法：</p><ul><li>少即是多</li><li>质量而不是数量</li><li>定力，定力，定力（Location, Location, Location）</li></ul><p>【翻译原文】:（有删减） <a href="https://hackernoon.com/why-i-stopped-using-multiple-monitors-bfd87efa2e5b" target="_blank" rel="external">https://hackernoon.com/why-i-stopped-using-multiple-monitors-bfd87efa2e5b</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;许多开发人员认为多个显示器可以提高生产力。研究证明是这样，对吧？那么，请记住，许多这些研究是由戴尔和NEC等监控制造商委托进行的。🤔&lt;/p&gt;&lt;p&gt;尽管多个显示器使您看起来像一个重度的计算机使用者，但我在几年前卖了我的多显示器，并切换到一个监视器。而且我并不是一个人。&lt;/p&gt;&lt;p&gt;下面就是为什么。
    
    </summary>
    
      <category term="performance" scheme="http://robin-front.github.io/categories/performance/"/>
    
    
      <category term="performance" scheme="http://robin-front.github.io/tags/performance/"/>
    
  </entry>
  
  <entry>
    <title>不要混用 import 和 require</title>
    <link href="http://robin-front.github.io/2017/07/10/dont-mixin-import-and-require/"/>
    <id>http://robin-front.github.io/2017/07/10/dont-mixin-import-and-require/</id>
    <published>2017-07-10T08:30:11.000Z</published>
    <updated>2017-07-10T08:30:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>import 是 ES6 规范语法之一。而 require 属于CommonJS规范的一部分。</p><p>目前来说，使用现代浏览器还无法支持 import，一般都会搭配 babel 使用，而 babel 会把 import 转换成 CommonJS 的 require.</p><p>但是，我们不能混用 import 和 require。有时候会看下如下代码：<a id="more"></a></p><p><img src="https://pbs.twimg.com/media/DESmTTXUMAAJcIW.jpg:large" alt="https://pbs.twimg.com/media/DESmTTXUMAAJcIW.jpg:large"></p><p>但实际执行顺序并不是你想象或看到的那样。import 具有声明提升效果，会首先执行。所以最好 <strong>不要混用</strong>。 import 是 ES6 标准，如果可能，首先使用 import, 如果不行，就用 require。</p><h2 id="ES6-import"><a href="#ES6-import" class="headerlink" title="ES6 import"></a>ES6 import</h2><ul><li>具有声明提升效果</li><li>您可以使用命名导入来选择性地加载所需的部分。这样可以节省内存， 如：<code>import { render } from react</code></li><li>导入可以是异步的</li><li>ES6 标准</li></ul><h2 id="require"><a href="#require" class="headerlink" title="require"></a>require</h2><ul><li>您可以在加载的模块名称不是预定义/静态的情况下进行动态加载，或者只有在真正需要的情况下才有条件地加载模块（取决于某些代码流）</li><li>CommonJS 规范加载是同步的。这意味着如果你有多个require，它们将逐个加载和处理（AMD规范是可以异步的）</li><li>只是约定的规范</li></ul><p>参考：<a href="https://twitter.com/dan_abramov/status/883375646357041152" target="_blank" rel="external">https://twitter.com/dan_abramov/status/883375646357041152</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;import 是 ES6 规范语法之一。而 require 属于CommonJS规范的一部分。&lt;/p&gt;&lt;p&gt;目前来说，使用现代浏览器还无法支持 import，一般都会搭配 babel 使用，而 babel 会把 import 转换成 CommonJS 的 require.&lt;/p&gt;&lt;p&gt;但是，我们不能混用 import 和 require。有时候会看下如下代码：
    
    </summary>
    
      <category term="es6" scheme="http://robin-front.github.io/categories/es6/"/>
    
    
      <category term="import" scheme="http://robin-front.github.io/tags/import/"/>
    
      <category term="require" scheme="http://robin-front.github.io/tags/require/"/>
    
  </entry>
  
  <entry>
    <title>react性能优化：提取子组件中额外的事件绑定</title>
    <link href="http://robin-front.github.io/2017/07/06/react-pattern-extract-child-components-to-avoid-binding/"/>
    <id>http://robin-front.github.io/2017/07/06/react-pattern-extract-child-components-to-avoid-binding/</id>
    <published>2017-07-06T08:24:53.000Z</published>
    <updated>2017-07-06T08:24:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn-images-1.medium.com/max/800/1*zISOb74W7PriWKX0y7biKg.jpeg" alt=""></p><p>我们经常在快要完成一个<code>react</code>中型应用时，发现页面并没有想象中那么流畅。 react 理论性能是不错的，但是对开发者要求也很高，一些不易注意的点很容易造成性能问题。正所谓“烂泥扶不上墙”。</p><p>下面看看子组件的事件绑定写法对性能的影响。<a id="more"></a></p><p>这是React中的常见情况：您正在映射数组，您需要每个项目调用点击处理程序和一些相关数据。</p><p>这是一个例子。我正在迭代一个用户列表，并将<code>userId</code>传递给第29行的<code>deleteUser</code>函数。</p><script src="https://gist.github.com/coryhouse/01339ce21024cfd7f5cd4c64d1fd26c4.js"></script><p>这是<a href="https://codesandbox.io/" target="_blank" rel="external">Codeandbox</a>上的一个<a href="https://codesandbox.io/s/0OP2Yq87" target="_blank" rel="external">工作示例</a>。（真棒）</p><h1 id="所以-有什么问题？"><a href="#所以-有什么问题？" class="headerlink" title="所以, 有什么问题？"></a>所以, 有什么问题？</h1><p>我在点击处理程序中使用箭头函数。这意味着每次渲染运行时，都会分配一个新函数。在许多情况下，这不是一件多大的事。但是，如果您有子组件，即使数据没有更改，它们也将重新渲染，因为每个渲染分配一个新的函数。</p><p>底线：避免在渲染中声明箭头函数或绑定以获得最佳性能。我的团队使用这个<a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-no-bind.md" target="_blank" rel="external">ESLint规则</a>帮助提醒我们这个问题。</p><h1 id="解决方案是什么？"><a href="#解决方案是什么？" class="headerlink" title="解决方案是什么？"></a>解决方案是什么？</h1><p>那么你如何在渲染中避免绑定和箭头函数呢？一个选项是提取一个子组件。在这里，我将列表项提取到<code>UserListItem.js</code>：</p><script src="https://gist.github.com/coryhouse/a002111d01fb7ee1862af55d4a26abfa.js"></script><p>然后，父组件的渲染变得更简单，不再需要包含箭头函数。它只是通过<code>props</code>传递每个列表项的相关上下文：</p><script src="https://gist.github.com/coryhouse/f5758f5355da5280fc0e3350453fef31.js"></script><p>这是一个<a href="https://codesandbox.io/s/Q1Jo3zB79" target="_blank" rel="external">重构的工作实例</a>。</p><h1 id="Yay-or-Yuck"><a href="#Yay-or-Yuck" class="headerlink" title="Yay or Yuck?"></a>Yay or Yuck?</h1><p>此模式通过消除冗余的函数分配来提高性能。所以当这种情况适用于您的组件时，它是最有用的：</p><ul><li>渲染频繁被调用</li><li>渲染子组件非常耗时</li></ul><p>诚然，我提取子组件也是我提到的一个额外的工作。它需要更多的移动部件和更多的代码。所以如果你没有出现性能问题，可以说这是一个过早的优化。</p><p>所以你有两个选择：允许箭头和绑定到任何地方（如果有性能问题再处理），或禁止他们获得最佳性能和一致性。</p><p>底线：我建议禁止箭头函数并在<code>render</code>中绑定。下面就是为什么：</p><ul><li>你必须禁用我上面建议的有用的<a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-no-bind.md" target="_blank" rel="external">ESLint规则</a>来允许它。</li><li>禁用linting规则后，人们可能会复制此模式，并开始禁用其他linting规则。一个处例外可以很快成为规范…</li></ul><p></p><blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">General rule for code reviews:<br><br>Each line of code should be worthy of copying.<br><br>Because people will.<a href="https://twitter.com/hashtag/cleancode?src=hash" target="_blank" rel="external">#cleancode</a></p>&mdash; Cory House 🏠 (@housecor) <a href="https://twitter.com/housecor/status/839511073279598594" target="_blank" rel="external">March 8, 2017</a></blockquote><p></p><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script><p>所以我发现提取子组件是一个有用的模式，以避免在渲染中绑定。</p><h1 id="其他的反例"><a href="#其他的反例" class="headerlink" title="其他的反例"></a>其他的反例</h1><p>还有些人会想要这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">deleteUser = id=<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line"> <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> &#123;</div><div class="line"> <span class="keyword">return</span> &#123; <span class="attr">users</span>: prevState.users.filter( <span class="function"><span class="params">user</span> =&gt;</span> user.id !== id)&#125;</div><div class="line"> &#125;)</div><div class="line">&#125;</div><div class="line"><span class="comment">// …</span></div><div class="line">onClick=&#123;<span class="keyword">this</span>.deleteUser(user.id)&#125;</div></pre></td></tr></table></figure><p>他们认为传递参数会比其他方式更加方便。但这和第一个糟糕的例子并无太大区别，子组件同样会再次渲染。</p><p>如果有相当多类似的输入框，像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;form&gt;</div><div class="line">Render = <span class="function"><span class="params">()</span> =&gt;</span></div><div class="line">Input1 value=<span class="keyword">this</span>.state.input1 onChange= update state <span class="keyword">for</span> field1</div><div class="line">Input2….</div><div class="line">Input3….</div></pre></td></tr></table></figure><p><a href="https://facebook.github.io/react/docs/forms.html#handling-multiple-inputs" target="_blank" rel="external">官方给出的方法</a>是给每个 input 添加 name 属性，进而获取参数。</p><p>当然也有人会想要在 html 上动文章，比如添加自定义属性 <code>data-id=${userId}</code>。这当然也能实现，但是 html不应该是数据源，这应该避免。</p><p>【翻译原文】:(有改动)<a href="https://medium.freecodecamp.org/react-pattern-extract-child-components-to-avoid-binding-e3ad8310725e" target="_blank" rel="external">https://medium.freecodecamp.org/react-pattern-extract-child-components-to-avoid-binding-e3ad8310725e</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*zISOb74W7PriWKX0y7biKg.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;我们经常在快要完成一个&lt;code&gt;react&lt;/code&gt;中型应用时，发现页面并没有想象中那么流畅。 react 理论性能是不错的，但是对开发者要求也很高，一些不易注意的点很容易造成性能问题。正所谓“烂泥扶不上墙”。&lt;/p&gt;&lt;p&gt;下面看看子组件的事件绑定写法对性能的影响。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="react" scheme="http://robin-front.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>如何使用Memoize来缓存JavaScript函数结果并加快代码的速度</title>
    <link href="http://robin-front.github.io/2017/07/04/understanding-memoize-in-javascript/"/>
    <id>http://robin-front.github.io/2017/07/04/understanding-memoize-in-javascript/</id>
    <published>2017-07-04T09:57:51.000Z</published>
    <updated>2017-07-04T09:57:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Function</code> 是编程的组成部分。它们有助于为我们的代码增加模块化和可重用性。</p><p>将程序划分为大块是很常见的功能，我们稍后可以使用这些功能来执行一些有用的操作。</p><p>有时，多次调用功能可能会变得昂贵（比如，计算一个数字的阶乘的函数）。但是有一种方法可以优化这些功能，使它们执行得更快：<strong>缓存</strong>。<a id="more"></a></p><p>例如，假设我们<code>function</code>要返回一个数字的阶乘：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">    <span class="comment">// Calculations: n * (n-1) * (n-2) * ... (2) * (1)</span></div><div class="line">    <span class="keyword">return</span> factorial</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>非常好，现在我们来看看<code>factorial(50)</code>。计算机会执行计算，并返回给我们最后的答案，不错！</p><p>完成后，让我们来看看<code>factorial(51)</code>。计算机再次执行一些计算并获得结果，但是您可能已经注意到我们已经重复了可以避免的一些步骤。优化的方式是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">factorial(<span class="number">51</span>) = factorial(<span class="number">50</span>) * <span class="number">51</span>;</div></pre></td></tr></table></figure><p>但是我们<code>function</code>每次调用时都会从头开始执行计算：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">factorial(<span class="number">51</span>) = <span class="number">51</span> * <span class="number">50</span> * <span class="number">49</span> * ... * <span class="number">2</span> * <span class="number">1</span></div></pre></td></tr></table></figure><p>如果我们的函数<code>factorial</code>能记住它之前运算的结果并用它来提交运行效率，那不是很酷吗？</p><p>谈到<code>Memoization</code>，一种让我们的<code>function</code>记住（缓存）结果的方式。既然您对我们要实现的目标有一个基本的了解，这里是一个正式的定义：</p><blockquote><p><a href="https://en.wikipedia.org/wiki/Memoization" target="_blank" rel="external">Memoization</a>是一种优化技术，主要用于通过 <strong>存储昂贵的函数调用的结果</strong> 来加速计算机程序，并在相同的输入再次发生时返回缓存的结果.</p></blockquote><p>记住简单的东西意味着记忆或存储在内存中。记忆函数通常更快，因为如果随后使用先前的值调用该函数，我们将从缓存中获取结果来代替执行该函数，。</p><p>这看起来像一个简单的记忆函数（如果你想进行测试它，这里是一个<a href="https://codepen.io/divyanshu013/pen/xdQPvp?editors=0011" target="_blank" rel="external">CodePen</a>）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a simple function to add something</span></div><div class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">n</span>) =&gt;</span> (n + <span class="number">10</span>);</div><div class="line">add(<span class="number">9</span>);</div><div class="line"><span class="comment">// a simple memoized function to add something</span></div><div class="line"><span class="keyword">const</span> memoizedAdd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">let</span> cache = &#123;&#125;;</div><div class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (n <span class="keyword">in</span> cache) &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'Fetching from cache'</span>);</div><div class="line">      <span class="keyword">return</span> cache[n];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'Calculating result'</span>);</div><div class="line">      <span class="keyword">let</span> result = n + <span class="number">10</span>;</div><div class="line">      cache[n] = result;</div><div class="line">      <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// returned function from memoizedAdd</span></div><div class="line"><span class="keyword">const</span> newAdd = memoizedAdd();</div><div class="line"><span class="built_in">console</span>.log(newAdd(<span class="number">9</span>)); <span class="comment">// calculated</span></div><div class="line"><span class="built_in">console</span>.log(newAdd(<span class="number">9</span>)); <span class="comment">// cached</span></div></pre></td></tr></table></figure><h1 id="Memoization-要点"><a href="#Memoization-要点" class="headerlink" title="Memoization 要点"></a>Memoization 要点</h1><p>以上代码的一些要点是：</p><p><code>memoizedAdd</code>返回一个<code>function</code>以便稍后调用的。这是可能的，因为在JavaScript中，函数是一等公民，它们可以将它们用作<a href="http://eloquentjavascript.net/05_higher_order.html#h_xxCc98lOBK" target="_blank" rel="external">高阶的函数</a>并返回另一个函数。</p><p><code>cache</code>可以记住它的值，因为返回的函数被<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Closures" target="_blank" rel="external">闭包</a>封装了。</p><p><code>memoized</code>功能纯粹<a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976" target="_blank" rel="external">(Pure)</a>是至关重要的。纯函数将为特定输入返回相同的输出，而不需要调用多少次，这使得<code>cache</code>按预期的工作。</p><h1 id="编写自己的-memoize-功能"><a href="#编写自己的-memoize-功能" class="headerlink" title="编写自己的 memoize 功能"></a>编写自己的 memoize 功能</h1><p>以前的代码工作正常，但如果我们想将任何函数转换为记忆函数呢？</p><p>以下是如何编写自己的<code>memoize</code>函数（<a href="https://codepen.io/divyanshu013/pen/zwMPdK?editors=0011#code-area" target="_blank" rel="external">codepen</a>）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a simple pure function to get a value adding 10</span></div><div class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">n</span>) =&gt;</span> (n + <span class="number">10</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Simple call'</span>, add(<span class="number">3</span>));</div><div class="line"><span class="comment">// a simple memoize function that takes in a function</span></div><div class="line"><span class="comment">// and returns a memoized function</span></div><div class="line"><span class="keyword">const</span> memoize = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">let</span> cache = &#123;&#125;;</div><div class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> n = args[<span class="number">0</span>];  <span class="comment">// just taking one argument here</span></div><div class="line">    <span class="keyword">if</span> (n <span class="keyword">in</span> cache) &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'Fetching from cache'</span>);</div><div class="line">      <span class="keyword">return</span> cache[n];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'Calculating result'</span>);</div><div class="line">      <span class="keyword">let</span> result = fn(n);</div><div class="line">      cache[n] = result;</div><div class="line">      <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// creating a memoized function for the 'add' pure function</span></div><div class="line"><span class="keyword">const</span> memoizedAdd = memoize(add);</div><div class="line"><span class="built_in">console</span>.log(memoizedAdd(<span class="number">3</span>));  <span class="comment">// calculated</span></div><div class="line"><span class="built_in">console</span>.log(memoizedAdd(<span class="number">3</span>));  <span class="comment">// cached</span></div><div class="line"><span class="built_in">console</span>.log(memoizedAdd(<span class="number">4</span>));  <span class="comment">// calculated</span></div><div class="line"><span class="built_in">console</span>.log(memoizedAdd(<span class="number">4</span>));  <span class="comment">// cached</span></div></pre></td></tr></table></figure><p>这很棒！这个简单的<code>memoize</code>功能将任何简单的<code>function</code>封装成一个有记忆性的等价物。该代码适用于简单的功能，可以根据您的需要轻松调整处理任意数量的<code>arguments</code>代码。另一个选择是利用一些的类库，如：</p><p><a href="https://lodash.com/docs/4.17.4#memoize" target="_blank" rel="external">Lodash</a>的<code>_.memoize(func, [resolver])</code></p><p>来自<a href="https://github.com/developit/decko#memoize" target="_blank" rel="external">decko</a>的 ES7 <code>@memoize</code> <a href="https://babeljs.io/docs/plugins/transform-decorators/" target="_blank" rel="external">装饰器</a></p><h1 id="记忆递归函数"><a href="#记忆递归函数" class="headerlink" title="记忆递归函数"></a>记忆递归函数</h1><p>如果您尝试将递归函数传递到<code>memoize</code>上面的函数或Lodash的<code>_.memoize</code>函数，结果将不会如预期的那样，因为其后续调用的递归函数将最终调用自身而不是记忆函数，从而不再使用<code>cache</code>。</p><p>只需确保递归函数调用记忆函数。这里是你如何调整教科书<a href="https://en.wikipedia.org/wiki/Factorial" target="_blank" rel="external">阶乘</a>例子（<a href="https://codepen.io/divyanshu013/pen/JNevOm" target="_blank" rel="external">codepen</a>）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// same memoize function from before</span></div><div class="line"><span class="keyword">const</span> memoize = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">let</span> cache = &#123;&#125;;</div><div class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> n = args[<span class="number">0</span>];</div><div class="line">    <span class="keyword">if</span> (n <span class="keyword">in</span> cache) &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'Fetching from cache'</span>, n);</div><div class="line">      <span class="keyword">return</span> cache[n];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'Calculating result'</span>, n);</div><div class="line">      <span class="keyword">let</span> result = fn(n);</div><div class="line">      cache[n] = result;</div><div class="line">      <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> factorial = memoize(</div><div class="line">  <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (x === <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> x * factorial(x - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">);</div><div class="line"><span class="built_in">console</span>.log(factorial(<span class="number">5</span>)); <span class="comment">// calculated</span></div><div class="line"><span class="built_in">console</span>.log(factorial(<span class="number">6</span>)); <span class="comment">// calculated for 6 and cached for 5</span></div></pre></td></tr></table></figure><p>从这段代码注意几点：</p><p>该<code>factorial</code>函数递归地调用自己的记忆版本。</p><p>记忆功能是缓存先前阶乘的值，从而可以重复使用，从而显着改善了计算 <code>factorial(6) = 6 * factorial(5)</code></p><h1 id="memoization-是否与-caching-相同？"><a href="#memoization-是否与-caching-相同？" class="headerlink" title="memoization 是否与 caching 相同？"></a>memoization 是否与 caching 相同？</h1><p>是的，有点。<code>Memoization</code>实际上是一种特定类型的缓存。虽然缓存通常可以引用任何存储技术（如HTTP缓存）以供将来使用，但是<code>memoizing</code>特指调用缓存的<code>function</code>返回值。</p><h1 id="什么时候记录你的-functions"><a href="#什么时候记录你的-functions" class="headerlink" title="什么时候记录你的 functions"></a>什么时候记录你的 functions</h1><p>虽然可能看起来 <code>memoize</code> 可以与所有函数一起使用，但它实际上有限制的用例：</p><ul><li>为了记忆一个函数，它应该是纯粹的（pure），所以每次返回值对于相同的输入是相同的</li><li>记忆是增加的空间和增加的速度之间的权衡，因此对于具有有限的输入范围的功能而言是重要的，以便可以更频繁地使用缓存的值</li><li>它可能看起来像您记住您的API调用，但这并不是必需的，因为浏览器会为您自动缓存它们。有关详细信息，请参阅<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching" target="_blank" rel="external">HTTP缓存</a></li><li>我发现用于记忆功能的最佳用例是 <strong>重度计算功能</strong>，可以显着提高性能（阶乘和斐波那契不是真正现实世界的例子）</li><li>如果您进入React / Redux，您可以检查重新选择哪个使用记忆选择器，以确保仅在状态树的相关部分发生更改时进行计算。</li></ul><h1 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h1><p>如果您想更详细地了解本文中的一些主题，以下链接可能很有用：</p><ul><li>JavaScript中的<a href="http://eloquentjavascript.net/05_higher_order.html#h_xxCc98lOBK" target="_blank" rel="external">高阶函数</a></li><li>JavaScript<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Closures" target="_blank" rel="external">闭包</a></li><li><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976" target="_blank" rel="external">纯函数</a></li><li>Lodash的<code>_.memoize</code> <a href="https://lodash.com/docs/4.17.4#memoize" target="_blank" rel="external">文档</a>和<a href="https://github.com/lodash/lodash/blob/4.17.4/lodash.js#L10554-L10572" target="_blank" rel="external">源代码</a></li><li>更多的<code>memoization</code>例子在<a href="https://www.sitepoint.com/implementing-memoization-in-javascript/" target="_blank" rel="external">这里</a>和<a href="http://inlehmansterms.net/2015/03/01/javascript-memoization/" target="_blank" rel="external">这里</a></li><li><a href="https://github.com/reactjs/reselect" target="_blank" rel="external">reactjs/reSelect</a></li></ul><p>【翻译原文】: <a href="https://medium.freecodecamp.org/understanding-memoize-in-javascript-51d07d19430e" target="_blank" rel="external">https://medium.freecodecamp.org/understanding-memoize-in-javascript-51d07d19430e</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Function&lt;/code&gt; 是编程的组成部分。它们有助于为我们的代码增加模块化和可重用性。&lt;/p&gt;&lt;p&gt;将程序划分为大块是很常见的功能，我们稍后可以使用这些功能来执行一些有用的操作。&lt;/p&gt;&lt;p&gt;有时，多次调用功能可能会变得昂贵（比如，计算一个数字的阶乘的函数）。但是有一种方法可以优化这些功能，使它们执行得更快：&lt;strong&gt;缓存&lt;/strong&gt;。
    
    </summary>
    
      <category term="javaScript" scheme="http://robin-front.github.io/categories/javaScript/"/>
    
    
      <category term="Memoize" scheme="http://robin-front.github.io/tags/Memoize/"/>
    
  </entry>
  
  <entry>
    <title>css3中background-position的四值语法</title>
    <link href="http://robin-front.github.io/2017/07/04/background-position-of-css3-about-four-value-syntax/"/>
    <id>http://robin-front.github.io/2017/07/04/background-position-of-css3-about-four-value-syntax/</id>
    <published>2017-07-04T03:27:55.000Z</published>
    <updated>2017-07-04T03:27:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>刨根问底，每个css属性都要知道它的所有值实在不容易。今天看看 <code>background-position</code>.</p><p>background-positionCSS中的属性允许您在其容器内移动背景图像（或渐变）。<a id="more"></a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">html</span> &#123;</div><div class="line">  <span class="attribute">background-position</span>: <span class="number">100px</span> <span class="number">5px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>它有三种不同的取值：</p><ul><li>长度值（例如<code>100px 5px</code>）</li><li>百分比（例如<code>100% 5%</code>）</li><li>关键字（例如<code>top right</code>）</li></ul><p>默认值为<code>0 0</code>。这会将您的背景图像放在容器的左上角。</p><p>长度值很简单：第一个值是水平位置，第二个值是垂直位置。因此，<code>100px 5px</code>将图像向右移动100像素，向下移动五个像素。您可以设定长度值单位为<code>px</code>，<code>em</code>或<a href="http://www.w3.org/Style/Examples/007/units.en.html" target="_blank" rel="external">任何其他的CSS长度值</a>。</p><p>百分比有所不同。戴上你的数学帽子：用<code>x％</code>移动背景图像意味着 <strong>将图像中的<code>X％</code>点</strong> 与 <strong>容器中的<code>X％</code>点</strong> 对齐(PS：很多人解释的时候只会说向左向下移动了x%,这就无法解释50%)。例如，<code>50%</code>意味着它会将图像的中间与容器的中间对齐。<code>100%</code>意味着它会将图像的最后一个像素与容器的最后一个像素对齐，依此类推。</p><p>关键字只是百分比的捷径。这<code>top right</code>比记住和写作要容易得多<code>0 100%</code>，这就是关键字的意义。以下是所有五个关键字及其等价取值的列表：</p><ul><li><code>top</code>：垂直0％</li><li><code>right</code>：水平100％</li><li><code>bottom</code>：垂直100％</li><li><code>left</code>：水平0％</li><li><code>center</code>：如果水平尚未定义，则水平为50％。如果定义了则应用到垂直。</li></ul><p>有趣的是，您关键字使用的顺序并不重要：与之<code>top center</code>相同<code>center top</code>。只有当您使用单一关键字时，您才能做到这一点。<code>center 10%</code>是不一样的<code>10% center</code>。</p><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><p>此演示演示了<code>background-position</code>具有长度单位，百分比和关键字取值的集合示例。</p><iframe height="265" scrolling="no" title="background-position values" src="//codepen.io/team/css-tricks/embed/ogqrGw/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/team/css-tricks/pen/ogqrGw/" target="_blank" rel="external">background-position values</a> by CSS-Tricks (<a href="https://codepen.io/css-tricks" target="_blank" rel="external">@css-tricks</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><h1 id="声明值-Declaring-Values"><a href="#声明值-Declaring-Values" class="headerlink" title="声明值(Declaring Values)"></a>声明值(Declaring Values)</h1><p><code>background-position</code>现代浏览器中最多可以放置四个值（有关详细信息，请参阅<a href="#browser-support">浏览器支持列表</a>）。</p><p>如果您只声明 <strong>一个值</strong>，则该值是水平偏移量。浏览器将垂直偏移设置为<code>center</code>。</p><p>当您声明 <strong>两个值</strong> 时，第一个值是水平偏移量，第二个值是垂直偏移量。</p><p>当您开始使用三个或四个值时，事情会变得更加棘手，但您也可以更好地控制您的背景位置。</p><p>三或四值语法在关键字和长度或百分比单位之间进行交替。您可以在<code>background-position</code>的三值或四值中使用任何关键字值， <em>除</em> <code>center</code>之外。</p><p>当您指定 <strong>三个值</strong> 时，浏览器将“丢失”第四个值插入为<code>0.</code>以下是三值的示例<code>background-position</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#threevalues</span> &#123;</div><div class="line">  <span class="attribute">background-position</span>: right <span class="number">45px</span> bottom;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样就可以将背景图像定位在右侧的<code>45px</code>和容器底部的<code>0px</code>。</p><p>这是一个<code>background-position</code> <strong>四值</strong> 的例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#fourvalues</span> &#123;</div><div class="line">  <span class="attribute">background-position</span>: right <span class="number">45px</span> bottom <span class="number">20px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这将背景图片定位在右侧的<code>45px</code>和容器底部的<code>20px</code>。</p><p>注意上面示例中值的顺序：关键字后跟长度单位。三或四个值<code>background-position</code>必须遵循该格式，关键字在长度或百分比单位之前。</p><h1 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h1><p>此演示包括一个值，两个值，三个值和四个值的示例background-position。</p><iframe height="265" scrolling="no" title="background-position 1, 2, 3, and 4 value syntax" src="//codepen.io/team/css-tricks/embed/yyKdPB/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/team/css-tricks/pen/yyKdPB/" target="_blank" rel="external">background-position 1, 2, 3, and 4 value syntax</a> by CSS-Tricks (<a href="https://codepen.io/css-tricks" target="_blank" rel="external">@css-tricks</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><h1 id="更多参考"><a href="#更多参考" class="headerlink" title="更多参考"></a>更多参考</h1><ul><li><a href="http://www.w3.org/TR/css3-background/#the-background-position" target="_blank" rel="external">background-position 在CSS3规范</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/background-position" target="_blank" rel="external">background-position 在MDN</a></li><li><a href="http://css-tricks.com/positioning-offset-background-images/" target="_blank" rel="external">偏移背景图像</a></li></ul><h1 id="browser-support"><a href="#browser-support" class="headerlink" title="browser-support"></a>browser-support</h1><p>基本价值得到支持。四值语法具有此支持：</p><table><thead><tr><th style="text-align:center">Chrome</th><th style="text-align:center">Safari</th><th style="text-align:center">Firefox</th><th style="text-align:center">Opera</th><th style="text-align:center">IE</th><th style="text-align:center">Android</th><th style="text-align:center">iOS</th></tr></thead><tbody><tr><td style="text-align:center">25+</td><td style="text-align:center">7+</td><td style="text-align:center">13+</td><td style="text-align:center">10.5+</td><td style="text-align:center">9+</td><td style="text-align:center">4+</td><td style="text-align:center">7.1+</td></tr></tbody></table><p>【翻译原文：】<a href="https://css-tricks.com/almanac/properties/b/background-position/" target="_blank" rel="external">https://css-tricks.com/almanac/properties/b/background-position/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刨根问底，每个css属性都要知道它的所有值实在不容易。今天看看 &lt;code&gt;background-position&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;background-positionCSS中的属性允许您在其容器内移动背景图像（或渐变）。
    
    </summary>
    
      <category term="css3" scheme="http://robin-front.github.io/categories/css3/"/>
    
    
      <category term="css3" scheme="http://robin-front.github.io/tags/css3/"/>
    
      <category term="background" scheme="http://robin-front.github.io/tags/background/"/>
    
  </entry>
  
  <entry>
    <title>Array数组的indexOf、includes vs for-loop性能比较</title>
    <link href="http://robin-front.github.io/2017/07/03/arr-of-indexOf-vs-includes-and-for-loop/"/>
    <id>http://robin-front.github.io/2017/07/03/arr-of-indexOf-vs-includes-and-for-loop/</id>
    <published>2017-07-03T03:02:06.000Z</published>
    <updated>2017-07-03T03:02:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到一道算法题，然后有些人会使用 <code>includes</code>、<code>indexOf</code> 去判断是否存在另一个数。这让我不禁思考，这和 <code>for loop</code>有什么区别，能减少时间复杂度吗？我一开始也不是很清楚，但我可以找文档，找标准。我的第一判断是 <code>includes</code> 完全和 <code>for loop</code>没有区别的，只是es6 标准规范提供的语法糖，而 <code>indexOf</code> 还是有一定效率的。带着疑惑，查看 MDN 和 <a href="http://www.ecma-international.org/ecma-262" target="_blank" rel="external">ecma-262</a><a id="more"></a></p><h1 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h1><p><code>includes</code> 是 ES6 新增语法，返回 布尔值。最容易拿 <code>indexOf</code> 来比较， <code>indexOf</code> 不能判断 <code>NaN</code>, 而且不够语义，返回的是 匹配值的位置 或 <code>-1</code>。 <code>includes</code> 内部实现是这样的：</p><blockquote><ol><li>Let O be ? ToObject(this value).</li><li>Let len be ? ToLength(? Get(O, “length”)).</li><li>If len is 0, return false.</li><li>Let n be ? ToInteger(fromIndex). (If fromIndex is undefined, this step produces the value 0.)</li><li>If n ≥ 0, then<ol><li>Let k be n.</li></ol></li><li>Else n &lt; 0,<ol><li>Let k be len + n.</li><li>If k &lt; 0, let k be 0.</li></ol></li><li>Repeat, while k &lt; len<ol><li>Let elementK be the result of ? Get(O, ! ToString(k)).</li><li>If SameValueZero(searchElement, elementK) is true, return true.</li><li>Increase k by 1.</li></ol></li><li>Return false.</li></ol></blockquote><p>其中的 <code>SameValueZero</code> 内部实现是这样的：</p><blockquote><ol><li>If Type(x) is different from Type(y), return false.</li><li>If Type(x) is Number, then<ol><li>If x is NaN and y is NaN, return true.</li><li>If x is +0 and y is -0, return true.</li><li>If x is -0 and y is +0, return true.</li><li>If x is the same Number value as y, return true.</li></ol></li><li>Return false.</li><li>Return SameValueNonNumber(x, y).</li></ol></blockquote><p>从上面可以看出 <code>includes</code> 内部是使用 <code>while</code> 循环，并不能够降低时间复杂度。它能判断出 <code>NaN</code> 以及 <code>+0</code>等于<code>-0</code>。</p><p><strong>所以，返回值的语义化和 <code>NaN</code>的判断就是 <code>includes</code> 的场景。</strong></p><h1 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h1><p>好，<code>includes</code> 用来提升效率的幻想破灭了，那 <code>indexOf</code> 呢，规范是这么写的：</p><blockquote><ol><li>Let O be ? ToObject(this value).</li><li>Let len be ? ToLength(? Get(O, “length”)).</li><li>If len is 0, return -1.</li><li>Let n be ? ToInteger(fromIndex). (If fromIndex is undefined, this step produces the value 0.)</li><li>If n ≥ len, return -1.</li><li>If n ≥ 0, then<ol><li>If n is -0, let k be +0; else let k be n.</li></ol></li><li>Else n &lt; 0,<ol><li>Let k be len + n.</li><li>If k &lt; 0, let k be 0.</li></ol></li><li>Repeat, while k &lt; len<ol><li>Let kPresent be ? HasProperty(O, ! ToString(k)).</li><li>If kPresent is true, then<ol><li>Let elementK be ? Get(O, ! ToString(k)).</li><li>Let same be the result of performing Strict Equality Comparison searchElement === elementK.</li><li>If same is true, return k.</li></ol></li><li>Increase k by 1.</li></ol></li><li>Return -1.</li></ol></blockquote><p><code>Array</code>的 <code>indexOf</code> 也使用了 <code>while</code> 循环，并使用 <code>===</code> 全等比较。（<strong>注： 与 <code>String.prototype.indexOf</code> 并不同</strong>）</p><p><strong><code>indexOf</code> 使用场景是需要知道 匹配值的位置。</strong></p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>这是一个<a href="https://jsperf.com/includes-vs-indexof-vs-forloop/1" target="_blank" rel="external">性能测试比较</a></p><p><img src="https://raw.githubusercontent.com/Robin-front/blog/master/source/images/20170703/includes.vs.indexOf.png" alt="我的测试结果"></p><p>so? 如果单纯只是想比较，简单的才是最快的。 <code>includes</code>与<code>indexOf</code>效率相当，而<code>for Loop</code>最快，因为没有其他的前置判断和浏览器对它的优化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近遇到一道算法题，然后有些人会使用 &lt;code&gt;includes&lt;/code&gt;、&lt;code&gt;indexOf&lt;/code&gt; 去判断是否存在另一个数。这让我不禁思考，这和 &lt;code&gt;for loop&lt;/code&gt;有什么区别，能减少时间复杂度吗？我一开始也不是很清楚，但我可以找文档，找标准。我的第一判断是 &lt;code&gt;includes&lt;/code&gt; 完全和 &lt;code&gt;for loop&lt;/code&gt;没有区别的，只是es6 标准规范提供的语法糖，而 &lt;code&gt;indexOf&lt;/code&gt; 还是有一定效率的。带着疑惑，查看 MDN 和 &lt;a href=&quot;http://www.ecma-international.org/ecma-262&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ecma-262&lt;/a&gt;
    
    </summary>
    
      <category term="Array" scheme="http://robin-front.github.io/categories/Array/"/>
    
    
      <category term="Array" scheme="http://robin-front.github.io/tags/Array/"/>
    
      <category term="indexOf" scheme="http://robin-front.github.io/tags/indexOf/"/>
    
      <category term="includes" scheme="http://robin-front.github.io/tags/includes/"/>
    
      <category term="loop" scheme="http://robin-front.github.io/tags/loop/"/>
    
  </entry>
  
  <entry>
    <title>Web Animations API 入门教程总结回顾</title>
    <link href="http://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Conclusion/"/>
    <id>http://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Conclusion/</id>
    <published>2017-06-28T03:11:47.000Z</published>
    <updated>2017-06-28T03:11:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是 Web Animations API 入门教程系列的总结部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与<a href="https://twitter.com/dancwilson" target="_blank" rel="external">@dancwilson</a>联系。</p><p>我们已经涵盖了相当多的知识面，希望能够解决有关Web Animations API是什么（而不是什么）的问题。要总结这个系列，我们将回顾一下我们已经讨论过的内容，并看看尚未实现的内容。<a id="more"></a></p><h1 id="为什么要用API？"><a href="#为什么要用API？" class="headerlink" title="为什么要用API？"></a>为什么要用API？</h1><p>在介绍中，我们讨论了API是如何将CSS，JS和SVG中的各种方法结合起来进行动画处理，旨在充分利用它们。这意味着，例如，JavaScript可以锁定CSS多年来的硬件加速，并不限于CSS的声明性。API并不意味着替换像<a href="http://greensock.com/" target="_blank" rel="external">GSAP</a>这样的库，而只是为了在浏览器级别提供更多的选项。</p><p><a href="https://birtles.github.io/areweanimatedyet/" target="_blank" rel="external">Firefox</a>和<a href="https://www.chromestatus.com/features#animations" target="_blank" rel="external">Chrome</a>都已经开始实施，而Edge已经<a href="https://dev.modern.ie/platform/status/webanimationsjavascriptapi/" target="_blank" rel="external">积压了很多事没有做</a>。随着团队完成<a href="https://w3c.github.io/web-animations/" target="_blank" rel="external">规范</a>，<a href="https://github.com/web-animations/web-animations-js" target="_blank" rel="external">polyfill</a>可以让我们开始玩转它。</p><h1 id="动画基础"><a href="#动画基础" class="headerlink" title="动画基础"></a>动画基础</h1><p>要<a href="https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/">创建一个基本的动画</a>，我们通过提供关键帧和时序属性来跟踪类似于CSS的结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> player = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>).animate([</div><div class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(1)'</span>, <span class="attr">opacity</span>: <span class="number">1</span>, <span class="attr">offset</span>: <span class="number">0</span> &#125;,</div><div class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(.6)'</span>, <span class="attr">opacity</span>: <span class="number">.6</span>, <span class="attr">offset</span>: <span class="number">1</span> &#125;</div><div class="line">  ], &#123;</div><div class="line">    <span class="attr">duration</span>: <span class="number">700</span>,</div><div class="line">  &#125;);</div></pre></td></tr></table></figure><p><a href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/">时间轴控制</a>是当前CSS中明显不存在的部分。通过<code>playState</code>属性读取动画的状态，并改变状态，例如<code>play()</code>，<code>pause()</code>，和<code>finish()</code>。我们也可以通过读/写<code>playbackRate</code>属性将播放速度更改或更快。<code>currentTime</code>可读写，我们可以设置当动画与完成回调<code>onfinish</code>。</p><h1 id="多个动画和分组"><a href="#多个动画和分组" class="headerlink" title="多个动画和分组"></a>多个动画和分组</h1><p>Web Animations API允许对元素设置<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations/">多个动画</a>，创建单独的动画对象。<code>document</code>上默认的<code>timeline</code>可以使用<code>getAnimations()</code>方法让我们访问创建的所有动画。可以通过使用<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/">GroupEffects 和 SequenceEffects</a>（在polyfill中提供但不在Level 1规范中）将动画组合在一起或一个接一个地进行播放。</p><h1 id="运动路径与未来"><a href="#运动路径与未来" class="headerlink" title="运动路径与未来"></a>运动路径与未来</h1><p>在这个系列中，沿着<a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path/">一条路径运动</a>让我们看到了它在CSS中的第一个实现，但还有很多其他模块尚未实现。</p><h1 id="间距-Spacing"><a href="#间距-Spacing" class="headerlink" title="间距(Spacing)"></a>间距(Spacing)</h1><p>如果在关键帧中没有设置<code>offset</code>，则当前的实现使用默认的间隔，这意味着它们是均匀分布的（例如，三个帧将具有0,1,5和1的偏移量）。该规范还定义了一种基于属性来调整动画的方法，以使其具有恒定的变化率。当讨论<a href="http://w3c.github.io/web-animations/#spacing-keyframes" target="_blank" rel="external">Spacing keyframes</a>时，该规范描述了这一点。</p><h1 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h1><p>该规范已经演变成–包括<code>ready</code>在内的，每次动画取消或进入挂起状态（通常在更改为“运行”或“已暂停”）之前将会被新的<code>Promise</code>替换。除了<code>onfinish</code>, 我们在本系列中讨论的使用回调之外，我们还可使用<code>finished</code>返回的<code>Promise</code>在动画完成后运行其他功能。</p><h1 id="让我们继续谈论Web动画API"><a href="#让我们继续谈论Web动画API" class="headerlink" title="让我们继续谈论Web动画API"></a>让我们继续谈论Web动画API</h1><p>人们开始更多地谈论这个API，我希望这个讨论继续下去。规格，浏览器实现和polyfill已经持续了一段时间，他们准备好仔细检查。</p><p>有时CSS会有更多场景，有时候是<code>requestAnimationFrame</code>，有时使用类库会是最好的解决方案。知道什么时候使用什么是好的，这个API提供了不少以前我们以前没有的可用的东西，所以很有趣。</p><p>查看本系列的其余部分：</p><ul><li><a href="https://robin-front.github.io/2017/06/25/animations-intro/">介绍</a></li><li>第1部分：<a href="https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/">创建基本动画</a></li><li>第2部分：<a href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/">动画和时间线控制</a></li><li>第3部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations/">多个动画</a></li><li>第4部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/">GroupEffects和SequenceEffects</a></li><li>第5部分：<a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path/">运动路径</a></li><li><a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Conclusion/">总结与回顾</a></li></ul><p>【翻译原文】： <a href="http://danielcwilson.com/blog/2015/09/animations-conclusion/" target="_blank" rel="external">http://danielcwilson.com/blog/2015/09/animations-conclusion/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是 Web Animations API 入门教程系列的总结部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与&lt;a href=&quot;https://twitter.com/dancwilson&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@dancwilson&lt;/a&gt;联系。&lt;/p&gt;&lt;p&gt;我们已经涵盖了相当多的知识面，希望能够解决有关Web Animations API是什么（而不是什么）的问题。要总结这个系列，我们将回顾一下我们已经讨论过的内容，并看看尚未实现的内容。
    
    </summary>
    
      <category term="Web Animations" scheme="http://robin-front.github.io/categories/Web-Animations/"/>
    
    
      <category term="Web Animations" scheme="http://robin-front.github.io/tags/Web-Animations/"/>
    
  </entry>
  
  <entry>
    <title>Web Animations API 入门教程第5部分: 可爱的运动路径</title>
    <link href="http://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path/"/>
    <id>http://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path/</id>
    <published>2017-06-28T01:59:47.000Z</published>
    <updated>2017-06-28T01:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是 Web Animations API 入门教程系列的第5部分。</p><p>重要信息：自撰写本文以来，运动路径的规范（和Chromium实现）已经发生了重大变化。以下在概念上仍然有效，但是属性名称和更多内容已经改变。截至2016年10月，请查看<a href="https://codepen.io/danwilson/post/css-motion-paths-2016" target="_blank" rel="external">CSS运动路径</a>。</p><p>最后，沿着路径动画…不再仅仅是SVG的领域。<a id="more"></a></p><h1 id="运动路径：当前方向（Spec）"><a href="#运动路径：当前方向（Spec）" class="headerlink" title="运动路径：当前方向（Spec）"></a>运动路径：当前方向（Spec）</h1><iframe height="265" scrolling="no" title="Motion Path Infinity" src="//codepen.io/danwilson/embed/MwLmby/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/MwLmby/" target="_blank" rel="external">Motion Path Infinity</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><p>随着API规范的运用，运动路径出现了不同的形式。最初有可能的一个方向是一个形式的特效（如前面所讨论的<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/">GroupEffect</a>），但随后借助CSS模块的运动路径的气势一点点上升（<a href="https://www.w3.org/TR/motion-1/" target="_blank" rel="external">拥有它自己的规范</a>）。</p><p>因此，沿着路径动画将只是另一组CSS属性，可以动画化，正如<code>opacity</code>和<code>tranform</code>也可以。这样，CSS过渡和关键帧可以使用它,Web Animations API也是…这是伟大的，因为我们想要尽可能多的这些方法之间共享给我们更多的灵活性。Chrome和Opera已经发布了一个初步的实现，所以我们可以在今天开始玩它，尽管还没有在polyfill找到它的任何使用方式。</p><p>让我们分解这些属性，我们如何使用它们，现在还有什么事情可以阻碍我们。</p><h1 id="运动路径属性"><a href="#运动路径属性" class="headerlink" title="运动路径属性"></a>运动路径属性</h1><p>我们将讨论<code>motion</code>的三个属性。现在，要查看示例，您将需要运行Chrome 46或Opera 33。</p><h2 id="motion-path"><a href="#motion-path" class="headerlink" title="motion-path"></a>motion-path</h2><p>起始点是<code>motion-path</code>定义元素可以移动的路径，遵循SVG 1.1中的路径工作方式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#motioner</span> &#123;</div><div class="line">  <span class="attribute">motion-path</span>: <span class="built_in">path</span>(<span class="string">"M200 200 S 200.5 200.1 348.7 184.4z"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这也可以<code>fill-rule</code>在路径调用中作为可选的第一个参数。我建议您阅读<a href="http://svgpocketguide.com/book/#section-4" target="_blank" rel="external">Joni Trythall的“优秀口袋指南”</a>，就SVG进行讨论。</p><p>根据规范，您还可以使用基本形状，例如<code>circle</code>，<code>polygon</code>，<code>ellipse</code>，和<code>inset</code>。如果您尝试过使用<a href="http://alistapart.com/article/css-shapes-101" target="_blank" rel="external">CSS shape</a>，这些应该看起来很熟悉。</p><p>根据Blink的初始实现，我只看过这个<code>path()</code>方法可以工作，所以我一直没有正确使用形状或者还没到时候。</p><h2 id="motion-offset"><a href="#motion-offset" class="headerlink" title="motion-offset"></a>motion-offset</h2><p>驱动运动，并将元素放在我们使用的路径上的某个位置<code>motion-offset</code>。这可以是双倍长度值或百分比。因此，从路径的起点到最后，我们设置一个从0到100％的动画。使用我们拥有的Web Animations API</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> m = <span class="built_in">document</span>.getElementById(<span class="string">'motioner'</span>);</div><div class="line">m.animate([</div><div class="line">  &#123; <span class="attr">motionOffset</span>: <span class="number">0</span> &#125;,</div><div class="line">  &#123; <span class="attr">motionOffset</span>: <span class="string">'100%'</span> &#125;</div><div class="line">], <span class="number">1000</span>);</div></pre></td></tr></table></figure><p>以及CSS的写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#motioner</span> &#123;</div><div class="line">  <span class="attribute">animation</span>: path-animation <span class="number">1s</span>;</div><div class="line">&#125;</div><div class="line">@<span class="keyword">keyframes</span> path-animation &#123;</div><div class="line">  0% &#123;</div><div class="line">    <span class="attribute">motion-offset</span>: <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  100% &#123;</div><div class="line">    <span class="attribute">motion-offset</span>: <span class="string">'100%'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><iframe height="265" scrolling="no" title="CSS Motion Path Spiral" src="//codepen.io/danwilson/embed/ZGmeRO/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/ZGmeRO/" target="_blank" rel="external">CSS Motion Path Spiral</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><p>该CodePen演示显示了从外部到内部沿着螺旋路径移动的几个点。随着每个点接近中心，它变得越来越快，变得越来越透明。 <code>.animate()</code>在每个点被称为两次无限迭代和一个延迟，其中一个调用集中在运动偏移，另一个焦点在缩放和不透明度上。我分解了他们，指出了不同的解决方案，当然，他们也可以结合在一起。</p><p>这种方法还使用功能检测，您将会注意到，如果您在Safari，Firefox，Edge或旧版Chrome / Opera中查看，因为您将看到一条消息而不是动画。有几种方法可以做到这一点，比如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> m = <span class="built_in">document</span>.getElementById(<span class="string">'motioner'</span>);</div><div class="line"><span class="keyword">if</span> (m.style.motionOffset !== <span class="literal">undefined</span>) &#123; ... &#125;</div></pre></td></tr></table></figure><p>当然，我们不想在真正的网页中完全阻止用户，所以如果支持，我们可以有另一个动画（或者没有动画）切换到<code>Motion Path</code>动画。像往常一样，渐进增强(Progressive Enhancement)是我们的朋友。</p><h2 id="motion-rotation"><a href="#motion-rotation" class="headerlink" title="motion-rotation"></a>motion-rotation</h2><p>最后的属性是motion-rotation，它处理元素沿着路径移动时面向哪个方向。有四种主要方法可以指定这一点。</p><ul><li>auto 表示元素将随路径旋转。</li><li>reverse 元素也将随着路径旋转，但会增加180度，因此将向后。</li><li>auto Xdeg / reverse Xdeg 除了添加X度也会一样</li><li>Xdeg 将不再与路径一起旋转，元素将保持固定朝向相同的方向。</li></ul><iframe height="265" scrolling="no" title="CSS MotionPath" src="//codepen.io/danwilson/embed/qdLQjz/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/qdLQjz/" target="_blank" rel="external">CSS MotionPath</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><h1 id="少了点什么东西？"><a href="#少了点什么东西？" class="headerlink" title="少了点什么东西？"></a>少了点什么东西？</h1><p>这是第一个版本，当然，浏览器制造商和规范作者仍在讨论这一切。在尝试这一过程中，我注意到的最大的一件事就是缺少适应不同屏幕/容器尺寸的路径。</p><p>路径只是按照它们的定义出现。当使用SVG时，我们获得灵活性，因为我们在容器上具有不同的坐标系和属性，如 <a href="http://sarasoueidan.com/blog/svg-coordinate-systems/#svg-viewbox" target="_blank" rel="external">viewBox</a>。使用CSS中定义的运动路径，路径的大小不能被其他属性另外修改或约束。元素上定义的宽度和高度仅适用于元素，而不是其运动路径。您可以使用媒体查询或JavaScript来定义不同条件的不同路径，但是想通过<code>motion</code>属性灵活地设置它们是不可能的事。</p><h1 id="回顾和下一节"><a href="#回顾和下一节" class="headerlink" title="回顾和下一节"></a>回顾和下一节</h1><p>我们将看到规范的方向，但现在尝试这样做是很有趣的，看看它可能提供什么（和不提供什么）。我正在收集我在CodePen上找到的<a href="http://codepen.io/collection/AQWaem" target="_blank" rel="external">CSS Motion Path演示文稿</a>，而Eric Willigers（Chrome开发团队的相关实现任务的所有者）拥有一个<a href="https://docs.google.com/document/d/15nn0tc9meyahzSBAauYtIUpGFsuHaieZt403k1v9B90/edit" target="_blank" rel="external">Google Doc的例子</a>。</p><p>我们将在下次再次介绍我们所讨论的内容，并且再看几个目前唯一的规范主题。</p><p>查看本系列的其余部分：</p><ul><li><a href="https://robin-front.github.io/2017/06/25/animations-intro/">介绍</a></li><li>第1部分：<a href="https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/">创建基本动画</a></li><li>第2部分：<a href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/">动画和时间线控制</a></li><li>第3部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations/">多个动画</a></li><li>第4部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/">GroupEffects和SequenceEffects</a></li><li>第5部分：<a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path/">运动路径</a></li><li><a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Conclusion/">总结与回顾</a></li></ul><p>【翻译原文】： <a href="http://danielcwilson.com/blog/2015/09/animations-part-5/" target="_blank" rel="external">http://danielcwilson.com/blog/2015/09/animations-part-5/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是 Web Animations API 入门教程系列的第5部分。&lt;/p&gt;&lt;p&gt;重要信息：自撰写本文以来，运动路径的规范（和Chromium实现）已经发生了重大变化。以下在概念上仍然有效，但是属性名称和更多内容已经改变。截至2016年10月，请查看&lt;a href=&quot;https://codepen.io/danwilson/post/css-motion-paths-2016&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CSS运动路径&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;最后，沿着路径动画…不再仅仅是SVG的领域。
    
    </summary>
    
      <category term="Web Animations" scheme="http://robin-front.github.io/categories/Web-Animations/"/>
    
    
      <category term="Web Animations" scheme="http://robin-front.github.io/tags/Web-Animations/"/>
    
  </entry>
  
  <entry>
    <title>Web Animations API 入门教程第4部分: GroupEffects &amp; SequenceEffects</title>
    <link href="http://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/"/>
    <id>http://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/</id>
    <published>2017-06-27T03:24:55.000Z</published>
    <updated>2017-06-27T03:24:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是 Web Animations API 入门教程系列的第4部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与<a href="https://twitter.com/dancwilson" target="_blank" rel="external">@dancwilson</a>联系。</p><p>让我们继续讨论Web动画API中的多个动画，通过讨论今天在polyfill中提供的几个部分来提供分组和排序。<a id="more"></a></p><h1 id="KeyframeEffects"><a href="#KeyframeEffects" class="headerlink" title="KeyframeEffects"></a>KeyframeEffects</h1><p>A KeyframeEffect需要三个参数：动画元素(element)，关键帧数组(keyframes)和时间选项(timing options)。这些都是我们以前使用过的参数<code>element.animate()</code>。这个新对象本质上是单个动画的蓝图，当我们讨论分组(group)和队列(sequence)动画的方法时，我们会看到它。它不启动动画，它只是定义动画。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>);</div><div class="line"><span class="keyword">var</span> timings = &#123;</div><div class="line">  <span class="attr">duration</span>: <span class="number">1000</span>,</div><div class="line">  <span class="attr">fill</span>: <span class="string">'both'</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> keyframes = [</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">1</span> &#125;.</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">0</span> &#125;</div><div class="line">];</div><div class="line"></div><div class="line"><span class="keyword">var</span> effect = <span class="keyword">new</span> KeyframeEffect(elem, keyframes, timings);</div></pre></td></tr></table></figure><h1 id="GroupEffects"><a href="#GroupEffects" class="headerlink" title="GroupEffects"></a>GroupEffects</h1><p>虽然在任何浏览器中都没有实现此功能，甚至在Level 2规范中找不到，但是polyfill提供了一种组合动画并将其一起播放的方法。 <strong>GroupEffect</strong>（是的，它是未来将集成在Level 2规范）组合一个或多个KeyframeEffects同时播放。</p><iframe height="265" scrolling="no" title="Group Effects with WAAPI" src="//codepen.io/danwilson/embed/zGeVey/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/zGeVey/" target="_blank" rel="external">Group Effects with WAAPI</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><p>一个<code>GroupEffect</code>任务需要一个<code>Effects</code>参数，我们可以传递代表我们多个动画的<code>KeyframeEffect</code>数组。一旦定义，我们可以在准备好的时候在默认时间轴上播放动画组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>);</div><div class="line"><span class="keyword">var</span> elem2 = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate2'</span>);</div><div class="line"><span class="keyword">var</span> timings = &#123;</div><div class="line">  <span class="attr">duration</span>: <span class="number">1000</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> keyframes = [</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">1</span> &#125;.</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">0</span> &#125;</div><div class="line">];</div><div class="line"></div><div class="line"><span class="keyword">var</span> kEffects = [</div><div class="line">  <span class="keyword">new</span> KeyframeEffect(elem, keyframes, timings),</div><div class="line">  <span class="keyword">new</span> KeyframeEffect(elem2, keyframes, timings)</div><div class="line">];</div><div class="line"><span class="keyword">var</span> group = <span class="keyword">new</span> GroupEffect(kEffects);</div><div class="line"><span class="built_in">document</span>.timeline.play(group);</div></pre></td></tr></table></figure><h1 id="SequenceEffects"><a href="#SequenceEffects" class="headerlink" title="SequenceEffects"></a>SequenceEffects</h1><p>类似于<code>GroupEffect</code>，<code>SequenceEffect</code>允许我们将多个动画（由<code>KeyframeEffects</code> 指定）组合在一起…不是并行播放它们，而是一个接一个地播放它们。您也可以按照polyfill中的定义将<code>GroupEffect</code>和<code>SequenceEffect</code>一起使用（例如具有多个序列的分组）。</p><iframe height="265" scrolling="no" title="SequenceEffect with WAAPI" src="//codepen.io/danwilson/embed/vNYQLL/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/vNYQLL/" target="_blank" rel="external">SequenceEffect with WAAPI</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><p>队列提供给你一些我们必须用CSS或者我们在 animations API中看到的东西。我们必须根据早期动画的持续时间或使用 <strong>finish</strong> 回调来维持延迟。这些方法可能难以维护，或者不会如此精确。</p><p>使用先前在<code>GroupEffect</code>代码段中的变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sequence = <span class="keyword">new</span> SequenceEffect(kEffects);</div><div class="line"><span class="built_in">document</span>.timeline.play(sequence);</div></pre></td></tr></table></figure><h1 id="创建动画的备用方法"><a href="#创建动画的备用方法" class="headerlink" title="创建动画的备用方法"></a>创建动画的备用方法</h1><p>我们以前看过<code>element.animate()</code>创建动画的方式。这是创建动画的快捷方式，立即播放，并获取<code>Animation</code>对象的引用。我们专注于这一点，因为Chrome支持了一段时间了，polyfill也是。Firefox是第一个支持替代方式的：·构造函数。它向我们展示了另一种使用方法<code>KeyframeEffect</code>，而且它在Level 1规范中，所以我们应该很快会看到它的更多应用。</p><p>首先提醒一下如何<code>element.animate()</code>工作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>);</div><div class="line"><span class="keyword">var</span> timings = &#123;</div><div class="line">  <span class="attr">duration</span>: <span class="number">1000</span>,</div><div class="line">  <span class="attr">fill</span>: <span class="string">'both'</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> keyframes = [</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">1</span> &#125;.</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">0</span> &#125;</div><div class="line">];</div><div class="line"></div><div class="line">elem.animate(keyframes, timings);</div></pre></td></tr></table></figure><p>使用与上述相同的变量，以下是使用<code>Animation</code>构造函数的等价写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> kEffect = <span class="keyword">new</span> KeyframeEffect(elem, keyframes, timings);</div><div class="line"><span class="keyword">var</span> player = <span class="keyword">new</span> Animation(kEffect, elem.ownerDocument.timeline);</div><div class="line">player.play();</div></pre></td></tr></table></figure><p>这里的主要区别在于，动画不会立即开始播放，所以在提前创建动画以便稍后播放时，这将非常有用。</p><h1 id="回顾和下一节"><a href="#回顾和下一节" class="headerlink" title="回顾和下一节"></a>回顾和下一节</h1><p>当Level 2规范通过工作草案时，我们应该看到更多关于这些不同效果的定义。本系列中还有两个计划的章节。下一次我们将再次看看未来，还有什么我们可以期待看到。</p><p>查看本系列的其余部分：</p><ul><li><a href="https://robin-front.github.io/2017/06/25/animations-intro/">介绍</a></li><li>第1部分：<a href="https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/">创建基本动画</a></li><li>第2部分：<a href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/">动画和时间线控制</a></li><li>第3部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations/">多个动画</a></li><li>第4部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/">GroupEffects和SequenceEffects</a></li><li>第5部分：<a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path/">运动路径</a></li><li><a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Conclusion/">总结与回顾</a></li></ul><p>【翻译原文】：<a href="http://danielcwilson.com/blog/2015/09/animations-part-4/" target="_blank" rel="external">http://danielcwilson.com/blog/2015/09/animations-part-4/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是 Web Animations API 入门教程系列的第4部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与&lt;a href=&quot;https://twitter.com/dancwilson&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@dancwilson&lt;/a&gt;联系。&lt;/p&gt;&lt;p&gt;让我们继续讨论Web动画API中的多个动画，通过讨论今天在polyfill中提供的几个部分来提供分组和排序。
    
    </summary>
    
      <category term="Web Animations" scheme="http://robin-front.github.io/categories/Web-Animations/"/>
    
    
      <category term="Web Animations" scheme="http://robin-front.github.io/tags/Web-Animations/"/>
    
  </entry>
  
  <entry>
    <title>Web Animations API 入门教程第3部分: 多个Animations对象</title>
    <link href="http://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations/"/>
    <id>http://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations/</id>
    <published>2017-06-27T02:17:19.000Z</published>
    <updated>2017-06-27T02:17:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是 Web Animations API 入门教程系列的第3部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与<a href="https://twitter.com/dancwilson" target="_blank" rel="external">@dancwilson</a>联系。</p><p>在我们讨论<a href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/">动画和时间线控制</a>之后，让我们来讨论多个动画。<a id="more"></a></p><h1 id="每个元素的多个动画"><a href="#每个元素的多个动画" class="headerlink" title="每个元素的多个动画"></a>每个元素的多个动画</h1><iframe height="265" scrolling="no" title="Multiple animate calls" src="//codepen.io/danwilson/embed/PqxvJo/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/PqxvJo/" target="_blank" rel="external">Multiple animate calls</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><p>在这个例子中，每个矩形都有三个动画应用（涉及到transform，opacity和color）。您可以多次调用元素的<code>animate()</code>方法，类似于允许多个动画的CSS。</p><p>使用CSS：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#toAnimate</span> &#123;</div><div class="line">  <span class="attribute">animation</span>: pulse <span class="number">1s</span>, activate <span class="number">3000ms</span>, have-fun-with-it <span class="number">2.5s</span>;</div><div class="line">&#125;</div><div class="line">@<span class="keyword">keyframes</span> pulse &#123; <span class="comment">/* ... */</span> &#125;</div><div class="line">@<span class="keyword">keyframes</span> activate &#123; <span class="comment">/* ... */</span> &#125;</div><div class="line">@<span class="keyword">keyframes</span> have-fun-with-it &#123; <span class="comment">/* ... */</span> &#125;</div></pre></td></tr></table></figure><p>使用Web Animations API：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> animated = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>);</div><div class="line"><span class="keyword">var</span> pulseKeyframes, <span class="comment">//在这里定义 keyframes.</span></div><div class="line">    activateKeyframes,</div><div class="line">    haveFunKeyframes;</div><div class="line"><span class="keyword">var</span> pulse = animated.animate(pulseKeyframes, <span class="number">1000</span>); <span class="comment">// 第二个数值参数作为持续时间的缩写</span></div><div class="line"><span class="keyword">var</span> activate = animated.animate(activateKeyframes, <span class="number">3000</span>);</div><div class="line"><span class="keyword">var</span> haveFunWithIt = animated.animate(haveFunKeyframes, <span class="number">2500</span>);</div></pre></td></tr></table></figure><p>使用Web Animations API，这将创建三个Animation对象，每个对象可以通过时间轴(timeline)或播放速率(playback rate)进行暂停，播放，完成，取消的操作。</p><h1 id="获取-Animations，全部动画对象"><a href="#获取-Animations，全部动画对象" class="headerlink" title="获取 Animations，全部动画对象"></a>获取 Animations，全部动画对象</h1><p>所以你可以知道一个动画开始播放了，但是当你想在元素上调用<code>animate()</code>时你却还没有捕获到Animation的引用。那要怎么做？</p><iframe height="265" scrolling="no" title="Pause All those Random Dots!" src="//codepen.io/danwilson/embed/PqgKVK/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/PqgKVK/" target="_blank" rel="external">Pause All those Random Dots!</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><p>该规范允许<code>getAnimations()</code>在文档上的方法。在最新版本的规范中，它直接在<code>document（document.getAnimations()）</code>上，在Firefox 48+上它是这样实现的。然而，对于Chrome 52 和<a href="https://github.com/web-animations/web-animations-js" target="_blank" rel="external">polyfill</a>（如V2.2.0的），则根据该旧规范将其置于新的<code>timeline</code>对象上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如果引用了 polyfill ，你可以这样写</span></div><div class="line"><span class="keyword">var</span> animations = <span class="built_in">document</span>.getAnimations ? <span class="built_in">document</span>.getAnimations() : <span class="built_in">document</span>.timeline.getAnimations();</div><div class="line"><span class="comment">// 返回一个数组，包含所有正在进行的（除了已完成的和被取消的）动画</span></div></pre></td></tr></table></figure><p>在CodePen示例中，您将看到随机的持续时间，延迟和无限持续时间的变换移动的几个点。“暂停全部”按钮调用<code>getAnimations()</code>并遍历所有, 返回的玩家（每个动画对象）并暂停每一个。</p><h1 id="下一节…"><a href="#下一节…" class="headerlink" title="下一节…"></a>下一节…</h1><p>在下一部分中，我们将看看WAAPI动画可以创建的不同方式（因为它不仅仅是<code>element.animate</code>）。提示：<code>document.timeline</code>会出现更多的体现。</p><p>查看本系列的其余部分：</p><ul><li><a href="https://robin-front.github.io/2017/06/25/animations-intro/">介绍</a></li><li>第1部分：<a href="https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/">创建基本动画</a></li><li>第2部分：<a href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/">动画和时间线控制</a></li><li>第3部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations/">多个动画</a></li><li>第4部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/">GroupEffects和SequenceEffects</a></li><li>第5部分：<a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path/">运动路径</a></li><li><a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Conclusion/">总结与回顾</a></li></ul><p>【翻译原文】: <a href="http://danielcwilson.com/blog/2015/08/animations-part-3/" target="_blank" rel="external">http://danielcwilson.com/blog/2015/08/animations-part-3/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是 Web Animations API 入门教程系列的第3部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与&lt;a href=&quot;https://twitter.com/dancwilson&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@dancwilson&lt;/a&gt;联系。&lt;/p&gt;&lt;p&gt;在我们讨论&lt;a href=&quot;http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/&quot;&gt;动画和时间线控制&lt;/a&gt;之后，让我们来讨论多个动画。
    
    </summary>
    
      <category term="Web Animations" scheme="http://robin-front.github.io/categories/Web-Animations/"/>
    
    
      <category term="Web Animations" scheme="http://robin-front.github.io/tags/Web-Animations/"/>
    
  </entry>
  
  <entry>
    <title>Web Animations API入门教程第2部分：动画和时间线控制</title>
    <link href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/"/>
    <id>http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/</id>
    <published>2017-06-26T09:51:00.000Z</published>
    <updated>2017-06-26T09:51:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是 Web Animations API 入门教程系列的第2部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与<a href="https://twitter.com/dancwilson" target="_blank" rel="external">@dancwilson</a>联系。</p><p>现在我们了解如何使用Web Animations API <a href="https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/">创建基本动画</a>，让我们来谈谈状态（states），控制(controls)，回调(callback)和时间轴(timelines)。<a id="more"></a></p><h1 id="Animations-播放状态和控制"><a href="#Animations-播放状态和控制" class="headerlink" title="Animations 播放状态和控制"></a>Animations 播放状态和控制</h1><p>当你调用时<code>element.animate()</code>，返回一个<code>Animation</code>对象（以前称为<code>AnimationPlayerspec</code>），动画开始播放。要查看动画的当前状态，您可以检查<code>readonly</code>属性<code>playState</code>，该属性将返回五个字符串之一。我们也可以通过调用四种方法之一修改动画的当前状态：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> player = element.animate(<span class="comment">/* ... */</span>);</div><div class="line"><span class="built_in">console</span>.log(player.playState); <span class="comment">//"running"</span></div><div class="line"></div><div class="line">player.pause(); <span class="comment">//"paused"</span></div><div class="line">player.play();  <span class="comment">//"running"</span></div><div class="line">player.cancel(); <span class="comment">//"idle"... 跳到原始状态</span></div><div class="line">player.finish(); <span class="comment">//"finished"...跳到结束状态</span></div></pre></td></tr></table></figure><p>此外<code>running</code>，<code>paused</code>，<code>idle</code>，和<code>finished</code>播放状态有一个<code>pending</code>状态定义当播放或暂停任务正在等待批准即将发生。</p><p>这个“步行圆圈”示例显示六个圆缩放。您可以暂停或播放每个圈子，以查看上述播放状态的一部分。</p><iframe height="265" scrolling="no" title="Blob That Walks" src="//codepen.io/danwilson/embed/WvXRYg/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/WvXRYg/" target="_blank" rel="external">Blob That Walks</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><h1 id="播放速率"><a href="#播放速率" class="headerlink" title="播放速率"></a>播放速率</h1><p>在之前的CodePen示例中，还有一个“2x”按钮，您可以按更改动画的播放速度，将其切换到双倍速度。这是通过读/写<code>playbackRate</code>属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> player = element.animate(<span class="comment">/* ... */</span>);</div><div class="line"><span class="built_in">console</span>.log(player.playbackRate); <span class="comment">//1</span></div><div class="line"></div><div class="line">player.playbackRate = <span class="number">2</span>; <span class="comment">//双倍速度, 也可以使用十进制数字控制它降低速度.</span></div></pre></td></tr></table></figure><h1 id="动画完成后的回调"><a href="#动画完成后的回调" class="headerlink" title="动画完成后的回调"></a>动画完成后的回调</h1><p>使用CSS transitions，当转换结束时，通常会触发一个事件。类似地，<code>Animation</code>允许您指定一个<code>onfinish</code>函数，在动画完成或调用之前讨论过的<code>finish()</code>方法时调用它。请注意，根据规范，无法完成无限次迭代的动画集，也不能完成一个具有<code>playbackRate = 0</code> 的动画集。还有一个<code>oncancel</code>处理程序，以及在<code>Animation</code>完成时使用<code>Promises</code>的写法。</p><p>以下示例用于<code>onfinish</code>在动画完成后显示一些统计信息（并且它也很好地切换到下一次关于时间轴的讨论）。</p><iframe height="265" scrolling="no" title="Timer Countdown" src="//codepen.io/danwilson/embed/RPMVZJ/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/RPMVZJ/" target="_blank" rel="external">Timer Countdown</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><h1 id="时间轴"><a href="#时间轴" class="headerlink" title="时间轴"></a>时间轴</h1><p>每个<code>Animation</code>都公开两个读/写时间相关属性 - <code>currentTime</code>和<code>startTime</code>。现在，我们将重点关注前者。</p><p><code>currentTime</code>返回动画当前的毫秒数。最大值将为延迟时间 +（持续时间<em>迭代次数）（`delay + (duration </em>iterations)`），因此无限次迭代将不具有最大值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> player = element.animate([</div><div class="line">  &#123;<span class="attr">opacity</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">opacity</span>: <span class="number">0</span>&#125;</div><div class="line">], &#123;</div><div class="line">  <span class="attr">duration</span>: <span class="number">1000</span>,</div><div class="line">  <span class="attr">delay</span>: <span class="number">500</span>,</div><div class="line">  <span class="attr">iterations</span>: <span class="number">3</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">player.onfinish = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(player.currentTime); <span class="comment">// 3500</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>播放速率将影响时间轴的持续时间。如果您将播放速度设置为10，则您的最大时间保持不变，但您的时间轴会快10倍。这个概念也在之前的“计时器倒计时”示例中显示。</p><p>由于<code>currentTime</code>是可 读/写，我们也可以使用它来跳转到时间轴中的某一点。它也可以让我们同步两个动画，如下例所示。</p><iframe height="265" scrolling="no" title="Syncing Timelines - WAAPI" src="//codepen.io/danwilson/embed/YXYWKK/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/YXYWKK/" target="_blank" rel="external">Syncing Timelines - WAAPI</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><h1 id="还有一个选项：-reverse"><a href="#还有一个选项：-reverse" class="headerlink" title="还有一个选项： reverse()"></a>还有一个选项： reverse()</h1><p>你也可以使用<code>reverse()</code>反转一个与之非常相似的动画<code>play()</code>（比如它会有相同的playState），除了它将以相反的方式遍历时间轴。当动画完成时，<code>currentTime</code>将为0。</p><iframe height="265" scrolling="no" title="waRKOm" src="//codepen.io/danwilson/embed/waRKOm/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/waRKOm/" target="_blank" rel="external">waRKOm</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><h1 id="下一节…"><a href="#下一节…" class="headerlink" title="下一节…"></a>下一节…</h1><p>这包含了很多的信息，但仍然只是熟悉一下WAAPI有哪些可用的。下面我们来看一些更高级的用法。</p><p>查看本系列的其余部分：</p><ul><li><a href="https://robin-front.github.io/2017/06/25/animations-intro/">介绍</a></li><li>第1部分：<a href="https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/">创建基本动画</a></li><li>第2部分：<a href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/">动画和时间线控制</a></li><li>第3部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations/">多个动画</a></li><li>第4部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/">GroupEffects和SequenceEffects</a></li><li>第5部分：<a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path/">运动路径</a></li><li><a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Conclusion/">总结与回顾</a></li></ul><p>【翻译原文】: <a href="http://danielcwilson.com/blog/2015/07/animations-part-2/" target="_blank" rel="external">http://danielcwilson.com/blog/2015/07/animations-part-2/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是 Web Animations API 入门教程系列的第2部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与&lt;a href=&quot;https://twitter.com/dancwilson&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@dancwilson&lt;/a&gt;联系。&lt;/p&gt;&lt;p&gt;现在我们了解如何使用Web Animations API &lt;a href=&quot;https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/&quot;&gt;创建基本动画&lt;/a&gt;，让我们来谈谈状态（states），控制(controls)，回调(callback)和时间轴(timelines)。
    
    </summary>
    
      <category term="Web Animations" scheme="http://robin-front.github.io/categories/Web-Animations/"/>
    
    
      <category term="Web Animations" scheme="http://robin-front.github.io/tags/Web-Animations/"/>
    
  </entry>
  
  <entry>
    <title>Web Animations API 入门教程第1部分:创建一个基本的动画</title>
    <link href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/"/>
    <id>http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/</id>
    <published>2017-06-26T03:25:31.000Z</published>
    <updated>2017-06-26T03:25:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是 Web Animations API 入门教程系列的第1部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与<a href="https://twitter.com/dancwilson" target="_blank" rel="external">@dancwilson</a>联系。</p><p>我们之前初步看了下 Web Animations API，但是我们没有得到任何真正的细节，所以现在我们来看看。</p><p>WAAPI（Web Animations API, 以下均简称WAAPI）为您提供更多的控制比您可能已经习惯使用的CSS动画，但在我们进入这些演示之前，我们需要设置基本目标：如何通过此API创建基本动画？<a id="more"></a></p><h1 id="创建关键帧动画"><a href="#创建关键帧动画" class="headerlink" title="创建关键帧动画"></a>创建关键帧动画</h1><p>如果您熟悉CSS Transitions/ Animations，这将非常熟悉。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> player = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>).animate([</div><div class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(1)'</span>, <span class="attr">opacity</span>: <span class="number">1</span>, <span class="attr">offset</span>: <span class="number">0</span> &#125;,</div><div class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(.5)'</span>, <span class="attr">opacity</span>: <span class="number">.5</span>, <span class="attr">offset</span>: <span class="number">.3</span> &#125;,</div><div class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(.667)'</span>, <span class="attr">opacity</span>: <span class="number">.667</span>, <span class="attr">offset</span>: <span class="number">.7875</span> &#125;,</div><div class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(.6)'</span>, <span class="attr">opacity</span>: <span class="number">.6</span>, <span class="attr">offset</span>: <span class="number">1</span> &#125;</div><div class="line">  ], &#123;</div><div class="line">    <span class="attr">duration</span>: <span class="number">700</span>, <span class="comment">//毫秒</span></div><div class="line">    easing: <span class="string">'ease-in-out'</span>, <span class="comment">//'linear', a bezier curve等.</span></div><div class="line">    delay: <span class="number">10</span>, <span class="comment">//毫秒</span></div><div class="line">    iterations: <span class="literal">Infinity</span>, <span class="comment">//或其他数值</span></div><div class="line">    direction: <span class="string">'alternate'</span>, <span class="comment">//'normal', 'reverse', 等.</span></div><div class="line">    fill: <span class="string">'forwards'</span> <span class="comment">//'backwards', 'both', 'none', 'auto'</span></div><div class="line">  &#125;);</div></pre></td></tr></table></figure><p>为了对照，这里是一个等效的CSS关键帧动画</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> emphasis &#123;</div><div class="line">  0% &#123;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(1);</div><div class="line">    <span class="attribute">opacity</span>: <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  30% &#123;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(.5);</div><div class="line">    <span class="attribute">opacity</span>: .<span class="number">5</span>;</div><div class="line">  &#125;</div><div class="line">  78<span class="selector-class">.75</span>% &#123;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(.667);</div><div class="line">    <span class="attribute">opacity</span>: .<span class="number">667</span>;</div><div class="line">  &#125;</div><div class="line">  100% &#123;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(.6);</div><div class="line">    <span class="attribute">opacity</span>: .<span class="number">6</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="selector-id">#toAnimate</span> &#123;</div><div class="line">  <span class="attribute">animation</span>: emphasis <span class="number">700ms</span> ease-in-out <span class="number">10ms</span> infinite alternate forwards;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们将分解这一切，解释每一部会。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> player = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>).animate()</div></pre></td></tr></table></figure><p>动画将返回一个 <strong>Animation</strong>（以前在规范中称为 <strong>AnimationPlayer</strong>）对象，这将给我们做些有趣的事情，所以你可能想要设置一个变量来捕获这个引用。我们找到我们想要的动画元素（这里简单地使用document.getElementById）并调用该<code>animate</code>函数。此功能是新添加的特性，所以如果您必须要测试它的支持性/存在性，在使用它之前或者引用 <a href="https://github.com/web-animations/web-animations-js" target="_blank" rel="external">polyfill</a>。</p><p>该<code>animate</code>函数有两个参数，一个<code>KeyframeEffects</code>和一个<code>AnimationEffectTimingProperties</code>选项的数组。本质上，第一个参数映射到CSS中的内容<code>@keyframe</code>s，第二个参数是您在CSS规则中使用的<code>animation-*</code>属性（或<code>animation</code>简写，如我之前的示例）所指定的那样。这里的主要优点是我们可以使用变量或重用以前定义的<code>KeyframeEffects</code>，而使用CSS我们仅限于我们在前面声明的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> player = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>).animate([</div><div class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(1)'</span>, <span class="attr">opacity</span>: <span class="number">1</span> &#125;,</div><div class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(.5)'</span>, <span class="attr">opacity</span>: <span class="number">.5</span> &#125;,</div><div class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(.667)'</span>, <span class="attr">opacity</span>: <span class="number">.667</span> &#125;,</div><div class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(.6)'</span>, <span class="attr">opacity</span>: <span class="number">.6</span> &#125;</div><div class="line">  ]);</div></pre></td></tr></table></figure><p>对于每一个<code>KeyframeEffect</code>，我们将CSS中的百分比偏移量改为<code>offset</code>从0到1 的十进制值。它是可选的，如果没有指定，它们将均匀分布（因此，如果您有三个，则第一个具有偏移为0，第二个偏移量为.5，第三个偏移量为1）。您还可以指定<code>easing</code>与<code>animation-timing-functionCSS</code>中相同的属性。每个的其他属性<code>KeyframeEffect</code>都是动画的属性。每个属性的值应该符合在JavaScript的<code>element.style</code>中的用法，因此<code>opacity</code>将是一个数字，但<code>transform</code>会期望一个字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> player = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>).animate([], &#123;</div><div class="line">    <span class="attr">duration</span>: <span class="number">700</span>, <span class="comment">//milliseconds</span></div><div class="line">    easing: <span class="string">'ease-in-out'</span>, <span class="comment">//'linear', a bezier curve, etc.</span></div><div class="line">    delay: <span class="number">10</span>, <span class="comment">//milliseconds</span></div><div class="line">    iterations: <span class="literal">Infinity</span>, <span class="comment">//or a number</span></div><div class="line">    direction: <span class="string">'alternate'</span>, <span class="comment">//'normal', 'reverse', etc.</span></div><div class="line">    fill: <span class="string">'forwards'</span> <span class="comment">//'backwards', 'both', 'none', 'auto'</span></div><div class="line">  &#125;);</div></pre></td></tr></table></figure><p>时间属性将映射到CSS动画属性，尽管有时会使用不同的名称。较早的代码示例讨论了主要选项。</p><p>以下是使用<code>polyfill</code>的示例（但如果您正在Chrome 36+，Opera 23+或Firefox 48+中查看，则应使用实际的浏览器实现）。第一列灰色块使用WAAPI动画，第二列红色块使用CSS关键帧进行动画。</p><iframe height="265" scrolling="no" title="CSS Keyframes v. WAAPI" src="//codepen.io/danwilson/embed/QwrZwd/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/QwrZwd/" target="_blank" rel="external">CSS Keyframes v. WAAPI</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><h1 id="下一节…"><a href="#下一节…" class="headerlink" title="下一节…"></a>下一节…</h1><p>现在我们知道如何创建在CSS中熟知的等效动画，我们将开始查看<code>Animation</code> 的 <code>animate</code> 函数返回的对象。这是我们看到真正的功能和改进的地方。</p><p>查看本系列的其余部分：</p><ul><li><a href="https://robin-front.github.io/2017/06/25/animations-intro/">介绍</a></li><li>第1部分：<a href="https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/">创建基本动画</a></li><li>第2部分：<a href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/">动画和时间线控制</a></li><li>第3部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations/">多个动画</a></li><li>第4部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/">GroupEffects和SequenceEffects</a></li><li>第5部分：<a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path/">运动路径</a></li><li><a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Conclusion/">总结与回顾</a></li></ul><p>【翻译原文】： <a href="http://danielcwilson.com/blog/2015/07/animations-part-1/" target="_blank" rel="external">http://danielcwilson.com/blog/2015/07/animations-part-1/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是 Web Animations API 入门教程系列的第1部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与&lt;a href=&quot;https://twitter.com/dancwilson&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@dancwilson&lt;/a&gt;联系。&lt;/p&gt;&lt;p&gt;我们之前初步看了下 Web Animations API，但是我们没有得到任何真正的细节，所以现在我们来看看。&lt;/p&gt;&lt;p&gt;WAAPI（Web Animations API, 以下均简称WAAPI）为您提供更多的控制比您可能已经习惯使用的CSS动画，但在我们进入这些演示之前，我们需要设置基本目标：如何通过此API创建基本动画？
    
    </summary>
    
      <category term="Web Animations" scheme="http://robin-front.github.io/categories/Web-Animations/"/>
    
    
      <category term="Web Animations" scheme="http://robin-front.github.io/tags/Web-Animations/"/>
    
  </entry>
  
  <entry>
    <title>让我们谈谈 Web Animations API</title>
    <link href="http://robin-front.github.io/2017/06/25/animations-intro/"/>
    <id>http://robin-front.github.io/2017/06/25/animations-intro/</id>
    <published>2017-06-25T03:53:30.000Z</published>
    <updated>2017-06-25T03:53:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是 Web Animations API 入门教程系列的总结部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与<a href="https://twitter.com/dancwilson" target="_blank" rel="external">@dancwilson</a>联系。</p><p>2014年夏天，Google宣布通过<a href="https://www.polymer-project.org/0.5/platform/web-animations.html" target="_blank" rel="external">Polymer</a>在网页中展示Material设计…使用polyfill技术支持即将推出的标准Web Animations API。</p><p>我没有听说过这个API，但是我很感兴趣，特别是因为它谈到了<code>MotionPath</code>(运动路径)效果。这还没有实现（你会在<a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path/">第5部分</a>发现这是什么），但是它的目标是提供一种组合CSS，JS和SVG的动画方式，让我感兴趣。一年以后，Chrome和Firefox开始实施，polyfill的进步是稳定的，现在是认真看待它的时候了。</p><p>但是很少有人在谈论WAAPI！我希望开始一系列突出浏览器（和polyfill）功能的帖子，探索为什么我们想要这个API，并找出细微差别。希望我们也能让更多的人讨论和使用这个API。<a id="more"></a></p><h1 id="什么是Web动画API？"><a href="#什么是Web动画API？" class="headerlink" title="什么是Web动画API？"></a>什么是Web动画API？</h1><p>我们将通过弄清楚它是什么，以及它正在努力完成的事情来开始这个探索。</p><p>动画在过去的十年中已经取得了很好的进展，并提供了很好的CSS支持和新增功能来改进JavaScript。但是，每种动画方法仍然对他们所提供的所有优点都有一些缺陷。</p><ul><li>CSS具有用于平滑过渡的硬件加速，并且浏览器内置了支持，但规则在CSS中声明，并且需要跳过JavaScript环节以获得动态更改的值。</li><li><code>requestAnimationFrame</code>有很好的支持，让浏览器在动画时进行优化，但如果还有很多其他JavaScript运行，它仍然可以挂起。它也经常需要更多的数学知识来获得定时。</li><li><code>setInterval</code>被很多开发人员用来做动画，但它是不精确的，可以导致动画卡顿。</li><li><code>jQuery.animate()</code> 被其他一些开发人员推荐制作动画，但往往有性能问题。</li><li>诸如<a href="http://julian.com/research/velocity/" target="_blank" rel="external">Velocity</a>和<a href="http://greensock.com/" target="_blank" rel="external">GreenSock（GSAP）</a>这样的类库可以提高JavaScript的性能，并且在许多情况下已经被测试成为最好的。然而，他们仍然需要维护和加载额外的库。</li></ul><p>一般来说，我们喜欢浏览器的支持尽可能多，直接被优化过的方式。现在浏览器有<code>document.querySelector</code>，因为我们看到jQuery提供选择DOM元素的值。理想情况下，我们可以在浏览器级别包装尽可能多的动画控件。这些库可以专注于提供更新的功能，并且可以持续迭代。</p><p>Web Animations API尝试这样做。它旨在带来CSS性能的强大，增加了JavaScript的好处和灵活性（以及SVG动画，我们将在以后的一篇文章中讨论），并将其留给浏览器使其运行良好。</p><h1 id="让我们通过添加新的东西来解决这个问题！"><a href="#让我们通过添加新的东西来解决这个问题！" class="headerlink" title="让我们通过添加新的东西来解决这个问题！"></a>让我们通过添加新的东西来解决这个问题！</h1><p>在以前的工作中，我们收到一封电子邮件，表示他们知道我们有太多的地方可以查看公司公告 - 电子邮件，办公室的监视器，Yammer，Google Chat和Intranet / wiki。所以要解决他们宣布的问题，他们正在添加一个博客。</p><p>我第一次听到有关Web Animations API 和我听到我公司新增博客的想法一样 - 这只会使事情变得更糟。果然，博客没有集中任何东西，它只是添加了一个地方，我们必须查看新闻，然后不了了之了。</p><p>这感觉不一样。 <a href="https://w3c.github.io/web-animations/" target="_blank" rel="external">审查规范</a>（第一次我在这个程度上真的做到这一点）显示了对此的关注。这并不意味着取代现有的行为（尽管有些浏览器似乎已经<a href="https://www.chromestatus.com/features/5371475380928512" target="_blank" rel="external">不赞成某些行为</a>），而是将各种方式联合起来，并允许他们进行交互。语法类似于CSS，但添加了变量，控制和完成回调的选项。</p><h1 id="下一节…"><a href="#下一节…" class="headerlink" title="下一节…"></a>下一节…</h1><p>因此，Web Animations API是新的，并且开始实现（目前在<a href="https://www.chromestatus.com/features#animations" target="_blank" rel="external">Chrome</a>和<a href="https://birtles.github.io/areweanimatedyet/" target="_blank" rel="external">Firefox</a>中），除了拥有一个polyfill。下次我们实际上会开始看看它为开发者提供了什么…有例子！</p><p>查看本系列的其余部分：</p><ul><li><a href="https://robin-front.github.io/2017/06/25/animations-intro/">介绍</a></li><li>第1部分：<a href="https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/">创建基本动画</a></li><li>第2部分：<a href="http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/">动画和时间线控制</a></li><li>第3部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations/">多个动画</a></li><li>第4部分：<a href="https://robin-front.github.io/2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects/">GroupEffects和SequenceEffects</a></li><li>第5部分：<a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path/">运动路径</a></li><li><a href="https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Conclusion/">总结与回顾</a></li></ul><p>【翻译原文】：<a href="http://danielcwilson.com/blog/2015/07/animations-intro/" target="_blank" rel="external">http://danielcwilson.com/blog/2015/07/animations-intro/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是 Web Animations API 入门教程系列的总结部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与&lt;a href=&quot;https://twitter.com/dancwilson&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@dancwilson&lt;/a&gt;联系。&lt;/p&gt;&lt;p&gt;2014年夏天，Google宣布通过&lt;a href=&quot;https://www.polymer-project.org/0.5/platform/web-animations.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Polymer&lt;/a&gt;在网页中展示Material设计…使用polyfill技术支持即将推出的标准Web Animations API。&lt;/p&gt;&lt;p&gt;我没有听说过这个API，但是我很感兴趣，特别是因为它谈到了&lt;code&gt;MotionPath&lt;/code&gt;(运动路径)效果。这还没有实现（你会在&lt;a href=&quot;https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path/&quot;&gt;第5部分&lt;/a&gt;发现这是什么），但是它的目标是提供一种组合CSS，JS和SVG的动画方式，让我感兴趣。一年以后，Chrome和Firefox开始实施，polyfill的进步是稳定的，现在是认真看待它的时候了。&lt;/p&gt;&lt;p&gt;但是很少有人在谈论WAAPI！我希望开始一系列突出浏览器（和polyfill）功能的帖子，探索为什么我们想要这个API，并找出细微差别。希望我们也能让更多的人讨论和使用这个API。
    
    </summary>
    
      <category term="Web Animations" scheme="http://robin-front.github.io/categories/Web-Animations/"/>
    
    
      <category term="Web Animations" scheme="http://robin-front.github.io/tags/Web-Animations/"/>
    
  </entry>
  
  <entry>
    <title>css 动画和 Web Animation API(WAAPI)对比</title>
    <link href="http://robin-front.github.io/2017/06/22/css-animations-vs-web-animations-api/"/>
    <id>http://robin-front.github.io/2017/06/22/css-animations-vs-web-animations-api/</id>
    <published>2017-06-22T09:48:00.000Z</published>
    <updated>2017-06-22T09:48:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>有一个JavaScript的动画原生API，称为<code>Web Animation API</code>。我们在这篇文章中称之为<code>WAAPI</code>。MDN有很好的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API" target="_blank" rel="external">文档</a>，Dan Wilson 有一个伟大的<a href="http://danielcwilson.com/blog/2015/07/animations-part-1/" target="_blank" rel="external">系列文章</a>。</p><p>在本文中，我们将比较WAAPI和CSS中完成的动画。<a id="more"></a></p><h1 id="关于浏览器支持的提示"><a href="#关于浏览器支持的提示" class="headerlink" title="关于浏览器支持的提示"></a>关于浏览器支持的提示</h1><p>尽管现在浏览器的支持很有限，但WAAPI有一个全面而强大的<a href="https://github.com/web-animations/web-animations-js/tree/master" target="_blank" rel="external">polyfill</a>工具，让它可以在当前的生产环境中使用。</p><p>一如既往，您可以检查<a href="http://caniuse.com/#feat=web-animation" target="_blank" rel="external">Can I Use</a> 的浏览器支持数据。然而，这并没有提供非常好的信息来支持WAAPI的所有子功能。这是一个检查器：</p><iframe height="265" scrolling="no" title="WAAPI Browser Support Test" src="//codepen.io/danwilson/embed/xGBKVq/?height=265&theme-id=0&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/danwilson/pen/xGBKVq/" target="_blank" rel="external">WAAPI Browser Support Test</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="external">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><p>想要不使用polyfill而体验所有功能，请使用Firefox Nightly。</p><h1 id="WAAPI的基础知识"><a href="#WAAPI的基础知识" class="headerlink" title="WAAPI的基础知识"></a>WAAPI的基础知识</h1><p>如果您曾经使用<code>jQuery.animate()</code>，WAAPI的基本语法应该看起来很熟悉。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.querySelector(<span class="string">'.animate-me'</span>);</div><div class="line">element.animate(keyframes, <span class="number">1000</span>);</div></pre></td></tr></table></figure><p>该<code>animate</code>方法接受两个参数：关键帧和持续时间。与jQuery不同的是，它不仅具有内置在浏览器中的优点，而且性能也更高。</p><p>第一个参数，关键帧应该是一个对象数组。每个对象都是我们动画中的一个关键帧。这是一个简单的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> keyframes = [</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">0</span> &#125;,</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">1</span> &#125;</div><div class="line">];</div></pre></td></tr></table></figure><p>第二个参数，持续时间，是我们想要动画持续多久。在上面的例子中是1000毫秒。我们来看一个更令人兴奋的例子。</p><h1 id="用WAAPI重新创建animista-CSS动画"><a href="#用WAAPI重新创建animista-CSS动画" class="headerlink" title="用WAAPI重新创建animista CSS动画"></a>用WAAPI重新创建animista CSS动画</h1><p>这里有一些CSS代码，从非常棒的<a href="http://animista.net/" target="_blank" rel="external">animista</a>中吸取了一些称为“幻灯片模糊的”入场动画的东西。看起来很可爱。</p><p><img src="https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_368,f_auto,q_auto/v1496792139/slide-down_ohemtx.gif" alt="实际[效果](http://animista.net/play/entrances/slide-in-blurred)要比这个 GIF 要棒很多"></p><p>以下是CSS中的关键帧：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">0% &#123;</div><div class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-1000px) <span class="built_in">scaleY</span>(2.5) <span class="built_in">scaleX</span>(.2);</div><div class="line">  <span class="attribute">transform-origin</span>: <span class="number">50%</span> <span class="number">0</span>;</div><div class="line">  <span class="attribute">filter</span>: <span class="built_in">blur</span>(40px);</div><div class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">100% &#123;</div><div class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(0) <span class="built_in">scaleY</span>(1) <span class="built_in">scaleX</span>(1);</div><div class="line">  <span class="attribute">transform-origin</span>: <span class="number">50%</span> <span class="number">50%</span>;</div><div class="line">  <span class="attribute">filter</span>: <span class="built_in">blur</span>(0);</div><div class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>WAAPI中的代码相同：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> keyframes = [</div><div class="line">  &#123;</div><div class="line">    <span class="attr">transform</span>: <span class="string">'translateY(-1000px) scaleY(2.5) scaleX(.2)'</span>,</div><div class="line">    <span class="attr">transformOrigin</span>: <span class="string">'50% 0'</span>, <span class="attr">filter</span>: <span class="string">'blur(40px)'</span>, <span class="attr">opacity</span>: <span class="number">0</span></div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="attr">transform</span>: <span class="string">'translateY(0) scaleY(1) scaleX(1)'</span>,</div><div class="line">    <span class="attr">transformOrigin</span>: <span class="string">'50% 50%'</span>,</div><div class="line">    <span class="attr">filter</span>: <span class="string">'blur(0)'</span>,</div><div class="line">    <span class="attr">opacity</span>: <span class="number">1</span></div><div class="line">  &#125;</div><div class="line">];</div></pre></td></tr></table></figure><p>我们已经看到，将关键帧应用到要运动的任何元素是多么容易的事：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">element.animate(keyframes, <span class="number">700</span>);</div></pre></td></tr></table></figure><p>为了简单起见，我只指定了持续时间。但是，我们可以使用这个第二个参数来传递更多的选项。至少我们也应该指定一个缓动函数。以下是可用选项的完整列表，其中包含一些示例值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> options = &#123;</div><div class="line">  <span class="attr">iterations</span>: <span class="literal">Infinity</span>,</div><div class="line">  <span class="attr">iterationStart</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">delay</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">endDelay</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">direction</span>: <span class="string">'alternate'</span>,</div><div class="line">  <span class="attr">duration</span>: <span class="number">700</span>,</div><div class="line">  <span class="attr">fill</span>: <span class="string">'forwards'</span>,</div><div class="line">  <span class="attr">easing</span>: <span class="string">'ease-out'</span>,</div><div class="line">&#125;</div><div class="line">element.animate(keyframes, options);</div></pre></td></tr></table></figure><p>有了这些选项，我们的动画将从头开始，没有任何延迟，永远循环在向前和向后播放。</p><iframe height="265" scrolling="no" title="motion blur waapi circle" src="//codepen.io/cssgrid/embed/EmBGxG/?height=265&theme-id=0&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/cssgrid/pen/EmBGxG/" target="_blank" rel="external">motion blur waapi circle</a> by CSS GRID (<a href="https://codepen.io/cssgrid" target="_blank" rel="external">@cssgrid</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><p>令人烦恼的是，对于我们熟悉CSS动画的人来说，一些术语与我们习惯的不同。虽然在积极的一面看，有些事情写起来更快一点！</p><ul><li>这里用<code>easing</code>而不是<code>animation-timing-function</code></li><li>使用<code>iterations</code>而不是<code>animation-iteration-count</code>。如果我们希望动画永远重复，用<code>Infinity</code>而不是<code>infinite</code>。有点混乱，<code>Infinity</code>不是引用。Infinity是一个JavaScript关键字，而其他值是字符串。</li><li>我们使用毫秒而不是秒，对于之前编写过许多JavaScript的人来说，这应该是熟悉的。（您可以在CSS动画中使用毫秒数，但很少有人使用。）</li></ul><p>我们来仔细看看一个选项：<code>iterationStart</code>。</p><p>当我第一次碰到<code>iterationStart</code>, 我被难住了。你为什么要指定迭代的开始，而不仅仅是减少迭代次数？当您使用十进制数时，此选项非常有用。例如，您可以将其设置为 <code>.5</code>，动画将开始一半。要做一整个动画需要两半，所以如果你的迭代次数设置为1，并且你的<code>iterationStart</code>设置为 <code>.5</code>，动画将从一半到动画结束播放，然后从动画开头开始，结束于中间！</p><p>值得注意的是，您也可以将迭代次数设置为小于1。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> option = &#123;</div><div class="line">  <span class="attr">iterations</span>: <span class="number">.5</span>,</div><div class="line">  <span class="attr">iterationStart</span>: <span class="number">.5</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这将从中间到最后播放动画。 <code>endDelay：endDelay</code>如果要将多个动画串在一起，但是希望在一个动画的结尾和任何后续动画的开始之间存在差距。这是一个有用的视频，Patrick Brosset 的解释。</p><div style="position:relative;height:0;padding-bottom:56.22%"><iframe src="https://www.youtube.com/embed/hWe-qukNrN8?ecver=2" style="position:absolute;width:100%;height:100%;left:0" width="640" height="360" frameborder="0" allowfullscreen></iframe></div><h1 id="缓动"><a href="#缓动" class="headerlink" title="缓动"></a>缓动</h1><p>缓动是任何动画中最重要的元素之一。WAAPI为我们提供了两种不同的方式设置缓动函数 - 在我们的关键帧阵列或我们的选项对象内。 在CSS中，如果你应用了，<code>animation-timing-function: ease-in-out</code>你可能会假设你的动画的开始会<code>ease in</code>，动画的结束将会<code>ease out</code>。实际上，这些缓动函数应用在关键帧之间，而不是整个动画。这可以对动画的感觉进行细粒度的控制。WAAPI还提供这种能力。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> keyframes = [</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">0</span>, <span class="attr">easing</span>: <span class="string">'ease-in'</span> &#125;,</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">0.5</span>, <span class="attr">easing</span>: <span class="string">'ease-out'</span> &#125;,</div><div class="line">  &#123; <span class="attr">opacity</span>: <span class="number">1</span> &#125;</div><div class="line">]</div></pre></td></tr></table></figure><p>值得注意的是，在CSS和WAAPI中，您不应该传入最后一帧的缓动值，因为这将不起作用。这是很多人犯的错误。 有时候，在整个动画中添加缓动效果更为直观。这在CSS是不可能的，但现在可以实现与WAAPI。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> options = &#123;</div><div class="line">  <span class="attr">duration</span>: <span class="number">1000</span>,</div><div class="line">  <span class="attr">easing</span>: <span class="string">'ease-in-out'</span>,</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>你可以看到这两种缓动在CodePen上的区别：</p><iframe height="265" scrolling="no" title="Same animation, different easing" src="//codepen.io/cssgrid/embed/OmrVeQ/?height=265&theme-id=0&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/cssgrid/pen/OmrVeQ/" target="_blank" rel="external">Same animation, different easing</a> by CSS GRID (<a href="https://codepen.io/cssgrid" target="_blank" rel="external">@cssgrid</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><h1 id="ease-vs-linear"><a href="#ease-vs-linear" class="headerlink" title="ease vs linear"></a>ease vs linear</h1><p>值得注意的是CSS动画和WAAPI之间的另一个区别：CSS ease的默认值是<code>ease</code>,WAAPI的默认值<code>linear</code>。 <code>Ease</code>实际上是一个版本，<code>ease-in-out</code>是一个非常好的选择，如果你感到懒惰。同时，<code>linear</code> 是沉闷的和无生机的 - 一致的速度看起来机械和不自然。它被选为默认值，可能因为它是最中立的选项。然而，在WAAPI中使用时，使用缓动比在CSS更重要，以免您的动画看起来很乏味和机械地。</p><h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>WAAPI提供与CSS动画相同的性能改进，尽管这并不意味着平滑的动画是不可避免的。</p><p>我希望这个API的性能优化意味着我们可以避免使用<code>will-change</code>和完全hack <code>translateZ</code> - 最终可能。但是，至少在目前的浏览器实现中，这些属性在处理闪烁问题（<code>jank issue</code>）方面仍然是有帮助和必要的。</p><p>但是，至少如果您的动画有延迟，则无需担心使用<code>will-change</code>。网络动画规范的主要作者对“<a href="https://damp-lake-50659.herokuapp.com/" target="_blank" rel="external">Animation for Work Slack community</a>”提出了一些有趣的建议，希望他不介意我在这里重复：</p><blockquote><p>如果您有一个积极的延迟，您不需要<code>will-change</code>因为浏览器将在延迟开始时进行分层，当动画启动时，它将准备就绪。</p></blockquote><h1 id="WAAPI对战CSS动画？"><a href="#WAAPI对战CSS动画？" class="headerlink" title="WAAPI对战CSS动画？"></a>WAAPI对战CSS动画？</h1><p>WAAPI为我们提供了一个在JavaScript中实现css中的语法。然而，他们不应该被视为对手。如果我们决定坚持使用CSS进行<code>animations</code>和<code>transitions</code>，那么我们可以与WAAPI进行动画交互。</p><h1 id="Animation-对象"><a href="#Animation-对象" class="headerlink" title="Animation 对象"></a>Animation 对象</h1><p>该<code>.animate()</code>方法不仅仅是动画我们的元素，它也返回一些东西。</p><p><img src="https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1000,f_auto,q_auto/v1496519294/animationobject_ujevsk.png" alt="在控制台中查看的动画对象"></p><p>如果我们看看控制台中的返回值，我们将看到它的一个动画对象。这为我们提供了各种各样的功能，其中一些是非常不言自明的<code>myAnimation.pause()</code>。通过更改<code>animation-play-state</code>属性，我们可以通过CSS动画实现类似的结果，但WAAPI语法比稍微简单<code>element.style.animationPlayState = &quot;paused&quot;</code>。我们也有权力轻松地扭转我们的动画<code>myAnimation.reverse()</code>，再次，<code>animation-direction</code>与使用我们的脚本更改CSS属性相比，稍微有点改进。</p><p>然而，到目前为止，<code>@keyframe</code>用JavaScript进行操作并不是世界上最简单的事情。即使像重新启动动画一样简单，就像Chris Coyier 先前<a href="https://css-tricks.com/restart-css-animation/" target="_blank" rel="external">写过的</a>那样，这个技巧也有<a href="https://css-tricks.com/restart-css-animation/" target="_blank" rel="external">一些技巧</a>。使用WAAPI，我们可以简单地使用<code>myAnimation.play()</code>，它从一开始就重播动画，如果它已经完成，或者如果我们暂停播放，则从中间迭代继续播放动画。</p><p>我们甚至可以轻松地改变动画的速度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myAnimation.playbackRate = <span class="number">2</span>; <span class="comment">// speed it up</span></div><div class="line">myAnimation.playbackRate = <span class="number">.4</span>; <span class="comment">// use a number less than one to slow it down</span></div></pre></td></tr></table></figure><h1 id="getAnimations（）"><a href="#getAnimations（）" class="headerlink" title="getAnimations（）"></a>getAnimations（）</h1><p>此方法将返回任何动画对象的数组，以便我们使用WAAPI定义的任何动画以及 <em>任何CSS <code>transitions</code>或<code>animations</code></em>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">element.getAnimations() <span class="comment">// returns any animations or transitions applied to our element using CSS or WAAPI</span></div></pre></td></tr></table></figure><p>如果您感觉使用CSS来定义和应用您的动画比较顺手，<code>getAnimations()</code>可以使用API​​与<code>@keyframes</code> 结合使用。您可以继续使用CSS进行大部分动画工作，并在需要API时获得API的优势。让我们看看这是多么简单。</p><p>即使一个DOM元素只有一个动画应用到它，<code>getAnimations()</code>也将始终返回一个数组。我们来抓住那个单一的动画对象来处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> h2 = <span class="built_in">document</span>.querySelector(<span class="string">"h2"</span>);</div><div class="line"><span class="keyword">var</span> myCSSAnimation = h2.getAnimations()[<span class="number">0</span>];</div></pre></td></tr></table></figure><p>现在我们可以在我们的CSS动画中使用web animation API :)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myCSSAnimation.playbackRate = <span class="number">4</span>;</div><div class="line">myCSSAnimation.reverse();</div></pre></td></tr></table></figure><h1 id="Promise和事件"><a href="#Promise和事件" class="headerlink" title="Promise和事件"></a>Promise和事件</h1><p>我们已经有多种通过CSS触发的事件，我们可以在我们的JavaScript代码利用的有：<code>animationstart</code>，<code>animationend</code>，<code>animationiteration</code>和<code>transitionend</code>。我经常需要收听<code>animations</code>或<code>transitions</code>的结束，以便从DOM中删除应用于它的元素。</p><p>在WAAPI 中使用<code>animationend</code>或<code>transitionend</code>为此目的相当于再次使用动画对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">myAnimation.onfinish = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  element.remove();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>WAAPI为我们提供了事件和Promise的选择。我们的动画的<code>.finished</code>属性对象将在动画结束时返回一个resolve 的 Promise。以下是上面的例子，就像使用Promise一样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myAnimation.finished.then(<span class="function"><span class="params">()</span> =&gt;</span></div><div class="line">  element.remove())</div></pre></td></tr></table></figure><p>我们来看看Mozilla开发人员网络中的一个稍微有点省略的例子。<code>Promise.all</code>接收一个Promise数组，一旦所有这些Promise得到解决，才会运行我们的回调函数。我们已经看到，<code>element.getAnimations()</code>返回一个动画对象数组。我们可以将数组中的所有动画对象映射到每个动画对象<code>.finished</code>上，为我们提供所需的Promise数组。</p><p>在这个例子中，只有在页面上的所有动画完成后，我们的函数才能运行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.all(<span class="built_in">document</span>.getAnimations().map(<span class="function"><span class="params">animation</span> =&gt;</span></div><div class="line">  animation.finished)).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;           </div><div class="line">    <span class="comment">// do something cool</span></div><div class="line">  &#125;);</div></pre></td></tr></table></figure><h1 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h1><p>本文中提到的功能只是开始。目前的规范和实践看起来是一件伟大的事情的开始。</p><p>「翻譯原文」：<a href="https://css-tricks.com/css-animations-vs-web-animations-api/?utm_source=frontendfocus" target="_blank" rel="external">https://css-tricks.com/css-animations-vs-web-animations-api/?utm_source=frontendfocus</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一个JavaScript的动画原生API，称为&lt;code&gt;Web Animation API&lt;/code&gt;。我们在这篇文章中称之为&lt;code&gt;WAAPI&lt;/code&gt;。MDN有很好的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文档&lt;/a&gt;，Dan Wilson 有一个伟大的&lt;a href=&quot;http://danielcwilson.com/blog/2015/07/animations-part-1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;系列文章&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;在本文中，我们将比较WAAPI和CSS中完成的动画。
    
    </summary>
    
      <category term="css3" scheme="http://robin-front.github.io/categories/css3/"/>
    
      <category term="Animation" scheme="http://robin-front.github.io/categories/css3/Animation/"/>
    
    
      <category term="css3" scheme="http://robin-front.github.io/tags/css3/"/>
    
      <category term="Animation" scheme="http://robin-front.github.io/tags/Animation/"/>
    
  </entry>
  
  <entry>
    <title>webpack3官方正式发布,亮点:作用域提升，“魔法注释”，以及更多新特性！</title>
    <link href="http://robin-front.github.io/2017/06/21/webpack3%E5%AE%98%E6%96%B9%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83-%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%90%E5%8D%87%EF%BC%8C%E2%80%9C%E9%AD%94%E6%B3%95%E6%B3%A8%E9%87%8A%E2%80%9D%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%9B%B4%E5%A4%9A%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%81/"/>
    <id>http://robin-front.github.io/2017/06/21/webpack3官方正式发布-作用域提升，“魔法注释”，以及更多新特性！/</id>
    <published>2017-06-21T07:35:55.000Z</published>
    <updated>2017-06-22T07:35:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="作用域提升，“魔法注释”，以及更多新特性！"><a href="#作用域提升，“魔法注释”，以及更多新特性！" class="headerlink" title="作用域提升，“魔法注释”，以及更多新特性！"></a>作用域提升，“魔法注释”，以及更多新特性！</h1><p><a href="https://medium.com/webpack/webpack-3-official-release-15fd2dd8f07b" target="_blank" rel="external">原文</a></p><p>在我们发布了 webpack v2 之后，我们曾向社区做了一些承诺。 我们承诺，我们将提供用户投票的功能。 此外，我们承诺我们的发布周期会 <strong>更快，更稳定</strong>。</p><p>这次没有 beta 版本，完全向下兼容。我们承诺让你们、让 webpack 成长的社区更轻松的使用。webpack 团队自豪地宣布，今天我们已经发布了 webpack 3.0.0！ 现在就可以下载或升级！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install webpack@3.0.0 --save-dev</div></pre></td></tr></table></figure><p>或者使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yarn add webpack@3.0.0 --dev</div></pre></td></tr></table></figure><p><em>从 webpack 2 迁移到 3，只需要执行升级命令，在使用上没有任何差别。我们将这次升级标记为版本的重大升级，是因为内部的突破性变化可能会影响某些插件的使用。</em></p><p><strong>到目前为止，98%的升级的用户都没有遇到任何不兼容！</strong><a id="more"></a></p><h1 id="有哪些新特性"><a href="#有哪些新特性" class="headerlink" title="有哪些新特性?"></a>有哪些新特性?</h1><p>像上文提到的一样，我们发布了一些由用户投票选出的功能，感谢 Github，赞助商和我们的支持者，有了他们我们才能做出每一个改进。😍</p><h2 id="🔬作用域提升（Scope-Hoisting）🔬"><a href="#🔬作用域提升（Scope-Hoisting）🔬" class="headerlink" title="🔬作用域提升（Scope Hoisting）🔬"></a>🔬作用域提升（Scope Hoisting）🔬</h2><p>作用域提升是 webpack 3 的重点功能。之前 webpack 在打包时，您的 bundle 中的每个模块都将被包装在单独的函数闭包中。这些闭包会使您的 JavaScript 在浏览器中执行速度更慢。相比之下，像 Closure Compiler 和 RollupJS 这样的工具可以将所有模块包装在一个大的闭包内，从而使您的代码在浏览器中具有更快的执行速度。</p><p></p><blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">70K =&gt; 37K (gzip!) savings on our main bundle using <a href="https://twitter.com/hashtag/webpack?src=hash" target="_blank" rel="external">#webpack</a> 3 RC.2 + ModuleConcatenationPlugin 😲 🔥 Awesome work <a href="https://twitter.com/TheLarkInn" target="_blank" rel="external">@TheLarkInn</a> <a href="https://twitter.com/wSokra" target="_blank" rel="external">@wSokra</a> et al! <a href="https://t.co/zVfQoivT9d" target="_blank" rel="external">pic.twitter.com/zVfQoivT9d</a></p>&mdash; Jeremy Gayed 🤓 (@tizmagik) <a href="https://twitter.com/tizmagik/status/876128847682523138" target="_blank" rel="external">June 17, 2017</a></blockquote><p></p><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script><p>而现在，使用 webpack 3，您现在可以 <strong>在配置中添加下面的插件以启用作用域提升</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">  <span class="attr">plugins</span>: [</div><div class="line">    <span class="keyword">new</span> webpack.optimize.ModuleConcatenationPlugin()</div><div class="line">  ]</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>作用域提升是基于 ECMAScript Module 语法实现的一个特征。通过这个，webpack 可以根据你正在使用什么样的模块和<a href="https://medium.com/webpack/webpack-freelancing-log-book-week-5-7-4764be3266f5" target="_blank" rel="external">一些其他条件</a>来回退到正常的捆绑。</p><p>为了了解什么触发了这些回退，我们添加了一个 <code>--display-optimization-bailout</code>cli 标志，它将告诉你是什么导致的回退。</p><p></p><blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Total evaluation script time went from 2.52s to 2.06s, first meaningful paint from 3.43s to 2.70s and all initial event fired 20% earlier</p>&mdash; Jeremias Menichelli (@jeremenichelli) <a href="https://twitter.com/jeremenichelli/status/876527176606265344" target="_blank" rel="external">June 18, 2017</a></blockquote><p></p><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script><p>同时，由于作用域提升会移除模块外的函数包装，你可能会看到一些小的体积改进。然而，更显着的改进是JavaScript在浏览器中加载的速度。 如果您在比较使用之前和之后时发现加载速度取得了非常棒的改进，请随时回复一些数据，我们将很荣幸分享！</p><h2 id="🔮-魔法注释-”Magic-Comments”-🔮"><a href="#🔮-魔法注释-”Magic-Comments”-🔮" class="headerlink" title="🔮 魔法注释 ”Magic Comments” 🔮"></a>🔮 魔法注释 ”Magic Comments” 🔮</h2><p>当我们在webpack 2中引入使用动态导入语法（<code>import()</code>）时，用户表示，他们不能像使用 <code>require.ensure</code> 一样创建命名 chunk。我们现在介绍由社区创建的“魔法注释”，它可以传递 chunk 名称，还有<a href="https://medium.com/webpack/how-to-use-webpacks-new-magic-comment-feature-with-react-universal-component-ssr-a38fd3e296a" target="_blank" rel="external">更多功能</a>，例如可以添加更多的内联注释到 <code>import()</code> 语句中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "my-chunk-name" */</span> <span class="string">'module'</span>);</div></pre></td></tr></table></figure><p>通过使用注释，我们能够在使用动态导入语法的同时，对代码块进行命名。</p><p>尽管这是我们在 v2.4 和 v2.6 中发布的技术特性，但在 v3 中，我们修复了这些功能的一些错误，使其变得更稳定。 同时，现在允许动态导入语法具有与 <code>require.ensure</code> 相同的灵活性。</p><p></p><blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">TIL webpack /<em>chunkName</em>/ comments aren&#39;t just for nicer filenames—also great for organizing your chunks. Even interops w/ commonsChunk! <a href="https://t.co/wjdT9y6oTE" target="_blank" rel="external">pic.twitter.com/wjdT9y6oTE</a></p>&mdash; Adam Rackis (@AdamRackis) <a href="https://twitter.com/AdamRackis/status/872602076056088576" target="_blank" rel="external">June 7, 2017</a></blockquote><p></p><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script><p>要了解更多信息，请参阅我们<a href="https://webpack.js.org/guides/code-splitting-async" target="_blank" rel="external">最新文档的代码分割部分</a>，文档高亮了这些新功能！</p><h2 id="😍-接下来是什么？😍"><a href="#😍-接下来是什么？😍" class="headerlink" title="😍 接下来是什么？😍"></a>😍 接下来是什么？😍</h2><p>我们有很多功能和增强功能想要推出！但我们需要了解用户需求的优先级。所以访问我们的<a href="http://webpack.js.org/vote" target="_blank" rel="external">投票页面</a>，并提出你想看到的功能！</p><p>这些是我们希望带给您的一些功能：</p><ul><li>更好地构建缓存</li><li>更快的初始构建和增量构建</li><li>更好的TypeScript体验</li><li>改进长期缓存</li><li>WASM模块支持</li><li>改善用户体验</li></ul><h2 id="🙇-致谢-🙇"><a href="#🙇-致谢-🙇" class="headerlink" title="🙇 致谢 🙇"></a>🙇 致谢 🙇</h2><p>感谢我们所有的用户，贡献者，文档作者，博客，赞助商，支持者和维护者。是他们都帮助我们确保 webpack 在未来几年成功。</p><p>为此，我们感谢所有人。webpack 发展到现在与你的支持密不可分，我们迫不及待地想要与你分享未来 webpack 的新进展！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;作用域提升，“魔法注释”，以及更多新特性！&quot;&gt;&lt;a href=&quot;#作用域提升，“魔法注释”，以及更多新特性！&quot; class=&quot;headerlink&quot; title=&quot;作用域提升，“魔法注释”，以及更多新特性！&quot;&gt;&lt;/a&gt;作用域提升，“魔法注释”，以及更多新特性！&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://medium.com/webpack/webpack-3-official-release-15fd2dd8f07b&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;&lt;p&gt;在我们发布了 webpack v2 之后，我们曾向社区做了一些承诺。 我们承诺，我们将提供用户投票的功能。 此外，我们承诺我们的发布周期会 &lt;strong&gt;更快，更稳定&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;这次没有 beta 版本，完全向下兼容。我们承诺让你们、让 webpack 成长的社区更轻松的使用。webpack 团队自豪地宣布，今天我们已经发布了 webpack 3.0.0！ 现在就可以下载或升级！&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;npm install webpack@3.0.0 --save-dev&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;或者使用&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;yarn add webpack@3.0.0 --dev&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;em&gt;从 webpack 2 迁移到 3，只需要执行升级命令，在使用上没有任何差别。我们将这次升级标记为版本的重大升级，是因为内部的突破性变化可能会影响某些插件的使用。&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;到目前为止，98%的升级的用户都没有遇到任何不兼容！&lt;/strong&gt;
    
    </summary>
    
      <category term="webpack" scheme="http://robin-front.github.io/categories/webpack/"/>
    
    
      <category term="webpack" scheme="http://robin-front.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Flow和TypeScript之间的区别和优劣</title>
    <link href="http://robin-front.github.io/2017/06/14/Flow%E5%92%8CTypeScript%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BC%98%E5%8A%A3/"/>
    <id>http://robin-front.github.io/2017/06/14/Flow和TypeScript之间的区别和优劣/</id>
    <published>2017-06-14T15:28:54.000Z</published>
    <updated>2017-06-14T15:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>采用Flow＆TypeScript, 两者上手流程之间的比较。</p><p>让我们想象一下我们想要采用一种类型检查器的场景…</p><p>本文译自： <a href="http://thejameskyle.com/adopting-flow-and-typescript.html" target="_blank" rel="external">adopting flow and typescript</a><a id="more"></a></p><p>最近我们已经注意到了我们的应用程序中的很多NaN的出现。我们搜索源代码并找到以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// math.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n;</div><div class="line">&#125;</div><div class="line">square(<span class="string">"oops"</span>);</div></pre></td></tr></table></figure><p>我们对自己叹了口气，也许决定添加一个类型检查器。我们退后一步，查看我们的选项： <a href="https://flow.org/" target="_blank" rel="external">Flow</a> 或 <a href="http://www.typescriptlang.org/" target="_blank" rel="external">TypeScript</a>。</p><p>这两个工具都有相当简单的方法给逐个文件应用：</p><ul><li>Flow: <code>// @flow</code> 向文件顶部添加注释</li><li>TypeScript：将扩展名更改为<code>.js</code>扩展<code>.ts</code> 名</li></ul><p>但是让我们比较一下这里面发生了什么。</p><h3 id="采用TypeScript"><a href="#采用TypeScript" class="headerlink" title="采用TypeScript"></a>采用TypeScript</h3><p>要采用TypeScript，我们首先重命名<code>math.js</code>为 <code>math.ts</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// math.ts</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n;</div><div class="line">&#125;</div><div class="line">square(<span class="string">"oops"</span>);</div></pre></td></tr></table></figure><p>现在我们将运行typescript：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(no errors)</div></pre></td></tr></table></figure><p>没有错误，是因为TypeScript要求我们给函数键入注释，然后才会根据注释检查类型。如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n: number</span>): <span class="title">number</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n;</div><div class="line">&#125;</div><div class="line">square(<span class="string">"oops"</span>);</div></pre></td></tr></table></figure><p>如果没有这些类型，TypeScript将根据您的配置执行下面两件事情之一：</p><ul><li><ol><li>隐含地将每个未知类型转换为<code>any</code>。这种任何类型将让您退出所有类型检查。</li></ol></li><li><ol><li>或者如果您使用了<code>--noImplicitAny</code>选项，它会为任何未知类型抛出错误，指明需要添加类型注释。</li></ol></li></ul><p>这意味着TypeScript 覆盖的代码量与您所写的类型相关。写入类型时，类型coverage将线性上升。</p><h3 id="类型覆盖（type-coverage）"><a href="#类型覆盖（type-coverage）" class="headerlink" title="类型覆盖（type coverage）"></a>类型覆盖（type coverage）</h3><p>在我们进一步讲解之前，我应该解释一下什么是类型覆盖。</p><p><img src="http://thejameskyle.com/img/type-coverage.png" alt="未有类型覆盖的代码用红色显示"></p><p>未有类型覆盖的代码用红色显示</p><p>如果你看到你的代码中的值和表达式，并问类型检查器“你知道这是什么类型吗”。</p><p>如果类型检查器知道它类型，则覆盖该值或表达式。如果类型检查器不知道类型，那么它没有被覆盖。</p><p>您希望您的程序尽可能多地提供类型覆盖，因为这样可以在更多地方抛出错误时提前告诉您。</p><p>没有类型覆盖，类型检查器什么都不是。</p><h3 id="采用Flow"><a href="#采用Flow" class="headerlink" title="采用Flow"></a>采用Flow</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// @flow</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n;</div><div class="line">&#125;</div><div class="line">square(<span class="string">"oops"</span>);</div></pre></td></tr></table></figure><p>然后我们将运行Flow并查看结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n;</div><div class="line">         ^   ^</div><div class="line">         <span class="built_in">Error</span> (x2)</div><div class="line">&#125;</div><div class="line">square(<span class="string">"oops"</span>);</div><div class="line"></div><div class="line"><span class="built_in">Error</span> (x2)</div><div class="line">string. The operand <span class="keyword">of</span> an arithmetic operation must be a number.</div></pre></td></tr></table></figure><p>紧接着就抛出了类型错误，告诉我们代码出了问题。</p><p>Flow 只需要我们键入文件和外部模块的导出。可以推测出其他一切。</p><p>这使得类型覆盖率快得多。只需几种类型，您可以快速获取具有非常高类型覆盖率的文件。</p><p>根据我的经验，我可以在短短几分钟内将文件覆盖约70-90％。</p><p>这是一个非常科学的差异图：</p><p><img src="http://thejameskyle.com/img/adopting-flow-and-typescript-graph.png" alt=""></p><p>这不是我一家之言，你可以自己尝试一下，看看几种类型的区别。</p><p>要查看Flow中文件的类型覆盖，可以运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flow coverage path/to/file.js --color</div></pre></td></tr></table></figure><p>您还可以使用 <a href="https://github.com/rpl/flow-coverage-report" target="_blank" rel="external">流量报告</a> 来帮助您。</p><blockquote><p>注意：我没有注意到TypeScript 有任何的类型报告工具（如果您知道一个，请给我发送一个链接）。但是，您可以测试代码是否覆盖，以确定当您出现错误时是否会报告错误。</p></blockquote><h3 id="这个的工作原理是什么"><a href="#这个的工作原理是什么" class="headerlink" title="这个的工作原理是什么"></a>这个的工作原理是什么</h3><p>这两种工具具有不同行为的原因归结于其架构之间的区别。</p><h4 id="TypeScript体系结构：AST导向"><a href="#TypeScript体系结构：AST导向" class="headerlink" title="TypeScript体系结构：AST导向"></a>TypeScript体系结构：AST导向</h4><p>TypeScript将遍历您的程序并构建已知类型的表。当它发现值和表达式时，它会立即为其分配类型。当TypeScript发现一个未知的类型时，它必须立即作出决定，这意味着将其分配给<code>any</code>或抛出错误。</p><h4 id="Flow-架构：图形导向"><a href="#Flow-架构：图形导向" class="headerlink" title="Flow 架构：图形导向"></a>Flow 架构：图形导向</h4><p>Flow 将建立一个你所有的值和表达式及其彼此之间的关系的图表。然后，它将开始为每个值和表达式分配类型。如果它找到一个未知的类型，它将使它成为一个“开放”类型，稍后再回来判断。</p><p>一旦Flow具有您的程序的完整蓝图，它将开始连接所有点，从一个值连接到另一个值地跟踪类型。打开类型接受流入它们的所有值的类型 - 生成的类型称为 “推断类型”。</p><p>你可以看这个是怎么回事。来看看我们在之前的类型错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n;</div><div class="line">         ^   ^</div><div class="line">         <span class="built_in">Error</span> (x2)</div><div class="line">&#125;</div><div class="line">square(<span class="string">"oops"</span>);</div><div class="line"></div><div class="line"><span class="built_in">Error</span> (x2)</div><div class="line">string. The operand <span class="keyword">of</span> an arithmetic operation must be a number.</div></pre></td></tr></table></figure><p>注意错误是指向<code>n * n</code>而不是 <code>square(&quot;oops&quot;)</code>。因为我们没有写入一个类型为n的 “oops”字符串流入它，并且Flow开始检查n，就好像它是一个字符串。</p><p>添加类型注释我们可以看到错误点移动了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n: number</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n;</div><div class="line">&#125;</div><div class="line">square(<span class="string">"oops"</span>);</div><div class="line">       ^ <span class="built_in">Error</span></div><div class="line"></div><div class="line"><span class="built_in">Error</span>: string.</div><div class="line">This type is incompatible <span class="keyword">with</span> the expected param type <span class="keyword">of</span> number.</div></pre></td></tr></table></figure><p>这提出了一个重要的一点：Flow可以在任何地方自动推断类型并不意味着你不应该添加类型注释你的代码。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>TypeScript和Flow都有非常好的上手过程。一个个文件地尝试是一个很好的经历。</p><p>但是，如果使用Flow，你就会有更高以及更快的覆盖类型，你就可以安心睡觉。</p><p>使用Flow，您可以添加类型以使错误更友好，而不仅只是发现它们。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;采用Flow＆TypeScript, 两者上手流程之间的比较。&lt;/p&gt;&lt;p&gt;让我们想象一下我们想要采用一种类型检查器的场景…&lt;/p&gt;&lt;p&gt;本文译自： &lt;a href=&quot;http://thejameskyle.com/adopting-flow-and-typescript.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;adopting flow and typescript&lt;/a&gt;
    
    </summary>
    
      <category term="Flow" scheme="http://robin-front.github.io/categories/Flow/"/>
    
      <category term="TypeScript" scheme="http://robin-front.github.io/categories/Flow/TypeScript/"/>
    
    
      <category term="Flow" scheme="http://robin-front.github.io/tags/Flow/"/>
    
      <category term="TypeScript" scheme="http://robin-front.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>使用RXJS组合、过滤和映射数据流的值</title>
    <link href="http://robin-front.github.io/2017/06/05/%E4%BD%BF%E7%94%A8RXJS%E7%BB%84%E5%90%88%E3%80%81%E8%BF%87%E6%BB%A4%E5%92%8C%E6%98%A0%E5%B0%84%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E5%80%BC/"/>
    <id>http://robin-front.github.io/2017/06/05/使用RXJS组合、过滤和映射数据流的值/</id>
    <published>2017-06-05T08:24:16.000Z</published>
    <updated>2017-06-05T08:24:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查询可观测序列"><a href="#查询可观测序列" class="headerlink" title="查询可观测序列"></a>查询可观测序列</h1><p>在<a href="https://robin-front.github.io/RxJS-doc-chinese/content/getting_started_with_rxjs/creating_and_querying_observable_sequences/bridging_to_events.md">事件桥接</a> 一文中，我们将现有的DOM和Node.js事件转换成可观察的序列以订阅它们。在本主题中，我们将把可观察序列的父级class视为IObservable对象，其中Rx组件提供通用LINQ操作符来操作这些对象。大多数操作符获取可观察的序列并对其执行一些逻辑并输出另一个可观测序列。另外，从代码示例可以看出，甚至可以在源序列上使用多个运算符，最终将结果序列调整到您的确切需求。<a id="more"></a></p><p>本文翻译在： <a href="https://robin-front.github.io/RxJS-doc-chinese/content/getting_started_with_rxjs/creating_and_querying_observable_sequences/querying_observable_sequences.html">RXJS中文文档</a></p><h2 id="使用不同的运算符"><a href="#使用不同的运算符" class="headerlink" title="使用不同的运算符"></a>使用不同的运算符</h2><p>我们已经在以前的主题中使用<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservablecreatesubscribe" target="_blank" rel="external"><code>create</code></a>和<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservablerangestart-count-scheduler" target="_blank" rel="external"><code>range</code></a>运算符来创建和返回简单的序列。我们还使用<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservablefromeventelement-eventname" target="_blank" rel="external"><code>fromEvent</code></a>和<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservablefromeventpatternaddhandler-removehandler" target="_blank" rel="external"><code>fromEventPattern</code></a>运算符将现有事件转换成可观察的序列。在本主题中，我们将使用其他<code>Observable</code>类型的运算符，以便可以过滤，分组和转换数据。这些运算符将可观察到的序列作为输入，并生成输出另一个可观察序列。</p><h2 id="组合不同序列"><a href="#组合不同序列" class="headerlink" title="组合不同序列"></a>组合不同序列</h2><p>在本节中，我们会研究将各种可观察序列组合成单个可观察序列的操作符。请注意，当我们组合序列时，数据不会被转换。在以下示例中，我们使用Concat运算符将两个序列组合成一个序列并订阅它。为了说明的目的，我们将使用非常简单的<code>range(x, y)</code>运算符创建一个从x开始的整数序列，然后产生y个序列数字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> source1 = Rx.Observable.range(<span class="number">1</span>, <span class="number">3</span>);</div><div class="line"><span class="keyword">var</span> source2 = Rx.Observable.range(<span class="number">1</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line">source1.concat(source2)</div><div class="line">   .subscribe(<span class="built_in">console</span>.log.bind(<span class="built_in">console</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; 1</span></div><div class="line"><span class="comment">// =&gt; 2</span></div><div class="line"><span class="comment">// =&gt; 3</span></div><div class="line"><span class="comment">// =&gt; 1</span></div><div class="line"><span class="comment">// =&gt; 2</span></div><div class="line"><span class="comment">// =&gt; 3</span></div></pre></td></tr></table></figure><p>注意，结果序列是1,2,3,1,2,3。这是因为当您使用<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypeconcatargs" target="_blank" rel="external"><code>concat</code></a>运算符时，第二个序列（source2）将在第一个序列（source1）完成推送其所有值之后才会激活。只有在source1完成之后，source2才会将值推送到最后的序列。然后，订阅者将从得到的序列中获取所有值。</p><p>与<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypemergemaxconcurrent--other" target="_blank" rel="external"><code>merge</code></a> 操作符进行比较。如果运行以下示例代码，您将获得1,1,2,2,3,3。这是因为两个序列同时处于活动状态，并且值在数据源中发生时被推出。结果序列仅在最后一个数据源完成推送值时完成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> source1 = Rx.Observable.range(<span class="number">1</span>, <span class="number">3</span>);</div><div class="line"><span class="keyword">var</span> source2 = Rx.Observable.range(<span class="number">1</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line">source1.merge(source2)</div><div class="line">   .subscribe(<span class="built_in">console</span>.log.bind(<span class="built_in">console</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; 1</span></div><div class="line"><span class="comment">// =&gt; 1</span></div><div class="line"><span class="comment">// =&gt; 2</span></div><div class="line"><span class="comment">// =&gt; 2</span></div><div class="line"><span class="comment">// =&gt; 3</span></div><div class="line"><span class="comment">// =&gt; 3</span></div></pre></td></tr></table></figure><p><a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypecatchsecond--handler" target="_blank" rel="external"><code>catch</code></a> 操作符可以进行另一个比较。在这种情况下，如果source1完成没有任何错误，那么source2将不会启动。因此，如果运行以下示例代码，则获得1,2,3因为source2（产生4,5,6））被忽略。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> source1 = Rx.Observable.range(<span class="number">1</span>, <span class="number">3</span>);</div><div class="line"><span class="keyword">var</span> source2 = Rx.Observable.range(<span class="number">4</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line">source1.catch(source2)</div><div class="line">   .subscribe(<span class="built_in">console</span>.log.bind(<span class="built_in">console</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; 1</span></div><div class="line"><span class="comment">// =&gt; 2</span></div><div class="line"><span class="comment">// =&gt; 3</span></div></pre></td></tr></table></figure><p>最后，我们来看看<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypeonerrorresumenextsecond" target="_blank" rel="external"><code>onErrorResumeNext</code></a>。即使由于错误导致source1无法完成，该操作符也将移动到source2。在以下示例中，即使source1表示通过使用<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservablethrowexception-scheduler" target="_blank" rel="external"><code>throw</code></a>运算符终止异常的序列，用户将接收source2发布的值（1,2,3）。因此，如果您预期到任何一个源序列产生任何错误，那么使用它<code>onErrorResumeNext</code>来保证用户仍然会收到一些值是更安全的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> source1 = Rx.Observable.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'An error has occurred.'</span>));</div><div class="line"><span class="keyword">var</span> source2 = Rx.Observable.range(<span class="number">1</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line">source1.onErrorResumeNext(source2)</div><div class="line">   .subscribe(<span class="built_in">console</span>.log.bind(<span class="built_in">console</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; 1</span></div><div class="line"><span class="comment">// =&gt; 2</span></div><div class="line"><span class="comment">// =&gt; 3</span></div></pre></td></tr></table></figure><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p><a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypeselectselector-thisarg" target="_blank" rel="external"><code>select</code></a>或 <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypemapselector-thisarg" target="_blank" rel="external"><code>map</code></a> 操作符将可观察到的一个序列的每个元素转换成另一种形式。</p><p>在下面的示例中，我们将一系列字符串映射到一系列表示长度的整数中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> array = [<span class="string">'Reactive'</span>, <span class="string">'Extensions'</span>, <span class="string">'RxJS'</span>];</div><div class="line"></div><div class="line"><span class="keyword">var</span> seqString = Rx.Observable.from(array);</div><div class="line"></div><div class="line"><span class="keyword">var</span> seqNum = seqString.map(<span class="function"><span class="params">x</span> =&gt;</span> x.length);</div><div class="line"></div><div class="line">seqNum</div><div class="line">   .subscribe(<span class="built_in">console</span>.log.bind(<span class="built_in">console</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; 8</span></div><div class="line"><span class="comment">// =&gt; 10</span></div><div class="line"><span class="comment">// =&gt; 4</span></div></pre></td></tr></table></figure><p>在以下示例中，我们在“<a href="https://robin-front.github.io/RxJS-doc-chinese/content/getting_started_with_rxjs/creating_and_querying_observable_sequences/bridging_to_events.md">桥接现有事件</a>”主题中看到的事件转换示例的扩展，我们使用<code>select</code>或<code>map</code>运算符将事件参数投影到x和y点。这样，我们将鼠标移动事件序列转换为可以进一步解析和操作的数据类型，如下一个“过滤”部分所示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> move = Rx.Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'mousemove'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> points = move.map(<span class="function"><span class="params">e</span> =&gt;</span> (&#123;<span class="attr">x</span>: e.clientX, <span class="attr">y</span>: e.clientY &#125;));</div><div class="line"></div><div class="line">points.subscribe(</div><div class="line">	<span class="function"><span class="params">pos</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Mouse at point '</span> + pos.x + <span class="string">', '</span> + pos.y));</div></pre></td></tr></table></figure><p>最后，我们来看看<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypeselectmanyselector-resultselector" target="_blank" rel="external"><code>selectMany</code></a> or <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypeflatmapselector-resultselector" target="_blank" rel="external"><code>flatMap</code></a>运算符。<code>selectMany</code>或<code>flatMap</code>操作符具有许多重载，其中一个就是需要选择器函数作为参数。这个选择器函数是由数据源推出的每个值去调用的。对于每一个值，选择器将其映射成一个迷你的可观察序列。最后，<code>selectMany</code>或者<code>flatMap</code>操作符将所有这些迷你序列扁平化成单个结果序列，然后将其推送到用户。</p><p>在数据源和由选择器函数产生的所有迷你可观察序列都已经完成之后，源序列返回<code>selectMany</code>或<code>flatMap</code>发布的<code>onCompleted</code>。当发生源数据流中的错误时触发<code>onError</code>，当一个异常被选择函数抛出，或者当在任何迷你观察序列的发生了错误。</p><p>在下面的例子中，我们首先创建一个数据源序列，每5秒产生一个整数，并决定使用生成的前两个值（使用<code>take</code>运算符）。然后，我们使用<code>selectMany</code>或者<code>flatMap</code>对另一个序列{100,101,102}这些整数进行映射。通过这样做，产生两个迷你观察序列{100,101,102}和{100,101,102}。它们最终平坦化成{100,101,102,100,101,102}的单个整数流，并被推送到观察者。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> source1 = Rx.Observable.interval(<span class="number">5000</span>).take(<span class="number">2</span>);</div><div class="line"><span class="keyword">var</span> proj = Rx.Observable.range(<span class="number">100</span>, <span class="number">3</span>);</div><div class="line"><span class="keyword">var</span> resultSeq = source1.flatMap(proj);</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription = resultSeq.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onNext: %s'</span>, x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'onError: %s'</span>, e.message),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; onNext: 100</span></div><div class="line"><span class="comment">// =&gt; onNext: 101</span></div><div class="line"><span class="comment">// =&gt; onNext: 102</span></div><div class="line"><span class="comment">// =&gt; onNext: 100</span></div><div class="line"><span class="comment">// =&gt; onNext: 101</span></div><div class="line"><span class="comment">// =&gt; onNext: 102</span></div><div class="line"><span class="comment">// =&gt; onCompleted</span></div></pre></td></tr></table></figure><h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><p>在下面的例子中，我们使用<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservablegenerateinitialstate-condition-iterate-resultselector-scheduler" target="_blank" rel="external"><code>generate</code></a> 运算符创建一个简单的可观察数字序列。该<code>generate</code>操作符有几个版本，包括有相对和绝对时间调度。在我们的示例中，它需要初始状态（在我们的示例中为0），一个条件函数终止（少于10次），迭代器（+1），结果选择器（当前值的平方函数））和打印只使用小于5的那些使用<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypefilterpredicate-thisarg" target="_blank" rel="external"><code>filter</code></a>或<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypewherepredicate-thisarg" target="_blank" rel="external"><code>where</code></a>运算符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> seq = Rx.Observable.generate(</div><div class="line">	<span class="number">0</span>,</div><div class="line">	i =&gt; i &lt; <span class="number">10</span>,</div><div class="line">	i =&gt; i + <span class="number">1</span>,</div><div class="line">	i =&gt; i * i);</div><div class="line"></div><div class="line"><span class="keyword">var</span> source = seq.filter(<span class="function"><span class="params">n</span> =&gt;</span> n &lt; <span class="number">5</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription = source.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onNext: %s'</span>, x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'onError: %s'</span>, e.message),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'onCompleted'</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; onNext: 0</span></div><div class="line"><span class="comment">// =&gt; onNext: 1</span></div><div class="line"><span class="comment">// =&gt; onNext: 4</span></div><div class="line"><span class="comment">// =&gt; onCompleted</span></div></pre></td></tr></table></figure><p>以下示例是本主题前面已经看到的映射示例的扩展。在该示例中，我们使用<code>select</code>或<code>map</code>运算符将事件参数投影到具有x和y的点。在下面的例子中，我们使用<code>filter</code>或<code>where</code>和<code>select</code>或<code>map</code>操作符只挑选那些鼠标移动，我们感兴趣的是，在这种情况下，我们鼠标移动过滤，以找出在第一平分线（其中x和y坐标是相等的）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> move = Rx.Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'mousemove'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> points = move.map(<span class="function"><span class="params">e</span> =&gt;</span> (&#123; <span class="attr">x</span>: e.clientX, <span class="attr">y</span>: e.clientY &#125;));</div><div class="line"></div><div class="line"><span class="keyword">var</span> overfirstbisector = points.filter(<span class="function"><span class="params">pos</span> =&gt;</span> pos.x === pos.y);</div><div class="line"></div><div class="line"><span class="keyword">var</span> movesub = overfirstbisector.subscribe(<span class="function"><span class="params">pos</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'mouse at '</span> + pos.x + <span class="string">', '</span> pos.y));</div></pre></td></tr></table></figure><h2 id="基于时间的操作"><a href="#基于时间的操作" class="headerlink" title="基于时间的操作"></a>基于时间的操作</h2><p>您可以使用缓冲区运算符执行基于时间的操作。</p><p>缓冲可观察序列意味着可观测序列的值基于指定的时间段或计数阈值被放入缓冲区。这在您预期有大量数据被序列推出的情况下特别有用，并且订阅者没有资源来处理这些值。通过基于时间或计数缓冲结果，并且只有在超过条件时才返回值序列（或者源序列完成时），用户可以按照自己的速度处理<code>OnNext</code>调用。</p><p>在下面的例子中，我们首先创建一个以每秒为时间单位的简单的整数序列。然后我们使用<code>bufferWithCount</code>运算符，并指定每个缓冲区将保存序列中的5个项目。在<code>onNext</code>当缓冲区已满被调用。然后我们使用缓冲区的总和<code>Array.reduce</code>。缓冲区自动刷新，另一个循环开始。打印输出将为10,35,60 …，其中10 = 0 + 1 + 2 + 3 + 4,35 = 5 + 6 + 7 + 8 + 9等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> seq = Rx.Observable.interval(<span class="number">1000</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> bufSeq = seq.bufferWithCount(<span class="number">5</span>);</div><div class="line"></div><div class="line">bufSeq</div><div class="line">	.map(<span class="function"><span class="params">arr</span> =&gt;</span> arr.reduce(<span class="function">(<span class="params">acc, x</span>) =&gt;</span> acc + x, <span class="number">0</span>))</div><div class="line">	.subscribe(<span class="built_in">console</span>.log.bind(<span class="built_in">console</span>));</div><div class="line"></div><div class="line"><span class="comment">// =&gt; 10</span></div><div class="line"><span class="comment">// =&gt; 35</span></div><div class="line"><span class="comment">// =&gt; 60</span></div><div class="line">...</div></pre></td></tr></table></figure><p>我们还可以创建一个指定时间跨度（以毫秒为单位）的缓冲区。在以下示例中，缓冲区将保存累积3秒钟的项目。打印输出将为3,12,21 …其中3 = 0 + 1 + 2,12 = 3 + 4 + 5，依此类推。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> seq = Rx.Observable.interval(<span class="number">1000</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> bufSeq = seq.bufferWithTime(<span class="number">3000</span>);</div><div class="line"></div><div class="line">bufSeq</div><div class="line">	.map(<span class="function"><span class="params">arr</span> =&gt;</span> arr.reduce(<span class="function">(<span class="params">acc, x</span>) =&gt;</span> acc + x, <span class="number">0</span>))</div><div class="line">	.subscribe(<span class="built_in">console</span>.log.bind(<span class="built_in">console</span>));</div></pre></td></tr></table></figure><p>请注意，如果您使用任何一个<code>buffer*</code>或<code>window*</code>运算符，则必须确保序列不为空，然后再过滤。</p><h2 id="按类别操作"><a href="#按类别操作" class="headerlink" title="按类别操作"></a>按类别操作</h2><p>按<a href="https://robin-front.github.io/RxJS-doc-chinese/content/getting_started_with_rxjs/creating_and_querying_observable_sequences/operators_by_category.md">类别划分的操作符</a>主题列出了按类别实施的<code>Observable</code>的所有主要操作符; 具体来说：创建，转换，合并，功能，数学，时间，异常，杂项，选择和原值。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;查询可观测序列&quot;&gt;&lt;a href=&quot;#查询可观测序列&quot; class=&quot;headerlink&quot; title=&quot;查询可观测序列&quot;&gt;&lt;/a&gt;查询可观测序列&lt;/h1&gt;&lt;p&gt;在&lt;a href=&quot;https://robin-front.github.io/RxJS-doc-chinese/content/getting_started_with_rxjs/creating_and_querying_observable_sequences/bridging_to_events.md&quot;&gt;事件桥接&lt;/a&gt; 一文中，我们将现有的DOM和Node.js事件转换成可观察的序列以订阅它们。在本主题中，我们将把可观察序列的父级class视为IObservable对象，其中Rx组件提供通用LINQ操作符来操作这些对象。大多数操作符获取可观察的序列并对其执行一些逻辑并输出另一个可观测序列。另外，从代码示例可以看出，甚至可以在源序列上使用多个运算符，最终将结果序列调整到您的确切需求。
    
    </summary>
    
      <category term="RXJS" scheme="http://robin-front.github.io/categories/RXJS/"/>
    
    
      <category term="RXJS" scheme="http://robin-front.github.io/tags/RXJS/"/>
    
  </entry>
  
  <entry>
    <title>如何调试Node.js|使用谷歌chrome浏览器调试Node.js</title>
    <link href="http://robin-front.github.io/2017/06/02/%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95Node-js%E4%BD%BF%E7%94%A8%E8%B0%B7%E6%AD%8Cchrome%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95Node-js/"/>
    <id>http://robin-front.github.io/2017/06/02/如何调试Node-js使用谷歌chrome浏览器调试Node-js/</id>
    <published>2017-06-02T09:46:03.000Z</published>
    <updated>2017-06-02T09:46:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>如何调试 Node.js, 还在使用 console.log 来调试 Node.js 吗，可以像调试前端页面一样调试 Node.js!<a id="more"></a></p><p>译文：<a href="https://medium.com/the-node-js-collection/debugging-node-js-with-google-chrome-4965b5f910f4" target="_blank" rel="external">Debugging Node.js with Google Chrome</a></p><p>调试是从软件应用程序中识别和删除错误的任务，而不仅仅是打印代码中的值。本文介绍如何使用最新的Google Chrome DevTools高效地调试Node.js程序。</p><h2 id="为什么console-log不是最好的选择？"><a href="#为什么console-log不是最好的选择？" class="headerlink" title="为什么console.log不是最好的选择？"></a>为什么console.log不是最好的选择？</h2><p>使用<code>console.log</code>来调试你的代码，通常你会无限重复地做 “停止你的应用程序，添加一个console.log，并再次启动你的应用程序” 这样的操作。除了减缓您的应用程序的开发外，它还使您的书写变得脏乱并创建不必要的代码。最后，尝试注销变量以及其他可能的日志记录操作的噪点时，可能会在尝试找到正在调试的值时使调试变得困难。</p><h2 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h2><p>调试工具为用户提供的是几个重要的功能<code>console.log</code>无法提供。特别是，它们允许您在代码中的特定点暂停执行应用程序，并在程序仍在运行时检查和修改变量的值。</p><h2 id="设置Chrome-for-Node-js调试"><a href="#设置Chrome-for-Node-js调试" class="headerlink" title="设置Chrome for Node.js调试"></a>设置Chrome for Node.js调试</h2><p>使用<code>Chrome 57+</code>，<code>Node.js</code>调试功能是默认启用的，不需要像以前的版本那样从“实验功能”面板手动启用它。</p><p>如果您还没有完成，请将Google Chrome更新到最新版本，并确保使用<code>Node.js 6.4+</code>。</p><p>要开始调试，请使用 <code>- inspect</code>标志运行<code>Node.js</code>应用程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ node --inspect &lt;your_file&gt; .js</div></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/800/1*NIVrIoEiniOt6cP-d-0LFQ.png" alt="在调试模式下运行Node.js应用程序"></p><p>接下来，忽略从终端中显示的“<code>chrome-devtools://</code>”开头的URL ，而是在Google Chrome中打开“ <code>about:inspect</code> ”。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*QAmWRyPtdfF5X7VuvDN1zg.png" alt="chrome DevTools"></p><p>最后点击“ Open dedicated DevTools for Node” 开始调试应用程序的代码。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*zQ1uLl_qiRIAJ7Lxw_LFAQ.png" alt="deloper tools for Node"></p><p>此外，关于调试<a href="https://nodejs.org/en/docs/guides/debugging-getting-started/" target="_blank" rel="external">Node.js App</a>的官方文档还提供了所有其他检查器工具和客户端选项的详细列表。</p><h2 id="Chrome-DevTools的应用"><a href="#Chrome-DevTools的应用" class="headerlink" title="Chrome DevTools的应用"></a>Chrome DevTools的应用</h2><p>要结束本文，我想说明一下<code>Chrome DevTools</code>在以下<code>Express</code>应用程序中的应用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</div><div class="line"><span class="keyword">const</span> app = express()</div><div class="line"></div><div class="line"><span class="keyword">const</span> PORT = process.env.PORT || <span class="number">3000</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">capitalize</span> (<span class="params">str</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> firstLetter = str.charAt(<span class="number">0</span>) <span class="comment">// we can check what's inside here</span></div><div class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;firstLetter.toUpperCase()&#125;</span><span class="subst">$&#123;str.slice(<span class="number">1</span>)&#125;</span>`</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">app.get(<span class="string">'/:name?'</span>, (req, res) =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> name = req.params.name ? capitalize(req.params.name) : <span class="string">'World'</span></div><div class="line">  res.send(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>!`</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">app.listen(PORT, () =&gt; <span class="built_in">console</span>.log(<span class="string">`App listening on *:<span class="subst">$&#123;PORT&#125;</span>`</span>))</div></pre></td></tr></table></figure><p>让我们从运行<code>- inspect</code>标志，并打开专用<code>DevTools for Node</code>如前所述。</p><p>此时，您将可以访问您可能已经熟悉的所有功能：断点(<code>breakpoints</code>)，压缩代码的源映射(<code>source map for transpiled code</code>)，堆快照检查(<code>heap snapshot inspection</code>)，分配分析(<code>allocation profiling</code>)，JavaScript值热插拔(<code>JavaScript values hot-swapping</code>)等。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*jTzAaK_zRNynCMvlDbx2rA.png" alt="使用断点来调试Express应用程序"></p><p>具体来说，如下图所示，您可以插入断点来停止执行程序，检查和“热交换”变量的值。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*URHvZNuF7RksLoDZRbYnpQ.png" alt="JavaScript值热拔插"></p><p><img src="https://cdn-images-1.medium.com/max/800/1*mk2Ro3VX6iAw7YLWJzlmtw.png" alt="JavaScript值热拔插2"></p><p>使用Chrome作为调试工具的另外一件好事是您可以使用相同的界面🚀调试前端和后端JavaScript代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何调试 Node.js, 还在使用 console.log 来调试 Node.js 吗，可以像调试前端页面一样调试 Node.js!
    
    </summary>
    
      <category term="Node.js" scheme="http://robin-front.github.io/categories/Node-js/"/>
    
    
      <category term="debug" scheme="http://robin-front.github.io/tags/debug/"/>
    
      <category term="Node.js" scheme="http://robin-front.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>RXJS我该选用哪个操作符之-创建篇</title>
    <link href="http://robin-front.github.io/2017/06/01/RXJS%E6%88%91%E8%AF%A5%E9%80%89%E7%94%A8%E5%93%AA%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8B-%E5%88%9B%E5%BB%BA%E7%AF%87/"/>
    <id>http://robin-front.github.io/2017/06/01/RXJS我该选用哪个操作符之-创建篇/</id>
    <published>2017-06-01T10:16:43.000Z</published>
    <updated>2017-06-01T10:16:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>RXJS该怎么上手？这么多操作符该用哪个？RXJS比较强大，操作符众多，想熟悉需要比较长时间的运用，所以大部分新手都比较疑惑应该使用哪些操作符去实现自己的数据流的操作。</p><p>更多详情请翻阅 <a href="https://robin-front.github.io/RxJS-doc-chinese">RXJS中文翻译文档</a></p><h1 id="我该选用哪个操作符-创建操作符"><a href="#我该选用哪个操作符-创建操作符" class="headerlink" title="我该选用哪个操作符? - 创建操作符"></a>我该选用哪个操作符? - 创建操作符</h1><p>使用此页面查找<a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/index.html"><code>Observable</code></a>符合您需求的类型创建操作：<a id="more"></a></p><table style="display:table"><thead>静态方法</thead><tbody><tr><td rowspan="26">我想创建一个新的序列</td><td rowspan="4">使用自定义逻辑</td><td colspan="2"></td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/create.html">Observable.create</a></td></tr><tr><td rowspan="3">像一个for循环</td><td></td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/generate.html">Observable.generate</a></td></tr><tr><td rowspan="2">并随时间发射值</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/generatewithrelativetime.html">Observable.generateWithRelativeTime</a></td></tr><tr><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/generatewithabsolutetime.html">Observable.generateWithAbsoluteTime</a></td></tr><tr><td rowspan="2">它返回一个值</td><td colspan="2"></td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/return.html">Observable.return/just</a></td></tr><tr><td colspan="2">多次</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/repeat.html">Observable.repeat</a></td></tr><tr><td colspan="3">这会抛出错误</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/throw.html">Observable.throw</a></td></tr><tr><td colspan="3">完成了</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/empty.html">Observable.empty</a></td></tr><tr><td colspan="3">从来没有做任何事情</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/never.html">Observable.never</a></td></tr><tr><td rowspan="2">从事件</td><td colspan="2"></td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/fromevent.html">Observable.fromEvent</a></td></tr><tr><td colspan="2">它使用自定义函数来添加和删除事件处理程序</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/fromeventpattern.html">Observable.fromEventPattern</a></td></tr><tr><td colspan="3">来自一个<a title="ES6 Promise" href="https://www.promisejs.org" target="_blank" rel="external">ES6 Promise</a></td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/frompromise.html">Observable.fromPromise</a></td></tr><tr><td rowspan="6">它可迭代</td><td rowspan="2">覆盖到数组中的值</td><td></td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/fromarray.html">Observable.fromArray</a><br></td></tr><tr><td>对象键/值对</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/pairs.html">Observable.pairs</a></td></tr><tr><td colspan="2">异步元素</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/for.html">Observable.for</a></td></tr><tr><td colspan="2">数值范围内的值</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/range.html">Observable.range</a></td></tr><tr><td colspan="2">来自一个可迭代的数组或类似数组的对象的值</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/from.html">Observable.from</a></td></tr><tr><td colspan="2">来自参数</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/of.html">Observable.of</a></td></tr><tr><td rowspan="2">根据定时器发出值</td><td colspan="2"></td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/interval.html">Observable.interval</a></td></tr><tr><td colspan="2">具有可选的初始延迟</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/timer.html">Observable.timer</a></td></tr><tr><td rowspan="2" colspan="2">不传参调用函数</td><td>在特定的调度程序</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/start.html">Observable.start</a></td></tr><tr><td>异步</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/startasync.html">Observable.startAsync</a></td></tr><tr><td rowspan="4">取决于订阅时</td><td colspan="2">基于布尔条件</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/if.html">Observable.if</a></td></tr><tr><td colspan="2">f从一组预先设定的序列</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/case.html">Observable.case</a></td></tr><tr><td colspan="1" rowspan="2">使用自定义逻辑</td><td></td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/defer.html">Observable.defer</a></td></tr><tr><td>它取决于资源</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/using.html">Observable.using</a></td></tr><tr><td rowspan="3">我想包装一个函数</td><td colspan="2"></td><td rowspan="3">并产生一个序列的结果</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/toasync.html">Observable.toAsync</a></td></tr><td colspan="2">它接受回调</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/fromcallback.html">Observable.fromCallback</a></td><tr><td colspan="2">它接受Node.js回调</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/fromnodecallback.html">Observable.fromNodeCallback</a></td></tr><tr><td rowspan="30">我想结合多个序列</td><td colspan="3">并且仅从产生值的序列中接收值</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/amb.html">Observable.amb</a></td></tr><tr><td colspan="3">所有人都已经完成通知</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/forkjoin.html">Observable.forkJoin</a></td></tr><tr><td colspan="3">并输出所有这些值</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/merge.html">Observable.merge</a></td></tr><tr><td rowspan="2">为了</td><td colspan="2">不改变时重复使用最新值</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/operators/combinelatest.html">Observable.combineLatest</a></td></tr><tr><td colspan="2">每个值只使用一次</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/zip.html">Observable.zip</a></td></tr><tr><td rowspan="3">通过订阅每个序列为了</td><td colspan="2">当前一个序列完成时</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/concat.html">Observable.concat</a></td></tr><tr><td colspan="2">当另一个序列抛出错误时</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/catch.html">Observable.catch</a></td></tr><tr><td colspan="2">不管先前的序列是完成还是抛出错误</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/onerrorresumenext.html">Observable.onErrorResumeNext</a></td></tr><tr><td colspan="3">通过响应不同的值组合<a href="http://en.wikipedia.org/wiki/Join-calculus" target="_blank" rel="external">（连接微积分）</a></td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/when.html">Observable.when</a></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RXJS该怎么上手？这么多操作符该用哪个？RXJS比较强大，操作符众多，想熟悉需要比较长时间的运用，所以大部分新手都比较疑惑应该使用哪些操作符去实现自己的数据流的操作。&lt;/p&gt;&lt;p&gt;更多详情请翻阅 &lt;a href=&quot;https://robin-front.github.io/RxJS-doc-chinese&quot;&gt;RXJS中文翻译文档&lt;/a&gt;&lt;/p&gt;&lt;h1 id=&quot;我该选用哪个操作符-创建操作符&quot;&gt;&lt;a href=&quot;#我该选用哪个操作符-创建操作符&quot; class=&quot;headerlink&quot; title=&quot;我该选用哪个操作符? - 创建操作符&quot;&gt;&lt;/a&gt;我该选用哪个操作符? - 创建操作符&lt;/h1&gt;&lt;p&gt;使用此页面查找&lt;a href=&quot;https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/index.html&quot;&gt;&lt;code&gt;Observable&lt;/code&gt;&lt;/a&gt;符合您需求的类型创建操作：
    
    </summary>
    
      <category term="RXJS" scheme="http://robin-front.github.io/categories/RXJS/"/>
    
    
      <category term="RXJS" scheme="http://robin-front.github.io/tags/RXJS/"/>
    
  </entry>
  
  <entry>
    <title>RXJS我该选用哪个操作符之-实例操作符篇</title>
    <link href="http://robin-front.github.io/2017/06/01/RXJS%E6%88%91%E8%AF%A5%E9%80%89%E7%94%A8%E5%93%AA%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8B-%E5%AE%9E%E4%BE%8B%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%AF%87/"/>
    <id>http://robin-front.github.io/2017/06/01/RXJS我该选用哪个操作符之-实例操作符篇/</id>
    <published>2017-06-01T09:54:53.000Z</published>
    <updated>2017-06-01T09:54:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>RXJS比较强大，操作符众多，想熟悉需要比较长时间的运用，所以大部分新手都比较疑惑应该使用哪些操作符去实现自己的数据流的操作。</p><p>更多详情请翻阅 <a href="https://robin-front.github.io/RxJS-doc-chinese">RXJS中文翻译文档</a></p><h1 id="我该选用哪个操作符-实例操作符"><a href="#我该选用哪个操作符-实例操作符" class="headerlink" title="我该选用哪个操作符? - 实例操作符"></a>我该选用哪个操作符? - 实例操作符</h1><p>使用此页面通过类型查找<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md" target="_blank" rel="external"><code>Observable</code></a> 适合您需要的实例运算符：<a id="more"></a></p><table style="display:table"><thead>实例操作符</thead><tbody><tr><td rowspan="71">使用现有的序列</td><td colspan="3">我想改变每个值</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/select.html">map/select</a></td></tr><tr><td colspan="3">我想从每个值拉一个属性</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/pluck.html">pluck</a></td></tr><tr><td colspan="3">我想在不影响值的情况下被通知值</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/do.html">do/tap</a><br><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/doonnext.html">doOnNext/tapOnNext</a><br><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/doonerror.html">doOnError/tapOnError</a><br><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/dooncompleted.html">doOnCompleted/tapOnCompleted</a></td></tr><tr><td rowspan="6">我想包含值</td><td colspan="2">基于自定义逻辑</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/where.html">filter/where</a></td></tr><tr><td rowspan="2">从序列开头</td><td></td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/take.html">take</a></td></tr><tr><td>基于自定义逻辑</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/takewhile.html">takeWhile</a></td></tr><tr></tr><tr><td colspan="2">从序列的末尾</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/takelast.html">takeLast</a></td></tr><tr><td colspan="2">直到另一个序列发射一个值或完成</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/takeuntil.html">takeUntil</a></td></tr><tr><td rowspan="7">我想忽略值</td><td colspan="2">全部</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/ignoreelements.html">ignoreElements</a></td></tr><tr><td rowspan="2">从序列的开头</td><td></td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/skip.html">skip</a></td></tr><tr><td>基于自定义逻辑</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/skipwhile.html">skipWhile</a></td></tr><tr><td colspan="2">从序列的末尾</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/skiplast.html">skipLast</a></td></tr><tr><td colspan="2">直到另一个序列发出一个值</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/skipuntil.html">skipUntil</a></td></tr><tr><td colspan="2">与以前的值相同</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/distinctuntilchanged.html">distinctUntilChanged</a></td></tr><tr><td colspan="2">这（触发）太频繁</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/throttle.html">throttle</a></td></tr><tr><td rowspan="4">我想计算</td><td>总和</td><td rowspan="2">这些值的</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/sum.html">sum</a></td></tr><tr><td>平均值</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/average.html">average</a></td></tr><tr><td rowspan="2">使用自定义逻辑</td><td>并且只输出最终值</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/aggregate.html">aggregate</a><br><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/reduce.html">reduce</a></td></tr><tr><td>并在计算出值时输出（每一步的）值</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/scan.html">scan</a></td></tr><tr><td rowspan="3">我想用元数据包装它的消息</td><td colspan="2">描述每个消息</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/materialize.html">materialize</a></td></tr><tr><td colspan="2">包括从最后一个价值以来的时间</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/timeinterval.html">timeInterval</a></td></tr><tr><td colspan="2">包括时间戳</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/timestamp.html">timestamp</a></td></tr><tr><td rowspan="2">经过一段时间的不活动</td><td colspan="2">我想抛出一个错误</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/timeout.html">timeout</a></td></tr><tr><td colspan="2">我想切换到另一个序列</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/timeout.html">timeout</a></td></tr><tr><td rowspan="2">我想确保只有一个值</td><td colspan="2">并且如果存在多于或少于一个值则抛出错误</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/single.html">single</a></td></tr><tr><td colspan="2">并且如果没有值，则使用默认值</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/singleordefault.html">singleOrDefault</a></td></tr><tr><td rowspan="3">我只想取第一个值</td><td colspan="2">并且如果没有值，则抛出错误</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/first.html">first</a></td></tr><tr><td colspan="2">并且如果没有值，则使用默认值</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/firstordefault.html">firstOrDefault</a></td></tr><tr><td colspan="2">在一段时间内</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/sample.html">sample</a></td></tr><tr><td rowspan="2">我只想取最后的值</td><td colspan="2">如果没有值，则报错</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/last.html">last</a></td></tr><tr><td colspan="2">并且如果没有值，则使用默认值</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/lastordefault.html">lastOrDefault</a></td></tr><tr><td colspan="3">我想知道它包含多少值</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/count.html">count</a></td></tr><tr><td colspan="3">我想知道它是否包含一个指定的值</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/includes.html">contains</a></td></tr><tr><td rowspan="2">我想知道条件是否满足</td><td colspan="2">只需要任一值满足</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/any.html">any/some</a></td></tr><tr><td colspan="2">需要所有值都满足</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/every.html">all/every</a></td></tr><tr><td rowspan="2" colspan="2">我想把消息延迟一段特定的时间</td><td></td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/delay.html">delay</a></td></tr><tr><td>基于自定义逻辑</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/delaywithselector.html">delayWithSelector</a></td></tr><tr><td rowspan="11">我想给值分组</td><td colspan="2">直到序列完成</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/toarray.html">toArray</a><br><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/tomap.html">toMap</a><br><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/toset.html">toSet</a></td></tr><tr><td rowspan="2">使用自定义逻辑</td><td>作为数组</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/buffer.html">buffer</a></td></tr><tr><td>作为序列</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/window.html">window</a></td></tr><tr><td rowspan="2">根据特定大小分批</td><td>作为数组</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/bufferwithcount.html">bufferWithCount</a></td></tr><tr><td>作为序列</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/windowwithcount.html">windowWithCount</a></td></tr><tr><td rowspan="2">基于时间</td><td>作为数组</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/bufferwithtime.html">bufferWithTime</a></td></tr><tr><td>作为序列</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/windowwithtime.html">windowWithTime</a></td></tr><tr><td rowspan="2">基于时间或计数，以先发生者为准</td><td>作为数组</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/bufferwithtimeorcount.html">bufferWithTimeOrCount</a></td></tr><tr><td>作为序列</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/windowwithtimeorcount.html">windowWithTimeOrCount</a></td></tr><tr><td rowspan="2">基于一个指定的key</td><td>直到序列完成</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/groupby.html">groupBy</a></td></tr><tr><td>并控制每组的生命周期</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/groupbyuntil.html">groupByUntil</a></td></tr><tr><td rowspan="6">我想为每个值开始一个新的序列</td><td colspan="2">并且并行地从所有序列中发出值</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/selectmany.html">flatMap/selectMany</a></td></tr><tr><td colspan="2">并按顺序从每个序列中输出值</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/concatmap.html">concatMap/selectConcat</a></td></tr><tr><td colspan="2">并在新值到达时取消先前的序列</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/flatmaplatest.html">flatMapLatest/selectSwitch</a></td></tr><tr><td colspan="2">并递归地为每个新值启动一个新的序列</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/expand.html">expand</a></td></tr><tr><td colspan="2">并根据onNext，onError和onCompleted并行地从所有序列发出值</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/flatmapobserver.html">flatMapObserver/selectManyObserver</a></td></tr><tr><td colspan="2">并根据onNext，onError和onCompleted顺序地从所有序列发出值</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/flatmapobserver.html">concatMapObserver/selectConcatObserver</a></td></tr><tr><td>我想把它与另一个结合起来</td><td colspan="2">两者都完成时发出通知</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/forkjoin.html">forkJoin</a></td></tr><tr><td colspan="3">我想执行复杂的操作，而不会打破流畅的调用</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/let.html">let</a></td></tr><tr><td rowspan="5">我想在多个订阅者之间共享订阅</td><td colspan="2">使用特定的<code>subject</code>实现</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/multicast.html">multicast</a></td></tr><tr><td colspan="2"></td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/publish.html">publish</a><br><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/share.html">share</a></td></tr><tr><td colspan="2">并向未来订阅者提供最后的值</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/publishlast.html">publishLast</a><br><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/sharelast.html">shareLast</a></td></tr><tr><td colspan="2">并向未来订阅者重播默认值或最新值</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/publishvalue.html">publishValue</a><br><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/sharevalue.html">shareValue</a></td></tr><tr><td colspan="2">并向未来的订阅者重播n个值</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/publish.html">replay</a><br><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/share.html">shareReplay</a></td></tr><tr><td rowspan="3">发生错误时</td><td colspan="2">我想重新订阅</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/retry.html">retry</a></td></tr><tr><td rowspan="2">我想开始一个新序列</td><td></td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/catch.html">catch</a></td></tr><tr><td>取决于错误</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/catch.html">catch</a></td></tr><tr><td rowspan="2">当完成时</td><td colspan="2">我想重新订阅</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/repeat.html">repeat</a></td></tr><tr><td colspan="2">我想开始一个新序列</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/concat.html">concat</a></td></tr><tr><td>当完成或抛出错误时</td><td colspan="2">我想开始一个新序列</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/onerrorresumenext.html">onErrorResumeNext</a></td></tr><tr><td>当完成，抛出错误或退订时</td><td colspan="2">我想执行一个函数</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/finally.html">finally</a></td></tr><tr><td rowspan="2">我想改变路由的调度程序</td><td colspan="2">调用<code>subscribe</code>（订阅）</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/subscribeon.html">subscribeOn</a></td></tr><tr><td colspan="2">消息</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/observeon.html">observeOn</a></td></tr><tr><td rowspan="9">使用两个序列</td><td>我想决定从哪个接收值</td><td colspan="2">取决于哪个序列先发出值</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/amb.html">amb</a></td></tr><tr><td colspan="3">我想确定它们的值是否相等</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/sequenceequal.html">sequenceEqual</a></td></tr><tr><td rowspan="5">我想合并它们的值</td><td colspan="2">只有当第一个序列发射时，使用每个序列的最新值</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/withlatestfrom.html">withLatestFrom</a></td></tr><tr><td rowspan="2">为了</td><td>不改变时重复使用最新值</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/combinelatest.html">combineLatest</a></td></tr><tr><td>每个值只使用一次</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/zip.html">zip</a></td></tr><tr><td rowspan="2">重复分享我选择的“生命周期”</td><td>并通知每个组合</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/join.html">join</a></td></tr><tr><td>并给每个“左”的序列的值给“右”的序列</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/groupjoin.html">groupJoin</a></td></tr><tr><td colspan="3">我想包含两者的值</td><td><a href="https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_instance_methods/merge.html">merge</a></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RXJS比较强大，操作符众多，想熟悉需要比较长时间的运用，所以大部分新手都比较疑惑应该使用哪些操作符去实现自己的数据流的操作。&lt;/p&gt;&lt;p&gt;更多详情请翻阅 &lt;a href=&quot;https://robin-front.github.io/RxJS-doc-chinese&quot;&gt;RXJS中文翻译文档&lt;/a&gt;&lt;/p&gt;&lt;h1 id=&quot;我该选用哪个操作符-实例操作符&quot;&gt;&lt;a href=&quot;#我该选用哪个操作符-实例操作符&quot; class=&quot;headerlink&quot; title=&quot;我该选用哪个操作符? - 实例操作符&quot;&gt;&lt;/a&gt;我该选用哪个操作符? - 实例操作符&lt;/h1&gt;&lt;p&gt;使用此页面通过类型查找&lt;a href=&quot;https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;Observable&lt;/code&gt;&lt;/a&gt; 适合您需要的实例运算符：
    
    </summary>
    
      <category term="RXJS" scheme="http://robin-front.github.io/categories/RXJS/"/>
    
    
      <category term="RXJS" scheme="http://robin-front.github.io/tags/RXJS/"/>
    
  </entry>
  
</feed>
