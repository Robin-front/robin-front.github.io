<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>三寸稚笔</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://robin-front.github.io/"/>
  <updated>2017-09-21T02:23:04.000Z</updated>
  <id>http://robin-front.github.io/</id>
  
  <author>
    <name>robin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IphoneX 的缺口（小刘海）及其css样式解决方案</title>
    <link href="http://robin-front.github.io/2017/09/21/the-notch-and-css/"/>
    <id>http://robin-front.github.io/2017/09/21/the-notch-and-css/</id>
    <published>2017-09-21T02:23:04.000Z</published>
    <updated>2017-09-21T02:23:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IphoneX-的缺口（小刘海）及其css样式解决方案"><a href="#IphoneX-的缺口（小刘海）及其css样式解决方案" class="headerlink" title="IphoneX 的缺口（小刘海）及其css样式解决方案"></a>IphoneX 的缺口（小刘海）及其css样式解决方案</h1><p>苹果公司的 IphoneX 拥有了全面屏，只保留了‘小刘海’给摄像头和一些传感设备。结果就是让屏幕设计陷入尴尬的境地，就像限制网页有一个“安全区域”和白色边缘条。虽然没有太多的黑魔法去消除它，但给 <code>body</code> 设置一个 <code>background-color</code> 属性也可以做到。或者扩展网页以覆盖整个屏幕（该死的缺口），可以给 viewport 的 meta 标签添加 <code>viewport-fit=cover</code>。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1000,f_auto,q_auto/v1505590717/iphonex-safari_njxeiw.png" data-original="https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1000,f_auto,q_auto/v1505590717/iphonex-safari_njxeiw.png"><a id="more"></a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, viewport-fit=cover"</span>&gt;</span></div></pre></td></tr></table></figure><p>然后，由你自己决定如何处理安全区域的重叠。这里有一些新的 css 可以帮助适配它。<a href="http://stephenradford.me/removing-the-white-bars-in-safari-on-iphone-x/" target="_blank" rel="external">Stephen Radford documents</a></p><blockquote><p>为了适配缺口，可以引入 ios 11 版本包含的一些常量，这些常量需要使用了 <code>viewport-fit=cover</code> 才会生效。</p><ul><li>safe-area-inset-top</li><li>safe-area-inset-right</li><li>safe-area-inset-left</li><li>safe-area-inset-bottom</li></ul><p>这些常量可以被用在 <code>margin</code>, <code>padding</code>, 或者绝对定位的 <code>top</code>, <code>left</code> 等属性上。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">padding</span>: <span class="selector-tag">constant</span>(<span class="selector-tag">safe-area-inset-top</span>) <span class="selector-tag">constant</span>(<span class="selector-tag">safe-area-inset-right</span>) <span class="selector-tag">constant</span>(<span class="selector-tag">safe-area-inset-bottom</span>) <span class="selector-tag">constant</span>(<span class="selector-tag">safe-area-inset-left</span>);</div></pre></td></tr></table></figure></blockquote><p>还有另外一个尴尬的局面关于缺口，安全区域和 fixed 定位。<a href="https://ayogo.com/blog/ios11-viewport/" target="_blank" rel="external">Darryl Pogue reports:</a></p><blockquote><p>ios 11与早期的版本不太一样，它现在遵守安全区域这一规则。这意味着，如果你有一个 header bar， 并且设置 <code>position: fixed;top: 0;</code>，它初始化时会渲染在顶部的 <code>20px</code> 下面：对齐顶部状态栏的底部。当你向下浏览网页，它会隐藏状态栏。如果向上滚动，状态栏又来跑出来（留下尴尬的20px间隙）。</p><video src="https://cdn.css-tricks.com/wp-content/uploads/2017/09/ios11-viewport.mp4" controls name="fitvid0"></video></blockquote><p>幸运的是这也很容易解决。只需要添加 <code>viewport-fit=cover</code> 到 <code>meta viewport</code> 标签上。</p><p>如果覆盖了全屏幕，那可能需要耍点小聪明去避免挡住内容。</p><p></p><blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">I think I’ve fixed the notch issue in landscape 🍾 <a href="https://twitter.com/hashtag/iphoneX?src=hash" target="_blank" rel="external">#iphoneX</a> <a href="https://t.co/hGytyO3DRV" target="_blank" rel="external">pic.twitter.com/hGytyO3DRV</a></p>&mdash; Vojta Stavik (@vojtastavik) <a href="https://twitter.com/vojtastavik/status/907911237983449088" target="_blank" rel="external">September 13, 2017</a></blockquote><p></p><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IphoneX-的缺口（小刘海）及其css样式解决方案&quot;&gt;&lt;a href=&quot;#IphoneX-的缺口（小刘海）及其css样式解决方案&quot; class=&quot;headerlink&quot; title=&quot;IphoneX 的缺口（小刘海）及其css样式解决方案&quot;&gt;&lt;/a&gt;IphoneX 的缺口（小刘海）及其css样式解决方案&lt;/h1&gt;&lt;p&gt;苹果公司的 IphoneX 拥有了全面屏，只保留了‘小刘海’给摄像头和一些传感设备。结果就是让屏幕设计陷入尴尬的境地，就像限制网页有一个“安全区域”和白色边缘条。虽然没有太多的黑魔法去消除它，但给 &lt;code&gt;body&lt;/code&gt; 设置一个 &lt;code&gt;background-color&lt;/code&gt; 属性也可以做到。或者扩展网页以覆盖整个屏幕（该死的缺口），可以给 viewport 的 meta 标签添加 &lt;code&gt;viewport-fit=cover&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1000,f_auto,q_auto/v1505590717/iphonex-safari_njxeiw.png&quot; alt=&quot;https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1000,f_auto,q_auto/v1505590717/iphonex-safari_njxeiw.png&quot;&gt;
    
    </summary>
    
      <category term="css" scheme="http://robin-front.github.io/categories/css/"/>
    
    
      <category term="css" scheme="http://robin-front.github.io/tags/css/"/>
    
      <category term="iphoneX" scheme="http://robin-front.github.io/tags/iphoneX/"/>
    
      <category term="notch" scheme="http://robin-front.github.io/tags/notch/"/>
    
      <category term="viewport" scheme="http://robin-front.github.io/tags/viewport/"/>
    
  </entry>
  
  <entry>
    <title>避免大型，复杂的布局和布局颠覆</title>
    <link href="http://robin-front.github.io/2017/08/30/avoid-large-complex-layouts-and-layout-thrashing/"/>
    <id>http://robin-front.github.io/2017/08/30/avoid-large-complex-layouts-and-layout-thrashing/</id>
    <published>2017-08-30T02:11:00.000Z</published>
    <updated>2017-08-30T02:11:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="避免大型，复杂的布局和布局颠覆"><a href="#避免大型，复杂的布局和布局颠覆" class="headerlink" title="避免大型，复杂的布局和布局颠覆"></a>避免大型，复杂的布局和布局颠覆</h1><p>布局是浏览器查找元素的几何信息：其大小和页面中的位置。每个元素将基于所使用的CSS，元素的内容或父元素显示或隐式的大小调整信息。该过程在 Chrome，Opera，Safari 和 Internet Explorer中称为“布局”。在 Firefox 中，它被称为 Reflow （回流），但是这个过程的作用是相同的。</p><p>类似于 style 计算，布局成本的直接相关是：</p><ul><li>需要布局的元素数量。</li><li>这些布局的复杂性。<a id="more"></a></li></ul><p>TL; DR</p><ul><li>布局通常作用于整个文档。</li><li>DOM 元素的数量将影响性能; 您应尽可能避免触发布局。</li><li>评估布局模型性能; 新的Flexbox通常比旧版Flexbox或基于浮动的布局模型更快。</li><li>避免强制同步布局和布局颠覆; 先读取样式值，然后再进行样式更改。</li></ul><h2 id="尽可能避免布局"><a href="#尽可能避免布局" class="headerlink" title="尽可能避免布局"></a>尽可能避免布局</h2><p>当您更改样式时，浏览器将检查以查看是否有任何更改需要计算布局，并为该渲染树进行更新。对“几何属性”的更改，如宽度，高度，左侧或顶部都需要布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 改变宽高</div><div class="line"> * 触发 layout.</div><div class="line"> */</div><div class="line"><span class="selector-class">.box--expanded</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">350px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>布局几乎总是作用于整个文档</strong>。如果你有很多元素，那么需要很长时间来确定它们的位置和尺寸。</p><p>如果不可能避免布局，那么关键是再次使用 Chrome DevTools 来查看花费多长时间，并确定布局是否是瓶颈的原因。首先，打开 DevTools，转到“时间轴”选项卡，点击记录并与您的网站进行交互。当您停止录制时，您会看到您的网站执行的细目：</p><p><img src="/js/lazyload-plugin/loading.svg" alt="" data-original="https://developers.google.com/web/fundamentals/performance/rendering/images/avoid-large-complex-layouts-and-layout-thrashing/big-layout.jpg"></p><p>当在上面的例子中挖掘每一帧时，我们看到在布局中花费了超过20毫秒，当我们的屏幕在动画中有16ms时，这太高了。您还可以看到，DevTools 会告诉您 DOM 树的大小（在这种情况下为1,618个元素），以及需要多少个节点进行布局。</p><blockquote><p>注意：想要明确列出哪些 CSS 属性触发布局(layout)，绘画(paint)或复合(composite)？查看<a href="https://csstriggers.com/" target="_blank" rel="external">CSS触发器</a>。</p></blockquote><h2 id="在旧的布局模型上使用-flexbox"><a href="#在旧的布局模型上使用-flexbox" class="headerlink" title="在旧的布局模型上使用 flexbox"></a>在旧的布局模型上使用 flexbox</h2><p>网络上有一系列的布局模式，其中一些比其他模型更受广泛支持。最旧的 CSS 布局模型允许我们在屏幕上进行相对，绝对地定位元素和浮动元素。</p><p>下面的截图显示了在1,300个盒子上使用浮点数时的布局成本。诚然，这是一个例证，因为大多数应用程序将使用各种方法来定位元素。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="" data-original="https://developers.google.com/web/fundamentals/performance/rendering/images/avoid-large-complex-layouts-and-layout-thrashing/layout-float.jpg"></p><p>如果我们更新样本以使用 Flexbox，这是Web平台上最近的一个补充，我们得到了一个不同的图片：</p><p><img src="/js/lazyload-plugin/loading.svg" alt="" data-original="https://developers.google.com/web/fundamentals/performance/rendering/images/avoid-large-complex-layouts-and-layout-thrashing/layout-flex.jpg"></p><p>现在，在相同数量的元素和相同的视觉外观的布局中，我们花费更少的时间（在这种情况下，3.5ms对14ms）。重要的是要记住，对于某些浏览器环境，您可能无法选择 Flexbox，因为它比<a href="http://caniuse.com/#search=flexbox" target="_blank" rel="external">浮动布局更不受支持</a>，但您应该至少应该调查布局模型对您的性能的影响，并将其最小化执行成本</p><p>无论您是否选择Flexbox，您仍然应该 <strong>尝试避免</strong> 在应用程序的高压点 <strong>完全触发布局</strong>！</p><h2 id="避免强制同步布局"><a href="#避免强制同步布局" class="headerlink" title="避免强制同步布局"></a>避免强制同步布局</h2><p>运送一个框架到屏幕有这样的顺序：</p><p><img src="/js/lazyload-plugin/loading.svg" alt="" data-original="https://developers.google.com/web/fundamentals/performance/rendering/images/avoid-large-complex-layouts-and-layout-thrashing/frame.jpg"></p><p>首先 JavaScript 运行，然后进行风格计算，然后进行布局。然而，可以强制浏览器使用 JavaScript 更早地执行布局。它被称为 <strong>强制同步布局</strong>。</p><p>要记住的第一件事是，由于 JavaScript 运行，所有旧的布局值都是已知的，可供您查询。所以如果你想在下一帧之前写出一个元素的高度（我们称之为“box”），你可以编写一些这样的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Schedule our function to run at the start of the frame.</span></div><div class="line">requestAnimationFrame(logBoxHeight);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">logBoxHeight</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// Gets the height of the box in pixels and logs it out.</span></div><div class="line">  <span class="built_in">console</span>.log(box.offsetHeight);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果您在要求其高度之前更改了 box 的样式，那么事情会变得有问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">logBoxHeight</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  box.classList.add(<span class="string">'super-big'</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Gets the height of the box in pixels</span></div><div class="line">  <span class="comment">// and logs it out.</span></div><div class="line">  <span class="built_in">console</span>.log(box.offsetHeight);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在，为了回答高度问题，浏览器必须首先应用样式更改（因为添加了 <code>super-big</code> 类），然后运行布局。只有这样才能恢复正确的高度。这是不必要的和潜在的昂贵的工作。</p><p>因此，您应该始终批评这类的样式读取，并首先执行（浏览器可以使用上一帧的布局值），然后执行任何写操作：</p><p>完成上述功能将是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">logBoxHeight</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// Gets the height of the box in pixels</span></div><div class="line">  <span class="comment">// and logs it out.</span></div><div class="line">  <span class="built_in">console</span>.log(box.offsetHeight);</div><div class="line"></div><div class="line">  box.classList.add(<span class="string">'super-big'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在大多数情况下，您不应该需要应用样式，然后查询值; 使用最后一帧的值应该是足够的。过早地运行 style 计算和布局是浏览器同步和布局潜在的瓶颈，这不是您通常想要做的事情。</p><h2 id="避免布局颠覆"><a href="#避免布局颠覆" class="headerlink" title="避免布局颠覆"></a>避免布局颠覆</h2><p>有一种方法可以使强制同步布局更加糟糕：<em>快速连续地做很多事情</em>。看看这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">resizeAllParagraphsToMatchBlockWidth</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// Puts the browser into a read-write-read-write cycle.</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; paragraphs.length; i++) &#123;</div><div class="line">    paragraphs[i].style.width = box.offsetWidth + <span class="string">'px'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>此代码循环遍历一组段落，并设置每个段落的宽度以匹配名为“box”的元素的宽度。它看起来很无害，但问题是循环的每次迭代读取一个样式值（<code>box.offsetWidth</code>），然后立即使用它来更新一个paragraph（<code>paragraphs[i].style.width</code>）的宽度。在循环的下一个迭代中，浏览器必须考虑到 <code>offsetWidth</code> 上一次请求（在上一次迭代中）样式已经改变的事实，因此它必须应用样式更改并运行布局。这将在每一次迭代中发生！</p><p>此示例的解决方法是缓存读取值，然后写值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Read.</span></div><div class="line"><span class="keyword">var</span> width = box.offsetWidth;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">resizeAllParagraphsToMatchBlockWidth</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; paragraphs.length; i++) &#123;</div><div class="line">    <span class="comment">// Now write.</span></div><div class="line">    paragraphs[i].style.width = width + <span class="string">'px'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果您想保证安全性，您应该检查<a href="https://github.com/wilsonpage/fastdom" target="_blank" rel="external">FastDOM</a>，这将自动为您分配读取和写入数据，并且应防止您意外触发强制同步布局或布局颠覆。</p><p>【翻译原文】:<a href="https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing?hl=en" target="_blank" rel="external">Avoid Large, Complex Layouts and Layout Thrashing</a></p><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;避免大型，复杂的布局和布局颠覆&quot;&gt;&lt;a href=&quot;#避免大型，复杂的布局和布局颠覆&quot; class=&quot;headerlink&quot; title=&quot;避免大型，复杂的布局和布局颠覆&quot;&gt;&lt;/a&gt;避免大型，复杂的布局和布局颠覆&lt;/h1&gt;&lt;p&gt;布局是浏览器查找元素的几何信息：其大小和页面中的位置。每个元素将基于所使用的CSS，元素的内容或父元素显示或隐式的大小调整信息。该过程在 Chrome，Opera，Safari 和 Internet Explorer中称为“布局”。在 Firefox 中，它被称为 Reflow （回流），但是这个过程的作用是相同的。&lt;/p&gt;&lt;p&gt;类似于 style 计算，布局成本的直接相关是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;需要布局的元素数量。&lt;/li&gt;&lt;li&gt;这些布局的复杂性。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="layout" scheme="http://robin-front.github.io/tags/layout/"/>
    
      <category term="css" scheme="http://robin-front.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>使用 requestIdleCallback</title>
    <link href="http://robin-front.github.io/2017/08/25/using-requestIdleCallback/"/>
    <id>http://robin-front.github.io/2017/08/25/using-requestIdleCallback/</id>
    <published>2017-08-25T07:40:26.000Z</published>
    <updated>2017-08-25T07:40:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-requestIdleCallback"><a href="#使用-requestIdleCallback" class="headerlink" title="使用 requestIdleCallback"></a>使用 requestIdleCallback</h1><p>许多网站和应用程序都有很多脚本来执行。您的 JavaScript 通常需要尽快运行，但同时您不希望它阻碍用户那条路。如果您在用户滚动页面时发送分析数据，或者在轻触按钮时将元素附加到 DOM，则您的 Web 应用程序将无法响应，从而导致用户体验不佳。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://developers.google.com/web/updates/images/2015-08-27-using-requestidlecallback/main.png" data-original="https://developers.google.com/web/updates/images/2015-08-27-using-requestidlecallback/main.png"></p><p>好消息是，现在有一个 API 可以帮助：<code>requestIdleCallback</code>。以同样的方式，<code>requestAnimationFrame</code> 我们可以正确地安排动画，并最大限度地提高 60fps 的机会，<code>requestIdleCallback</code> 当一个框架结束时，或当用户处于非活动状态时，可以安排工作。这意味着有机会在用户不使用的情况下进行工作。它可用于 Chrome 47！这是一个实验性的功能，规格还在不断变化，所以将来会发生变化。<a id="more"></a></p><h2 id="检查-requestIdleCallback-支持"><a href="#检查-requestIdleCallback-支持" class="headerlink" title="检查 requestIdleCallback 支持"></a>检查 requestIdleCallback 支持</h2><p>这是早期的 <code>requestIdleCallback</code>，所以在使用它之前，您应该检查它是否可用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="string">'requestIdleCallback'</span> <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</div><div class="line">  <span class="comment">// Use requestIdleCallback to schedule work.</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="comment">// Do what you’d do today.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>你也可以 polyfill 它的行为，这需要回到 <code>setTimeout</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.requestIdleCallback = <span class="built_in">window</span>.requestIdleCallback ||</div><div class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">cb</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> start = <span class="built_in">Date</span>.now();</div><div class="line">    <span class="keyword">return</span> setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      cb(&#123;</div><div class="line">        <span class="attr">didTimeout</span>: <span class="literal">false</span>,</div><div class="line">        <span class="attr">timeRemaining</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">          <span class="keyword">return</span> <span class="built_in">Math</span>.max(<span class="number">0</span>, <span class="number">50</span> - (<span class="built_in">Date</span>.now() - start));</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;, <span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="built_in">window</span>.cancelIdleCallback = <span class="built_in">window</span>.cancelIdleCallback ||</div><div class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</div><div class="line">    clearTimeout(id);</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>使用 <code>setTimeout</code> 不是很好，因为它不知道 <code>requestIdleCallback</code> 的空闲时间是如何工作的，但是如果 <code>requestIdleCallback</code> 不可用的话，你可以直接调用你的回调，你没有比这更差的方式。有了垫片，<code>requestIdleCallback</code> 就可以使用，你将被默认重定向到直接调用，这是很棒的。</p><p>现在，我们假设它存在。</p><h2 id="使用requestIdleCallback"><a href="#使用requestIdleCallback" class="headerlink" title="使用requestIdleCallback"></a>使用requestIdleCallback</h2><p>调用 <code>requestIdleCallback</code> 非常类似于 <code>requestAnimationFrame</code>, 它需要回调函数作为其第一个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">requestIdleCallback(myNonEssentialWork);</div></pre></td></tr></table></figure><p>当 <code>myNonEssentialWork</code> 被调用时，它将被赋予一个 <code>deadline</code>, 它是一个包含函数的对象，该函数返回一个数字，指示您的工作剩余多少时间：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNonEssentialWork</span> (<span class="params">deadline</span>) </span>&#123;</div><div class="line">  <span class="keyword">while</span> (deadline.timeRemaining() &gt; <span class="number">0</span>)</div><div class="line">    doWorkIfNeeded();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>timeRemaining</code> 可以调用该函数来获取最新值。当 <code>timeRemaining()</code> 返回零时，您可以安排另一个 <code>requestIdleCallback</code>, 如果您还有更多的工作要做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNonEssentialWork</span> (<span class="params">deadline</span>) </span>&#123;</div><div class="line">  <span class="keyword">while</span> (deadline.timeRemaining() &gt; <span class="number">0</span> &amp;&amp; tasks.length &gt; <span class="number">0</span>)</div><div class="line">    doWorkIfNeeded();</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (tasks.length &gt; <span class="number">0</span>)</div><div class="line">    requestIdleCallback(myNonEssentialWork);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="调用你的任务"><a href="#调用你的任务" class="headerlink" title="调用你的任务"></a>调用你的任务</h2><p>如果浏览器真的很忙，你该怎么办？您可能会担心您的回调可能永远不会被调用。嗯，虽然 <code>requestIdleCallback</code> 类似 <code>requestAnimationFrame</code>，但它也有所不同，它需要一个可选的第二个参数：具有 <code>timeout</code> 属性的 <code>options</code> 对象。此超时（如果设置）为浏览器提供了必须执行回调的时间（以毫秒为单位）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Wait at most two seconds before processing events.</span></div><div class="line">requestIdleCallback(processPendingAnalyticsEvents, &#123; <span class="attr">timeout</span>: <span class="number">2000</span> &#125;);</div></pre></td></tr></table></figure><p>如果您的回调由于超时触发而执行，您会注意到两件事情：</p><ul><li><code>timeRemaining()</code> 将返回零。</li><li>对象的 <code>didTimeout</code> 属性 <code>deadline</code> 将为 <code>true</code>。</li></ul><p>如果你看到这 <code>didTimeout</code> 是真的，你很可能只想运行这个工作并完成它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNonEssentialWork</span> (<span class="params">deadline</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// Use any remaining time, or, if timed out, just run through the tasks.</span></div><div class="line">  <span class="keyword">while</span> ((deadline.timeRemaining() &gt; <span class="number">0</span> || deadline.didTimeout) &amp;&amp;</div><div class="line">         tasks.length &gt; <span class="number">0</span>)</div><div class="line">    doWorkIfNeeded();</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (tasks.length &gt; <span class="number">0</span>)</div><div class="line">    requestIdleCallback(myNonEssentialWork);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>由于潜在的中断，这种超时可能会导致您的用户（工作可能会导致您的应用程序变得无响应或janky）设置此参数时要谨慎。在哪里可以让浏览器决定何时调用回调。</p><h2 id="使用-requestIdleCallback-发送分析数据"><a href="#使用-requestIdleCallback-发送分析数据" class="headerlink" title="使用 requestIdleCallback 发送分析数据"></a>使用 requestIdleCallback 发送分析数据</h2><p>让我们来看看 <code>requestIdleCallback</code> 发送分析数据。在这种情况下，我们可能会想跟踪一个事件，比如说 - 点击导航菜单。不过，由于通常在萤幕上设定动画，我们希望避免立即将此事件发送到 Google Analytics（分析）。我们将创建一系列事件来发送和请求在将来的某个时间发送它们：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> eventsToSend = [];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onNavOpenClick</span> (<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// Animate the menu.</span></div><div class="line">  menu.classList.add(<span class="string">'open'</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Store the event for later.</span></div><div class="line">  eventsToSend.push(</div><div class="line">    &#123;</div><div class="line">      <span class="attr">category</span>: <span class="string">'button'</span>,</div><div class="line">      <span class="attr">action</span>: <span class="string">'click'</span>,</div><div class="line">      <span class="attr">label</span>: <span class="string">'nav'</span>,</div><div class="line">      <span class="attr">value</span>: <span class="string">'open'</span></div><div class="line">    &#125;);</div><div class="line"></div><div class="line">  schedulePendingEvents();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在我们需要使用 <code>requestIdleCallback</code> 来处理任何待处理的事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">schedulePendingEvents</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// Only schedule the rIC if one has not already been set.</span></div><div class="line">  <span class="keyword">if</span> (isRequestIdleCallbackScheduled)</div><div class="line">    <span class="keyword">return</span>;</div><div class="line"></div><div class="line">  isRequestIdleCallbackScheduled = <span class="literal">true</span>;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (<span class="string">'requestIdleCallback'</span> <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</div><div class="line">    <span class="comment">// Wait at most two seconds before processing events.</span></div><div class="line">    requestIdleCallback(processPendingAnalyticsEvents, &#123; <span class="attr">timeout</span>: <span class="number">2000</span> &#125;);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    processPendingAnalyticsEvents();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在这里，您可以看到我设置了2秒的超时时间，但这个值取决于你的应用程序。对于分析数据，有意义的是，将使用超时时间来确保数据在合理的时间内报告，而不仅仅是在将来的某个时间点。</p><p>最后我们需要编写 <code>requestIdleCallback</code> 将执行的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">processPendingAnalyticsEvents</span> (<span class="params">deadline</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// Reset the boolean so future rICs can be set.</span></div><div class="line">  isRequestIdleCallbackScheduled = <span class="literal">false</span>;</div><div class="line"></div><div class="line">  <span class="comment">// If there is no deadline, just run as long as necessary.</span></div><div class="line">  <span class="comment">// This will be the case if requestIdleCallback doesn’t exist.</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> deadline === <span class="string">'undefined'</span>)</div><div class="line">    deadline = &#123; <span class="attr">timeRemaining</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">Number</span>.MAX_VALUE &#125; &#125;;</div><div class="line"></div><div class="line">  <span class="comment">// Go for as long as there is time remaining and work to do.</span></div><div class="line">  <span class="keyword">while</span> (deadline.timeRemaining() &gt; <span class="number">0</span> &amp;&amp; eventsToSend.length &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">var</span> evt = eventsToSend.pop();</div><div class="line"></div><div class="line">    ga(<span class="string">'send'</span>, <span class="string">'event'</span>,</div><div class="line">        evt.category,</div><div class="line">        evt.action,</div><div class="line">        evt.label,</div><div class="line">        evt.value);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Check if there are more events still to send.</span></div><div class="line">  <span class="keyword">if</span> (eventsToSend.length &gt; <span class="number">0</span>)</div><div class="line">    schedulePendingEvents();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对于这个例子，我假设如果 <code>requestIdleCallback</code> 不存在分析数据应该立即发送。然而，在生产应用程序中，延迟发送超时可能会更好，以确保它不会与任何交互冲突，并导致 jank。</p><h2 id="使用-requestIdleCallback-进行-DOM-更改"><a href="#使用-requestIdleCallback-进行-DOM-更改" class="headerlink" title="使用 requestIdleCallback 进行 DOM 更改"></a>使用 <code>requestIdleCallback</code> 进行 DOM 更改</h2><p>另一种 <code>requestIdleCallback</code> 真正有助于表现的情况是当您进行非必要的 DOM 更改时，例如将项目添加到不断增长的惰性列表的末尾。我们来看一下如何将 requestIdleCallback 实际应用在一个典型的框架。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://developers.google.com/web/updates/images/2015-08-27-using-requestidlecallback/frame.jpg" data-original="https://developers.google.com/web/updates/images/2015-08-27-using-requestidlecallback/frame.jpg"></p><p>浏览器可能太忙，无法在给定的框架中运行任何回调，所以您不应该期望在框架结尾处有任何空闲时间来执行任何更多的工作。这使得它不同于 <code>setImmediate</code> 这类每帧都运行的东西。</p><p>如果回调在框架结束时被触发，它将被调度到当前帧已经提交之后，这意味着将应用样式更改，并且重要的是布局计算。如果我们在空闲回调内部进行 DOM 更改，这些布局计算将无效。如果有任何读取下一帧布局的事件，例如 <code>getBoundingClientRect</code>，<code>clientWidth</code>等等，浏览器将不得不进行<a href="https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing#avoid-forced-synchronous-layouts" target="_blank" rel="external">强制同步布局</a>，这是一个潜在的性能瓶颈。</p><p>不要在空闲回调中 DOM 更改的另一个原因是更改 DOM 的时间影响是不可预测的，因此我们可以很容易地超过浏览器提供的期限。</p><p>最好的做法是只能在 <code>requestAnimationFrame</code> 回调内部进行 DOM 更改，因为它是由浏览器安排的那种类型的工作。这意味着我们的代码将需要使用一个文档片段，然后可以将其附加在下一个 <code>requestAnimationFrame</code> 回调中。如果您正在使用 VDOM 库，则可以使用 <code>requestIdleCallback</code> 进行更改，但是您可以在下一个回调中应用 DOM 修补程序 <code>requestAnimationFrame</code>，而不是空闲回调。</p><p>所以考虑到这一点，让我们来看看代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">processPendingElements</span> (<span class="params">deadline</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// If there is no deadline, just run as long as necessary.</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> deadline === <span class="string">'undefined'</span>)</div><div class="line">    deadline = &#123; <span class="attr">timeRemaining</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">Number</span>.MAX_VALUE &#125; &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!documentFragment)</div><div class="line">    documentFragment = <span class="built_in">document</span>.createDocumentFragment();</div><div class="line"></div><div class="line">  <span class="comment">// Go for as long as there is time remaining and work to do.</span></div><div class="line">  <span class="keyword">while</span> (deadline.timeRemaining() &gt; <span class="number">0</span> &amp;&amp; elementsToAdd.length &gt; <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">    <span class="comment">// Create the element.</span></div><div class="line">    <span class="keyword">var</span> elToAdd = elementsToAdd.pop();</div><div class="line">    <span class="keyword">var</span> el = <span class="built_in">document</span>.createElement(elToAdd.tag);</div><div class="line">    el.textContent = elToAdd.content;</div><div class="line"></div><div class="line">    <span class="comment">// Add it to the fragment.</span></div><div class="line">    documentFragment.appendChild(el);</div><div class="line"></div><div class="line">    <span class="comment">// Don't append to the document immediately, wait for the next</span></div><div class="line">    <span class="comment">// requestAnimationFrame callback.</span></div><div class="line">    scheduleVisualUpdateIfNeeded();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Check if there are more events still to send.</span></div><div class="line">  <span class="keyword">if</span> (elementsToAdd.length &gt; <span class="number">0</span>)</div><div class="line">    scheduleElementCreation();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在这里我创建元素并使用该 <code>textContent</code> 属性来填充它，但是您的元素创建代码可能会更多的操作！在创建元素后 <code>scheduleVisualUpdateIfNeeded</code>，调用该元素将会建立一个单独的 <code>requestAnimationFrame</code> 回调，然后依次将文档片段附加到正文中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleVisualUpdateIfNeeded</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (isVisualUpdateScheduled)</div><div class="line">    <span class="keyword">return</span>;</div><div class="line"></div><div class="line">  isVisualUpdateScheduled = <span class="literal">true</span>;</div><div class="line"></div><div class="line">  requestAnimationFrame(appendDocumentFragment);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">appendDocumentFragment</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// Append the fragment and reset.</span></div><div class="line">  <span class="built_in">document</span>.body.appendChild(documentFragment);</div><div class="line">  documentFragment = <span class="literal">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>一切顺利，我们现在将把项目附加到 DOM 时看起来更少 jank。优秀！</p><h2 id="常问问题"><a href="#常问问题" class="headerlink" title="常问问题"></a>常问问题</h2><ul><li>是否有 polyfill？ 可悲的是，没有。如果你想要透明的重定向到 <code>setTimeout</code>，那就有一个 <code>shim</code> 。该API存在的原因是因为它在Web平台中插入了非常真实的差距。但是没有JavaScript API来确定框架结束时的空闲时间，所以最多只能做出猜测。像 <code>setTimeout</code>，<code>setInterval</code> 或者 <code>setImmediate</code> 这样的 API 可以用于调度工作，但是并不是按照 <code>requestIdleCallback</code> 这样的方式避开用户交互。</li><li>如果我设置 <code>timeout</code>，会发生什么？ 如果 <code>timeRemaining()</code> 返回零，但是您选择运行更长时间，您可以这样做，而不用担心浏览器停止工作。但是，浏览器为您提供了最终期限，以确保您的用户顺利体验，因此除非有非常好的理由，否则您应始终遵守最终期限。</li><li><code>timeRemaining()</code> 会返回有最大值吗？ 是的，现在是 <code>50ms</code> 。在尝试维护响应式应用程序时，所有对用户交互的响应应保持在 100ms 以下。如果用户在 50ms 窗口中进行交互，在大多数情况下应允许空闲回调完成，并且浏览器可以响应用户的交互。您可能会得到多个空闲的回调（如果浏览器确定有足够的时间来运行它们），那么它们将被一个个安排。</li><li>有没有什么工作我不应该在 <code>requestIdleCallback</code> 里执行？ 理想情况下，您所做的工作应该是具有相对可预测特征的小块（微任务）。例如，特别是更改 DOM 将具有不可预测的执行时间，因为它将触发样式计算，布局，绘画和合成。因此，您应该仅在上述 requestAnimationFrame 回调中进行 DOM 更改。要注意的另一件事是解决（或拒绝）Promises，因为在空闲回调完成后回调将立即执行，即使没有更多的时间剩余。</li><li>我会总是在一帧结束时被执行 <code>requestIdleCallback</code> ？不，不总是。浏览器将在帧结束时的空闲时间或用户处于非活动状态的时段内调度回调。您不应该期望每帧调用回调，并且如果要求它在给定的时间范围内运行，则应该使用超时。</li><li>我可以有多个 <code>requestIdleCallback</code> 回调吗？ 是的，你可以拥有非常多个 <code>requestAnimationFrame</code> 回调。值得记住的是，如果你的第一个回调使用了它在回调期间的剩余时间，那么任何其他回调都不会有更多的时间。然后，其他回调将不得不等待浏览器下一个空闲，才能运行。根据您要完成的工作，可能会有一个空闲的回调，并将工作分配到那里。或者，您可以使用超时时间来确保回调都有机会执行。</li><li>如果我在另一个内部设置一个新的空闲回调，会发生什么？ 新的空闲回调将被安排尽快运行，从下一个帧开始（而不是当前的）。</li></ul><h2 id="利用空闲"><a href="#利用空闲" class="headerlink" title="利用空闲"></a>利用空闲</h2><p><code>requestIdleCallback</code> 是一个非常棒的方法，以确保您可以运行您的代码，但没有阻碍用户的交互。使用起来很简单，非常灵活。但仍然属于早期，而且规范还没有完全解决，所以你所提供的任何反馈都是值得欢迎的。</p><p>【翻译原文】:<a href="https://developers.google.com/web/updates/2015/08/using-requestidlecallback" target="_blank" rel="external">useing requestIdleCallback</a></p><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用-requestIdleCallback&quot;&gt;&lt;a href=&quot;#使用-requestIdleCallback&quot; class=&quot;headerlink&quot; title=&quot;使用 requestIdleCallback&quot;&gt;&lt;/a&gt;使用 requestIdleCallback&lt;/h1&gt;&lt;p&gt;许多网站和应用程序都有很多脚本来执行。您的 JavaScript 通常需要尽快运行，但同时您不希望它阻碍用户那条路。如果您在用户滚动页面时发送分析数据，或者在轻触按钮时将元素附加到 DOM，则您的 Web 应用程序将无法响应，从而导致用户体验不佳。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://developers.google.com/web/updates/images/2015-08-27-using-requestidlecallback/main.png&quot; alt=&quot;https://developers.google.com/web/updates/images/2015-08-27-using-requestidlecallback/main.png&quot;&gt;&lt;/p&gt;&lt;p&gt;好消息是，现在有一个 API 可以帮助：&lt;code&gt;requestIdleCallback&lt;/code&gt;。以同样的方式，&lt;code&gt;requestAnimationFrame&lt;/code&gt; 我们可以正确地安排动画，并最大限度地提高 60fps 的机会，&lt;code&gt;requestIdleCallback&lt;/code&gt; 当一个框架结束时，或当用户处于非活动状态时，可以安排工作。这意味着有机会在用户不使用的情况下进行工作。它可用于 Chrome 47！这是一个实验性的功能，规格还在不断变化，所以将来会发生变化。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="performance" scheme="http://robin-front.github.io/tags/performance/"/>
    
      <category term="optimization" scheme="http://robin-front.github.io/tags/optimization/"/>
    
      <category term="requestIdleCallback" scheme="http://robin-front.github.io/tags/requestIdleCallback/"/>
    
  </entry>
  
  <entry>
    <title>IntersectionObserver API</title>
    <link href="http://robin-front.github.io/2017/08/24/intersectionobserver/"/>
    <id>http://robin-front.github.io/2017/08/24/intersectionobserver/</id>
    <published>2017-08-24T01:59:34.000Z</published>
    <updated>2017-08-24T01:59:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IntersectionObserver"><a href="#IntersectionObserver" class="headerlink" title="IntersectionObserver"></a>IntersectionObserver</h1><p>假设你想追踪 DOM 里的一个元素是否进入 <a href="https://en.wikipedia.org/wiki/Viewport" target="_blank" rel="external">viewport</a> 的可视区。你做这件事可能是因为你想在这个时机 lazyload 图片或者你需要知道用户是否真的在看一个某个广告横幅。你可以通过添加 <code>scroll</code> 事件钩子或使用定时器去调用元素的 <code>getBoundingClientRect()</code> 方法。然而，这种方法真的很慢，因为每次调用 <code>getBoundingClientRect()</code> <a href="https://gist.github.com/paulirish/5d52fb081b3570c81e3a" target="_blank" rel="external">会造成浏览器 re-layout 当前页面</a> 并会在你的页面造成很大的卡顿和闪烁。 <code>iframe</code> 里的元素是否可见这样的事情几乎很难做到。 基于单一源模型，浏览器不会让你访问包含 <code>iframe</code> 的页面的任何数据。这是频繁使用 <code>iframe</code> 加载广告的常见问题。</p><p>为了让可见度测试更有效率， <a href="https://wicg.github.io/IntersectionObserver/" target="_blank" rel="external">IntersectionObserver</a> 被设计出来了。<code>IntersectionObserver</code> 让你知道观察的元素何时进入或退出浏览器 <code>viewport</code>。<a id="more"></a></p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://developers.google.com/web/updates/images/2016/04/intersectionobserver/iframe.gif" data-original="https://developers.google.com/web/updates/images/2016/04/intersectionobserver/iframe.gif"></p><h2 id="如何创建一个-IntersectionObserver"><a href="#如何创建一个-IntersectionObserver" class="headerlink" title="如何创建一个 IntersectionObserver"></a>如何创建一个 IntersectionObserver</h2><p>API 相当简单，例子一看就懂：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> io = <span class="keyword">new</span> IntersectionObserver(</div><div class="line">    <span class="function"><span class="params">entries</span> =&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(entries);</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        <span class="comment">/* 使用默认选项，详细在下面会介绍 */</span></div><div class="line">    &#125;</div><div class="line">);</div><div class="line"><span class="comment">// 开始观察一个元素</span></div><div class="line">io.observe(element);</div><div class="line"></div><div class="line"><span class="comment">// 停止观察一个元素</span></div><div class="line"><span class="comment">// io.unobserve(element);</span></div><div class="line"></div><div class="line"><span class="comment">// 禁用整个 IntersectionObserver</span></div><div class="line"><span class="comment">// io.disconnect();</span></div></pre></td></tr></table></figure><p>使用默认选项，回调会在元素进入和完全退出 <code>viewport</code> 的时候触发。</p><p>如果你需要观察多个元素，建议在同一个 <code>IntersectionObserver</code> 实例上多次调用 <code>observe()</code> 来观察多个元素，这也是允许的调用方式。</p><p>回调函数回传的参数是一个数组对象 <a href="https://wicg.github.io/IntersectionObserver/#intersection-observer-entry" target="_blank" rel="external"><code>IntersectionObserverEntry</code></a> 。每个这样的对象都包含了每个观察元素的最新数据。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">🔽[IntersectionObserverEntry]</div><div class="line">  🔽 0: IntersectionObserverEntry</div><div class="line">       time: 3893.92</div><div class="line">    🔽 rootBounds: ClientRect</div><div class="line">        bottom: 920</div><div class="line">        height: 1024</div><div class="line">        left: 0</div><div class="line">        right: 1024</div><div class="line">        top: 0</div><div class="line">        width: 920</div><div class="line">    🔽 boundingClientRect: ClientRect</div><div class="line">       // ...</div><div class="line">    🔽 intersectionRect: ClientRect</div><div class="line">       // ...</div><div class="line">      intersectionRatio: 0.54</div><div class="line">    🔽 target: div#observee</div><div class="line">       // ...</div></pre></td></tr></table></figure><ul><li><a href="https://wicg.github.io/IntersectionObserver/#dom-intersectionobserverentry-rootbounds" target="_blank" rel="external"><code>rootBounds</code></a> 是对 root 元素调用 <code>getBoundingClientRect</code> 的结果，默认 root 元素是 viewport 。</li><li><a href="https://wicg.github.io/IntersectionObserver/#dom-intersectionobserverentry-boundingclientrect" target="_blank" rel="external"><code>boundingClientRect</code></a> 是被观察元素调用 <code>getBoundingClientRect</code> 的结果。</li><li><a href="https://wicg.github.io/IntersectionObserver/#dom-intersectionobserverentry-intersectionrect" target="_blank" rel="external"><code>intersectionRect</code></a> 是两个矩形的交叉部分，可能有效地告诉你被观察的元素的哪一部分是可见的。</li><li><a href="https://wicg.github.io/IntersectionObserver/#dom-intersectionobserverentry-intersectionratio" target="_blank" rel="external"><code>intersectionRatio</code></a> 是最相关的，告诉你元素有百分之几是可见的。</li></ul><p>有了这些信息，你现在可以实现元素进入 viewport 前及时加载的特性。非常有用。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://developers.google.com/web/updates/images/2016/04/intersectionobserver/intersectratio.png" data-original="https://developers.google.com/web/updates/images/2016/04/intersectionobserver/intersectratio.png"></p><p><code>IntersectionObservers</code> 是异步推送他们的数据，而回调是运行在主线程的。另外，规范提到 <code>IntersectionObserver</code> 应该使用 <a href="https://wicg.github.io/IntersectionObserver/#queue-intersection-observer-task" target="_blank" rel="external"><code>requestIdleCallback()</code></a>。 这意味着调用回调函数的优先级是非常低的，只会在浏览器有空闲的时候调用。这是有意设计的。</p><h2 id="Scrolling-divs"><a href="#Scrolling-divs" class="headerlink" title="Scrolling divs"></a>Scrolling divs</h2><p>我并不喜欢在 div 中滚动元素, 但我不会用 <code>scroll</code> 判定, 而是用 <code>IntersectionObserver</code>。 <a href="https://wicg.github.io/IntersectionObserver/#dictdef-intersectionobserverinit" target="_blank" rel="external"><code>option</code></a> 对象有一个 <a href="https://wicg.github.io/IntersectionObserver/#dom-intersectionobserverinit-root" target="_blank" rel="external"><code>root</code></a> 选项让你定义一个代替 viewport 的 root 元素。需要记住的是，要保证 root 元素是所有被观察元素的祖先。</p><h2 id="重叠所有元素"><a href="#重叠所有元素" class="headerlink" title="重叠所有元素"></a>重叠所有元素</h2><p>不！那是糟糕的开发者！请注意使用用户的 CPU 周期。让我们考虑一下无限滚动的例子： 在脚本中，添加一个哨兵来观察和回收是明智的选择。你应该在无限滚动的最后一个元素添加哨兵。当哨兵快要进入 viewport 的时候，在回调函数中加载数据，创建接下来的元素，并添加到哨兵之前的 DOM 结构中。如果重复利用哨兵，不需要再调用 <code>observe()</code>， <code>IntersectionObserver</code> 仍然会继续工作。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://developers.google.com/web/updates/images/2016/04/intersectionobserver/infinitescroller.png" data-original="https://developers.google.com/web/updates/images/2016/04/intersectionobserver/infinitescroller.png"></p><h3 id="更多地更新与回调调用"><a href="#更多地更新与回调调用" class="headerlink" title="更多地更新与回调调用"></a>更多地更新与回调调用</h3><p>就像前面提到的，当被监听元素进入或离开 viewport 的时候，回调函数会分别单次触发。 这让<code>IntersectionObserver</code> 可以给你这个问题的答案，“元素 X 是否在视图中？”。但在某些场景中，这还不够。</p><p><a href="https://wicg.github.io/IntersectionObserver/#dom-intersectionobserverinit-threshold" target="_blank" rel="external"><code>theshold</code></a> 选项登场。它允许你定义一个 <a href="https://wicg.github.io/IntersectionObserver/#dom-intersectionobserverentry-intersectionratio" target="_blank" rel="external"><code>intersectionRatio</code></a> 阈值数组。当达到每一个 <code>intersectionRatio</code> 值时，回调函数都会被调用。<code>theshold</code> 默认值是 <code>[0]</code>，就是我们解释的默认表现。当设定 <code>theshold</code> 为 <code>[0, 0.25, 0.5, 0.75, 1]</code>, 我们会在元素每四分之一的部分进入 viewport 时得到通知。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://developers.google.com/web/updates/images/2016/04/intersectionobserver/threshold.gif" data-original="https://developers.google.com/web/updates/images/2016/04/intersectionobserver/threshold.gif"></p><h3 id="还有其他问题吗？"><a href="#还有其他问题吗？" class="headerlink" title="还有其他问题吗？"></a>还有其他问题吗？</h3><p>到现在为止，还有一个选项没有被提到。<a href="https://wicg.github.io/IntersectionObserver/#dom-intersectionobserverinit-rootmargin" target="_blank" rel="external"><code>rootMargin</code></a> 允许你指定 <code>root</code> 元素的 <code>margin</code>，有效地允许你增加或缩减实际的交叉区域。<code>margin</code> 使用 css-style 的规则， <code>10px 20px 30px 40px</code> 分别表示上、右、下、左。总的来说，<code>IntersectionObserver</code> 的选项总结如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> IntersectionObserver(<span class="function"><span class="params">entries</span> =&gt;</span> &#123;<span class="comment">/* … */</span>&#125;, &#123;</div><div class="line">  <span class="comment">// The root to use for intersection.</span></div><div class="line">  <span class="comment">// If not provided, use the top-level document’s viewport.</span></div><div class="line">  root: <span class="literal">null</span>,</div><div class="line">  <span class="comment">// Same as margin, can be 1, 2, 3 or 4 components, possibly negative lengths.  </span></div><div class="line">  <span class="comment">// If an explicit root element is specified, components may be percentages of the</span></div><div class="line">  <span class="comment">// root element size.  If no explicit root element is specified, using a percentage</span></div><div class="line">  <span class="comment">// is an error.</span></div><div class="line">  rootMargin: <span class="string">"0px"</span>,</div><div class="line">  <span class="comment">// Threshold(s) at which to trigger callback, specified as a ratio, or list of</span></div><div class="line">  <span class="comment">// ratios, of (visible area / total area) of the observed element (hence all</span></div><div class="line">  <span class="comment">// entries must be in the range [0, 1]).  Callback will be invoked when the visible</span></div><div class="line">  <span class="comment">// ratio of the observed element crosses a threshold in the list.</span></div><div class="line">  threshold: [<span class="number">0</span>],</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3 id="iframe-魔法"><a href="#iframe-魔法" class="headerlink" title="iframe 魔法"></a>iframe 魔法</h3><p><code>IntersectionObserver</code> 被设计时明确考虑广告服务和网络社交服务，可能经常会用到 <code>iframe</code> 和有益于知道他们是否在看。如果观察 <code>iframe</code> 中的元素，那么滚动 <code>iframe</code> 和滚动父页面都可以在适当的时候触发回调函数。对于后者， <code>rootBounds</code> 将被设置为 <code>null</code> 以避免数据源泄漏。</p><h2 id="IntersectionObserver-不是什么？"><a href="#IntersectionObserver-不是什么？" class="headerlink" title="IntersectionObserver 不是什么？"></a><code>IntersectionObserver</code> 不是什么？</h2><p>需要知道的是， <code>IntersectionObserver</code> 是被故意设置成不完美和低延迟的。使用它们努力实现像滚动动画之类是注定会失败的。因为严格地说，当你获得数据时，数据已经过时了。这里有更多的关于 <code>IntersectionObserver</code> <a href="https://github.com/WICG/IntersectionObserver/blob/gh-pages/explainer.md" target="_blank" rel="external">原始用例</a>。</p><h2 id="可以在-callback-中做多少事情"><a href="#可以在-callback-中做多少事情" class="headerlink" title="可以在 callback 中做多少事情"></a>可以在 <code>callback</code> 中做多少事情</h2><p>在回调中花太多时候会让你的应用滞后，和常见的实践一样。</p><h2 id="使用-IntersectionObserver"><a href="#使用-IntersectionObserver" class="headerlink" title="使用 IntersectionObserver"></a>使用 IntersectionObserver</h2><p>对于 <code>IntersectionObserver</code>，浏览器的支持仍然很弱，所以它不会马上被普遍应用。同时，<a href="https://github.com/WICG/IntersectionObserver" target="_blank" rel="external">WICG</a> 的 polyfill 也被建立起来。显然，使用 polyfill 不如原生实现的效率好。</p><blockquote><p>Except as otherwise noted, the content of this page is licensed under the Creative Commons Attribution 3.0 License, and code samples are licensed under the Apache 2.0 License. For details, see our Site Policies. Java is a registered trademark of Oracle and/or its affiliates. 上次更新日期：六月 5, 2017</p></blockquote><p>【翻译原文】： <a href="https://developers.google.com/web/updates/2016/04/intersectionobserver" target="_blank" rel="external">intersectionobserver</a></p><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IntersectionObserver&quot;&gt;&lt;a href=&quot;#IntersectionObserver&quot; class=&quot;headerlink&quot; title=&quot;IntersectionObserver&quot;&gt;&lt;/a&gt;IntersectionObserver&lt;/h1&gt;&lt;p&gt;假设你想追踪 DOM 里的一个元素是否进入 &lt;a href=&quot;https://en.wikipedia.org/wiki/Viewport&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;viewport&lt;/a&gt; 的可视区。你做这件事可能是因为你想在这个时机 lazyload 图片或者你需要知道用户是否真的在看一个某个广告横幅。你可以通过添加 &lt;code&gt;scroll&lt;/code&gt; 事件钩子或使用定时器去调用元素的 &lt;code&gt;getBoundingClientRect()&lt;/code&gt; 方法。然而，这种方法真的很慢，因为每次调用 &lt;code&gt;getBoundingClientRect()&lt;/code&gt; &lt;a href=&quot;https://gist.github.com/paulirish/5d52fb081b3570c81e3a&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;会造成浏览器 re-layout 当前页面&lt;/a&gt; 并会在你的页面造成很大的卡顿和闪烁。 &lt;code&gt;iframe&lt;/code&gt; 里的元素是否可见这样的事情几乎很难做到。 基于单一源模型，浏览器不会让你访问包含 &lt;code&gt;iframe&lt;/code&gt; 的页面的任何数据。这是频繁使用 &lt;code&gt;iframe&lt;/code&gt; 加载广告的常见问题。&lt;/p&gt;&lt;p&gt;为了让可见度测试更有效率， &lt;a href=&quot;https://wicg.github.io/IntersectionObserver/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;IntersectionObserver&lt;/a&gt; 被设计出来了。&lt;code&gt;IntersectionObserver&lt;/code&gt; 让你知道观察的元素何时进入或退出浏览器 &lt;code&gt;viewport&lt;/code&gt;。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="lazyload" scheme="http://robin-front.github.io/tags/lazyload/"/>
    
      <category term="performance" scheme="http://robin-front.github.io/tags/performance/"/>
    
      <category term="optimization" scheme="http://robin-front.github.io/tags/optimization/"/>
    
      <category term="IntersectionObserver" scheme="http://robin-front.github.io/tags/IntersectionObserver/"/>
    
  </entry>
  
  <entry>
    <title>使用 intersection observer 延迟加载图片</title>
    <link href="http://robin-front.github.io/2017/08/18/lazy-loading-images-using-intersection-observer/"/>
    <id>http://robin-front.github.io/2017/08/18/lazy-loading-images-using-intersection-observer/</id>
    <published>2017-08-18T02:14:15.000Z</published>
    <updated>2017-08-18T02:14:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-intersection-observer-延迟加载图片"><a href="#使用-intersection-observer-延迟加载图片" class="headerlink" title="使用 intersection observer 延迟加载图片"></a>使用 intersection observer 延迟加载图片</h1><p>如果您还没有看过，Paul Lewis 组织了一个令人敬畏的视频系列，演示如何构建媒体播放器以及拥有非常棒的特性的 Progressive Web Apps。他在YouTube上建立了<a href="https://www.youtube.com/playlist?list=PLNYkxOF6rcIBykcJ7bvTpqU7vt-oey72J" target="_blank" rel="external">一系列视频</a>，这些视频是在他建立网站的每一部分的过程中发生的。观看开发者展示他们工作的视频绝对是我最喜欢学习新事物的方法之一！</p><a id="more"></a><p>当他在演示他的代码时，我注意到他创建了一个出色的 helper 库来延迟加载图像。我一直在寻找改善我网站性能的方法，这无疑引起了我的兴趣。</p><h2 id="与懒惰加载有什么关系？"><a href="#与懒惰加载有什么关系？" class="headerlink" title="与懒惰加载有什么关系？"></a>与懒惰加载有什么关系？</h2><p>延迟加载图像背后的想法是，您等到用户向下滚动页面，并图像进入视图之前，再为这个图片发起网络请求。如果您的网页包含多个图像，但是只有在图像滚动到视图时才加载每个图像，您将最终节省带宽，并确保您的网页加载更快。</p><p>为了给你一个这样的想法，我们来想象下面有三个图像的页面。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://307a6ed092846b809be7-9cfa4cf7c673a59966ad8296f4c88804.ssl.cf3.rackcdn.com/intersection-observer/intersection-observer.png" data-original="https://307a6ed092846b809be7-9cfa4cf7c673a59966ad8296f4c88804.ssl.cf3.rackcdn.com/intersection-observer/intersection-observer.png"></p><p>如果用户登陆页面并且仅查看第一张图像，我们不想加载页面底部比萨的图像，直到用户向下滚动，并且等到图像真正在视图中。如果我们懒惰加载图像，这意味着用户只需要下载他们需要的东西，这使您的网页更精简。</p><p>对于更有经验的开发人员，您可能会熟悉延迟加载图像，毕竟这个概念已经有一段时间了。那么有什么新概念吗？！有很多懒加载库做得很好。我甚至以前在这个博客上写了一篇（<a href="https://deanhume.com/Home/BlogPost/lazy-loading-images-with-jquery/22" target="_blank" rel="external">很多年前</a>）。问题在于，几乎所有这些库都会绑定滚动事件，或者使用定时器来检查元素的边界，然后再确定是否在视图中。这种方法的问题是它强制浏览器重新布局（re-layout）整个页面，并且在某些情况下，您的网站会引起相当大的性能损失。我们可以做得更好！</p><h2 id="INTERSECTION-OBSERVER-来抢救！"><a href="#INTERSECTION-OBSERVER-来抢救！" class="headerlink" title="INTERSECTION OBSERVER 来抢救！"></a>INTERSECTION OBSERVER 来抢救！</h2><p>这是就是 Intersection Observer 的用处。Intersection Observer 内置于大多数现代浏览器中，让您知道被观察的元素何时进入或退出浏览器的视口。这使得它非常理想，因为它能够异步传输数据，并且不会影响主线程，使其成为提供反馈的有效手段。</p><p>在 <a href="https://github.com/googlechrome/sample-media-pwa" target="_blank" rel="external">Paul 的例子</a>中，他演示了如何使用 Intersection Observer 来延迟加载进入视口图像。我已经获取了他的初始代码，并稍微调整了一点，使我更容易理解。在本文中，我将通过了解 Intersection Observer 的基础知识，并向您展示如何以超级高效的方式做到延迟加载图像。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>想象一下一个基本的HTML页面，其中包含三个与上述相似的图像。在网页上，您将具有与以下熟悉的图像元素代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"js-lazy-image"</span> <span class="attr">data-src</span>=<span class="string">"burger.png"</span>&gt;</span></div></pre></td></tr></table></figure><p>您可能会注意到，在上面的代码中，图像文件没有 <code>src</code> 属性。这是因为它正在使用一个名为 <code>data-src</code> 的数据属性来指向图像源。当进入视口时，我们将使用它来加载图像。您还可能会注意到，图像元素还具有一个名为 “js-lazy-image” 的类 - 我们将在 JavaScript 代码中尽快使用这个类，以确定要延迟加载的元素。</p><p>接下来，我们需要创建将在页面上加载图像的代码。在我们的 JavaScript 文件中，我们需要创建一个新的 Intersection Observer 。</p><script src="https://gist.github.com/deanhume/1da60330fa8f6dc3d0f4885168a48f9e.js"></script><p>上面的例子看起来像很多代码，但是让我们一步一步地分解它。首先，我正在选择页面上具有类“js-lazy-image”的所有图像。接下来，我正在创建一个新的 <em>IntersectionObserver</em>，并使用它来观察我们选择的具有类“js-lazy-image”的所有图像。使用 <em>IntersectionObserver</em> 的默认选项，当元素部分进入视图或完全离开视口时，您的回调都将被调用。在这种情况下，我将几个额外的配置选项传递给 <em>IntersectionObserver</em>。使用 <code>rootMargin</code> 允许您指定根的边距，有效地允许您增加或缩小用于观察交点的区域。我们想确保如果图像在Y轴上的50像素内，我们将开始下载。</p><p>现在我们已经创建了一个 Intersection Observer，并且正在观察页面上的图像，我们可以进入到该元素进入视图时被触发的 intersection 事件。</p><script src="https://gist.github.com/deanhume/768666a8b37dce069d5ce7839100a4e4.js"></script><p>在上面的代码中，只要我们观察到的元素进入用户视口，<code>onIntersection</code> 功能将被触发。此时，我们可以循环查看我们观察到的图像，并确定哪个图像在视口中。如果当前元素处于交叉比例中，我们知道图像在用户视口中，我们可以加载它。加载图像后，我们不需要再观察图像，并且使用 <em><code>unobserve()</code></em> 将其从 Intersection Observer 中的条目列表中删除。</p><p>就是这样！一旦用户滚动并且图像进入视图，则将加载适当的图像。这个代码最好的办法是 Intersection Observer 比巴里·怀特（Barry White）更平滑。我尽量保持尽可能简洁的代码，但如果您想看到完整版本，我已经创建了一个Github repo，其中包含了一个<a href="https://deanhume.github.io/lazy-observer-load/" target="_blank" rel="external">有效的例子</a>。</p><h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><p>在这一点上，您可能会想知道浏览器对此功能的支持。<a href="http://caniuse.com/#feat=intersectionobserver" target="_blank" rel="external">Edge，Firefox，Chrome和Opera</a>目前支持 Intersection Observer，这是一个好消息。</p><p>但是，为了确保不支持此功能的浏览器的代码不会报错，我们可以使用功能检测来确定我们如何加载图像。我们来看看下面的代码。</p><script src="https://gist.github.com/deanhume/948c59af68c86da9d3b3f2955747a651.js"></script><p>在上面的代码中，我们正在检查 <em>IntersectionObserver</em> 是否在当前浏览器中可用，如果不支持我们只是简单地立即加载图像，否则我们使用我们的默认行为。</p><p>如果您真的喜欢 <em>IntersectionObserver</em> API 的简便性，并且想要使用 polyfill，则 WICG 已创建一个可在 <a href="https://github.com/WICG/IntersectionObserver/tree/gh-pages/polyfill" target="_blank" rel="external">Github repository</a> 中使用的功能。唯一的缺点是您不会获得原生实现给您的性能优势。</p><p>您甚至可以采取进一步措施，并为 <a href="https://www.robinosborne.co.uk/2016/05/16/lazy-loading-images-dont-rely-on-javascript/#a-no-JavaScript" target="_blank" rel="external">Robin Osborne</a> 建议的未启用 JavaScript 的用户添加支持。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中，我们已经使用 <em>IntersectionObserver</em> 来延迟加载图像，但是您可以使用它来进行更多操作。它可以用于确定某人是否正在查看广告，或者即使是在iFrame中的元素。易于理解的API使其可以打开许多选项。</p><p>如果您想了解有关交叉点观察者的更多信息，我建议您在Google Developers网站上阅读<a href="https://developers.google.com/web/updates/2016/04/intersectionobserver" target="_blank" rel="external">这篇有关信息</a>的文章。我还强烈建议在 Youtube 上观看<a href="https://www.youtube.com/watch?v=ncYQkOrKTaI&amp;list=PLNYkxOF6rcIBykcJ7bvTpqU7vt-oey72J&amp;index=7" target="_blank" rel="external">保罗·刘易斯的视频系列</a>，它包含了很棒的提示，你一定会学到一些东西。</p><p>【翻译原文】: <a href="https://deanhume.com/Home/BlogPost/lazy-loading-images-using-intersection-observer/10163" target="_blank" rel="external">LAZY LOADING IMAGES USING INTERSECTION OBSERVER</a></p><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用-intersection-observer-延迟加载图片&quot;&gt;&lt;a href=&quot;#使用-intersection-observer-延迟加载图片&quot; class=&quot;headerlink&quot; title=&quot;使用 intersection observer 延迟加载图片&quot;&gt;&lt;/a&gt;使用 intersection observer 延迟加载图片&lt;/h1&gt;&lt;p&gt;如果您还没有看过，Paul Lewis 组织了一个令人敬畏的视频系列，演示如何构建媒体播放器以及拥有非常棒的特性的 Progressive Web Apps。他在YouTube上建立了&lt;a href=&quot;https://www.youtube.com/playlist?list=PLNYkxOF6rcIBykcJ7bvTpqU7vt-oey72J&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;一系列视频&lt;/a&gt;，这些视频是在他建立网站的每一部分的过程中发生的。观看开发者展示他们工作的视频绝对是我最喜欢学习新事物的方法之一！&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="lazyload" scheme="http://robin-front.github.io/tags/lazyload/"/>
    
      <category term="performance" scheme="http://robin-front.github.io/tags/performance/"/>
    
      <category term="optimization" scheme="http://robin-front.github.io/tags/optimization/"/>
    
      <category term="IntersectionObserver" scheme="http://robin-front.github.io/tags/IntersectionObserver/"/>
    
  </entry>
  
  <entry>
    <title>你可能不知道的JSON用法及误区</title>
    <link href="http://robin-front.github.io/2017/07/28/you-may-dont-know-JSON/"/>
    <id>http://robin-front.github.io/2017/07/28/you-may-dont-know-JSON/</id>
    <published>2017-07-28T01:17:36.000Z</published>
    <updated>2017-07-28T01:17:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="再谈-JSON-你可能不知道的一些-JSON-用法及误区"><a href="#再谈-JSON-你可能不知道的一些-JSON-用法及误区" class="headerlink" title="再谈 JSON, 你可能不知道的一些 JSON 用法及误区"></a>再谈 JSON, 你可能不知道的一些 JSON 用法及误区</h1><p>最近也是看到很多人在讨论 <code>JSON</code>, 但有些点说得不太准确，翻翻犀牛书，再次复习一下。</p><h2 id="JSON-stringify-value-replacer-space"><a href="#JSON-stringify-value-replacer-space" class="headerlink" title="JSON.stringify(value [, replacer [, space]])"></a>JSON.stringify(value [, replacer [, space]])</h2><p>第一个参数一般是对象（Object）或数组（Array），或 <code>javascript</code> 基本值。</p><h3 id="误区：不支持的值都会被忽略"><a href="#误区：不支持的值都会被忽略" class="headerlink" title="误区：不支持的值都会被忽略"></a>误区：不支持的值都会被忽略</h3><p><strong>首先 JSON 只能序列化可枚举的值，其次 <code>undefined</code>，<code>NaN</code>，<code>Infinity</code>，<code>function</code>, <code>Date</code>, <code>RegExp</code>, <code>Error</code> 这些值或对象都是不支持的，但并不是这些值都会被忽略。</strong><a id="more"></a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="built_in">Symbol</span>(), <span class="comment">// 新增的 ES6 基本值</span></div><div class="line">  b: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</div><div class="line">  <span class="attr">c</span>: <span class="literal">undefined</span>,</div><div class="line">  <span class="attr">d</span>: <span class="literal">NaN</span>,</div><div class="line">  <span class="attr">e</span>: <span class="literal">Infinity</span>,</div><div class="line">  <span class="attr">f</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">1</span>;&#125;,</div><div class="line">  <span class="attr">g</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(),</div><div class="line">  <span class="attr">h</span>: <span class="regexp">/^\d$/gi</span>,</div><div class="line">  <span class="attr">i</span>: <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'err'</span>),</div><div class="line">  <span class="attr">j</span>: &#123;&#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">JSON</span>.stringify(o);</div><div class="line"></div><div class="line"><span class="comment">// output: '&#123;"b":[1,2,3],"d":null,"e":null,"g":"2017-07-28T02:56:37.102Z","h":&#123;&#125;,"i":&#123;&#125;,"j":&#123;&#125;&#125;'</span></div></pre></td></tr></table></figure><p>由上可以看出：</p><ul><li><code>Symbol</code>, <code>undefined</code>, <code>function</code> 会直接被忽略</li><li><code>NaN</code>, <code>Infinity</code> 被转换成了 <code>null</code></li><li><code>RegExp</code>, <code>Error</code> 则被转成了空对象 {}</li></ul><h3 id="replacer"><a href="#replacer" class="headerlink" title="replacer"></a>replacer</h3><p>因为 <code>JSON.stringify()</code> 序列化不支持部分值，所以不能简单地使用 <code>JSON</code> 的两个方法进行深拷贝。但可以利用 <code>JSON.stringify()</code> 的第二个参数进行正确序列化。</p><p><strong>但这并不推荐，因为 JSON.parse() 仍然无法还原不被支持的值。只有对象字面量 Object 和 数组 Array 可以被正确还原，其他都变成字符串</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 沿用上一例子的代码</span></div><div class="line"><span class="keyword">var</span> replacer = <span class="function"><span class="keyword">function</span>(<span class="params">k ,v</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> type = <span class="keyword">typeof</span> v;</div><div class="line">  <span class="keyword">if</span>(type === <span class="string">'function'</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Function</span>.prototype.toString.call(v)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (type === <span class="string">'undefined'</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'undefined'</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (type === <span class="string">'number'</span>)&#123;</div><div class="line">    <span class="keyword">if</span> (v !== v)&#123;</div><div class="line">      <span class="keyword">return</span> <span class="string">'NaN'</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (v === <span class="literal">Infinity</span>)&#123;</div><div class="line">      <span class="keyword">return</span> <span class="string">'Infinity'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (type === <span class="string">'symbol'</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Symbol</span>.prototype.toString.call(v)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (v <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">RegExp</span>.prototype.toString.call(v)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (v <span class="keyword">instanceof</span> <span class="built_in">Error</span> &amp;&amp; v.name !== <span class="string">''</span> &amp;&amp; v.message !== <span class="string">''</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'new '</span> + v.name + <span class="string">'('</span>+ v.message +<span class="string">')'</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> v</div><div class="line">&#125;</div><div class="line"><span class="built_in">JSON</span>.stringify(o, replacer);</div><div class="line"></div><div class="line"><span class="comment">//  output: '&#123;"a":"Symbol()","b":[1,2,3],"c":"undefined","d":"NaN","e":"Infinity","f":"function ()&#123; return 1;&#125;","g":"2017-07-28T02:56:37.102Z","h":"/^\\d$/gi","i":"new Error(err)","j":&#123;&#125;&#125;'</span></div></pre></td></tr></table></figure><p>另外一个用法就是传入数组，指定需要序列化的key.这个在提取部分属性的时候也是很有用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 沿用上面的代码</span></div><div class="line"><span class="built_in">JSON</span>.stringify(o, [<span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>]);</div><div class="line"></div><div class="line"><span class="comment">// output: '&#123;"b":[1,2,3],"d":null&#125;'</span></div></pre></td></tr></table></figure><h3 id="space"><a href="#space" class="headerlink" title="space"></a>space</h3><p>是一个可选的美化属性，序列化时是没有换行和空格的，此参数可指定一个数值（大于10则限制为10）或一组字符（长度最长为10个字符), 此参数不为空会自动插入换行。</p><p><strong>但是设置为字符时，无法使用 parse 复原</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">JSON</span>.stringify(o, <span class="literal">null</span>, <span class="string">'-'</span>);</div><div class="line"><span class="comment">// '&#123;</span></div><div class="line"><span class="comment">// -"b": [</span></div><div class="line"><span class="comment">// --1,</span></div><div class="line"><span class="comment">// --2,</span></div><div class="line"><span class="comment">// --3</span></div><div class="line"><span class="comment">// -],</span></div><div class="line"><span class="comment">// -"d": null,</span></div><div class="line"><span class="comment">// -"e": null,</span></div><div class="line"><span class="comment">// -"g": "2017-07-28T02:56:37.102Z",</span></div><div class="line"><span class="comment">// -"h": &#123;&#125;,</span></div><div class="line"><span class="comment">// -"i": &#123;&#125;,</span></div><div class="line"><span class="comment">// -"j": &#123;&#125;</span></div><div class="line"><span class="comment">// &#125;'</span></div></pre></td></tr></table></figure><h2 id="JSON-parse-value-reviver"><a href="#JSON-parse-value-reviver" class="headerlink" title="JSON.parse(value[, reviver])"></a>JSON.parse(value[, reviver])</h2><p><code>JSON.parse</code> 与 <code>JSON.stringify</code> 操作正好相反，但 <code>value</code> 必须严格符合 <code>JSON</code> 格式，否则报错。</p><p>第二个参数可传入一个函数，用以转换解析出来的值。</p><p>比如 <code>Date</code> 对象在序列化之后无法逆转成一个 <code>Date</code> 对象，此时可写一个函数去转换：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reviver = <span class="function"><span class="keyword">function</span> (<span class="params">name, value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="regexp">/^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\d.\d\d\dZ$/</span>.test(value));</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'string'</span> &amp;&amp; <span class="regexp">/^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\d.\d\d\dZ$/</span>.test(value))&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(value)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> value</div><div class="line">&#125;</div><div class="line"><span class="comment">// 沿用前个例子的代码</span></div><div class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(o.g), reviver)</div><div class="line"><span class="comment">// output: Fri Jul 28 2017 10:56:37 GMT+0800 (+08)</span></div></pre></td></tr></table></figure><h2 id="toJSON"><a href="#toJSON" class="headerlink" title="toJSON()"></a>toJSON()</h2><p>有些文章会说 <code>Object.toJSON()</code> ，这是不对的，<code>Object</code> 原型上并没有定义 <code>toJSON</code> 方法，该方法只被定义在 <code>Date</code> 对象上。<code>JSON.stringify()</code> 在序列化的时候会首先查找该方法，如果有则直接返回 <code>toJSON</code> 的调用结果。这个一开始是让 <code>Date</code> 正确序列化成 <code>JSON</code> 时设计的。但我们也可以利用 <code>toJSON</code> 的屏蔽功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.toJSON = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Function</span>.prototype.toString.call(<span class="keyword">this</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 沿用上面的例子</span></div><div class="line"><span class="built_in">JSON</span>.stringify(o);</div><div class="line"><span class="comment">// &#123;"b":[1,2,3],"d":null,"e":null,"f":"function ()&#123; return 1;&#125;","g":"2017-07-28T02:56:37.102Z","h":&#123;&#125;,"i":&#123;&#125;,"j":&#123;&#125;&#125;</span></div></pre></td></tr></table></figure><p>会发现，<code>function</code> 没有被忽略，但此方法要慎用，在原型上添加方法可能产生副作用。</p><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;再谈-JSON-你可能不知道的一些-JSON-用法及误区&quot;&gt;&lt;a href=&quot;#再谈-JSON-你可能不知道的一些-JSON-用法及误区&quot; class=&quot;headerlink&quot; title=&quot;再谈 JSON, 你可能不知道的一些 JSON 用法及误区&quot;&gt;&lt;/a&gt;再谈 JSON, 你可能不知道的一些 JSON 用法及误区&lt;/h1&gt;&lt;p&gt;最近也是看到很多人在讨论 &lt;code&gt;JSON&lt;/code&gt;, 但有些点说得不太准确，翻翻犀牛书，再次复习一下。&lt;/p&gt;&lt;h2 id=&quot;JSON-stringify-value-replacer-space&quot;&gt;&lt;a href=&quot;#JSON-stringify-value-replacer-space&quot; class=&quot;headerlink&quot; title=&quot;JSON.stringify(value [, replacer [, space]])&quot;&gt;&lt;/a&gt;JSON.stringify(value [, replacer [, space]])&lt;/h2&gt;&lt;p&gt;第一个参数一般是对象（Object）或数组（Array），或 &lt;code&gt;javascript&lt;/code&gt; 基本值。&lt;/p&gt;&lt;h3 id=&quot;误区：不支持的值都会被忽略&quot;&gt;&lt;a href=&quot;#误区：不支持的值都会被忽略&quot; class=&quot;headerlink&quot; title=&quot;误区：不支持的值都会被忽略&quot;&gt;&lt;/a&gt;误区：不支持的值都会被忽略&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;首先 JSON 只能序列化可枚举的值，其次 &lt;code&gt;undefined&lt;/code&gt;，&lt;code&gt;NaN&lt;/code&gt;，&lt;code&gt;Infinity&lt;/code&gt;，&lt;code&gt;function&lt;/code&gt;, &lt;code&gt;Date&lt;/code&gt;, &lt;code&gt;RegExp&lt;/code&gt;, &lt;code&gt;Error&lt;/code&gt; 这些值或对象都是不支持的，但并不是这些值都会被忽略。&lt;/strong&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="JSON" scheme="http://robin-front.github.io/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>像 google 一样通过缩短 css 类名和作用域隔离来压缩优化 css 包的大小</title>
    <link href="http://robin-front.github.io/2017/07/24/reducing-css-bundle-size-by-cutting-the-class-names-and-using-scope-isolation/"/>
    <id>http://robin-front.github.io/2017/07/24/reducing-css-bundle-size-by-cutting-the-class-names-and-using-scope-isolation/</id>
    <published>2017-07-24T09:05:01.000Z</published>
    <updated>2017-07-24T09:05:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="像-google-一样通过缩短-css-类名和作用域隔离来压缩优化-css-包的大小"><a href="#像-google-一样通过缩短-css-类名和作用域隔离来压缩优化-css-包的大小" class="headerlink" title="像 google 一样通过缩短 css 类名和作用域隔离来压缩优化 css 包的大小"></a>像 google 一样通过缩短 css 类名和作用域隔离来压缩优化 css 包的大小</h1><blockquote><h2 id="就像-google-的做法一样"><a href="#就像-google-的做法一样" class="headerlink" title="就像 google 的做法一样"></a>就像 google 的做法一样</h2></blockquote><p>今年年初，我已经退出咨询公司并开始构建 <a href="https://go2cinema.com/" target="_blank" rel="external">GO2CINEMA</a> - 一个 <em>快速，简单和安全</em> 的方式来预订英国的电影票的网站。我做了一个辉煌的工作，使其快速，简单和安全。在其中某个阶段，我一直痴迷于关键渲染路径的优化。⚡️</p><p>我已经使用 <a href="https://github.com/gajus/usus" target="_blank" rel="external">ūsus</a> 解决了 HTML 的预渲染。ūsus 渲染单页应用程序（SPA）的 HTML，并<a href="https://medium.com/@gajus/pre-rendering-spa-for-seo-and-improved-perceived-page-loading-speed-47075aa16d24" target="_blank" rel="external">内嵌了用于呈现页面的 CSS</a>。但是，我并不喜欢在每个 HTML 文档内嵌 70 KB 的 css，特别是其中大部分是 CSS 类名。</p><a id="more"></a><h2 id="就像Google一样"><a href="#就像Google一样" class="headerlink" title="就像Google一样"></a>就像Google一样</h2><p>你有没有看过 <a href="https://www.google.com/" target="_blank" rel="external">https://www.google.com/</a> 的源代码？如果看过，您注意到的第一件事是会是，CSS 类名称没有超过几个字符。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*mGuDYFM56iyLi1MgZPC8bw.png" data-original="https://cdn-images-1.medium.com/max/800/1*mGuDYFM56iyLi1MgZPC8bw.png"></p><p>但是怎么样做到的呢？</p><h2 id="CSS-minifiers-的缺点"><a href="#CSS-minifiers-的缺点" class="headerlink" title="CSS minifiers 的缺点"></a>CSS minifiers 的缺点</h2><p>有一件事，<code>minifier</code> 不能做 - 改变选择器名称。这是因为 <code>CSS minifier</code> 不能控制 HTML 输出。同时，CSS 名称可以很长。</p><p>如果您使用 <code>CSS modules</code>，您的 CSS modules 可能会包含样式表文件名，本地标识名和随机哈希。使用 <a href="https://github.com/webpack-contrib/css-loader" target="_blank" rel="external">css-loader</a> <a href="https://github.com/webpack-contrib/css-loader" target="_blank" rel="external">localIdentName</a> 配置描述类名模板，例如<code>[name]___[local]___[hash:base64:5]</code>。因此，生成的类名称将如下所示 <code>.MovieView___movie-title___yvKVV</code> ; 如果你喜欢描述性的名字，它可能更长，例如 <code>.MovieView___movie-description-with-summary-paragraph___yvKVV</code> 。</p><h2 id="在编译时重命名-CSS-类名"><a href="#在编译时重命名-CSS-类名" class="headerlink" title="在编译时重命名 CSS 类名"></a>在编译时重命名 CSS 类名</h2><p>但是，如果您使用的是 <a href="https://webpack.js.org/" target="_blank" rel="external"><code>webpack</code></a> 和 <a href="https://github.com/gajus/babel-plugin-react-css-modules" target="_blank" rel="external"><code>babel-plugin-react-css-modules</code></a>，那么您很幸运 🍀 - 您可以使用 <code>css-loader</code> 的 <code>getLocalIdent</code> 配置项或者等效的 <code>babel-plugin-react-css-modules</code> 中的 <code>generateScopedName</code> 配置项来达到在编译时重命名类名的目的。</p><script src="https://gist.github.com/gajus/a70df30613ebd848ab1ce27f3e33aac2.js"></script><p><code>generateScopedName</code> 中很酷的是，同样的功能实例可以用于 <code>Babel</code> 和 <code>webpack</code> 的构建过程：</p><script src="https://gist.github.com/gajus/acc6684de7ef310e9fdcbfa502307e50.js"></script><h2 id="让名字变短"><a href="#让名字变短" class="headerlink" title="让名字变短"></a>让名字变短</h2><p>感谢 <code>babel-plugin-react-css-modules</code> 和 <code>css-loader</code> 共享相同的逻辑来生成 CSS 类名称，我们可以将类名改为任何我们喜欢的，甚至是随机哈希。然而，我想要最短的类名，而不是随机哈希。</p><p>为了生成最短的类名，我创建了类名索引，并使用该 <code>incstr</code> 模块为索引中的每个条目生成增量ID。</p><script src="https://gist.github.com/gajus/b61ab58c4243f189722c0c13e59cdd24.js"></script><p>这保证了类名简短并且唯一。现在，<code>.MovieView___movie-title___yvKVV</code> 和 <code>.MovieView___movie-description-with-summary-paragraph___yvKVV</code> 的类名都成了 <code>.a_a</code>, <code>.b_a</code>等。</p><p>这将 <code>GO2CINEMA</code> CSS 压缩包的大小从 140 KB 降低到 53KB。</p><h2 id="使用作用域隔离来进一步减少包的大小"><a href="#使用作用域隔离来进一步减少包的大小" class="headerlink" title="使用作用域隔离来进一步减少包的大小"></a>使用作用域隔离来进一步减少包的大小</h2><p>分离组件名称和本地标识符名称是一个很好的理由让我添加 <code>_</code> 到 CSS 类名 - 对于缩小文件大小特别有用。</p><p><a href="https://github.com/css/csso" target="_blank" rel="external">csso</a>（CSS minifier）具有<a href="https://github.com/css/csso#scopes" target="_blank" rel="external">作用域</a>配置。作用域定义了在某些标记上专门使用的类名列表，即来自不同作用域的选择器不会匹配同一个元素。这一条让优化规则更进一步。</p><p>要利用此功能，请使用 <a href="https://github.com/zoobestik/csso-webpack-plugin" target="_blank" rel="external"><code>csso-webpack-plugin</code></a> 来后处理 CSS 包：</p><script src="https://gist.github.com/gajus/720ece26d03ea901b515c9b80b6ac4c8.js"></script><p>这使 GO2CINEMA CSS 捆绑包的大小从 53 KB 降至 47 KB。</p><h2 id="这值得么？"><a href="#这值得么？" class="headerlink" title="这值得么？"></a>这值得么？</h2><p>这种压缩的第一个争议是觉得压缩算法本来就可以做到。使用 <a href="https://en.wikipedia.org/wiki/Brotli" target="_blank" rel="external">Brotli</a> 算法压缩的 GO2CINEMA CSS 包与长类名的原始包相比只压缩了 1 KB。</p><p>另一方面，设置这个缩小是一次性投入，它减少了需要解析的文档的大小。它还具有其他好处，例如阻止依赖 CSS类名称的扫描仪导航或意外匹配广告拦截器<a href="https://gist.github.com/spyesx/42fe84c0ef757d1c38a4" target="_blank" rel="external">黑名单</a>的 CSS选择器。</p><p>同时，您可以看到在 GO2CINEMA 和 venue 页面上使用的这种压缩的演示，例如</p><ul><li><a href="https://go2cinema.com/movies/wonder-woman-2017-1305237" target="_blank" rel="external">https://go2cinema.com/movies/wonder-woman-2017-1305237</a></li><li><a href="https://go2cinema.com/venues/odeon-oxford-magdalen-st-1001053" target="_blank" rel="external">https://go2cinema.com/venues/odeon-oxford-magdalen-st-1001053</a></li></ul><p>【翻译原文】：<a href="https://medium.freecodecamp.org/reducing-css-bundle-size-70-by-cutting-the-class-names-and-using-scope-isolation-625440de600b" target="_blank" rel="external">https://medium.freecodecamp.org/reducing-css-bundle-size-70-by-cutting-the-class-names-and-using-scope-isolation-625440de600b</a></p><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;像-google-一样通过缩短-css-类名和作用域隔离来压缩优化-css-包的大小&quot;&gt;&lt;a href=&quot;#像-google-一样通过缩短-css-类名和作用域隔离来压缩优化-css-包的大小&quot; class=&quot;headerlink&quot; title=&quot;像 google 一样通过缩短 css 类名和作用域隔离来压缩优化 css 包的大小&quot;&gt;&lt;/a&gt;像 google 一样通过缩短 css 类名和作用域隔离来压缩优化 css 包的大小&lt;/h1&gt;&lt;blockquote&gt;&lt;h2 id=&quot;就像-google-的做法一样&quot;&gt;&lt;a href=&quot;#就像-google-的做法一样&quot; class=&quot;headerlink&quot; title=&quot;就像 google 的做法一样&quot;&gt;&lt;/a&gt;就像 google 的做法一样&lt;/h2&gt;&lt;/blockquote&gt;&lt;p&gt;今年年初，我已经退出咨询公司并开始构建 &lt;a href=&quot;https://go2cinema.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GO2CINEMA&lt;/a&gt; - 一个 &lt;em&gt;快速，简单和安全&lt;/em&gt; 的方式来预订英国的电影票的网站。我做了一个辉煌的工作，使其快速，简单和安全。在其中某个阶段，我一直痴迷于关键渲染路径的优化。⚡️&lt;/p&gt;&lt;p&gt;我已经使用 &lt;a href=&quot;https://github.com/gajus/usus&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ūsus&lt;/a&gt; 解决了 HTML 的预渲染。ūsus 渲染单页应用程序（SPA）的 HTML，并&lt;a href=&quot;https://medium.com/@gajus/pre-rendering-spa-for-seo-and-improved-perceived-page-loading-speed-47075aa16d24&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;内嵌了用于呈现页面的 CSS&lt;/a&gt;。但是，我并不喜欢在每个 HTML 文档内嵌 70 KB 的 css，特别是其中大部分是 CSS 类名。&lt;/p&gt;
    
    </summary>
    
      <category term="css" scheme="http://robin-front.github.io/categories/css/"/>
    
    
      <category term="react" scheme="http://robin-front.github.io/tags/react/"/>
    
      <category term="webpack" scheme="http://robin-front.github.io/tags/webpack/"/>
    
      <category term="css" scheme="http://robin-front.github.io/tags/css/"/>
    
      <category term="minifier" scheme="http://robin-front.github.io/tags/minifier/"/>
    
  </entry>
  
  <entry>
    <title>桂林山水最强徒步攻略-大圩古镇-奇峰镇-会仙镇-葡萄镇至兴坪古镇20公里经典徒步路线</title>
    <link href="http://robin-front.github.io/2017/07/23/Daxu-village-Huixian-wetland-Putao-Xingping-of-Guilin/"/>
    <id>http://robin-front.github.io/2017/07/23/Daxu-village-Huixian-wetland-Putao-Xingping-of-Guilin/</id>
    <published>2017-07-23T02:42:17.000Z</published>
    <updated>2017-07-23T02:42:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我可不是一个酒店享受者，我的玩法是 don’t stop, keep your step.</p></blockquote><h1 id="桂林山水最强徒步攻略-大圩古镇-奇峰镇-会仙镇-葡萄镇至兴坪古镇20公里经典徒步路线"><a href="#桂林山水最强徒步攻略-大圩古镇-奇峰镇-会仙镇-葡萄镇至兴坪古镇20公里经典徒步路线" class="headerlink" title="桂林山水最强徒步攻略-大圩古镇-奇峰镇-会仙镇-葡萄镇至兴坪古镇20公里经典徒步路线"></a>桂林山水最强徒步攻略-大圩古镇-奇峰镇-会仙镇-葡萄镇至兴坪古镇20公里经典徒步路线</h1><p>对于每个地方并不打算去两次的人来说（除了一些体验特别好的地方），一次性打包看完一个地方所有感兴趣的地点是最合适的。所以，每次去完，总是把一个市，甚至一个省的攻略都做完了。或许也是一种强迫症吧。</p><p>其实国内很多景点都是坑，网上照片基本都不是原片。写攻略是为了方便别人，也是为坑了别人一起，哈哈，顺便记录。<a id="more"></a></p><h2 id="路线规划"><a href="#路线规划" class="headerlink" title="路线规划"></a>路线规划</h2><p>下面先简要看看总体路线规划：</p><p>Day 1: 火车 ——&gt; 桂林市 ——&gt; 大圩古镇（+熊村） Day 2: 大圩古镇 ——&gt; 奇峰镇（遇到不可抗因素）——&gt; 会仙镇 Day 3: 会仙湿地 ——&gt; 玻璃田 ——&gt; 葡萄镇 Day 4: 葡萄镇 至 兴坪古镇 经典徒步路线 20 公里 ——&gt; 相公山（日落） Day 5: 相公山（日出）——&gt; 相公山至兴坪古镇 ——&gt; 老寨山（日落）——&gt; 阳朔高铁最后一班回（8pm）</p><p>补充几张线路图：</p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/guilin/tubu.jpeg" data-original="/images/guilin/tubu.jpeg"> <img src="/js/lazyload-plugin/loading.svg" alt="/images/guilin/tubu2.jpeg" data-original="/images/guilin/tubu2.jpeg"> 葡萄镇至兴坪古镇 徒步路线图</p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/guilin/huixian.jpeg" data-original="/images/guilin/huixian.jpeg"> 会仙玻璃田路线图</p><h2 id="大圩古镇（大墟）"><a href="#大圩古镇（大墟）" class="headerlink" title="大圩古镇（大墟）"></a>大圩古镇（大墟）</h2><p>“明清时期繁华一时的大圩古镇”。</p><p>在桂林火车站旁边的桂林长途汽车总站坐开往冠岩的专线车，40分钟左右即可到达大圩，票价5元左右。</p><p>古镇不大，1小时足以游完，距大圩镇8公里（在大圩路口能看到指路牌）的熊村（大圩县城搭公交过去3元）。</p><p>村上保留着完整的旧时村落格局，有上百栋明清建筑，现存有湖南会馆、江西会馆、财神殿等，村子的老建筑上保留了许多文革标语。</p><p>小吃：姜汁桂花凉粉</p><p>“大圩江上芦田寺，百尺深潭万竹围。柳店积薪晨爨后，僮人荷叶裹盐归”</p><h2 id="奇峰镇（李家村）"><a href="#奇峰镇（李家村）" class="headerlink" title="奇峰镇（李家村）"></a>奇峰镇（李家村）</h2><p>在桂林火车站对面搭乘4路车，开往奇峰镇方向，在 <strong>东山村</strong> 下车。每趟运行单程时间大约是40分钟。（我是大圩直接坐摩的30元抄小路到奇峰镇）</p><p>奇峰镇外看奇峰，万点尖峰锁碧空。</p><p><strong>事实上，里面是军事管制区，只有本村村民才能进。公交车到村口就被强制下车。请不要来这里，没有开放</strong></p><h2 id="会仙镇"><a href="#会仙镇" class="headerlink" title="会仙镇"></a>会仙镇</h2><p>桂林汽车站，乘坐桂林—会仙的班车，每隔15分钟一趟，票价8元（直达），也可在雁中路口，师大侧门坐车。</p><blockquote><p>秋天去看一片金黄，或田地放水时，一片天镜。</p></blockquote><ul><li><p>会仙湿地： 正在开发中，酒店食宿全没有，一年后应该会有。到睦洞村委路口，然后乘坐前往毛家村的三轮车每人2元钱（实际上有时会坑你10元）。也可从路口步行至毛家村，大概40分钟左右，路边一大片农田，湿地公园有一大片荷花。一般摄影人会去龙山，售票口的人会建议你坐船过去上龙山。票价不菲。觉得值可以坐。如果是穷学生，那就买门票，走过去，船是走近路直接到山脚，走路就要十八弯，40分钟左右。再不济，往回走有条岔路，是通向刚刚入口方向，人少时没人守，免票进入，这是我出来的时候发现的。</p></li><li><p>玻璃田： 湿地是后开发的，最开始出名的是玻璃田这一块。山也不难找，就是下图的 D 点，上山点在村口医院前。</p></li></ul><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/guilin/huixian.jpeg" data-original="/images/guilin/huixian.jpeg"></p><h2 id="葡萄镇"><a href="#葡萄镇" class="headerlink" title="葡萄镇"></a>葡萄镇</h2><p>这是个中转休息点，是经典徒步路线的起点。从会仙过来的话，先坐车到 雁中路口，师大侧门，然后在南下的大路上拦去阳朔的车，在葡萄镇下车。</p><p>《石头城到兴坪徒步 - 居高临下欣赏山水画卷》（总长度22.5公里）: 这条徒步线路清幽古朴，游人罕至，途中每一次登高俯视，都将为您展开一幅不同的阳朔山水画卷。阳朔的经典摄影主题，葡萄田园风光(地处阳朔葡萄镇乌龙村，拍摄葡萄田园风光多为逆光拍摄，应选择有太阳的天气下午4-5时到达山顶等候拍摄)、相公山日出以及老寨山日落，都在这条线路上。途径古朴的石头城以及兴坪老街，又给这条线路增加了人文风情。线路最好分两天完成，这样可以夜宿相公山以便第二天观看日出。全程难度不大，两三人轻装便可出发，沿途村庄可以补给，也可带少量食物和水以防万一</p><p>当然，这条路线可以反着来走，但我是从会仙过来的，这样走更顺路，最后阳朔高铁回。</p><p>【徒步线路A：小耀门村–石头寨–大岩头村–小冲崴村–大坪村–水岩门村–相公山–黄泥田村–镰刀湾村–大河背村–渔村村–兴坪镇。（全程约19公里） 徒步线路B：小耀门村—石头寨—大岩头村—小冲崴村—大坪村–水岩门村–相公山–荷苞山村–冷水村–画山村–兴坪镇。（全程约18公里）】 (PS: 其实应该有25公里，我在石头城迷路，走得太累，后来还搭了一段顺风车到相公山)</p><h2 id="兴坪古镇"><a href="#兴坪古镇" class="headerlink" title="兴坪古镇"></a>兴坪古镇</h2><p>相公山到冷水村路不太好走，比想象中远，但其实应该有近路，因为在路上有岔路，但地图上没有标。去冷水村需要渡河，10元。本地人免费。冷水村到兴坪古镇一路是风景，也可坐三轮车过去。下车点就是20元人民币上的图。之后在老寨山看日落。下山在汽车站坐小面包 5元到阳朔高铁站回。</p><h2 id="详细影摄"><a href="#详细影摄" class="headerlink" title="详细影摄"></a>详细影摄</h2><p>上面都是交通简要，下面是影摄：</p><blockquote><p>（待更。。）</p></blockquote><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;我可不是一个酒店享受者，我的玩法是 don’t stop, keep your step.&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 id=&quot;桂林山水最强徒步攻略-大圩古镇-奇峰镇-会仙镇-葡萄镇至兴坪古镇20公里经典徒步路线&quot;&gt;&lt;a href=&quot;#桂林山水最强徒步攻略-大圩古镇-奇峰镇-会仙镇-葡萄镇至兴坪古镇20公里经典徒步路线&quot; class=&quot;headerlink&quot; title=&quot;桂林山水最强徒步攻略-大圩古镇-奇峰镇-会仙镇-葡萄镇至兴坪古镇20公里经典徒步路线&quot;&gt;&lt;/a&gt;桂林山水最强徒步攻略-大圩古镇-奇峰镇-会仙镇-葡萄镇至兴坪古镇20公里经典徒步路线&lt;/h1&gt;&lt;p&gt;对于每个地方并不打算去两次的人来说（除了一些体验特别好的地方），一次性打包看完一个地方所有感兴趣的地点是最合适的。所以，每次去完，总是把一个市，甚至一个省的攻略都做完了。或许也是一种强迫症吧。&lt;/p&gt;&lt;p&gt;其实国内很多景点都是坑，网上照片基本都不是原片。写攻略是为了方便别人，也是为坑了别人一起，哈哈，顺便记录。
    
    </summary>
    
      <category term="travel" scheme="http://robin-front.github.io/categories/travel/"/>
    
    
      <category term="travel" scheme="http://robin-front.github.io/tags/travel/"/>
    
  </entry>
  
  <entry>
    <title>马萨萨海滩(masasa beach) 旅行预算指南</title>
    <link href="http://robin-front.github.io/2017/07/22/masasa-beach-travel-guide/"/>
    <id>http://robin-front.github.io/2017/07/22/masasa-beach-travel-guide/</id>
    <published>2017-07-22T03:29:35.000Z</published>
    <updated>2017-07-22T03:29:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="假期旅行之菲律宾系列之二-——-马萨萨海滩-masasa-beach"><a href="#假期旅行之菲律宾系列之二-——-马萨萨海滩-masasa-beach" class="headerlink" title="假期旅行之菲律宾系列之二 —— 马萨萨海滩(masasa beach)"></a>假期旅行之菲律宾系列之二 —— 马萨萨海滩(masasa beach)</h1><p>马萨沙滩可以说是 Tingloy 最好的海滩，这是 Batangas 唯一不在大陆吕宋岛上。它的主要岛屿是鱼形马里卡班（Maricaban），位于 Calumpang 半岛的一角，将巴拉扬湾（Balayan Bay）与八打雁湾（Batangas Bay）分开。</p><p>事实是，这里的沙滩不像你在长滩岛或巴拉望岛所期望的那样像白色珍珠，但是马萨沙滩在缺乏亮度的沙滩中展现出波浪的气息。它的水晶般清澈，浅水散发出美丽的绿松石闪光，即使远距离也能吸引您的注意。<a id="more"></a></p><p>来这里主要是玩水，如果你喜欢游泳，来这里吧。我是在这学会狗爬式的。哈哈。。 先来看看一些照片。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="http://www.thepoortraveler.net/wp-content/uploads/2014/02/Mabini-Tingloy-Map.png" data-original="http://www.thepoortraveler.net/wp-content/uploads/2014/02/Mabini-Tingloy-Map.png"> 小岛是一个小鱼形状，很可爱</p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/masasa/IMG_1398.JPG" data-original="/images/masasa/IMG_1398.JPG"> 在 Anilao Port 坐公共船只</p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/masasa/IMG_1419.JPG" data-original="/images/masasa/IMG_1419.JPG"> 到达 小鱼岛 ，准备浮潜，小哥很卖力！</p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/masasa/IMG_1429.JPG" data-original="/images/masasa/IMG_1429.JPG"> 没错，螃蟹船很好看，他们喜欢涂成各种颜色，艺术细胞不错。以及。。真正蓝色的大海，而不是灰色的。</p><p>浮潜只需100p !!超便宜，一定要尝试一下，虽然只是带着你转一圈，但是可以看到各种海龟，珊瑚，长带鱼等。怪不得很多本地大学生来！经济漂亮！但是我没有拍到好的海底照片。。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/masasa/IMG_1439.JPG" data-original="/images/masasa/IMG_1439.JPG"> 沙子确实不怎么样，但是水还是不错</p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/masasa/IMG_1477.JPG" data-original="/images/masasa/IMG_1477.JPG"> 水清见底</p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/masasa/IMG_1478.JPG" data-original="/images/masasa/IMG_1478.JPG"> 全貌</p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/masasa/IMG_1539.JPG" data-original="/images/masasa/IMG_1539.JPG"> 家庭出行非常多</p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/masasa/IMG_1588.JPG" data-original="/images/masasa/IMG_1588.JPG"> 香蕉船</p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/masasa/IMG_1643.JPG" data-original="/images/masasa/IMG_1643.JPG"> 附近村庄的小卖部的老人</p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/masasa/IMG_1692.JPG" data-original="/images/masasa/IMG_1692.JPG"> 这是什么，谁能告诉我</p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/masasa/IMG_1702.JPG" data-original="/images/masasa/IMG_1702.JPG"> 其实来到这里再找住宿也可以，因为很多，到处都是</p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/masasa/IMG_1732.JPG" data-original="/images/masasa/IMG_1732.JPG"> 菲菲 <img src="/js/lazyload-plugin/loading.svg" alt="/images/masasa/IMG_1741.JPG" data-original="/images/masasa/IMG_1741.JPG"></p><h2 id="交通"><a href="#交通" class="headerlink" title="交通"></a>交通</h2><ul><li><p>bus,在八打雁市区 Batangas Grand Terminal下车（3-4 小时）（<strong>同样的，半夜出发，早上到达，不然会塞车</strong>） 在LRT- Gil Puyat 车站旁边有公共汽车站（DLTB liner 或 JAM liner）。（注意，越早越好。如果您选择一辆带有 CALABARZON 标志的公共汽车，旅行时间将会更短）P120-P180。</p></li><li><p>转吉普尼（1小时） 40 minutes. Fare: PhP 37. 终点站是 Mabini Multi-purpose port.（又名 Anilao Port）(在habagat season季节，终点站是 Talaga Port )</p></li><li><p>a. 在 Anilao Port 坐船(<strong>推荐</strong>)（45min） 如果要在岛上住一晚，就选择公共船只，最便宜，P80。旅行时间：45分钟 - 1小时。 直接坐船到 masasa beach。但是直达的船更少，不可预测，P100 （注意，最后一艘返回 Anilao的船是上午九点，所以不得不住一晚,有些船在较小的码头在中午12点可以接乘客回,具体可以咨询当地人上船地点）</p></li><li><p>b. 如果是一日游，租船P4500，可坐10人，可以讲价。如果租船，可以要求中途登陆 Sombrero岛，上岛费 P200，有些要P500.（算是跳岛游，比较贵）</p></li></ul><h2 id="住宿"><a href="#住宿" class="headerlink" title="住宿"></a>住宿</h2><p>我当时是在 facebook 上搜索 masasa 然后联系的住宿，P300 每人！没有酒店。其实那里旁边有村子，有很多过夜的地方。以前可以在沙滩露营过夜，但后来不允许了。</p><h2 id="其他项目"><a href="#其他项目" class="headerlink" title="其他项目"></a>其他项目</h2><ul><li>环岛游： 标准费率：P1500，岛上可以联系当地船只。</li><li>浮潜：P100 !!我是当时住宿的人帮我安排联系的，30min,时间不长</li></ul><h2 id="费用清单"><a href="#费用清单" class="headerlink" title="费用清单"></a>费用清单</h2><ul><li>到八打雁的票价车票：票价：P157 从LRT-Buendia 出发，P127 从阿拉邦出发。</li><li>吉隆尼到阿尼洛的吉普尼票价：P37</li><li>从Anilao出发的小船出租（岛屿游览）：每船P4500（最大10人）Masasa</li><li>海滩的小船出租（岛屿游览）：每船P1500（3pax最大）</li><li>公共小船到 Tingloy：P80（推荐）</li><li>三轮车到马萨沙滩：P120/辆</li><li>环境费：P30</li><li>马萨沙滩：免费</li><li>Sombrero Island 上岛费：P200</li><li>租帐篷 P200</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>masasa beach只有一个洗手间，收费，P10 每次；</li><li>过夜可能没有电，带好充电宝；</li><li>看好天气，晴天比阴天更漂亮，水更清；</li></ul><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;假期旅行之菲律宾系列之二-——-马萨萨海滩-masasa-beach&quot;&gt;&lt;a href=&quot;#假期旅行之菲律宾系列之二-——-马萨萨海滩-masasa-beach&quot; class=&quot;headerlink&quot; title=&quot;假期旅行之菲律宾系列之二 —— 马萨萨海滩(masasa beach)&quot;&gt;&lt;/a&gt;假期旅行之菲律宾系列之二 —— 马萨萨海滩(masasa beach)&lt;/h1&gt;&lt;p&gt;马萨沙滩可以说是 Tingloy 最好的海滩，这是 Batangas 唯一不在大陆吕宋岛上。它的主要岛屿是鱼形马里卡班（Maricaban），位于 Calumpang 半岛的一角，将巴拉扬湾（Balayan Bay）与八打雁湾（Batangas Bay）分开。&lt;/p&gt;&lt;p&gt;事实是，这里的沙滩不像你在长滩岛或巴拉望岛所期望的那样像白色珍珠，但是马萨沙滩在缺乏亮度的沙滩中展现出波浪的气息。它的水晶般清澈，浅水散发出美丽的绿松石闪光，即使远距离也能吸引您的注意。
    
    </summary>
    
      <category term="travel" scheme="http://robin-front.github.io/categories/travel/"/>
    
    
      <category term="travel" scheme="http://robin-front.github.io/tags/travel/"/>
    
      <category term="philippine" scheme="http://robin-front.github.io/tags/philippine/"/>
    
  </entry>
  
  <entry>
    <title>Borawan island、Pagbilao Beach 和 Dampalitan island旅行预算指南——一个周末三个沙滩</title>
    <link href="http://robin-front.github.io/2017/07/22/borawan-island-Pagbilao-beach-and-Dampalitan-island/"/>
    <id>http://robin-front.github.io/2017/07/22/borawan-island-Pagbilao-beach-and-Dampalitan-island/</id>
    <published>2017-07-22T00:30:22.000Z</published>
    <updated>2017-07-22T00:30:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一个孩子的冒险故事 ————讲故事的人</p></blockquote><h1 id="假期旅行之菲律宾系列之一-————-Borawan岛、Pagbilao岛、Dampalitan岛"><a href="#假期旅行之菲律宾系列之一-————-Borawan岛、Pagbilao岛、Dampalitan岛" class="headerlink" title="假期旅行之菲律宾系列之一 ———— Borawan岛、Pagbilao岛、Dampalitan岛"></a>假期旅行之菲律宾系列之一 ———— Borawan岛、Pagbilao岛、Dampalitan岛</h1><p>坐落在奎松南部的边缘，布尔戈斯（Padre Burgos）和帕格比洛（Pagbilao）的城镇面向泰巴巴斯湾（Tayabas Bay），这是分离大陆吕宋岛和马林杜克岛（Marinduque）的通道。马尼拉市区的这一边只有四到五个小时的路程，甚至远远近于 Pangasinan和碧瑶（Baguio）。<a id="more"></a></p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/20170722/IMG_4158.JPG" data-original="/images/20170722/IMG_4158.JPG"> 这是Puting Buhangin，Pagbilao（也叫Kuwebang Lampas）最推荐，请在这里规划最长的时间</p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/20170722/IMG_4157.JPG" data-original="/images/20170722/IMG_4157.JPG"></p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/20170722/IMG_4139.JPG" data-original="/images/20170722/IMG_4139.JPG"></p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/20170722/IMG_3918.JPG" data-original="/images/20170722/IMG_3918.JPG"> <img src="/js/lazyload-plugin/loading.svg" alt="/images/20170722/IMG_3904.JPG" data-original="/images/20170722/IMG_3904.JPG"> Borawan，背靠山，是另一种风景，和岩石拍照特别好看。这是 Borawan 的日落。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/20170722/IMG_3979.JPG" data-original="/images/20170722/IMG_3979.JPG"> 水面很平静，没有浪，很适合游泳</p><p><img src="/js/lazyload-plugin/loading.svg" alt="/images/20170722/IMG_3383.JPG" data-original="/images/20170722/IMG_3383.JPG"> Dampalitan， 水很清！ <img src="/js/lazyload-plugin/loading.svg" alt="/images/20170722/IMG_3613.JPG" data-original="/images/20170722/IMG_3613.JPG"> <img src="/js/lazyload-plugin/loading.svg" alt="/images/20170722/IMG_3654.JPG" data-original="/images/20170722/IMG_3654.JPG"> 天气很好！</p><h2 id="公共交通如何到达"><a href="#公共交通如何到达" class="headerlink" title="公共交通如何到达"></a>公共交通如何到达</h2><ul><li>公共汽车站：JAM liner, DLTB liner, JAC liner. 位于 Taft Ave.</li><li>乘公共汽车到卢塞纳市（Lucena）。马尼拉大都会有许多终点站到卢塞纳。票价介于P250-260之间。旅行时间：3-4小时。</li><li>在卢塞纳站下车（Lucena Grand Terminal）。</li><li>a. 从终点站乘坐另一辆巴士到 Unisan。公共汽车没有空调，票价在P35-40左右。旅行时间：1个半小时。 b. 也有小面包车 （Vans），有招客牌写着 Unisan，说去 QCRB Bank 下车，大概 60p 每人</li><li>在QCRB银行（Padre Burgos）下车，或者 <strong>提前告诉司机让你这里下车</strong>。</li><li>乘坐三轮车到 Aplaya。告诉司机你打算去Borawan， 只需 20p。</li><li>在 Aplaya 有小船出租。这些船只可以带您前往 Puting Buhangin（Pagbilao），Dampalitan岛和Borawan岛的一个岛屿游览。P1500 - P2000，适合10人以下。</li></ul><h2 id="行程参考时间表"><a href="#行程参考时间表" class="headerlink" title="行程参考时间表"></a>行程参考时间表</h2><p>半夜出发是最合适的，早上就到。如果早上出发，你会在路上塞车并浪费一整天。不要把白天玩的时间浪费在车上。</p><ol><li>2:00 - Buendia Bus Terminal(DLTB liner or JAM liner)坐车 (P227-P250, 4h)【凌晨两点出发，早上六点到】 目的地：Lucena Grand Terminal</li><li>6:00 - Lucena Grand Terminal换乘去 Unisan 的公交bus（P35 - P40）【1.5h, 预计七点半到】</li><li>7:00 - 在 QCRB BANK下车。换tricycle三轮车（10min），去Aplaya (和司机说要去 Borawan)</li><li>在Aplaya租船 8:00 出发。</li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>该地区有水母（jerryfish），请一定注意，Borawan沙滩尤其多，所以建了水网区域游泳，不要在非安全区域游泳。被水母蛰了也不要惊慌，提前了解处理方法，使用碱性溶液（如肥皂水等）清洗。Pagbilao岛、Dampalitan岛比较安全，下水前可以询问岛上工作人员能否下水，或与其他人一同下水，勿单独游泳。</p><h2 id="露营或酒店或租船"><a href="#露营或酒店或租船" class="headerlink" title="露营或酒店或租船"></a>露营或酒店或租船</h2><p>Borawan 和 Dampalitan Islands 没有度假村或酒店，但允许露营过夜。如果你不是野营的类型，那么大陆有几个度假村，你可以选择留下来。以下是我收集的简短列表：</p><ul><li>Silangang Nayon餐厅和度假村。位于Pagbilao，它是Bicol绑定的路途跋涉者之间的共同点，他们渴望品尝到他们美味的Pinoy海鲜菜肴。他们只有少量的房间，所以如果你要在旺季，提前预订。联系电话：（042）7160077，0922 8867677</li></ul><p>但，如果你认为你是一个野营旅行，为什么不露营呢？露营不仅降低了成本，还使您更好地欣赏岛屿，从而使您更接近自然。所有你需要的是一个帐篷和一些易于准备的食品。如果有冲泡食品，沙滩小卖部有热水出售，20p。</p><p>租船（完全可以去到再租，如果不放心，可以提前询问）： 09501928546，09094819703</p><p>大部分人会在 Borawan 沙滩 和 Pagbilao 沙滩过夜，这两个地方有冲凉房和公厕，免费使用。我建议在 Puthang Buhangin, Pagbilao 过夜，那里水最清。</p><h2 id="备用物品提示"><a href="#备用物品提示" class="headerlink" title="备用物品提示"></a>备用物品提示</h2><ul><li>化妆品和防晒霜 - 通常。在岛上有商店，但预计价格有点过高，所以更好地带上洗发水，肥皂，牙膏，卫生纸和湿巾。Dampalitan 岛上有公厕，但水有点稀少。</li><li>防蚊洗剂 - 很多人会忘记带来。岛上有蚊子。</li><li>手电筒 - 那里偶尔会停电</li><li>打火机和很多故事 - 你会被诱惑开始篝火，你将需要打火机点火和对话，以保持燃烧。</li><li>急救包 - 你永远不会知道意外什么时候发生。</li><li>浮潜装置 - 我们没有看到活珊瑚，但有很多鱼。特别是在 Dampalitan和Pagbilao，这两个沙滩水更清。</li><li>防水相机 - Kuwebang Lampas（在Puthang Buhangin, Pagbilao）是非常棒的，但去那里的水很深。如果您想要在洞穴内的图片，防水相机非常有用。</li></ul><h2 id="预算详细条目"><a href="#预算详细条目" class="headerlink" title="预算详细条目"></a>预算详细条目</h2><p>以下是您期望的费用和其他费用清单。</p><p>乘船游览费（8人乘车）： P800 - Borawan海滩（往返） P1800 - Borawan + Dampalitan + Puting Buhangin（三岛两天一夜，这是总船费，不是每次）</p><p>Borawan海滩 上岛费：P80 帐篷租金：P500(买一个帐篷去最好，便宜的才1000p左右，还能带回去) 小屋出租：P700-P850 过夜费： P220每人 帐篷占地费用：P200-P250(分占地大小)</p><p>Puting Buhangin，Pagbilao 上岛费：P80 帐篷出租：P300-400</p><p>Dampalitan 岛 上岛费：P80 帐篷占地费：P100 小屋出租：P850-P1000 水：P40/5L，P400/大桶</p><p>以上费用可能会涨价，但不会偏离太多。最重要是带好食物和饮用水。过夜请拿好票据，以免其他员工再次来收钱。</p><h2 id="一般顺序："><a href="#一般顺序：" class="headerlink" title="一般顺序："></a>一般顺序：</h2><ul><li><strong>推荐：Borawan（9：00-午餐） ==&gt; Puting buhangin（14：00-过夜） ===&gt; Dampalitan (10：00 - 14:00回程)</strong></li><li>Puting buhangin（9：00） ==&gt; Dampalitan（11：30-午餐） ===&gt; Borawan (14：00 - 过夜)</li><li>Puting buhangin（9：00-午餐）===&gt; Borawan（14：00-过夜）===&gt; Dampalitan(10:00- 14:00回程)</li></ul><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;一个孩子的冒险故事 ————讲故事的人&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 id=&quot;假期旅行之菲律宾系列之一-————-Borawan岛、Pagbilao岛、Dampalitan岛&quot;&gt;&lt;a href=&quot;#假期旅行之菲律宾系列之一-————-Borawan岛、Pagbilao岛、Dampalitan岛&quot; class=&quot;headerlink&quot; title=&quot;假期旅行之菲律宾系列之一 ———— Borawan岛、Pagbilao岛、Dampalitan岛&quot;&gt;&lt;/a&gt;假期旅行之菲律宾系列之一 ———— Borawan岛、Pagbilao岛、Dampalitan岛&lt;/h1&gt;&lt;p&gt;坐落在奎松南部的边缘，布尔戈斯（Padre Burgos）和帕格比洛（Pagbilao）的城镇面向泰巴巴斯湾（Tayabas Bay），这是分离大陆吕宋岛和马林杜克岛（Marinduque）的通道。马尼拉市区的这一边只有四到五个小时的路程，甚至远远近于 Pangasinan和碧瑶（Baguio）。
    
    </summary>
    
      <category term="travel" scheme="http://robin-front.github.io/categories/travel/"/>
    
    
      <category term="travel" scheme="http://robin-front.github.io/tags/travel/"/>
    
      <category term="philippine" scheme="http://robin-front.github.io/tags/philippine/"/>
    
  </entry>
  
  <entry>
    <title>高性能 react：3种加快应用程序的新工具</title>
    <link href="http://robin-front.github.io/2017/07/18/make-react-fast-again-tools-and-techniques-for-speeding-up-your-react-app/"/>
    <id>http://robin-front.github.io/2017/07/18/make-react-fast-again-tools-and-techniques-for-speeding-up-your-react-app/</id>
    <published>2017-07-18T07:25:02.000Z</published>
    <updated>2017-07-18T07:25:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高性能-react：3种加快应用程序的新工具"><a href="#高性能-react：3种加快应用程序的新工具" class="headerlink" title="高性能 react：3种加快应用程序的新工具"></a>高性能 react：3种加快应用程序的新工具</h1><p>react 通常很快，但很容易造成导致性能问题的小错误。缓慢的组件安装，深层组件树和不必要的渲染循环可以快速添加到一个感觉缓慢的应用程序。</p><p>幸运的是，有很多工具，有些甚至内置于 React，这有助于诊断性能问题。在这篇文章中，我将强调使 React 应用程序更快速的工具和技术。每个部分还有一个互动，（希望）有趣的演示！<a id="more"></a></p><h2 id="工具＃1：性能时间表"><a href="#工具＃1：性能时间表" class="headerlink" title="工具＃1：性能时间表"></a>工具＃1：性能时间表</h2><p>React 15.4.0引入了一个新的性能时间轴功能，可让您准确了解组件的挂载，更新和卸载。它还可以让您可视化相关的组件生命周期。</p><p>注意：现在，此功能仅适用于Chrome，Edge和IE，因为它利用了尚未在所有浏览器中实现的用户时间轴API（User Timing API）。</p><h3 id="怎么运行的"><a href="#怎么运行的" class="headerlink" title="怎么运行的"></a>怎么运行的</h3><ul><li>打开你的应用程序并附加查询参数：<code>react_perf</code>。例如，<code>http://localhost:3000?react_perf</code></li><li>打开Chrome DevTools 性能选项卡，然后按 <strong>记录（Record）</strong>。</li><li>执行您要分析的操作。</li><li>停止记录</li><li>在 <code>User Timing</code> 下检查可视化。</li></ul><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/1000/1*cOO5vUnbkdDUcqMW8ebJqA.png" data-original="https://cdn-images-1.medium.com/max/1000/1*cOO5vUnbkdDUcqMW8ebJqA.png"></p><h3 id="了解输出"><a href="#了解输出" class="headerlink" title="了解输出"></a>了解输出</h3><p>每个彩色条显示组件正在做“工作”的时间。由于JavaScript是单线程的，每当组件正在加载或呈现时，它会阻止主线程，并阻止其他代码运行。</p><p>方括号中的文字<code>[update]</code>描述了组件生命周期的哪个部分正在发生。时间轴会分解每个步骤，因此您可以在<code>[componentDidMount]</code> <code>[componentWillReceiveProps]</code> <code>[ctor]</code>（构造函数）和 <code>[render]</code> 方法上看到细粒度的时序.</p><p>堆叠的条表示组件树。虽然在React中具有相当深的组件树是典型的，但如果要优化经常安装的组件，则可以帮助减少封装组件的数量，因为每个组件都会增加小的性能和内存损失。</p><p>这里有一点值得注意的是，时间表中的时间序列是用于开发构建React的，它比生产环境更慢。事实上，甚至性能时间表本身会减慢您的应用程序。虽然这些数字不应该被认为是真实表现的性能，但是不同组件之间的相对定时是准确的。此外，组件是否更新完全不依赖于生产环境上的构建。</p><h3 id="演示＃1"><a href="#演示＃1" class="headerlink" title="演示＃1"></a>演示＃1</h3><p>为了乐趣，我操纵了TodoMVC应用程序，出现一些严重的性能问题。你可以在<a href="https://perf-demo.firebaseapp.com/?react_perf" target="_blank" rel="external">这里试试看</a>。</p><p>要查看时间轴，请打开Chrome开发工具，转到“性能”选项卡，然后单击记录。然后在应用程序中添加一些TODO，停止录制并检查时间轴。看看是否可以发现哪些组件导致性能问题:)</p><h2 id="工具＃2：为什么更新"><a href="#工具＃2：为什么更新" class="headerlink" title="工具＃2：为什么更新"></a>工具＃2：为什么更新</h2><p>影响 React 中性能的最常见问题之一是不必要的渲染循环。默认情况下，即使他们的 props 没有改变，React 组件将在父级 render 时重新 render。</p><p>例如，如果我有一个这样的简单组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DumbComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> &#123;this.props.value&#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>加上父组件:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">      <span class="tag">&lt;<span class="name">DumbComponent</span> <span class="attr">value</span>=<span class="string">&#123;3&#125;</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>无论何时父组件 render，<code>DumbComponent</code> 都会重新 render，尽管其 <code>props</code> 没有改变。</p><p>通常，如果 render 运行，并且没有对虚拟DOM进行任何更改，则这是一个浪费的渲染循环，因为该 render 方法应该是纯的，并且没有任何副作用。在大规模的 React 应用程序中，检测发生这种情况的地方可能很棘手，但幸运的是，有一个可以帮助的工具！</p><h3 id="使用-why-did-you-update"><a href="#使用-why-did-you-update" class="headerlink" title="使用 why-did-you-update"></a>使用 why-did-you-update</h3><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/1000/1*Lb4nr_WLwnLt63jUoszrnQ.png" data-original="https://cdn-images-1.medium.com/max/1000/1*Lb4nr_WLwnLt63jUoszrnQ.png"></p><p><code>why-did-you-update</code> 是一个挂接到 React 的库，并检测潜在的不必要的组件渲染。它检测组件的render方法何时被调用，尽管它的 <code>props</code> 没有改变。</p><h3 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h3><p>安装 <code>npm： npm i --save-dev why-did-you-update</code></p><p>在您的应用程序的任何地方添加此代码段：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">  <span class="keyword">const</span> &#123;whyDidYouUpdate&#125; = <span class="built_in">require</span>(<span class="string">'why-did-you-update'</span>)</div><div class="line">  whyDidYouUpdate(React)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>请注意，此工具在本地开发中非常出色，但确保在生产中已被禁用，因为它会减慢您的应用程序。</p><h3 id="了解输出-1"><a href="#了解输出-1" class="headerlink" title="了解输出"></a>了解输出</h3><p><code>why-did-you-update</code> 监视您的应用程序运行并记录可能会不必要地更改的组件。它允许您在渲染循环之前和之后看到 <code>props</code>，确定它可能是不必要的。</p><h3 id="演示＃2"><a href="#演示＃2" class="headerlink" title="演示＃2"></a>演示＃2</h3><p>为了演示<code>why-did-you-update</code>，我将库安装在 TodoMVC 应用程序的 Code Sandbox 上，这是一个在线 React 游戏场。打开浏览器控制台并添加一些 TODO 以查看输出。</p><p><a href="https://codesandbox.io/s/xGJP4QExn" target="_blank" rel="external">这是演示</a></p><blockquote><p>请注意，应用程序中的几个组件不必要地 render。尝试实现上述技术来防止不必要的渲染。如果正确完成，则<code>why-did-you-update</code>控制台中不应有输出。</p></blockquote><h2 id="工具＃3：反应开发工具"><a href="#工具＃3：反应开发工具" class="headerlink" title="工具＃3：反应开发工具"></a>工具＃3：反应开发工具</h2><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/1000/1*1Ih6h8djFyH13tfFK3D1sw.png" data-original="https://cdn-images-1.medium.com/max/1000/1*1Ih6h8djFyH13tfFK3D1sw.png"></p><p>React 开发者工具 Chrome 扩展程序具有可视化组件更新的内置功能。这有助于检测不必要的渲染循环。要使用它，首先请确保在<a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=zh-CN" target="_blank" rel="external">此处安装扩展</a>。</p><p>然后，点击Chrome DevTools中的“React”标签打开扩展程序，然后选中“Highlight Updates”。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*GP4vXvW3WO0vTbggDfus4Q.png" data-original="https://cdn-images-1.medium.com/max/800/1*GP4vXvW3WO0vTbggDfus4Q.png"></p><p>然后，只需使用你的应用程序。与各种组件交互，并观看 DevTools 工作的魔力。</p><h3 id="了解输出-2"><a href="#了解输出-2" class="headerlink" title="了解输出"></a>了解输出</h3><p>“react 开发人员工具”突出显示在给定时间点重新呈现的组件。根据更新的频率，使用不同的颜色。对于频繁更新的组件，蓝色显示不频繁更新，按更新频率依次为绿色，黄色和红色。</p><p>看到黄色或红色不一定是坏事。当调整滑块或触发频繁更新的其他UI元素时，可以预期。但是，如果您点击一个简单的按钮并看到红色，这可能意味着某些东西是错误的。该工具的目的是发现不必要的更新的组件。作为应用程序开发人员，您应该有一个一般的想法，哪些组件应该在给定的时间更新。</p><h3 id="演示＃3"><a href="#演示＃3" class="headerlink" title="演示＃3"></a>演示＃3</h3><p>为了演示组件突出显示，我安装了 TodoMVC 应用程序来不必要地更新某些组件。</p><p><a href="https://highlight-demo.firebaseapp.com/" target="_blank" rel="external">这是演示</a></p><p>打开上面的链接，然后打开 React Developer Tools 并启用更新突出显示。当您输入顶部文本输入时，您将看到所有 TODO 都不必要地突出显示。当您输入更快时，您将看到颜色更改以指示更频繁的更新。</p><h2 id="修复不必要的渲染"><a href="#修复不必要的渲染" class="headerlink" title="修复不必要的渲染"></a>修复不必要的渲染</h2><p>一旦识别出应用程序中不必要的重新渲染的组件，就会有一些简单的修复。</p><h3 id="使用PureComponent"><a href="#使用PureComponent" class="headerlink" title="使用PureComponent"></a>使用PureComponent</h3><p>在上面的例子中，<code>DumbComponent</code> 是它 props 的纯函数。也就是说，该组件只有在其 <code>props</code> 更改时才需要重新 render。React 有一种内置的特殊类型的组件，<code>PureComponent</code> 这个类型是为这个用例准备的。</p><p>而不是继承自 <code>React.Component</code>，请使用 <code>React.PureComponent</code>，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DumbComponent</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> &#123;this.props.value&#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后，该组件只有在其 <code>props</code> 实际更改时才会重新 render。而已！</p><p>请注意，<code>PureComponent</code>做一个 <code>props</code> 的浅比较，所以如果你使用复杂的数据结构，它可能会错过一些 <code>props</code> 更改，而不是更新您的组件。</p><h3 id="实现-shouldComponentUpdate"><a href="#实现-shouldComponentUpdate" class="headerlink" title="实现 shouldComponentUpdate"></a>实现 shouldComponentUpdate</h3><p><code>shouldComponentUpdate</code> 是 render 任何一个 <code>props</code> 或 <code>state</code> 更改之前调用的组件方法。如果 <code>shouldComponentUpdate</code> 返回 <code>true</code>，render 将被调用，如果它返回 <code>false</code>，没有任何反应。</p><p>通过实现此方法，您可以指示 React 避免重新渲染给定的组件，当其 <code>props</code> 不更改的时候。</p><p>例如，我们可以像下面这样，在一个组件中实现一个 <code>shouldComponentUpdate</code> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DumbComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  shouldComponentUpdate(nextProps) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.value !== nextProps.value) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">render() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="调试生产中的性能问题"><a href="#调试生产中的性能问题" class="headerlink" title="调试生产中的性能问题"></a>调试生产中的性能问题</h2><p>如果您在自己的机器上运行应用程序，“React Developer Tools”才能起作用。如果您有兴趣了解用户在生产中看到的性能问题，请尝试使用<a href="https://logrocket.com/" target="_blank" rel="external">LogRocket</a>。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/1000/1*s_rMyo6NbrAsP-XtvBaXFg.png" data-original="https://cdn-images-1.medium.com/max/1000/1*s_rMyo6NbrAsP-XtvBaXFg.png"></p><p><a href="https://logrocket.com/" target="_blank" rel="external">LogRocket</a> 就像是网络应用程序，记录 DVR 字面上 的一切，您网站上发生的。您可以使用错误或性能问题重播会话，而不是猜测为什么会出现问题，以快速了解根本原因。</p><p>LogRocket 为您的应用程序记录性能数据，Redux actions/state，日志，错误，网络请求/响应与标题+主体和浏览器元数据。它还在页面上记录HTML和CSS，重新创建即使是最复杂的单页应用程序的像素视频。</p><blockquote><p>【翻译原文链接】：<a href="https://medium.freecodecamp.org/make-react-fast-again-tools-and-techniques-for-speeding-up-your-react-app-7ad39d3c1b82" target="_blank" rel="external">https://medium.freecodecamp.org/make-react-fast-again-tools-and-techniques-for-speeding-up-your-react-app-7ad39d3c1b82</a></p></blockquote><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;高性能-react：3种加快应用程序的新工具&quot;&gt;&lt;a href=&quot;#高性能-react：3种加快应用程序的新工具&quot; class=&quot;headerlink&quot; title=&quot;高性能 react：3种加快应用程序的新工具&quot;&gt;&lt;/a&gt;高性能 react：3种加快应用程序的新工具&lt;/h1&gt;&lt;p&gt;react 通常很快，但很容易造成导致性能问题的小错误。缓慢的组件安装，深层组件树和不必要的渲染循环可以快速添加到一个感觉缓慢的应用程序。&lt;/p&gt;&lt;p&gt;幸运的是，有很多工具，有些甚至内置于 React，这有助于诊断性能问题。在这篇文章中，我将强调使 React 应用程序更快速的工具和技术。每个部分还有一个互动，（希望）有趣的演示！
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="react" scheme="http://robin-front.github.io/tags/react/"/>
    
      <category term="tools" scheme="http://robin-front.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>Redux 并不慢，只是你使用姿势不对 —— 一份优化指南</title>
    <link href="http://robin-front.github.io/2017/07/17/react-redux-optimization/"/>
    <id>http://robin-front.github.io/2017/07/17/react-redux-optimization/</id>
    <published>2017-07-17T09:12:02.000Z</published>
    <updated>2017-07-17T09:12:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redux-并不慢，只是你使用姿势不对-——-一份优化指南"><a href="#Redux-并不慢，只是你使用姿势不对-——-一份优化指南" class="headerlink" title="Redux 并不慢，只是你使用姿势不对 —— 一份优化指南"></a>Redux 并不慢，只是你使用姿势不对 —— 一份优化指南</h1><p><em>如何优化使用了 Redux 的 react 应用程序并不是显而易见的。但实际上相当简单。这是一个简短的指南，以及一些例子。</em></p><p>当优化使用 Redux 的 react 应用程序时，我经常听到有人说 Redux 缓慢。在99％的情况下，性能不佳的原因（适用于任何其他框架）与不必要的渲染相关联，因为 DOM 更新是昂贵的！在本文中，您将学习如何在使用 Redux 绑定 react 时避免不必要的 <code>render</code>。</p><p>通常，我们使用<a href="https://github.com/reactjs/react-redux" target="_blank" rel="external">官方 react 绑定的 Redux</a> 的 <a href="https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options" target="_blank" rel="external">connect</a> 高阶组件， 当您的 Redux <code>store</code> 更新时，react 组件就会更新。这是一个将组件包装在另一个组件中的函数，该组件订阅了 Redux <code>store</code> 中的更改，并渲染 <code>store</code>，这就是它的子节点更新的原因。<a id="more"></a></p><h2 id="快速入坑-react-redux，官方-react-绑定-Redux"><a href="#快速入坑-react-redux，官方-react-绑定-Redux" class="headerlink" title="快速入坑 react-redux，官方 react 绑定 Redux"></a>快速入坑 react-redux，官方 react 绑定 Redux</h2><p>该 <code>connect</code> 高阶组件实际上是已经过优化。要了解如何最好地使用它，最好了解先它是如何工作的！</p><p>Redux 以及 react-redux 实际上是相当小的库，所以源代码并不费解。我鼓励大家阅读源代码，或至少其中的一些。如果你想进一步，编写自己的实现，它将让你深入了解为什么库的设计方式是这样的。</p><p>不用多说，我们来看看 react 绑定的工作原理。正如我们公认的那样，react 绑定的核心部分就是 <code>connect</code> 高阶组件，这是它的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"></span></span></div><div class="line">  mapStateToProps,</div><div class="line">  mapDispatchToProps,</div><div class="line">  mergeProps,</div><div class="line">  &#123;</div><div class="line">    pure = true,</div><div class="line">    areStatesEqual = strictEqual,</div><div class="line">    areOwnPropsEqual = shallowEqual,</div><div class="line">    areStatePropsEqual = shallowEqual,</div><div class="line">    areMergedPropsEqual = shallowEqual,</div><div class="line">    ...extraOptions</div><div class="line">  &#125; = &#123;&#125;</div><div class="line">) &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>作为附注 - 唯一的强制性参数是 <code>mapStateToProps</code>，在大多数情况下，您只需要前两个参数。但是，我在这里使用完整的写法来说明 <code>react bindings</code> 是如何工作的。</p><p>传递给 <code>connect</code> 函数的所有参数都用于生成一个对象，该对象作为 <code>props</code> 传递到封装的组件上。<code>mapStateToProps</code> 用于将状态从 Redux store 映射到一个对象，<code>mapDispatchToProps</code> 用于生成包含函数的对象 - 通常这些函数是 <code>actions</code> 创建者。最后，<code>mergeProps</code> 有三个参数 <code>stateProps</code>，<code>dispatchProps</code> 和 <code>ownProps</code>。第一个是 <code>mapStateToProps</code> 的结果，第二个参数是 <code>mapDispatchToProps</code> 的结果，第三个参数是从组件本身继承的 <code>props</code> 对象。默认情况下，<code>mergeProps</code> 将这些参数简单地组合到一个对象中，但是如果您传递一个函数作为 <code>mergeProps</code> 参数，<code>connect</code> 则将使用该函数生成封装组件的 <code>props</code>。</p><p><code>connect</code> 函数的第四个参数是一个 <code>options</code> 对象。这包含5个选项：<code>pure</code> 可以是 <code>true</code> 或 <code>false</code>，以及确定是否重新渲染组件的4个函数（应该返回一个布尔值）。<code>pure</code> 默认设置为<code>true</code>。如果设置为<code>false</code>，则<code>connect</code> 将跳过任何优化，并且<code>options</code>对象中的4个函数将不生效。我个人不能想到一个用例，但是如果您希望关闭优化，则将其设置为<code>false</code>。</p><p>我们的 <code>mergeProps</code> 函数产生的对象与最后一个 <code>props</code> 对象进行比较。如果我们的 <code>connect</code> 认为 <code>props</code> 对象已经改变了，那么这个组件就会重新渲染。要了解库如何决定是否有变更，我们可以查看该 <code>shallowEqual</code> 功能。如果函数返回 <code>true</code>，组件将不会重新渲染，如果返回 <code>false</code>，它将重新渲染。<code>shallowEqual</code> 执行此比较。下面你会看到 <code>shallowEqual</code> 方法的一部分，它告诉你所有你需要知道的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keysA.length; i++) &#123;</div><div class="line">  <span class="keyword">if</span> (!hasOwn.call(objB, keysA[i]) ||</div><div class="line">      !is(objA[keysA[i]], objB[keysA[i]])) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>总而言之，这是上面的代码：</p><p>它在 object a 中的 key 上循环，并检查 object B 是否拥有相同的属性。然后它检查 object A中的属性（具有相同名称）是否等于对象B的属性。如果只有一个比较返回false，那么对象将被视为不相等，并且会发生重新渲染。</p><p>这导致我们一个黄金法则：</p><h2 id="只给您的组件它需要呈现的数据"><a href="#只给您的组件它需要呈现的数据" class="headerlink" title="只给您的组件它需要呈现的数据"></a>只给您的组件它需要呈现的数据</h2><p>这说得很含糊，所以让我们用一些实际的例子来阐述。</p><h3 id="拆分连接的组件"><a href="#拆分连接的组件" class="headerlink" title="拆分连接的组件"></a>拆分连接的组件</h3><p>我看到人们这样做 订阅容器组件一系列状态，并通过 <code>props</code> 传递所有东西。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> BigComponent = <span class="function">(<span class="params">&#123; a, b, c, d &#125;</span>) =&gt;</span> (</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;CompA a=&#123;a&#125; /&gt;</div><div class="line">    &lt;CompB b=&#123;b&#125; /&gt;</div><div class="line">    &lt;CompC c=&#123;c&#125; /&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">);</div><div class="line"></div><div class="line">const ConnectedBigComponent = connect(</div><div class="line">  (&#123; a, b, c &#125;) =&gt; (&#123; a, b, c &#125;)</div><div class="line">);</div></pre></td></tr></table></figure><p>现在，每次要么a，b或c变化，BigComponent包括CompA，CompB并且CompC将重新呈现。</p><p>相反，拆分您的组件，不要害怕更多地使用 connect：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ConnectedA = connect(CompA, (&#123; a &#125;) =&gt; (&#123; a &#125;));</div><div class="line"><span class="keyword">const</span> ConnectedB = connect(CompB, (&#123; b &#125;) =&gt; (&#123; b &#125;));</div><div class="line"><span class="keyword">const</span> ConnectedC = connect(CompC, (&#123; c &#125;) =&gt; (&#123; c &#125;));</div><div class="line"></div><div class="line"><span class="keyword">const</span> BigComponent = <span class="function"><span class="params">()</span> =&gt;</span> (</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;ConnectedA a=&#123;a&#125; /&gt;</div><div class="line">    &lt;ConnectedB b=&#123;b&#125; /&gt;</div><div class="line">    &lt;ConnectedC c=&#123;c&#125; /&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">);</div></pre></td></tr></table></figure><p>通过此次更新，<code>CompA</code> 将只有当<code>a</code>已经改变才会重新渲染，<code>CompB</code>当<code>b</code>改变等。考虑这样一个场景，每一个值<code>a</code>，<code>b</code>并<code>c</code>分别经常更新。对于每次更新，我们现在重新渲染一个，而不是所有组件。这几乎没有什么明显的三个组件，但如果你有更多！</p><h3 id="改变你的状态，使其尽可能的最小"><a href="#改变你的状态，使其尽可能的最小" class="headerlink" title="改变你的状态，使其尽可能的最小"></a>改变你的状态，使其尽可能的最小</h3><p>这是一个假设（稍微设计过）的例子：</p><p>你有一个大的项目列表，我们假设有300或更多。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;List&gt;</div><div class="line">  &#123;<span class="keyword">this</span>.props.items.map(<span class="function">(<span class="params">&#123; content, itemId &#125;</span>) =&gt;</span> (</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ListItem</span></span></span></div><div class="line">      <span class="attr">onClick</span>=<span class="string">&#123;selectItem&#125;</span></div><div class="line">      <span class="attr">content</span>=<span class="string">&#123;content&#125;</span></div><div class="line">      <span class="attr">itemId</span>=<span class="string">&#123;itemId&#125;</span></div><div class="line">      <span class="attr">key</span>=<span class="string">&#123;itemId&#125;</span></div><div class="line">    /&gt;</div><div class="line">  ))&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">List</span>&gt;</span></div></pre></td></tr></table></figure><p>当我们点击一​​个列表项时，一个动作被触发，更新一个存储值 - <code>selectedItem</code>。每个列表项连接到 Redux 并获取<code>selectedItem</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ListItem = connect(</div><div class="line">  <span class="function">(<span class="params">&#123; selectedItem &#125;</span>) =&gt;</span> (&#123; selectedItem &#125;)</div><div class="line">)(SimpleListItem);</div></pre></td></tr></table></figure><p>我们正在做正确的事情，我们仅将组件连接到所需的状态。但是，当<code>selectedItem</code>更新时，所有<code>ListItem</code>组件都将重新渲染，因为我们返回的对象<code>selectedItem</code>已经更改。在此之前 <code>{ selectedItem: 123 }</code>，现在是 <code>{ selectedItem: 120 }</code>。</p><p>请记住，我们正在使用该 <code>selectedItem</code> 值来检查当前项目是否被选中。所以我们的组件真正需要知道的是它是否被选择 - 实质上是一个<code>Boolean</code>。<code>Boolean</code> 是伟大的，因为只有两个可能的值，<code>true</code> 或者 <code>false</code>。所以如果我们返回一个布尔值，而不是 <code>selectedItem</code> ，仅 <code>Boolean</code> 更改的两个项目将会重新渲染，这就是我们需要的。<code>mapStateToProps</code> 实际上 <code>props</code> 它是组件的第二个参数，我们可以用它来检查这是否实际上是选定的项目。以下是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ListItem = connect(</div><div class="line">  <span class="function">(<span class="params">&#123; selectedItem &#125;, &#123; itemId &#125;</span>) =&gt;</span> (&#123; <span class="attr">isSelected</span>: selectedItem === itemId &#125;)</div><div class="line">)(SimpleListItem);</div></pre></td></tr></table></figure><p>现在，只要我们的 <code>selectedItem</code> 值发生变化，只有两个组件重新呈现 - <code>ListItem</code> 现在已经被选择了，而且原来那个已经被取消选择了。</p><h3 id="保持数据扁平化"><a href="#保持数据扁平化" class="headerlink" title="保持数据扁平化"></a>保持数据扁平化</h3><p>在 <a href="http://redux.js.org/docs/recipes/reducers/NormalizingStateShape.html" target="_blank" rel="external">Redux文档提到</a> 这是一种最佳实践。保持您的store 扁平化是有益的一些原因。但是对于本文的主旨，嵌套会造成问题，因为为了让我们的应用程序尽可能的快，我们希望我们的更新尽可能的细微。假设我们有一个这样的嵌套形状：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">articles</span>: [&#123;</div><div class="line">    <span class="attr">comments</span>: [&#123;</div><div class="line">      <span class="attr">users</span>: [&#123;</div><div class="line">      &#125;]</div><div class="line">    &#125;]</div><div class="line">  &#125;],</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>为了优化我们的 <code>Article</code>，<code>Comment</code> 和 <code>User</code> 组件，我们现在需要所有的人订阅 <code>articles</code>，然后深深伸入这种结构只返回他们所需要的状态。相反地​​，如此设计你的形状更有意义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">articles</span>: [&#123;</div><div class="line">    ...</div><div class="line">  &#125;],</div><div class="line">  <span class="attr">comments</span>: [&#123;</div><div class="line">    <span class="attr">articleId</span>: ..,</div><div class="line">    <span class="attr">userId</span>: ...,</div><div class="line">    ...</div><div class="line">  &#125;],</div><div class="line">  <span class="attr">users</span>: [&#123;</div><div class="line">    ...</div><div class="line">  &#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后使用映射函数选择注释和用户信息。关于这一点的更多信息可以在 <a href="http://redux.js.org/docs/recipes/reducers/NormalizingStateShape.html" target="_blank" rel="external">Redux文档中阅读关于规范化状态的信息</a>。</p><h2 id="彩蛋：用于选择-Redux-state-的库"><a href="#彩蛋：用于选择-Redux-state-的库" class="headerlink" title="彩蛋：用于选择 Redux state 的库"></a>彩蛋：用于选择 Redux state 的库</h2><p>这是完全可选的，取决于您。通常所有以上的建议都足够深入地让你写出快速的 react 和 Redux 应用程序。但是有两个优秀的库使得选择状态更容易一些：</p><p><a href="https://github.com/reactjs/reselect" target="_blank" rel="external">Reselect</a> 是 <code>selectors</code> 为您的 Redux 应用程序编写的引人注目的工具。从重新选择文档：</p><ul><li>选择器可以计算派生数据，允许 Redux 存储尽可能小的状态。</li><li>选择器效率高。除非其中一个参数发生变化，否则不会重新计算选择器。</li><li>选择器是可组合的。它们可以用作其他选择器的输入。</li></ul><p>对于具有复杂接口，复杂状态 和/或 频繁更新的应用程序，重新选择可以帮助您轻松使您的应用程序更快！</p><p><a href="http://ramdajs.com/" target="_blank" rel="external">Ramda</a> 是一个功能强大的库，具有更高阶的函数。换句话说 - 用函数创建函数。由于我们的映射函数只是这个函数，所以我们可以很方便地使用 <code>Ramda</code> 创建我们的选择器。<code>Ramda</code> 可以有选择器的所有功能并做的更多。查看 <a href="https://github.com/ramda/ramda/wiki/Cookbook" target="_blank" rel="external">Ramda 食谱</a>的一些例子，您可以使用 Ramda 做什么。</p><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redux-并不慢，只是你使用姿势不对-——-一份优化指南&quot;&gt;&lt;a href=&quot;#Redux-并不慢，只是你使用姿势不对-——-一份优化指南&quot; class=&quot;headerlink&quot; title=&quot;Redux 并不慢，只是你使用姿势不对 —— 一份优化指南&quot;&gt;&lt;/a&gt;Redux 并不慢，只是你使用姿势不对 —— 一份优化指南&lt;/h1&gt;&lt;p&gt;&lt;em&gt;如何优化使用了 Redux 的 react 应用程序并不是显而易见的。但实际上相当简单。这是一个简短的指南，以及一些例子。&lt;/em&gt;&lt;/p&gt;&lt;p&gt;当优化使用 Redux 的 react 应用程序时，我经常听到有人说 Redux 缓慢。在99％的情况下，性能不佳的原因（适用于任何其他框架）与不必要的渲染相关联，因为 DOM 更新是昂贵的！在本文中，您将学习如何在使用 Redux 绑定 react 时避免不必要的 &lt;code&gt;render&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;通常，我们使用&lt;a href=&quot;https://github.com/reactjs/react-redux&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方 react 绑定的 Redux&lt;/a&gt; 的 &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;connect&lt;/a&gt; 高阶组件， 当您的 Redux &lt;code&gt;store&lt;/code&gt; 更新时，react 组件就会更新。这是一个将组件包装在另一个组件中的函数，该组件订阅了 Redux &lt;code&gt;store&lt;/code&gt; 中的更改，并渲染 &lt;code&gt;store&lt;/code&gt;，这就是它的子节点更新的原因。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="react" scheme="http://robin-front.github.io/tags/react/"/>
    
      <category term="redux" scheme="http://robin-front.github.io/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>优化 react 让它快如闪电——你是电，你是光，你是唯一的神话</title>
    <link href="http://robin-front.github.io/2017/07/17/react-at-light-speed/"/>
    <id>http://robin-front.github.io/2017/07/17/react-at-light-speed/</id>
    <published>2017-07-17T07:23:17.000Z</published>
    <updated>2017-07-17T07:23:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="光速-React"><a href="#光速-React" class="headerlink" title="光速 React"></a>光速 React</h1><h2 id="Vixlet-团队优化性能的经验教训"><a href="#Vixlet-团队优化性能的经验教训" class="headerlink" title="Vixlet 团队优化性能的经验教训"></a>Vixlet 团队优化性能的经验教训</h2><p>在过去一年多，我们 <a href="http://www.vixlet.com" target="_blank" rel="external">Vixlet</a> 的 web 团队已经着手于一个激动人心的项目：将我们的整个 web 应用迁移到 <code>React</code> + <code>Redux</code> 架构。对于整个团队来说，这是不断成长中的机会，在整个过程中，我们在这方面面临一些挑战。</p><p>因为我们的 web-app 可能有非常大的 feed 视图，包括成百上千的媒体、文本、视频、链接元素，我们花了相当多的时间寻找能充分利用 <code>React</code> 性能的方法。在这里，我们将分享我们这一路学到的一些经验教训。</p><p><strong>声明</strong>：<strong>下面讲的做法和方法更适用于我们具体应用的性能需求。然而，像所有的开发者建议的那样，最重要的是要考虑到你的应用程序和团队的实际需求。React 是一个开箱即用的框架，所以你可能不需要像我们一样细致地优化性能。话虽如此，我们还是希望你能在这篇文章里找到一些有用的信息。</strong><a id="more"></a></p><h3 id="基本优化"><a href="#基本优化" class="headerlink" title="基本优化"></a>基本优化</h3><p><img src="/js/lazyload-plugin/loading.svg" alt="" data-original="https://cdn-images-1.medium.com/max/800/1*UOGdUM1V_rGUbxLS-eaWdQ.gif"></p><p>向更大的世界迈出第一步。</p><h4 id="render-函数"><a href="#render-函数" class="headerlink" title="render() 函数"></a>render() 函数</h4><p>一般来说，要尽可能少地在 <code>render</code> 函数中做操作。如果非要做一些复杂操作或者计算，也许你可以考虑使用一个 <a href="https://en.wikipedia.org/wiki/Memoization" target="_blank" rel="external">memoized</a> 函数以便于缓存那些重复的结果。可以看看 <a href="https://lodash.com/docs#memoize" target="_blank" rel="external">Lodash.memoize</a>，这是一个开箱即用的记忆函数。</p><p>反过来讲，避免在组件的 <code>state</code> 上存储一些容易计算的值也很重要。举个例子，如果 <code>props</code> 同时包含 <code>firstName</code> 和 <code>lastName</code>，没必要在 <code>state</code> 上存一个 <code>fullName</code>，因为它可以很容易通过提供的 <code>props</code> 来获取。如果一个值可以通过简单的字符串拼接或基本的算数运算从 <code>props</code> 派生出来，那么没理由将这些值包含在组件的 <code>state</code> 上。</p><h4 id="Prop-和-Reconciliation"><a href="#Prop-和-Reconciliation" class="headerlink" title="Prop 和 Reconciliation"></a>Prop 和 Reconciliation</h4><p>重要的是要记住，只要 <code>props</code>（或 <code>state</code>）的值不等于之前的值，<code>React</code> 就会触发重新渲染。如果 <code>props</code> 或者 <code>state</code> 包含一个对象或者数组，嵌套值中的任何改变也会触发重新渲染。考虑到这一点，你需要注意在每次渲染的生命周期中，创建一个新的 <code>props</code> 或者 <code>state</code> 都可能无意中导致了性能下降。</p><p><strong>例子: 函数绑定的问题</strong></p><script src="https://gist.github.com/jacob-beltran/638dcc9978b498c82d68a19593266999.js"></script><p><strong>例子:</strong> <strong>对象或数组字面量</strong></p><script src="https://gist.github.com/jacob-beltran/7777a477942cbb2c9db65a1e3c312e88.js"></script><p><strong>例子</strong> <strong>: 注意字面量的回退值</strong></p><script src="https://gist.github.com/jacob-beltran/ae63069d95831fb49e59e74eb7ddbd11.js"></script><h4 id="尽可能的保持-Props（和-State）简单和精简"><a href="#尽可能的保持-Props（和-State）简单和精简" class="headerlink" title="尽可能的保持 Props（和 State）简单和精简"></a>尽可能的保持 Props（和 State）简单和精简</h4><p>理想情况下，传递给组件的 <code>props</code> 应该是它直接需要的。为了将值传给子组件而将一个大的、复杂的对象或者很多独立的 <code>props</code> 传递给一个组件会导致很多不必要的组件渲染（并且会增加开发复杂性）。</p><p>在 Vixlet，我们使用 Redux 作为状态容器，所以在我们看来，最理想的是方案在组件层次结构的每一个层级中使用 <a href="https://www.npmjs.com/package/react-redux" target="_blank" rel="external">react-redux</a> 的 <a href="https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options" target="_blank" rel="external">connect()</a> 函数直接从 <code>store</code> 上获取数据。<code>connect</code> 函数的性能很好，并且使用它的开销也非常小。</p><h4 id="组件方法"><a href="#组件方法" class="headerlink" title="组件方法"></a>组件方法</h4><p>由于组件方法是为组件的每个实例创建的，如果可能的话，使用 <code>helper/util</code> 模块的纯函数或者<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="external">静态类方法</a>。尤其在渲染大量组件的应用中会有明显的区别。</p><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p><img src="/js/lazyload-plugin/loading.svg" alt="" data-original="https://cdn-images-1.medium.com/max/800/1*9n2fdJB1gPYLFJAj5D5RqA.gif"></p><p>在我看来视图的变化是邪恶的！</p><h4 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate()"></a>shouldComponentUpdate()</h4><p>React 有一个生命周期函数 <a href="https://facebook.github.io/react/docs/react-component.html#shouldcomponentupdate" target="_blank" rel="external">shouldComponentUpdate()</a>。这个方法可以根据当前的和下一次的 <code>props</code> 和 <code>state</code> 来通知这个 React 组件是否应该被重新渲染。</p><p>然而使用这个方法有一个问题，开发者必须考虑到需要触发重新渲染的每一种情况。这会导致逻辑复杂，一般来说，会非常痛苦。如果非常需要，你可以使用一个自定义的 <code>shouldComponentUpdate()</code> 方法，但是很多情况下有更好的选择。</p><h4 id="React-PureComponent"><a href="#React-PureComponent" class="headerlink" title="React.PureComponent"></a>React.PureComponent</h4><p>React 从 <code>v15</code> 开始会包含一个 <code>PureComponent</code> 类，它可以被用来构建组件。<code>React.PureComponent</code> 声明了它自己的 <code>shouldComponentUpdate()</code> 方法，它自动对当前的和下一次的 <code>props</code> 和 <code>state</code> 做一次浅对比。有关浅对比的更多信息，请参考这个 Stack Overflow：</p><p><a href="http://stackoverflow.com/questions/36084515/how-does-shallow-compare-work-in-react" target="_blank" rel="external">http://stackoverflow.com/questions/36084515/how-does-shallow-compare-work-in-react</a></p><p>在大多数情况下，<code>React.PureComponent</code> 是比 <code>React.Component</code> 更好的选择。在创建新组件时，首先尝试将其构建为纯组件，只有组件需要更多功能时才使用 <code>React.Component</code>。</p><p>更多信息，请查阅相关文档 <a href="https://facebook.github.io/react/docs/react-api.html#react.purecomponent" target="_blank" rel="external">React.PureComponent</a>。</p><h4 id="组件性能分析（在-Chrome-里）"><a href="#组件性能分析（在-Chrome-里）" class="headerlink" title="组件性能分析（在 Chrome 里）"></a>组件性能分析（在 Chrome 里）</h4><p>在新版本的 Chrome <code>里，timeline</code> 工具里有一个额外的内置功能可以显示哪些 React 组件正在渲染以及他们花费的时间。要启用此功能，将 <code>?react_perf</code> 作为要测试的 URL 的查询字符串。React 渲染时间轴数据将位于 User Timing 部分。</p><p>更多相关信息，请查阅官方文档：<a href="https://facebook.github.io/react/docs/optimizing-performance.html#profiling-components-with-chrome-timeline" target="_blank" rel="external">Profiling Components with Chrome Timeline</a> 。</p><h4 id="有用的工具-why-did-you-update"><a href="#有用的工具-why-did-you-update" class="headerlink" title="有用的工具: why-did-you-update"></a>有用的工具: <a href="https://www.npmjs.com/package/why-did-you-update" target="_blank" rel="external">why-did-you-update</a></h4><p>这是一个很棒的 NPM 包，他们给 React 添加补丁，当一个组件触发了不必要的重新渲染时，它会在控制台输出一个 <code>console</code> 提示。</p><p><strong>注意</strong>: 这个模块在初始化时可以通过一个过滤器匹配特定的想要优化的组件，否则你的命令行可能会被垃圾信息填满，并且可能你的浏览器会因此而挂起或者崩溃，查阅 <a href="https://www.npmjs.com/package/why-did-you-update" target="_blank" rel="external">why-did-you-update 文档</a> 获取更多详细信息。</p><h3 id="常见性能陷阱"><a href="#常见性能陷阱" class="headerlink" title="常见性能陷阱"></a>常见性能陷阱</h3><p><img src="/js/lazyload-plugin/loading.svg" alt="" data-original="https://cdn-images-1.medium.com/max/800/1*GVteDSQnhXZCSui8JRp10A.gif"></p><h4 id="setTimeout-和-setInterval"><a href="#setTimeout-和-setInterval" class="headerlink" title="setTimeout() 和 setInterval()"></a>setTimeout() 和 setInterval()</h4><p>在 React 组件中使用 <code>setTimeout()</code> 或者 <code>setInterval()</code> 要十分小心。几乎总是有更好的选择，例如 ‘resize’ 和 ‘scroll’ 事件（注意：有关注意事项请参阅下一节）。</p><p>如果你需要使用 <code>setTimeout()</code> 和 <code>setInterval()</code>，你必须 <strong>遵守下面两条建议</strong></p><blockquote><p>不要设置过短的时间间隔。</p></blockquote><p>当心那些小于 100 ms 的定时器，他们很可能是没意义的。如果确实需要一个更短的时间，可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" target="_blank" rel="external">window.requestAnimationFrame()</a> 替代。</p><blockquote><p>保留对这些函数的引用，并且在 unmount 时取消或者销毁他们。</p></blockquote><p><code>setTimeout()</code> 和 <code>setInterval()</code> 都返回一个延迟函数的引用，并且需要的时候可以取消它们。由于这些函数是在全局作用域执行的，他们不在乎你的组件是否存在，这会导致报错甚至程序卡死。</p><p><strong>注意</strong>: 对 <code>window.requestAnimationFrame()</code> 来说也是如此</p><p>解决这个问题最简答的方法是使用 <a href="https://www.npmjs.com/package/react-timeout" target="_blank" rel="external">react-timeout</a> 这个 NPM 包，它提供了一个可以自动处理上述内容的高阶组件。它将 setTimeout/setInterval 等功能添加到包装组建的 <code>props</code> 上。(<strong>特别感谢 Vixlet 的开发人员 <a href="https://twitter.com/@carlpillot" target="_blank" rel="external"><em>Carl Pillot</em></a> 提供这个方法</strong>)</p><p>如果你不想引入这个依赖，并且希望自行解决此问题，你可以使用以下的方法：</p><script src="https://gist.github.com/jacob-beltran/910bd1d7ede863cd8178c0ecb40a075f.js"></script><p>如果你使用 requestAnimationFrame() 执行的一个动画循环，可以使用一个非常相似的解决方案，当前代码要有一点小的修改：</p><script src="https://gist.github.com/jacob-beltran/aa114af1b6fd5de866aa365e3763a90b.js"></script><h4 id="未-去抖-频繁触发的事件"><a href="#未-去抖-频繁触发的事件" class="headerlink" title="未 去抖 频繁触发的事件"></a>未 去抖 频繁触发的事件</h4><p>某些常见的事件可能会非常频繁的触发，例如 <code>scroll</code>，<code>resize</code>。去抖这些事件是明智的，特别是如果事件处理程序执行的不仅仅是基本功能。</p><p><code>Lodash</code> 有 <a href="https://lodash.com/docs/#debounce" target="_blank" rel="external">_.debounce</a> 方法。在 NPM 上还有一个独立的 <a href="https://www.npmjs.com/package/debounce" target="_blank" rel="external">debounce</a> 包.</p><blockquote><p>“但是我真的需要立即反馈 scroll/resize 或者别的事件”</p></blockquote><p>我发现一种可以处理这些事件并且以高性能的方式进行响应的方法，那就是在第一次事件触发时启动 <code>requestAnimationFrame()</code> 循环。然后可以使用 <code>[debounce()](https://lodash.com/docs#debounce)</code> 方法并且将 <code>trailing</code> 这个配置项设为 <code>true</code>（<strong>这意味着该功能只在频繁触发的事件流结束后触发</strong>）来取消对值的监听，看看下面这个例子。</p><script src="https://gist.github.com/jacob-beltran/84bd0aea2c1023743dda09172d30bc16.js"></script><h4 id="密集CPU任务线程阻塞"><a href="#密集CPU任务线程阻塞" class="headerlink" title="密集CPU任务线程阻塞"></a>密集CPU任务线程阻塞</h4><p>某些任务一直是 CPU 密集型的，因此可能会导致主渲染线程的阻塞。举几个例子，比如非常复杂的数学计算，迭代非常大的数组，使用 <code>File</code> api 进行文件读写，利用 <code>&lt;canvas&gt;</code> 对图片进行编码解码。</p><p>在这些情况下，如果有可能最好使用 <code>Web Worker</code> 将这些功能移到另一个线程上，这样我们的主渲染线程可以保持顺滑。</p><p><strong>相关阅读</strong></p><p>MDN 文章: <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="external">Using Web Workers</a></p><p>MDN 文档: <a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker" target="_blank" rel="external">Worker API</a></p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>我们希望上述建议对您能有所帮助。如果没有 Vixlet 团队的伟大工作和研究，上述的提示和编程技巧是不可能产出的。他们真的是我曾经合作过的最棒的团队之一。</p><p>在你的 React 的征途中保持学习和练习，愿原力与你同在！</p><blockquote><p>原文地址：<a href="https://blog.vixlet.com/react-at-light-speed-78cd172a6411" target="_blank" rel="external">React at Light Speed</a> <a href="https://blog.vixlet.com/@jacob_beltran" target="_blank" rel="external">@Jacob Beltran</a></p></blockquote><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;光速-React&quot;&gt;&lt;a href=&quot;#光速-React&quot; class=&quot;headerlink&quot; title=&quot;光速 React&quot;&gt;&lt;/a&gt;光速 React&lt;/h1&gt;&lt;h2 id=&quot;Vixlet-团队优化性能的经验教训&quot;&gt;&lt;a href=&quot;#Vixlet-团队优化性能的经验教训&quot; class=&quot;headerlink&quot; title=&quot;Vixlet 团队优化性能的经验教训&quot;&gt;&lt;/a&gt;Vixlet 团队优化性能的经验教训&lt;/h2&gt;&lt;p&gt;在过去一年多，我们 &lt;a href=&quot;http://www.vixlet.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Vixlet&lt;/a&gt; 的 web 团队已经着手于一个激动人心的项目：将我们的整个 web 应用迁移到 &lt;code&gt;React&lt;/code&gt; + &lt;code&gt;Redux&lt;/code&gt; 架构。对于整个团队来说，这是不断成长中的机会，在整个过程中，我们在这方面面临一些挑战。&lt;/p&gt;&lt;p&gt;因为我们的 web-app 可能有非常大的 feed 视图，包括成百上千的媒体、文本、视频、链接元素，我们花了相当多的时间寻找能充分利用 &lt;code&gt;React&lt;/code&gt; 性能的方法。在这里，我们将分享我们这一路学到的一些经验教训。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;声明&lt;/strong&gt;：&lt;strong&gt;下面讲的做法和方法更适用于我们具体应用的性能需求。然而，像所有的开发者建议的那样，最重要的是要考虑到你的应用程序和团队的实际需求。React 是一个开箱即用的框架，所以你可能不需要像我们一样细致地优化性能。话虽如此，我们还是希望你能在这篇文章里找到一些有用的信息。&lt;/strong&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="react" scheme="http://robin-front.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>npx是什么，为什么需要npx?</title>
    <link href="http://robin-front.github.io/2017/07/14/introducing-npx-an-npm-package-runner/"/>
    <id>http://robin-front.github.io/2017/07/14/introducing-npx-an-npm-package-runner/</id>
    <published>2017-07-14T09:31:57.000Z</published>
    <updated>2017-07-14T09:31:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍npx：一个npm包运行"><a href="#介绍npx：一个npm包运行" class="headerlink" title="介绍npx：一个npm包运行"></a>介绍npx：一个npm包运行</h1><p>NPM升级到最新版本，<a href="https://github.com/npm/npm/releases/tag/v5.2.0" target="_blank" rel="external">npm@5.2.0</a>，你可能会发现，它会安装一个新的二进制包跟着 <code>npm</code>：<a href="https://npm.im/npx" target="_blank" rel="external">npx</a>。</p><p><code>npx</code> 是一个工具，旨在帮助整理从npm注册软件包的体验 - 和 使得npm非常容易地安装和管理托管在注册表上的依赖关系是 同样的方式，<code>npx</code>使 npm 很方便使用CLI工具和其他被托管的可执行文件。它大大简化了一些事情，到目前为止，需要一些与普通的npm有关的步骤：</p><a id="more"></a><h1 id="使用本地化的安装工具而不用-npm-run-script"><a href="#使用本地化的安装工具而不用-npm-run-script" class="headerlink" title="使用本地化的安装工具而不用 npm run-script"></a>使用本地化的安装工具而不用 npm run-script</h1><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*A4HJT1FHQA_1_z3aMBc5mg.gif" data-original="https://cdn-images-1.medium.com/max/800/1*A4HJT1FHQA_1_z3aMBc5mg.gif"></p><center><small>将cowsay作为本地devDependency进行安装，并以“$ npx cowsay”运行</small></center><p>在过去几年中，npm生态系统越来越多地将安装工具作为项目本地化<code>devDependencies</code>，而不是要求用户在全局安装。这意味着，像工具<code>mocha</code>，<code>grunt</code>和<code>bower</code>，曾经被要求安装在系统的全局目录上，现在可以在每个项目的基础上管理自己的版本。这也意味着，所有你需要做的就是基于NPM的项目运行起来，以确保您有<code>node + NPM</code>您的系统上，克隆github项目，并运行<code>npm it</code>去运行<code>install</code>和<code>test</code>。由于<code>npm run-script</code>添加本地二进制文件到路径，这个工作很好！</p><p>不利之处在于，它不会快速/方便地以交互方式调用本地二进制文件。有几种方法可以做到这一点，他们都对他们有一些烦恼：你可以添加这些工具到你<code>scripts</code>，但是你需要记住通过使用传递参数<code>--</code>，你可以通过<code>shell</code>技巧<code>alias npmx=PATH=$(npm bin):$PATH</code> 做到，或者你可以手动路径他们，使用 <code>./node_modules/.bin/mocha</code>。这些都是工作，但没有一个是非常理想的。</p><p><code>npx</code>给你我认为是最好的解决方案：您需要做的是使用<code>$ npx mocha</code>进行本地安装。如果你再进行一个额外的步骤并<a href="https://www.npmjs.com/package/npx#shell-auto-fallback" target="_blank" rel="external">配置shell自动回退</a>（更多内容在下面会提到），那么在一个项目目录中运行<code>$ mocha</code>将会成为你的技巧！</p><p>作为彩蛋，如果调用已经安装的二进制文件，<a href="https://twitter.com/maybekatz/status/877444832494596096" target="_blank" rel="external">npx基本上没有开销</a> - 这足以将该工具的代码直接加载到当前运行的node进程中！这种事情就像读取文件一样快，并且使它成为一个完全可以接受的脚本编写工具。</p><h1 id="执行一次性命令"><a href="#执行一次性命令" class="headerlink" title="执行一次性命令"></a>执行一次性命令</h1><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*OlIRsvVO5aK7ja9HmwXz_Q.gif" data-original="https://cdn-images-1.medium.com/max/800/1*OlIRsvVO5aK7ja9HmwXz_Q.gif"></p><center><small><code>$ npx create-react-app my-cool-new-app</code>安装一个临时的创建应答程序并调用它，而不会污染全局安装或需要多个步骤！</small></center><p>你有没有遇到过 想要尝试一些CLI工具的情况，但是要安装一个全局只是为了运行一次，这很烦人？<code>npx</code>对这种情况也是很有用。调用的<code>npx &lt;command&gt;</code>当<code>&lt;command&gt;</code>不在你的<code>$PATH</code>意愿列表中，会自动从你的npm注册表中安装一个包含该名称的包，然后调用它。完成后，安装的软件包将不会储存在全球范围内任何地方，所以您不用担心长期的污染。</p><p>此功能也适用于<code>generators</code>等。像<code>yeoman</code>或<code>create-react-app</code>这样的工具只被调用一次。<strong>当你再次运行它们时，他们已经过时了，所以你最终不得不在每次想要使用它们时再次安装更新</strong>。</p><p>作为一种工具的维护者，我很喜欢这个功能，因为这意味着我可以把<code>$ npx my-tool</code>写进<code>README.md</code>的指令，而不是试图让人们在实际安装它的障碍。坦白说，说“哦，只需复制粘贴这一个命令，这是零成本的”更贴切，对于不确定是否使用这个工具的用户来说。</p><p>这里，你可能想用尝试一些其他有趣的包<code>npx</code>：<a href="https://npm.im/happy-birthday" target="_blank" rel="external">happy-birthday</a>，<a href="https://npm.im/benny-hill" target="_blank" rel="external">benny-hill</a>，<a href="https://npm.im/workin-hard" target="_blank" rel="external">workin-hard</a>，<a href="https://npm.im/cowsay" target="_blank" rel="external">cowsay</a>，<a href="https://npm.im/yo" target="_blank" rel="external">yo</a>，<a href="https://npm.im/create-react-app" target="_blank" rel="external">create-react-app</a>，<a href="https://npm.im/npm-check" target="_blank" rel="external">npm-check</a>。甚至有一个完整的<a href="https://github.com/js-n/awesome-npx" target="_blank" rel="external">awesome-npx</a><a href="https://github.com/js-n/awesome-npx" target="_blank" rel="external">入门</a>项目！来吧！获取一个<a href="https://twitter.com/maybekatz/status/878926190064668672" target="_blank" rel="external">足够小的完整的本地REST服务器运行的命令</a>以适应一个推文。</p><h1 id="使用不同Node-js版本运行命令"><a href="#使用不同Node-js版本运行命令" class="headerlink" title="使用不同Node.js版本运行命令"></a>使用不同Node.js版本运行命令</h1><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*cfjXl2hTKW7czetTfNGYbA.png" data-original="https://cdn-images-1.medium.com/max/800/1*cfjXl2hTKW7czetTfNGYbA.png"></p><center><small><code>npx -p node-bin @ &lt;version&gt; node -v</code>可用于执行节点版本的一次性运行。</small></center><p>事实证明，在npm注册表中有一个很酷的包叫 <code>node-bin</code>。这意味着你可以使用不同的<code>node</code>版本，而不必使用node版本管理器,像<code>nvm</code>，<code>nave</code>或<code>n</code>。所有你需要的只是安装<code>npm@5.2.0</code>！</p><p><code>-pnpx</code> 选项允许您指定要安装并添加到正在运行的软件包<code>$PATH</code>，这意味着您可以进行有趣的操作，例如：<code>$ npx -p node-bin@6 npm it</code>安装并测试当前的npm软件包，就像在<code>node@6</code>全局运行一样。我一直使用这个 - 我甚至最近不得不在一个项目中经常使用它，由于我的一个测试库在<code>node@8</code>环境下无法运行。这是一个真正的救世主，我发现使用这种类型的用例比版本管理器更容易，我总是以某种方式找到<code>break</code>或错误配置的方法。</p><p>注意：<code>node-bin</code>仅适用于<code>* nix</code>平台。这是<a href="https://medium.com/@aredridel" target="_blank" rel="external">Aria Stewart</a>的出色工作。在将来，同样的软件包将可以简单地使用<code>node</code>，所以您可以<code>$ npx node@6 ...</code>直接执行，包括在Windows上。</p><h1 id="与-npm-run-script-互动发展"><a href="#与-npm-run-script-互动发展" class="headerlink" title="与 npm run-script 互动发展"></a>与 npm run-script 互动发展</h1><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*JqCC1irC-XxXAWiThpOUiw.gif" data-original="https://cdn-images-1.medium.com/max/800/1*JqCC1irC-XxXAWiThpOUiw.gif"></p><center><small><code>$ npx -p cowsay -p lolcatjs -c&#39;echo“$ npm_package_name @ $ npm_package_version”| cowsay | lolcatjs&#39;s</code>将安装cowsay和lolcatjs，并使脚本从运行脚本访问一堆“$ npm_”变量。</small></center><p>很多<code>npm</code>的用户现在可以利用这个非常酷的<code>run-script</code>功能。他们不仅让您的<code>$PATH</code>本地二进制文件可访问，而且还添加了一大堆环境变量，您可以在这些脚本中访问。你可以看到这些额外的变量是什么<code>$ npm run env | grep npm_</code>。</p><p>这可以使开发和测试运行脚本变得棘手 - 这意味着即使使用诸如此类的技巧<code>$(npm bin)/some-bin</code>，在交互式工作的同时仍然无法访问这些神奇的<code>env var</code>。</p><p>可是等等！<code>npx</code>还有一个技巧：当你使用这个<code>-c</code>选项时，写入<code>string</code>参数内的脚本将能够像普通的运行脚本一样完全访问相同的<code>env</code>变量！您甚至可以使用管道和多个命令进行单次<code>npx</code>调用！</p><h1 id="与朋友以及你想要的任何人分享基于gist的脚本！"><a href="#与朋友以及你想要的任何人分享基于gist的脚本！" class="headerlink" title="与朋友以及你想要的任何人分享基于gist的脚本！"></a>与朋友以及你想要的任何人分享基于gist的脚本！</h1><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*Hdk5w080acQjABK3CQWh4Q.gif" data-original="https://cdn-images-1.medium.com/max/800/1*Hdk5w080acQjABK3CQWh4Q.gif"></p><p>使用<code>gist.github.com</code>分享各种实用程序脚本变得很常见，而不是设置整个<code>git repos</code>，发布新工具等。</p><p>使用<code>npx</code>，您可以进一步：因为<code>npx</code>接受<code>npm</code>本身所做的任何说明符，您可以创建一个人们可以直接使用单个命令调用的要点！</p><p>尝试使用<a href="https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32" target="_blank" rel="external">https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32</a>！</p><blockquote><p>注意：保持安全！在执行这些时，始终确保通过 <code>gists</code> 网站读取和执行代码，就像运行 <code>.sh</code> 脚本时一样谨慎！</p></blockquote><h1 id="彩蛋：shell自动回退"><a href="#彩蛋：shell自动回退" class="headerlink" title="彩蛋：shell自动回退"></a>彩蛋：shell自动回退</h1><p><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/600/1*MXY3EyWrnjdrv6gjDLgznw.png" data-original="https://cdn-images-1.medium.com/max/600/1*MXY3EyWrnjdrv6gjDLgznw.png"></p><center><small>将.zshrc中的npx自动回退意味着你可以在没有引用npx的情况下执行<code>$ ember-cli @ latest ...</code></small></center><p><code>FélixSaparelli</code>补充说，这个令人敬畏的功能意味着对于许多这些用例，您甚至不需要直接调用<code>npx</code>！常规的<code>npx</code>使用和回退之间的主要区别是，回退不会安装新软件包，除非您使用<code>pkg@version</code>语法：安全网来防止潜在的危险排序。</p><p>设置自动回退是很简单的：在<code>npx</code>文档中查看用于当前<code>shell</code>的命令，将其添加到 <code>.bashrc</code> / <code>.zshrc</code> / <code>.fishrc</code>，然后重新启动<code>shell</code>（或使用<code>source</code>或其他机制来刷新<code>shell</code>）。</p><p>现在，您可以做一些<code>$ standard@8 --version</code>尝试不同版本的东西，如果您在一个<code>npm</code>项目中，<code>$ mocha</code>则会自动回到本地安装的<code>mocha</code>版本，前提是它尚未在全局安装。</p><h1 id="现在就试试吧"><a href="#现在就试试吧" class="headerlink" title="现在就试试吧"></a>现在就试试吧</h1><p>你现在可以通过安装<code>npm@5.2.0</code>或更新来获得<code>npx</code> ，或者如果你不想使用<code>npm</code>，你可以安装独立版本的<code>npx</code>！它与其他软件包管理器完全兼容，因为任何<code>npm</code>使用仅适用于内部操作。哦，它有10种不同的语言，感谢来自世界各地的一大批早期采用者的贡献，<code>--help</code>以及所有的系统消息翻译，并可以根据系统区域设置自动提供！还有一个<code>awesome-npx</code><a href="https://github.com/js-n/awesome-npx" target="_blank" rel="external">repo</a>与<code>npx</code>工作地很好的例子！</p><p>你有最喜欢的功能吗？你有没有使用过？如果你有一些很酷炫的事，我没有在这里列出，请在评论中分享！我很想听听别人的意见！</p><p>PS人们不断地问这个，所以我只是会弹出它在这里：在这些GIF文件，我使用<a href="https://www.npmjs.com/package/hyperterm-monokai" target="_blank" rel="external">monokai</a>主题的<a href="https://hyper.is/" target="_blank" rel="external">Hyper</a>运行 <code>oh-my-zsh</code>中的<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes#spaceship" target="_blank" rel="external">spaceship主题</a>，再加上<a href="https://github.com/tonsky/FiraCode" target="_blank" rel="external">FiraCode</a>字体。</p><p>【翻译原文】: <a href="https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b" target="_blank" rel="external">https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b</a></p><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍npx：一个npm包运行&quot;&gt;&lt;a href=&quot;#介绍npx：一个npm包运行&quot; class=&quot;headerlink&quot; title=&quot;介绍npx：一个npm包运行&quot;&gt;&lt;/a&gt;介绍npx：一个npm包运行&lt;/h1&gt;&lt;p&gt;NPM升级到最新版本，&lt;a href=&quot;https://github.com/npm/npm/releases/tag/v5.2.0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;npm@5.2.0&lt;/a&gt;，你可能会发现，它会安装一个新的二进制包跟着 &lt;code&gt;npm&lt;/code&gt;：&lt;a href=&quot;https://npm.im/npx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;npx&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;code&gt;npx&lt;/code&gt; 是一个工具，旨在帮助整理从npm注册软件包的体验 - 和 使得npm非常容易地安装和管理托管在注册表上的依赖关系是 同样的方式，&lt;code&gt;npx&lt;/code&gt;使 npm 很方便使用CLI工具和其他被托管的可执行文件。它大大简化了一些事情，到目前为止，需要一些与普通的npm有关的步骤：&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="npm" scheme="http://robin-front.github.io/tags/npm/"/>
    
      <category term="npx" scheme="http://robin-front.github.io/tags/npx/"/>
    
  </entry>
  
  <entry>
    <title>为什么我停止使用多个显示器</title>
    <link href="http://robin-front.github.io/2017/07/11/why-should-stopped-using-multiple-monitors/"/>
    <id>http://robin-front.github.io/2017/07/11/why-should-stopped-using-multiple-monitors/</id>
    <published>2017-07-11T08:02:47.000Z</published>
    <updated>2017-07-11T08:02:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>许多开发人员认为多个显示器可以提高生产力。研究证明是这样，对吧？那么，请记住，许多这些研究是由戴尔和NEC等监控制造商委托进行的。🤔</p><p>尽管多个显示器使您看起来像一个重度的计算机使用者，但我在几年前卖了我的多显示器，并切换到一个监视器。而且我并不是一个人。</p><p>下面就是为什么。<a id="more"></a></p><h1 id="专注"><a href="#专注" class="headerlink" title="专注"></a>专注</h1><p>人类一次只能关注一件事情。那么为什么我们花钱来同时显示多个东西呢？如果我的电子邮件或社交媒体资讯提供一目了然，我会经常检查。这不仅不是不必要的，反而是有效的。在一个无休止的分心的世界中，能够长期专注于单一任务是一项非常有价值的技能。</p><blockquote><p>深刻的工作在我们分心充实的经济中变得越来越困难，但也变得越来越重要和罕见。少数能够在深度工作上度过的日子将变得非常市场化和成功。</p><ul><li>Cal Newport在“ 深加工 ”</li></ul></blockquote><p>一个监视器意味着我的工作 - 只有我的工作 - 显示在前面和中央。分心停留在视线之外，所以眼不见，心不烦。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="&#x8FD9;&#x770B;&#x8D77;&#x6765;&#x50CF;&#x662F;&#x4E13;&#x6CE8;&#x4E00;&#x9879;&#x4EFB;&#x52A1;&#x5417;" data-original="https://cdn-images-1.medium.com/max/800/1*gRNCnSRrV5JUxbMagFV0CA.jpeg"></p><center>这看起来像是专注一项任务吗</center><p>我们每天做的最有价值的工作之一就是要长期专注于一个单一的应用程序：<strong>阅读和写作</strong>。阅读和写作都受益于来自于屏幕上唯一的重点。一本带有移动微博的小本本在旁边将是一场灾难。但是很多人都愿意做这个。额外的显示经常导致潜在的持续分心。如果您的电子邮件，社交媒体等不可见，您更有可能继续工作。</p><p>作为开发人员，我每天都在编写代码。所以我经常阅读文档。但是我很少需要在读文档的 <strong>同时</strong> 编写代码。我读完相关的文档，然后再编码。我的工作流是模态的。</p><h1 id="减少窗口管理"><a href="#减少窗口管理" class="headerlink" title="减少窗口管理"></a>减少窗口管理</h1><p>我使用一个月的 34“LG超宽屏显示器，起初，我喜欢它。</p><p>不过，过了几天，我很惊讶地发现我出了个馊主意。我的桌面最大化，太宽了，所以我发现自己花了太多的时间摆弄桌面。“今天应该放在左边呢？”“现在有什么重要的事情呢？”</p><p>当然，屏幕足够宽，可以并排显示多个窗口，但是它非常宽，边缘感到不舒服。所以，我发现自己不断把我的工作转移到屏幕的中心，从而违背了买一个巨大的显示器的整个目的！Jeff Atwood很久以前在“<a href="https://blog.codinghorror.com/the-large-display-paradox/" target="_blank" rel="external">大型显示悖论</a>”中讨论了这个问题。他的解决方案，使用软件移动和调整大小的窗口更容易。我的解决方案，<strong>只需使用一个合理尺寸的显示器</strong>。</p><p>即使使用方便的窗口管理软件，多个显示器也会出现问题：如果我有两个显示器，内容不会直接在我的前面。我必须向右或向左转动我的头（特别烦在跑步机上行走的人，就像我经常看到的那样）。我可以把一个监视器直接放在我面前，但是第二个监视器甚至更远一些，这使得它显然是一个二等公民。这再次导致我从正在工作的中间屏幕移动。</p><p>正如巴里·施瓦茨（Barry Schwartz）在“<a href="https://www.amazon.com/Paradox-Choice-Why-More-Less/dp/0060005696" target="_blank" rel="external">选择的悖论</a>”中所探讨的那样，决策疲劳是一个真正的问题。有时候，少即是多。</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fembed.ted.com%2Ftalks%2Fbarry_schwartz_on_the_paradox_of_choice&amp;url=https%3A%2F%2Fwww.ted.com%2Ftalks%2Fbarry_schwartz_on_the_paradox_of_choice&amp;image=https%3A%2F%2Fpe.tedcdn.com%2Fimages%2Fted%2F8bdfbadbf8c620bfe3c5209c223a0f7b4316092a_240x180.jpg%3Flang%3Den&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=ted" allowfullscreen frameborder="0" scrolling="no"></iframe><blockquote><p>“选择使我们不是更自由，更瘫痪，不快乐，但更不满意。”</p></blockquote><p>只通过一个屏幕，我决定。我不会浪费时间决定在哪里拖曳窗口或摆放在给定窗口的位置。我最大化我正在使用的应用程序，以阻止所有其他分心…在上班的时候。</p><h1 id="虚拟桌面为赢"><a href="#虚拟桌面为赢" class="headerlink" title="虚拟桌面为赢"></a>虚拟桌面为赢</h1><p>Mac和Windows现在都支持虚拟桌面。在我的Mac上，我可以通过3个手指快速切换多个虚拟桌面。这需要不到一秒钟的时间，它不需要我转过头来重新聚焦我的眼睛在不同的地方的内容。我也不用浪费时间安排。最左边的虚拟桌面总是我的浏览器，右边是我的编辑器。<strong>所以我将虚拟桌面视为可靠呈现相同内容的物理屏幕</strong>。</p><p><img src="/js/lazyload-plugin/loading.svg" alt="&#x9876;&#x90E8;&#x7684;&#x4E09;&#x4E2A;&#x6846;&#x67B6;&#x8868;&#x793A;&#x4E09;&#x4E2A;&#x865A;&#x62DF;&#x684C;&#x9762;&#x3002;&#x4E09;&#x624B;&#x6307;&#x6ED1;&#x52A8;&#x53EF;&#x7ACB;&#x5373;&#x5728;&#x5B83;&#x4EEC;&#x4E4B;&#x95F4;&#x5207;&#x6362; - &#x65E0;&#x9700;&#x518D;&#x82B1;&#x65F6;&#x95F4;&#x65CB;&#x8F6C;&#x6211;&#x7684;&#x5934;&#xFF0C;&#x770B;&#x4E00;&#x4E2A;&#x5355;&#x72EC;&#x7684;&#x663E;&#x793A;&#x5668;&#x3002;" data-original="https://cdn-images-1.medium.com/max/800/1*BLoFtdzKsyuBaysiMNMaBA.png"></p><center>顶部的三个框架表示三个虚拟桌面。三手指滑动可立即在它们之间切换 - 无需再花时间旋转我的头，看一个单独的显示器。</center><h1 id="我用于完成工作的首选监视器"><a href="#我用于完成工作的首选监视器" class="headerlink" title="我用于完成工作的首选监视器"></a>我用于完成工作的首选监视器</h1><p>我更喜欢使用一个24“4K，为什么24”？因为如果你想完成实际的工作，更大的不一定更好。24“足够大，可以全屏显示单个应用程序，它足够大，可以在罕见的情况下并排显示两个应用程序，我真的需要同时看到两件事情（我在Mac上使用BetterTouchTool，只需击中Win +箭头在Windows），但是24“足够小，您可以最大限度地利用所有应用程序，而无需移动您的头部或眼睛很多看到屏幕边缘。记住，最大化所有的事情。最大化=集中。</p><p>为什么是4K？高DPI降低疲劳。文字更加清晰。价格也慢慢合理了，所以如果你还没有高DPI显示器，买一个。而24“4K每4K英寸的点数要大于4K屏幕，所以它更加清晰。过去几年内建成的任何MacBook Pro都可以在DisplayPort上以60hz的速度推出4K显示器，许多最近的Windows笔记本电脑也可以这样做。</p><p>那么为什么这么多工作者需要多台显示器呢？我相信这是极端不合逻辑的诱惑。</p><blockquote><p>太多的东西变得相反。 - 蒂姆·弗里斯</p></blockquote><p>显示器太多会变得分心。所以说到监视器，我拥抱这些想法：</p><ul><li>少即是多</li><li>质量而不是数量</li><li>定力，定力，定力（Location, Location, Location）</li></ul><p>【翻译原文】:（有删减） <a href="https://hackernoon.com/why-i-stopped-using-multiple-monitors-bfd87efa2e5b" target="_blank" rel="external">https://hackernoon.com/why-i-stopped-using-multiple-monitors-bfd87efa2e5b</a></p><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;许多开发人员认为多个显示器可以提高生产力。研究证明是这样，对吧？那么，请记住，许多这些研究是由戴尔和NEC等监控制造商委托进行的。🤔&lt;/p&gt;&lt;p&gt;尽管多个显示器使您看起来像一个重度的计算机使用者，但我在几年前卖了我的多显示器，并切换到一个监视器。而且我并不是一个人。&lt;/p&gt;&lt;p&gt;下面就是为什么。
    
    </summary>
    
      <category term="workflow" scheme="http://robin-front.github.io/categories/workflow/"/>
    
    
      <category term="performance" scheme="http://robin-front.github.io/tags/performance/"/>
    
  </entry>
  
  <entry>
    <title>不要混用 import 和 require</title>
    <link href="http://robin-front.github.io/2017/07/10/dont-mixin-import-and-require/"/>
    <id>http://robin-front.github.io/2017/07/10/dont-mixin-import-and-require/</id>
    <published>2017-07-10T08:30:11.000Z</published>
    <updated>2017-07-10T08:30:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>import 是 ES6 规范语法之一。而 require 属于CommonJS规范的一部分。</p><p>目前来说，使用现代浏览器还无法支持 import，一般都会搭配 babel 使用，而 babel 会把 import 转换成 CommonJS 的 require.</p><p>但是，我们不能混用 import 和 require。有时候会看下如下代码：<a id="more"></a></p><p><img src="/js/lazyload-plugin/loading.svg" alt="https://pbs.twimg.com/media/DESmTTXUMAAJcIW.jpg:large" data-original="https://pbs.twimg.com/media/DESmTTXUMAAJcIW.jpg:large"></p><p>但实际执行顺序并不是你想象或看到的那样。import 具有声明提升效果，会首先执行。所以最好 <strong>不要混用</strong>。 import 是 ES6 标准，如果可能，首先使用 import, 如果不行，就用 require。</p><h2 id="ES6-import"><a href="#ES6-import" class="headerlink" title="ES6 import"></a>ES6 import</h2><ul><li>具有声明提升效果</li><li>您可以使用命名导入来选择性地加载所需的部分。这样可以节省内存， 如：<code>import { render } from react</code></li><li>导入可以是异步的</li><li>ES6 标准</li></ul><h2 id="require"><a href="#require" class="headerlink" title="require"></a>require</h2><ul><li>您可以在加载的模块名称不是预定义/静态的情况下进行动态加载，或者只有在真正需要的情况下才有条件地加载模块（取决于某些代码流）</li><li>CommonJS 规范加载是同步的。这意味着如果你有多个require，它们将逐个加载和处理（AMD规范是可以异步的）</li><li>只是约定的规范</li></ul><p>参考：<a href="https://twitter.com/dan_abramov/status/883375646357041152" target="_blank" rel="external">https://twitter.com/dan_abramov/status/883375646357041152</a></p><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;import 是 ES6 规范语法之一。而 require 属于CommonJS规范的一部分。&lt;/p&gt;&lt;p&gt;目前来说，使用现代浏览器还无法支持 import，一般都会搭配 babel 使用，而 babel 会把 import 转换成 CommonJS 的 require.&lt;/p&gt;&lt;p&gt;但是，我们不能混用 import 和 require。有时候会看下如下代码：
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="import" scheme="http://robin-front.github.io/tags/import/"/>
    
      <category term="require" scheme="http://robin-front.github.io/tags/require/"/>
    
  </entry>
  
  <entry>
    <title>react性能优化：提取子组件中额外的事件绑定</title>
    <link href="http://robin-front.github.io/2017/07/06/react-pattern-extract-child-components-to-avoid-binding/"/>
    <id>http://robin-front.github.io/2017/07/06/react-pattern-extract-child-components-to-avoid-binding/</id>
    <published>2017-07-06T08:24:53.000Z</published>
    <updated>2017-07-06T08:24:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="react性能优化：提取子组件中额外的事件绑定"><a href="#react性能优化：提取子组件中额外的事件绑定" class="headerlink" title="react性能优化：提取子组件中额外的事件绑定"></a>react性能优化：提取子组件中额外的事件绑定</h1><p>我们经常在快要完成一个<code>react</code>中型应用时，发现页面并没有想象中那么流畅。 react 理论性能是不错的，但是对开发者要求也很高，一些不易注意的点很容易造成性能问题。正所谓“烂泥扶不上墙”。</p><p>下面看看子组件的事件绑定写法对性能的影响。<a id="more"></a></p><p>这是React中的常见情况：您正在映射数组，您需要每个项目调用点击处理程序和一些相关数据。</p><p>这是一个例子。我正在迭代一个用户列表，并将<code>userId</code>传递给第29行的<code>deleteUser</code>函数。</p><script src="https://gist.github.com/coryhouse/01339ce21024cfd7f5cd4c64d1fd26c4.js"></script><p>这是<a href="https://codesandbox.io/" target="_blank" rel="external">Codeandbox</a>上的一个<a href="https://codesandbox.io/s/0OP2Yq87" target="_blank" rel="external">工作示例</a>。（真棒）</p><h1 id="所以-有什么问题？"><a href="#所以-有什么问题？" class="headerlink" title="所以, 有什么问题？"></a>所以, 有什么问题？</h1><p>我在点击处理程序中使用箭头函数。这意味着每次渲染运行时，都会分配一个新函数。在许多情况下，这不是一件多大的事。但是，如果您有子组件，即使数据没有更改，它们也将重新渲染，因为每个渲染分配一个新的函数。</p><p>底线：避免在渲染中声明箭头函数或绑定以获得最佳性能。我的团队使用这个<a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-no-bind.md" target="_blank" rel="external">ESLint规则</a>帮助提醒我们这个问题。</p><h1 id="解决方案是什么？"><a href="#解决方案是什么？" class="headerlink" title="解决方案是什么？"></a>解决方案是什么？</h1><p>那么你如何在渲染中避免绑定和箭头函数呢？一个选项是提取一个子组件。在这里，我将列表项提取到<code>UserListItem.js</code>：</p><script src="https://gist.github.com/coryhouse/a002111d01fb7ee1862af55d4a26abfa.js"></script><p>然后，父组件的渲染变得更简单，不再需要包含箭头函数。它只是通过<code>props</code>传递每个列表项的相关上下文：</p><script src="https://gist.github.com/coryhouse/f5758f5355da5280fc0e3350453fef31.js"></script><p>这是一个<a href="https://codesandbox.io/s/Q1Jo3zB79" target="_blank" rel="external">重构的工作实例</a>。</p><h1 id="Yay-or-Yuck"><a href="#Yay-or-Yuck" class="headerlink" title="Yay or Yuck?"></a>Yay or Yuck?</h1><p>此模式通过消除冗余的函数分配来提高性能。所以当这种情况适用于您的组件时，它是最有用的：</p><ul><li>渲染频繁被调用</li><li>渲染子组件非常耗时</li></ul><p>诚然，我提取子组件也是我提到的一个额外的工作。它需要更多的移动部件和更多的代码。所以如果你没有出现性能问题，可以说这是一个过早的优化。</p><p>所以你有两个选择：允许箭头和绑定到任何地方（如果有性能问题再处理），或禁止他们获得最佳性能和一致性。</p><p>底线：我建议禁止箭头函数并在<code>render</code>中绑定。下面就是为什么：</p><ul><li>你必须禁用我上面建议的有用的<a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-no-bind.md" target="_blank" rel="external">ESLint规则</a>来允许它。</li><li>禁用linting规则后，人们可能会复制此模式，并开始禁用其他linting规则。一个处例外可以很快成为规范…</li></ul><p></p><blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">General rule for code reviews:<br><br>Each line of code should be worthy of copying.<br><br>Because people will.<a href="https://twitter.com/hashtag/cleancode?src=hash" target="_blank" rel="external">#cleancode</a></p>&mdash; Cory House 🏠 (@housecor) <a href="https://twitter.com/housecor/status/839511073279598594" target="_blank" rel="external">March 8, 2017</a></blockquote><p></p><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script><p>所以我发现提取子组件是一个有用的模式，以避免在渲染中绑定。</p><h1 id="其他的反例"><a href="#其他的反例" class="headerlink" title="其他的反例"></a>其他的反例</h1><p>还有些人会想要这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">deleteUser = id=<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line"> <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> &#123;</div><div class="line"> <span class="keyword">return</span> &#123; <span class="attr">users</span>: prevState.users.filter( <span class="function"><span class="params">user</span> =&gt;</span> user.id !== id)&#125;</div><div class="line"> &#125;)</div><div class="line">&#125;</div><div class="line"><span class="comment">// …</span></div><div class="line">onClick=&#123;<span class="keyword">this</span>.deleteUser(user.id)&#125;</div></pre></td></tr></table></figure><p>他们认为传递参数会比其他方式更加方便。但这和第一个糟糕的例子并无太大区别，子组件同样会再次渲染。</p><p>如果有相当多类似的输入框，像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;form&gt;</div><div class="line">Render = <span class="function"><span class="params">()</span> =&gt;</span></div><div class="line">Input1 value=<span class="keyword">this</span>.state.input1 onChange= update state <span class="keyword">for</span> field1</div><div class="line">Input2….</div><div class="line">Input3….</div></pre></td></tr></table></figure><p><a href="https://facebook.github.io/react/docs/forms.html#handling-multiple-inputs" target="_blank" rel="external">官方给出的方法</a>是给每个 input 添加 name 属性，进而获取参数。</p><p>当然也有人会想要在 html 上动文章，比如添加自定义属性 <code>data-id=${userId}</code>。这当然也能实现，但是 html不应该是数据源，这应该避免。</p><p>【翻译原文】:(有改动)<a href="https://medium.freecodecamp.org/react-pattern-extract-child-components-to-avoid-binding-e3ad8310725e" target="_blank" rel="external">https://medium.freecodecamp.org/react-pattern-extract-child-components-to-avoid-binding-e3ad8310725e</a></p><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;react性能优化：提取子组件中额外的事件绑定&quot;&gt;&lt;a href=&quot;#react性能优化：提取子组件中额外的事件绑定&quot; class=&quot;headerlink&quot; title=&quot;react性能优化：提取子组件中额外的事件绑定&quot;&gt;&lt;/a&gt;react性能优化：提取子组件中额外的事件绑定&lt;/h1&gt;&lt;p&gt;我们经常在快要完成一个&lt;code&gt;react&lt;/code&gt;中型应用时，发现页面并没有想象中那么流畅。 react 理论性能是不错的，但是对开发者要求也很高，一些不易注意的点很容易造成性能问题。正所谓“烂泥扶不上墙”。&lt;/p&gt;&lt;p&gt;下面看看子组件的事件绑定写法对性能的影响。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="react" scheme="http://robin-front.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>如何使用Memoize来缓存JavaScript函数结果并加快代码的速度</title>
    <link href="http://robin-front.github.io/2017/07/04/understanding-memoize-in-javascript/"/>
    <id>http://robin-front.github.io/2017/07/04/understanding-memoize-in-javascript/</id>
    <published>2017-07-04T09:57:51.000Z</published>
    <updated>2017-07-04T09:57:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Function</code> 是编程的组成部分。它们有助于为我们的代码增加模块化和可重用性。</p><p>将程序划分为大块是很常见的功能，我们稍后可以使用这些功能来执行一些有用的操作。</p><p>有时，多次调用功能可能会变得昂贵（比如，计算一个数字的阶乘的函数）。但是有一种方法可以优化这些功能，使它们执行得更快：<strong>缓存</strong>。<a id="more"></a></p><p>例如，假设我们<code>function</code>要返回一个数字的阶乘：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">    <span class="comment">// Calculations: n * (n-1) * (n-2) * ... (2) * (1)</span></div><div class="line">    <span class="keyword">return</span> factorial</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>非常好，现在我们来看看<code>factorial(50)</code>。计算机会执行计算，并返回给我们最后的答案，不错！</p><p>完成后，让我们来看看<code>factorial(51)</code>。计算机再次执行一些计算并获得结果，但是您可能已经注意到我们已经重复了可以避免的一些步骤。优化的方式是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">factorial(<span class="number">51</span>) = factorial(<span class="number">50</span>) * <span class="number">51</span>;</div></pre></td></tr></table></figure><p>但是我们<code>function</code>每次调用时都会从头开始执行计算：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">factorial(<span class="number">51</span>) = <span class="number">51</span> * <span class="number">50</span> * <span class="number">49</span> * ... * <span class="number">2</span> * <span class="number">1</span></div></pre></td></tr></table></figure><p>如果我们的函数<code>factorial</code>能记住它之前运算的结果并用它来提交运行效率，那不是很酷吗？</p><p>谈到<code>Memoization</code>，一种让我们的<code>function</code>记住（缓存）结果的方式。既然您对我们要实现的目标有一个基本的了解，这里是一个正式的定义：</p><blockquote><p><a href="https://en.wikipedia.org/wiki/Memoization" target="_blank" rel="external">Memoization</a>是一种优化技术，主要用于通过 <strong>存储昂贵的函数调用的结果</strong> 来加速计算机程序，并在相同的输入再次发生时返回缓存的结果.</p></blockquote><p>记住简单的东西意味着记忆或存储在内存中。记忆函数通常更快，因为如果随后使用先前的值调用该函数，我们将从缓存中获取结果来代替执行该函数，。</p><p>这看起来像一个简单的记忆函数（如果你想进行测试它，这里是一个<a href="https://codepen.io/divyanshu013/pen/xdQPvp?editors=0011" target="_blank" rel="external">CodePen</a>）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a simple function to add something</span></div><div class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">n</span>) =&gt;</span> (n + <span class="number">10</span>);</div><div class="line">add(<span class="number">9</span>);</div><div class="line"><span class="comment">// a simple memoized function to add something</span></div><div class="line"><span class="keyword">const</span> memoizedAdd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">let</span> cache = &#123;&#125;;</div><div class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (n <span class="keyword">in</span> cache) &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'Fetching from cache'</span>);</div><div class="line">      <span class="keyword">return</span> cache[n];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'Calculating result'</span>);</div><div class="line">      <span class="keyword">let</span> result = n + <span class="number">10</span>;</div><div class="line">      cache[n] = result;</div><div class="line">      <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// returned function from memoizedAdd</span></div><div class="line"><span class="keyword">const</span> newAdd = memoizedAdd();</div><div class="line"><span class="built_in">console</span>.log(newAdd(<span class="number">9</span>)); <span class="comment">// calculated</span></div><div class="line"><span class="built_in">console</span>.log(newAdd(<span class="number">9</span>)); <span class="comment">// cached</span></div></pre></td></tr></table></figure><h1 id="Memoization-要点"><a href="#Memoization-要点" class="headerlink" title="Memoization 要点"></a>Memoization 要点</h1><p>以上代码的一些要点是：</p><p><code>memoizedAdd</code>返回一个<code>function</code>以便稍后调用的。这是可能的，因为在JavaScript中，函数是一等公民，它们可以将它们用作<a href="http://eloquentjavascript.net/05_higher_order.html#h_xxCc98lOBK" target="_blank" rel="external">高阶的函数</a>并返回另一个函数。</p><p><code>cache</code>可以记住它的值，因为返回的函数被<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Closures" target="_blank" rel="external">闭包</a>封装了。</p><p><code>memoized</code>功能纯粹<a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976" target="_blank" rel="external">(Pure)</a>是至关重要的。纯函数将为特定输入返回相同的输出，而不需要调用多少次，这使得<code>cache</code>按预期的工作。</p><h1 id="编写自己的-memoize-功能"><a href="#编写自己的-memoize-功能" class="headerlink" title="编写自己的 memoize 功能"></a>编写自己的 memoize 功能</h1><p>以前的代码工作正常，但如果我们想将任何函数转换为记忆函数呢？</p><p>以下是如何编写自己的<code>memoize</code>函数（<a href="https://codepen.io/divyanshu013/pen/zwMPdK?editors=0011#code-area" target="_blank" rel="external">codepen</a>）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a simple pure function to get a value adding 10</span></div><div class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">n</span>) =&gt;</span> (n + <span class="number">10</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Simple call'</span>, add(<span class="number">3</span>));</div><div class="line"><span class="comment">// a simple memoize function that takes in a function</span></div><div class="line"><span class="comment">// and returns a memoized function</span></div><div class="line"><span class="keyword">const</span> memoize = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">let</span> cache = &#123;&#125;;</div><div class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> n = args[<span class="number">0</span>];  <span class="comment">// just taking one argument here</span></div><div class="line">    <span class="keyword">if</span> (n <span class="keyword">in</span> cache) &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'Fetching from cache'</span>);</div><div class="line">      <span class="keyword">return</span> cache[n];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'Calculating result'</span>);</div><div class="line">      <span class="keyword">let</span> result = fn(n);</div><div class="line">      cache[n] = result;</div><div class="line">      <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// creating a memoized function for the 'add' pure function</span></div><div class="line"><span class="keyword">const</span> memoizedAdd = memoize(add);</div><div class="line"><span class="built_in">console</span>.log(memoizedAdd(<span class="number">3</span>));  <span class="comment">// calculated</span></div><div class="line"><span class="built_in">console</span>.log(memoizedAdd(<span class="number">3</span>));  <span class="comment">// cached</span></div><div class="line"><span class="built_in">console</span>.log(memoizedAdd(<span class="number">4</span>));  <span class="comment">// calculated</span></div><div class="line"><span class="built_in">console</span>.log(memoizedAdd(<span class="number">4</span>));  <span class="comment">// cached</span></div></pre></td></tr></table></figure><p>这很棒！这个简单的<code>memoize</code>功能将任何简单的<code>function</code>封装成一个有记忆性的等价物。该代码适用于简单的功能，可以根据您的需要轻松调整处理任意数量的<code>arguments</code>代码。另一个选择是利用一些的类库，如：</p><p><a href="https://lodash.com/docs/4.17.4#memoize" target="_blank" rel="external">Lodash</a>的<code>_.memoize(func, [resolver])</code></p><p>来自<a href="https://github.com/developit/decko#memoize" target="_blank" rel="external">decko</a>的 ES7 <code>@memoize</code> <a href="https://babeljs.io/docs/plugins/transform-decorators/" target="_blank" rel="external">装饰器</a></p><h1 id="记忆递归函数"><a href="#记忆递归函数" class="headerlink" title="记忆递归函数"></a>记忆递归函数</h1><p>如果您尝试将递归函数传递到<code>memoize</code>上面的函数或Lodash的<code>_.memoize</code>函数，结果将不会如预期的那样，因为其后续调用的递归函数将最终调用自身而不是记忆函数，从而不再使用<code>cache</code>。</p><p>只需确保递归函数调用记忆函数。这里是你如何调整教科书<a href="https://en.wikipedia.org/wiki/Factorial" target="_blank" rel="external">阶乘</a>例子（<a href="https://codepen.io/divyanshu013/pen/JNevOm" target="_blank" rel="external">codepen</a>）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// same memoize function from before</span></div><div class="line"><span class="keyword">const</span> memoize = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">let</span> cache = &#123;&#125;;</div><div class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> n = args[<span class="number">0</span>];</div><div class="line">    <span class="keyword">if</span> (n <span class="keyword">in</span> cache) &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'Fetching from cache'</span>, n);</div><div class="line">      <span class="keyword">return</span> cache[n];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'Calculating result'</span>, n);</div><div class="line">      <span class="keyword">let</span> result = fn(n);</div><div class="line">      cache[n] = result;</div><div class="line">      <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> factorial = memoize(</div><div class="line">  <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (x === <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> x * factorial(x - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">);</div><div class="line"><span class="built_in">console</span>.log(factorial(<span class="number">5</span>)); <span class="comment">// calculated</span></div><div class="line"><span class="built_in">console</span>.log(factorial(<span class="number">6</span>)); <span class="comment">// calculated for 6 and cached for 5</span></div></pre></td></tr></table></figure><p>从这段代码注意几点：</p><p>该<code>factorial</code>函数递归地调用自己的记忆版本。</p><p>记忆功能是缓存先前阶乘的值，从而可以重复使用，从而显着改善了计算 <code>factorial(6) = 6 * factorial(5)</code></p><h1 id="memoization-是否与-caching-相同？"><a href="#memoization-是否与-caching-相同？" class="headerlink" title="memoization 是否与 caching 相同？"></a>memoization 是否与 caching 相同？</h1><p>是的，有点。<code>Memoization</code>实际上是一种特定类型的缓存。虽然缓存通常可以引用任何存储技术（如HTTP缓存）以供将来使用，但是<code>memoizing</code>特指调用缓存的<code>function</code>返回值。</p><h1 id="什么时候记录你的-functions"><a href="#什么时候记录你的-functions" class="headerlink" title="什么时候记录你的 functions"></a>什么时候记录你的 functions</h1><p>虽然可能看起来 <code>memoize</code> 可以与所有函数一起使用，但它实际上有限制的用例：</p><ul><li>为了记忆一个函数，它应该是纯粹的（pure），所以每次返回值对于相同的输入是相同的</li><li>记忆是增加的空间和增加的速度之间的权衡，因此对于具有有限的输入范围的功能而言是重要的，以便可以更频繁地使用缓存的值</li><li>它可能看起来像您记住您的API调用，但这并不是必需的，因为浏览器会为您自动缓存它们。有关详细信息，请参阅<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching" target="_blank" rel="external">HTTP缓存</a></li><li>我发现用于记忆功能的最佳用例是 <strong>重度计算功能</strong>，可以显着提高性能（阶乘和斐波那契不是真正现实世界的例子）</li><li>如果您进入React / Redux，您可以检查重新选择哪个使用记忆选择器，以确保仅在状态树的相关部分发生更改时进行计算。</li></ul><h1 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h1><p>如果您想更详细地了解本文中的一些主题，以下链接可能很有用：</p><ul><li>JavaScript中的<a href="http://eloquentjavascript.net/05_higher_order.html#h_xxCc98lOBK" target="_blank" rel="external">高阶函数</a></li><li>JavaScript<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Closures" target="_blank" rel="external">闭包</a></li><li><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976" target="_blank" rel="external">纯函数</a></li><li>Lodash的<code>_.memoize</code> <a href="https://lodash.com/docs/4.17.4#memoize" target="_blank" rel="external">文档</a>和<a href="https://github.com/lodash/lodash/blob/4.17.4/lodash.js#L10554-L10572" target="_blank" rel="external">源代码</a></li><li>更多的<code>memoization</code>例子在<a href="https://www.sitepoint.com/implementing-memoization-in-javascript/" target="_blank" rel="external">这里</a>和<a href="http://inlehmansterms.net/2015/03/01/javascript-memoization/" target="_blank" rel="external">这里</a></li><li><a href="https://github.com/reactjs/reselect" target="_blank" rel="external">reactjs/reSelect</a></li></ul><p>【翻译原文】: <a href="https://medium.freecodecamp.org/understanding-memoize-in-javascript-51d07d19430e" target="_blank" rel="external">https://medium.freecodecamp.org/understanding-memoize-in-javascript-51d07d19430e</a></p><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Function&lt;/code&gt; 是编程的组成部分。它们有助于为我们的代码增加模块化和可重用性。&lt;/p&gt;&lt;p&gt;将程序划分为大块是很常见的功能，我们稍后可以使用这些功能来执行一些有用的操作。&lt;/p&gt;&lt;p&gt;有时，多次调用功能可能会变得昂贵（比如，计算一个数字的阶乘的函数）。但是有一种方法可以优化这些功能，使它们执行得更快：&lt;strong&gt;缓存&lt;/strong&gt;。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="Memoize" scheme="http://robin-front.github.io/tags/Memoize/"/>
    
  </entry>
  
  <entry>
    <title>css3中background-position 的四值语法</title>
    <link href="http://robin-front.github.io/2017/07/04/background-position-of-css3-about-four-value-syntax/"/>
    <id>http://robin-front.github.io/2017/07/04/background-position-of-css3-about-four-value-syntax/</id>
    <published>2017-07-04T03:27:55.000Z</published>
    <updated>2017-07-04T03:27:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="css3中background-position的四值语法"><a href="#css3中background-position的四值语法" class="headerlink" title="css3中background-position的四值语法"></a>css3中background-position的四值语法</h1><p>刨根问底，每个css属性都要知道它的所有值实在不容易。今天看看 <code>background-position</code>.</p><p>background-positionCSS中的属性允许您在其容器内移动背景图像（或渐变）。<a id="more"></a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">html</span> &#123;</div><div class="line">  <span class="attribute">background-position</span>: <span class="number">100px</span> <span class="number">5px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>它有三种不同的取值：</p><ul><li>长度值（例如<code>100px 5px</code>）</li><li>百分比（例如<code>100% 5%</code>）</li><li>关键字（例如<code>top right</code>）</li></ul><p>默认值为<code>0 0</code>。这会将您的背景图像放在容器的左上角。</p><p>长度值很简单：第一个值是水平位置，第二个值是垂直位置。因此，<code>100px 5px</code>将图像向右移动100像素，向下移动五个像素。您可以设定长度值单位为<code>px</code>，<code>em</code>或<a href="http://www.w3.org/Style/Examples/007/units.en.html" target="_blank" rel="external">任何其他的CSS长度值</a>。</p><p>百分比有所不同。戴上你的数学帽子：用<code>x％</code>移动背景图像意味着 <strong>将图像中的<code>X％</code>点</strong> 与 <strong>容器中的<code>X％</code>点</strong> 对齐(PS：很多人解释的时候只会说向左向下移动了x%,这就无法解释50%)。例如，<code>50%</code>意味着它会将图像的中间与容器的中间对齐。<code>100%</code>意味着它会将图像的最后一个像素与容器的最后一个像素对齐，依此类推。</p><p>关键字只是百分比的捷径。这<code>top right</code>比记住和写作要容易得多<code>0 100%</code>，这就是关键字的意义。以下是所有五个关键字及其等价取值的列表：</p><ul><li><code>top</code>：垂直0％</li><li><code>right</code>：水平100％</li><li><code>bottom</code>：垂直100％</li><li><code>left</code>：水平0％</li><li><code>center</code>：如果水平尚未定义，则水平为50％。如果定义了则应用到垂直。</li></ul><p>有趣的是，您关键字使用的顺序并不重要：与之<code>top center</code>相同<code>center top</code>。只有当您使用单一关键字时，您才能做到这一点。<code>center 10%</code>是不一样的<code>10% center</code>。</p><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>此演示演示了<code>background-position</code>具有长度单位，百分比和关键字取值的集合示例。</p><iframe height="265" scrolling="no" title="background-position values" src="//codepen.io/team/css-tricks/embed/ogqrGw/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/team/css-tricks/pen/ogqrGw/" target="_blank" rel="external">background-position values</a> by CSS-Tricks (<a href="https://codepen.io/css-tricks" target="_blank" rel="external">@css-tricks</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><h2 id="声明值-Declaring-Values"><a href="#声明值-Declaring-Values" class="headerlink" title="声明值(Declaring Values)"></a>声明值(Declaring Values)</h2><p><code>background-position</code>现代浏览器中最多可以放置四个值（有关详细信息，请参阅<a href="#browser-support">浏览器支持列表</a>）。</p><p>如果您只声明 <strong>一个值</strong>，则该值是水平偏移量。浏览器将垂直偏移设置为<code>center</code>。</p><p>当您声明 <strong>两个值</strong> 时，第一个值是水平偏移量，第二个值是垂直偏移量。</p><p>当您开始使用三个或四个值时，事情会变得更加棘手，但您也可以更好地控制您的背景位置。</p><p>三或四值语法在关键字和长度或百分比单位之间进行交替。您可以在<code>background-position</code>的三值或四值中使用任何关键字值， <em>除</em> <code>center</code>之外。</p><p>当您指定 <strong>三个值</strong> 时，浏览器将“丢失”第四个值插入为<code>0.</code>以下是三值的示例<code>background-position</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#threevalues</span> &#123;</div><div class="line">  <span class="attribute">background-position</span>: right <span class="number">45px</span> bottom;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样就可以将背景图像定位在右侧的<code>45px</code>和容器底部的<code>0px</code>。</p><p>这是一个<code>background-position</code> <strong>四值</strong> 的例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#fourvalues</span> &#123;</div><div class="line">  <span class="attribute">background-position</span>: right <span class="number">45px</span> bottom <span class="number">20px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这将背景图片定位在右侧的<code>45px</code>和容器底部的<code>20px</code>。</p><p>注意上面示例中值的顺序：关键字后跟长度单位。三或四个值<code>background-position</code>必须遵循该格式，关键字在长度或百分比单位之前。</p><h2 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h2><p>此演示包括一个值，两个值，三个值和四个值的示例background-position。</p><iframe height="265" scrolling="no" title="background-position 1, 2, 3, and 4 value syntax" src="//codepen.io/team/css-tricks/embed/yyKdPB/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="https://codepen.io/team/css-tricks/pen/yyKdPB/" target="_blank" rel="external">background-position 1, 2, 3, and 4 value syntax</a> by CSS-Tricks (<a href="https://codepen.io/css-tricks" target="_blank" rel="external">@css-tricks</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</iframe><h2 id="更多参考"><a href="#更多参考" class="headerlink" title="更多参考"></a>更多参考</h2><ul><li><a href="http://www.w3.org/TR/css3-background/#the-background-position" target="_blank" rel="external">background-position 在CSS3规范</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/background-position" target="_blank" rel="external">background-position 在MDN</a></li><li><a href="http://css-tricks.com/positioning-offset-background-images/" target="_blank" rel="external">偏移背景图像</a></li></ul><h2 id="browser-support"><a href="#browser-support" class="headerlink" title="browser-support"></a>browser-support</h2><p>基本价值得到支持。四值语法具有此支持：</p><table><thead><tr><th style="text-align:center">Chrome</th><th style="text-align:center">Safari</th><th style="text-align:center">Firefox</th><th style="text-align:center">Opera</th><th style="text-align:center">IE</th><th style="text-align:center">Android</th><th style="text-align:center">iOS</th></tr></thead><tbody><tr><td style="text-align:center">25+</td><td style="text-align:center">7+</td><td style="text-align:center">13+</td><td style="text-align:center">10.5+</td><td style="text-align:center">9+</td><td style="text-align:center">4+</td><td style="text-align:center">7.1+</td></tr></tbody></table><p>【翻译原文：】<a href="https://css-tricks.com/almanac/properties/b/background-position/" target="_blank" rel="external">https://css-tricks.com/almanac/properties/b/background-position/</a></p><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;css3中background-position的四值语法&quot;&gt;&lt;a href=&quot;#css3中background-position的四值语法&quot; class=&quot;headerlink&quot; title=&quot;css3中background-position的四值语法&quot;&gt;&lt;/a&gt;css3中background-position的四值语法&lt;/h1&gt;&lt;p&gt;刨根问底，每个css属性都要知道它的所有值实在不容易。今天看看 &lt;code&gt;background-position&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;background-positionCSS中的属性允许您在其容器内移动背景图像（或渐变）。
    
    </summary>
    
      <category term="css" scheme="http://robin-front.github.io/categories/css/"/>
    
    
      <category term="background" scheme="http://robin-front.github.io/tags/background/"/>
    
      <category term="css3" scheme="http://robin-front.github.io/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>Array数组的indexOf、includes vs for-loop性能比较</title>
    <link href="http://robin-front.github.io/2017/07/03/arr-of-indexOf-vs-includes-and-for-loop/"/>
    <id>http://robin-front.github.io/2017/07/03/arr-of-indexOf-vs-includes-and-for-loop/</id>
    <published>2017-07-03T03:02:06.000Z</published>
    <updated>2017-07-03T03:02:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Array数组的indexOf、includes-vs-for-loop性能比较"><a href="#Array数组的indexOf、includes-vs-for-loop性能比较" class="headerlink" title="Array数组的indexOf、includes vs for-loop性能比较"></a>Array数组的indexOf、includes vs for-loop性能比较</h1><p>最近遇到一道算法题，然后有些人会使用 <code>includes</code>、<code>indexOf</code> 去判断是否存在另一个数。这让我不禁思考，这和 <code>for loop</code>有什么区别，能减少时间复杂度吗？我一开始也不是很清楚，但我可以找文档，找标准。我的第一判断是 <code>includes</code> 完全和 <code>for loop</code>没有区别的，只是es6 标准规范提供的语法糖，而 <code>indexOf</code> 还是有一定效率的。带着疑惑，查看 MDN 和 <a href="http://www.ecma-international.org/ecma-262" target="_blank" rel="external">ecma-262</a><a id="more"></a></p><h2 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h2><p><code>includes</code> 是 ES6 新增语法，返回 布尔值。最容易拿 <code>indexOf</code> 来比较， <code>indexOf</code> 不能判断 <code>NaN</code>, 而且不够语义，返回的是 匹配值的位置 或 <code>-1</code>。 <code>includes</code> 内部实现是这样的：</p><blockquote><ol><li>Let O be ? ToObject(this value).</li><li>Let len be ? ToLength(? Get(O, “length”)).</li><li>If len is 0, return false.</li><li>Let n be ? ToInteger(fromIndex). (If fromIndex is undefined, this step produces the value 0.)</li><li>If n ≥ 0, then<ol><li>Let k be n.</li></ol></li><li>Else n &lt; 0,<ol><li>Let k be len + n.</li><li>If k &lt; 0, let k be 0.</li></ol></li><li>Repeat, while k &lt; len<ol><li>Let elementK be the result of ? Get(O, ! ToString(k)).</li><li>If SameValueZero(searchElement, elementK) is true, return true.</li><li>Increase k by 1.</li></ol></li><li>Return false.</li></ol></blockquote><p>其中的 <code>SameValueZero</code> 内部实现是这样的：</p><blockquote><ol><li>If Type(x) is different from Type(y), return false.</li><li>If Type(x) is Number, then<ol><li>If x is NaN and y is NaN, return true.</li><li>If x is +0 and y is -0, return true.</li><li>If x is -0 and y is +0, return true.</li><li>If x is the same Number value as y, return true.</li></ol></li><li>Return false.</li><li>Return SameValueNonNumber(x, y).</li></ol></blockquote><p>从上面可以看出 <code>includes</code> 内部是使用 <code>while</code> 循环，并不能够降低时间复杂度。它能判断出 <code>NaN</code> 以及 <code>+0</code>等于<code>-0</code>。</p><p><strong>所以，返回值的语义化和 <code>NaN</code>的判断就是 <code>includes</code> 的场景。</strong></p><h2 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h2><p>好，<code>includes</code> 用来提升效率的幻想破灭了，那 <code>indexOf</code> 呢，规范是这么写的：</p><blockquote><ol><li>Let O be ? ToObject(this value).</li><li>Let len be ? ToLength(? Get(O, “length”)).</li><li>If len is 0, return -1.</li><li>Let n be ? ToInteger(fromIndex). (If fromIndex is undefined, this step produces the value 0.)</li><li>If n ≥ len, return -1.</li><li>If n ≥ 0, then<ol><li>If n is -0, let k be +0; else let k be n.</li></ol></li><li>Else n &lt; 0,<ol><li>Let k be len + n.</li><li>If k &lt; 0, let k be 0.</li></ol></li><li>Repeat, while k &lt; len<ol><li>Let kPresent be ? HasProperty(O, ! ToString(k)).</li><li>If kPresent is true, then<ol><li>Let elementK be ? Get(O, ! ToString(k)).</li><li>Let same be the result of performing Strict Equality Comparison searchElement === elementK.</li><li>If same is true, return k.</li></ol></li><li>Increase k by 1.</li></ol></li><li>Return -1.</li></ol></blockquote><p><code>Array</code>的 <code>indexOf</code> 也使用了 <code>while</code> 循环，并使用 <code>===</code> 全等比较。（<strong>注： 与 <code>String.prototype.indexOf</code> 并不同</strong>）</p><p><strong><code>indexOf</code> 使用场景是需要知道 匹配值的位置。</strong></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这是一个<a href="https://jsperf.com/includes-vs-indexof-vs-forloop/1" target="_blank" rel="external">性能测试比较</a></p><p><img src="/js/lazyload-plugin/loading.svg" alt="&#x6211;&#x7684;&#x6D4B;&#x8BD5;&#x7ED3;&#x679C;" data-original="https://raw.githubusercontent.com/Robin-front/blog/master/source/images/20170703/includes.vs.indexOf.png"></p><p>so? 如果单纯只是想比较，简单的才是最快的。 <code>includes</code>与<code>indexOf</code>效率相当，而<code>for Loop</code>最快，因为没有其他的前置判断和浏览器对它的优化。</p><script src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Array数组的indexOf、includes-vs-for-loop性能比较&quot;&gt;&lt;a href=&quot;#Array数组的indexOf、includes-vs-for-loop性能比较&quot; class=&quot;headerlink&quot; title=&quot;Array数组的indexOf、includes vs for-loop性能比较&quot;&gt;&lt;/a&gt;Array数组的indexOf、includes vs for-loop性能比较&lt;/h1&gt;&lt;p&gt;最近遇到一道算法题，然后有些人会使用 &lt;code&gt;includes&lt;/code&gt;、&lt;code&gt;indexOf&lt;/code&gt; 去判断是否存在另一个数。这让我不禁思考，这和 &lt;code&gt;for loop&lt;/code&gt;有什么区别，能减少时间复杂度吗？我一开始也不是很清楚，但我可以找文档，找标准。我的第一判断是 &lt;code&gt;includes&lt;/code&gt; 完全和 &lt;code&gt;for loop&lt;/code&gt;没有区别的，只是es6 标准规范提供的语法糖，而 &lt;code&gt;indexOf&lt;/code&gt; 还是有一定效率的。带着疑惑，查看 MDN 和 &lt;a href=&quot;http://www.ecma-international.org/ecma-262&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ecma-262&lt;/a&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="Array" scheme="http://robin-front.github.io/tags/Array/"/>
    
      <category term="indexOf" scheme="http://robin-front.github.io/tags/indexOf/"/>
    
      <category term="includes" scheme="http://robin-front.github.io/tags/includes/"/>
    
      <category term="loop" scheme="http://robin-front.github.io/tags/loop/"/>
    
  </entry>
  
</feed>
