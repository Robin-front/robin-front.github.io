<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>知更鸟</title>
  
  <subtitle>robin</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://robin-front.github.io/"/>
  <updated>2018-04-10T12:32:20.000Z</updated>
  <id>http://robin-front.github.io/</id>
  
  <author>
    <name>robin.law</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>keep-alive vs http2</title>
    <link href="http://robin-front.github.io/2018/04/10/keep-alive-vs-http2.html"/>
    <id>http://robin-front.github.io/2018/04/10/keep-alive-vs-http2.html</id>
    <published>2018-04-10T12:32:20.000Z</published>
    <updated>2018-04-10T12:32:20.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>我们经常谈论 http2 与 http1.1，却经常忽视一些细节的区别。最近谈到 keep-alive 与 http2 链路复用的区别。虽然我知道 http2 的多路复用技术是源自通信工程里的时分复用，但对 keep-alive 的复用却有些模糊。下面看来这些技术之间的进化。<a id="more"></a></p><h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><blockquote><p>有很多文章都说 http2 相比 http1.1 增加了连接复用。这句话其实是不准确的。</p></blockquote><p><strong>在 HTTP 1.1 中 所有的连接默认都是持续连接，除非特殊声明不支持。</strong> 而在 http1.0 中，官方没有支持 keep-alive, 通常会手动在请求头中添加 <code>Connection: Keep-Alive</code>。</p><p>keep-alive 就是 TCP 连接复用的开端。改善的效果就是不再重新建立TCP连接，省去 三次握手 的时间。如下图：</p><p><div class="progress-images" style="width:450px"><div class="progress-images--placeholder" style="padding-bottom: 62.22222222222222%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="" class="progress-images--original" data-original="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d5/HTTP_persistent_connection.svg/langzh-450px-HTTP_persistent_connection.svg.png" data-thumb="/images/thumb/7353254ef7a99448518bfdaee8f3b1b5.png"></div></p><p>优势有：</p><ul><li>较少的CPU和内存的使用（由于同时打开的连接的减少了）</li><li>允许请求和应答的HTTP管线化</li><li>降低拥塞控制 （TCP连接减少了）</li><li>减少了后续请求的延迟（无需再进行握手）</li><li>报告错误无需关闭TCP连接</li></ul><h3 id="http-pipelining"><a href="#http-pipelining" class="headerlink" title="http pipelining"></a>http pipelining</h3><p>有些文章中会有一个误区，就是TCP连接必须等一个请求响应完成后，才能复用。这是不对的，但其实可以注意上面优势里提到到 <code>http pipelining</code>，如下图：</p><p><div class="progress-images" style="width:450px"><div class="progress-images--placeholder" style="padding-bottom: 62.22222222222222%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="" class="progress-images--original" data-original="https://upload.wikimedia.org/wikipedia/commons/thumb/f/fb/HTTP_pipelining.svg/450px-HTTP_pipelining.svg.png" data-thumb="/images/thumb/7baf3db7a63725778692eb56432388da.png"></div></p><p>HTTP1.1 中，一个TCP连接里是可以同时发送（实际有先后，但可以在响应前）多个请求的。但它是有序的，遵循先进先出，服务端只能按顺序响应请求（如果前面的请求没有响应完成或需要很长时间，后面的请求就会被阻塞），所以可能发生 队头阻塞（HOL blocking），造成延迟。</p><p>连续的 GET 和 HEAD 请求总可以管线化的。一个连续的幂等请求，如 GET，HEAD，PUT，DELETE，是否可以被管线化取决于一连串请求是否依赖于其他的。</p><p>所以keep-alive 的劣势也很明显：</p><ul><li>Keep-Alive可能会极大的影响服务器性能，因为它在文件被请求之后还保持了不必要的连接很长时间</li><li>可能发生队头阻塞（HOL blocking），造成延迟</li></ul><h2 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h2><p>HTTP2 主要解决的问题也是 TCP连接复用。但它比 keep-alive 更彻底，类似于通信工程里的时分复用，多个请求可以同时发送（不分先后），同时响应，解决了 队头阻塞（HOL blocking）的问题，极大提高效率。</p><p><div class="progress-images" style="width:750px"><div class="progress-images--placeholder" style="padding-bottom: 24%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="" class="progress-images--original" data-original="https://upload.wikimedia.org/wikipedia/commons/7/73/Mux_color.png" data-thumb="/images/thumb/014d53dfd081d5aeaf29535108795aa7.png"></div></p><p>keep-alive 的 HTTP pipelining 相当于单线程的，而 HTTP2 相当于并发。</p><p>HTTP2 的优点：</p><ul><li>对HTTP头字段进行数据压缩(即HPACK算法)；</li><li>HTTP/2 服务端推送(Server Push)；</li><li>请求管线化；</li><li>修复HTTP/1.0版本以来未修复的 队头阻塞 问题；</li><li>对数据传输采用多路复用，让多个请求合并在同一 TCP 连接内。</li></ul><p>后三个优点其实都是 多路复用 带来的优点。</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们经常谈论 http2 与 http1.1，却经常忽视一些细节的区别。最近谈到 keep-alive 与 http2 链路复用的区别。虽然我知道 http2 的多路复用技术是源自通信工程里的时分复用，但对 keep-alive 的复用却有些模糊。下面看来这些技术之间的进化。
    
    </summary>
    
      <category term="http" scheme="http://robin-front.github.io/categories/http/"/>
    
    
      <category term="http" scheme="http://robin-front.github.io/tags/http/"/>
    
      <category term="http2" scheme="http://robin-front.github.io/tags/http2/"/>
    
      <category term="keep-alive" scheme="http://robin-front.github.io/tags/keep-alive/"/>
    
      <category term="HOL blocking" scheme="http://robin-front.github.io/tags/HOL-blocking/"/>
    
  </entry>
  
  <entry>
    <title>react 异步渲染的最新进展</title>
    <link href="http://robin-front.github.io/2018/04/04/update-on-async-rendering.html"/>
    <id>http://robin-front.github.io/2018/04/04/update-on-async-rendering.html</id>
    <published>2018-04-04T00:31:44.000Z</published>
    <updated>2018-04-04T00:31:44.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="react-异步渲染的最新进展"><a href="#react-异步渲染的最新进展" class="headerlink" title="react 异步渲染的最新进展"></a>react 异步渲染的最新进展</h1><p>一年多来，react 团队在实现异步渲染上做了许多工作。上个月的冰岛 JSConf 演讲上，Dan 揭晓了一些令人兴奋的解锁异步渲染的可能性。现在我们想与您分享一些我们研究这些功能时的一些经验，以及帮助你准备用于异步渲染的组件的一些秘诀。</p><p>我们了解到的最大的教训就是我们传统的一些组件生命周期倾向于鼓励不安全的实践。它们是：</p><ul><li>componentWillMount</li><li>componentWillReceiveProps</li><li>componentWillUpdate</li></ul><p>这些生命周期经常被误解或不知不觉地误用。此外，我们预料到这些潜在的滥用可能会给异步渲染造成更多问题。因此，我们将会在接下来的版本给这些生命周期添加 “<code>UNSAFE_</code>” 前缀。（这里，“unsafe” 指的不是安全，而是想传达在这些生命周期里编程可能会在未来的 react 版本引起 bug，尤其是异步渲染开启的情况下。）<a id="more"></a></p><h2 id="逐步迁移之路"><a href="#逐步迁移之路" class="headerlink" title="逐步迁移之路"></a>逐步迁移之路</h2><p>react 遵循语义版本控制，所以这个改变将是逐步的。我们当前的计划是：</p><ul><li>16.3：介绍不安全的生命周期别名，<code>UNSAFE_componentWillMount</code>, <code>UNSAFE_componentWillReceiveProps</code>, 和 <code>UNSAFE_componentWillUpdate</code>。 (旧的生命周期名和新的别名会在这个版本同时有效。)</li><li>之后的 16.x 版本： 对 <code>componentWillMount</code>, <code>componentWillReceiveProps</code>, and <code>componentWillUpdate</code> 开启警告提示。（旧的生命周期名和新的别名会在这个版本同时有效，但旧的名称在开发模式下将会有 log 警告）</li><li>17.0: 完全移除 <code>componentWillMount</code>, <code>componentWillReceiveProps</code>, and <code>componentWillUpdate</code>。（从这个版本开始，只有新的 “UNSAFE_” 生命周期名称有效）</li></ul><p><strong>注意，如果你是一个 react 应用开发者，你还不需要对传统的方法做任何改变。即将发布的 16.3 版本主要的意图是，让开源项目维护人员在任何弃用警告之前更新其库。这些警告还不会生效，直到之后的16.x版本</strong></p><p>我们在 Facebook 维护着超过 50，000 个 react 组件， 并且我们并没有计划立即重写它们。我们明白迁移需要时间。我们会带领 react 社区的每一个人逐步迁移。</p><h2 id="从旧的生命周期迁移"><a href="#从旧的生命周期迁移" class="headerlink" title="从旧的生命周期迁移"></a>从旧的生命周期迁移</h2><p>如果你想要在 react 16.3 版本使用上面介绍的新 APIs（或者如果你是一个维护者，想提前更新你的库），这里有一些示例希望能帮助你从另一个角度思考组件。之后，我们计划添加一些“秘诀” 到我们的文档中，以此展示如何以避免有问题的生命周期的方式编写普通业务。</p><p>在开始之前，快速回顾一下 16.3 版本所计划的生命周期的变更：</p><ul><li><strong>添加以下别名</strong>： <code>UNSAFE_componentWillMount</code>, <code>UNSAFE_componentWillReceiveProps</code>, and <code>UNSAFE_componentWillUpdate</code>（新旧生命周期同时支持）</li><li><strong>介绍两个新的生命周期</strong>， 静态方法 <code>getDerivedStateFromProps</code> and <code>getSnapshotBeforeUpdate</code>.</li></ul><h3 id="新生命周期：-getDerivedStateFromProps"><a href="#新生命周期：-getDerivedStateFromProps" class="headerlink" title="新生命周期： getDerivedStateFromProps"></a>新生命周期： getDerivedStateFromProps</h3><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">class</span> <span class="token class-name">Example</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>  <span class="token keyword">static</span> <span class="token function">getDerivedStateFromProps</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">,</span> prevState<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这个新的静态生命周期方法 <code>getDerivedStateFromProps</code> 是在组件实例化之后被调用，同时接收新的 <code>props</code> 作为参数。它可以返回一个对象去更新 <code>state</code>, 或者返回 <code>null</code> 来表明这个新的 <code>props</code> 不需要更新任何 <code>state</code>。</p><p>和 <code>componentDidUpdate</code> 一起，这个新生命周期应该覆盖传统的 <code>componentWillReceiveProps</code> 方法的所有用例。</p><h3 id="新生命周期：-getSnapshotBeforeUpdate"><a href="#新生命周期：-getSnapshotBeforeUpdate" class="headerlink" title="新生命周期： getSnapshotBeforeUpdate"></a>新生命周期： getSnapshotBeforeUpdate</h3><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">class</span> <span class="token class-name">Example</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>  <span class="token function">getSnapshotBeforeUpdate</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">,</span> prevState<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这个新生命周期 <code>getSnapshotBeforeUpdate</code> 会在突变之前（比如DOM更新之前）调用。这个方法的返回值将会作为第三个参数传递到 <code>componentDidUpdate</code>。 （这个生命周期并不常用，但对于 rerender 期间手动保留滚动位置非常有用。）</p><p>与 <code>componentDidUpdate</code> 一起，这个新生命周期应该覆盖传统的 <code>componentWillUpdate</code> 方法的所有用例。</p><p>在<a href="https://gist.github.com/gaearon/88634d27abbc4feeb40a698f760f3264" target="_blank" rel="noopener">这个 gist </a>里可以找到它们的类型签名。</p><p>下面我们用一些示例展示如何使用这两个新的生命周期。</p><h3 id="新生命周期示例"><a href="#新生命周期示例" class="headerlink" title="新生命周期示例"></a>新生命周期示例</h3><h4 id="初始化-state"><a href="#初始化-state" class="headerlink" title="初始化 state"></a>初始化 state</h4><p>这个例子展示了一个组件在 <code>componentWillMount</code> 里面调用了 <code>setState</code>:</p><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">// Before</span><span class="token keyword">class</span> <span class="token class-name">ExampleComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>  state <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token function">componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      currentColor<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>defaultColor<span class="token punctuation">,</span>      palette<span class="token punctuation">:</span> <span class="token string">'rgb'</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>简单地将 state 初始化移动到 constructor 或者 属性初始化的位置来重构这个组件，看起来像这样：</p><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">// After</span><span class="token keyword">class</span> <span class="token class-name">ExampleComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>  state <span class="token operator">=</span> <span class="token punctuation">{</span>    currentColor<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>defaultColor<span class="token punctuation">,</span>    palette<span class="token punctuation">:</span> <span class="token string">'rgb'</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="获取外部数据"><a href="#获取外部数据" class="headerlink" title="获取外部数据"></a>获取外部数据</h4><p>下面是一个组件在 <code>componentWillMount</code> 里面获取数据的例子：</p><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">// Before</span><span class="token keyword">class</span> <span class="token class-name">ExampleComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>  state <span class="token operator">=</span> <span class="token punctuation">{</span>    externalData<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token function">componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>_asyncRequest <span class="token operator">=</span> <span class="token function">asyncLoadData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>      externalData <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>_asyncRequest <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>externalData<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_asyncRequest<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>_asyncRequest<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>externalData <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// Render loading state ...</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// Render real UI ...</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上面的代理在服务端渲染（外部数据还没有用到）和即将到来的异步渲染模式（请求可能发送多次）两种情况下都会有问题。</p><p>对于大部分情况，推荐将数据获取移到 <code>componentDidMount</code>:</p><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">// After</span><span class="token keyword">class</span> <span class="token class-name">ExampleComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>  state <span class="token operator">=</span> <span class="token punctuation">{</span>    externalData<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>_asyncRequest <span class="token operator">=</span> <span class="token function">asyncLoadData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>      externalData <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>_asyncRequest <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>externalData<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_asyncRequest<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>_asyncRequest<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>externalData <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// Render loading state ...</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// Render real UI ...</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这里普遍的误解是，在 <code>componentWillMount</code> 里获取数据可以避免渲染空的状态。在实际中，这从来都是不对的，因为 react 总是在 <code>componentWillMount</code> 之后立即执行 <code>render</code>。如果数据在 <code>componentWillMount</code> 调用的时候还不可用，那么第一次 <code>render</code> 也仍然显示加载状态，而不管你在哪里获取数据。这就是为什么在绝大多数情况下，将数据获取移到 <code>componentDidMount</code> 是感受不到差别的。</p><blockquote><p>注意：</p><p>一些高级用例(比如像 Relay 这样的库)可能想要预读取异步数据。<a href="https://gist.github.com/bvaughn/89700e525ff423a75ffb63b1b1e30a8f" target="_blank" rel="noopener">这个示例</a>展示了它是如何成为可能的。</p><p>从长远来看，这个在 react 组件中获取数据的典例将可能基于<a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html" target="_blank" rel="noopener">冰岛 JSConf 介绍的</a> “suspense” API。简单的数据获取方案和像 Apollo、 Relay这样的库将可以使用这个钩子。这比上面任何一个解决方案都更简洁，但在 16.3 版本发布时还不能敲定。</p><p>需要支持服务端渲染的时候，当前很有必要提供同步的数据 —— <code>componentWillMount</code> 经常被用于这个目的，但 constructor 其实可以替代它。即将到来的 <code>suspense</code> APIs 将会让服务端和客户端的异步数据获取尽可能地清晰。</p></blockquote><h4 id="添加事件监听（或订阅）"><a href="#添加事件监听（或订阅）" class="headerlink" title="添加事件监听（或订阅）"></a>添加事件监听（或订阅）</h4><p>下面是一个在 mounting 订阅事件的组件示例:</p><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">// Before</span><span class="token keyword">class</span> <span class="token class-name">ExampleComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>  <span class="token function">componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      subscribedValue<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>dataSource<span class="token punctuation">.</span>value<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// This is not safe; it can leak!</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>dataSource<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>handleSubscriptionChange    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>dataSource<span class="token punctuation">.</span><span class="token function">unsubscribe</span><span class="token punctuation">(</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>handleSubscriptionChange    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  handleSubscriptionChange <span class="token operator">=</span> dataSource <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      subscribedValue<span class="token punctuation">:</span> dataSource<span class="token punctuation">.</span>value<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>不幸的是， 这会造成服务端（<code>componentWillUnmount</code> 永远都不会被调用）和异步渲染（在渲染完成之前可能会被中断，造成 <code>componentWillUnmount</code> 没有被调用）的内存泄漏。</p><p>有人经常假设 <code>componentWillMount</code> 和 <code>componentWillUnmount</code> 是对应存在的，这其实不能保证。只有 <code>componentDidMount</code> 被调用之后，react 才能保证 <code>componentWillUnmount</code> 会在清除时被调用。</p><p>因此，推荐在 <code>componentDidMount</code> 中添加事件监听和订阅。</p><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">// After</span><span class="token keyword">class</span> <span class="token class-name">ExampleComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>  state <span class="token operator">=</span> <span class="token punctuation">{</span>    subscribedValue<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>dataSource<span class="token punctuation">.</span>value<span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Event listeners are only safe to add after mount,</span>    <span class="token comment" spellcheck="true">// So they won't leak if mount is interrupted or errors.</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>dataSource<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>handleSubscriptionChange    <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// External values could change between render and mount,</span>    <span class="token comment" spellcheck="true">// In some cases it may be important to handle this case.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>subscribedValue <span class="token operator">!==</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>dataSource<span class="token punctuation">.</span>value    <span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        subscribedValue<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>dataSource<span class="token punctuation">.</span>value<span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>dataSource<span class="token punctuation">.</span><span class="token function">unsubscribe</span><span class="token punctuation">(</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>handleSubscriptionChange    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  handleSubscriptionChange <span class="token operator">=</span> dataSource <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      subscribedValue<span class="token punctuation">:</span> dataSource<span class="token punctuation">.</span>value<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>有时更新订阅以便响应属性变化是很重要的。如果你使用 redux or mobx， 这些库的容器组件应该做这些事。对于应用作者，我们创建了一个小巧的库，<a href="https://github.com/facebook/react/tree/master/packages/create-subscription" target="_blank" rel="noopener">create-subscription</a> 来帮助做这些事。它将会和 react v16.3 一起发布。</p><p>比起上面那样传递一个可订阅的  <code>dataSource</code> 属性，我们也可以使用 <code>create-subscription</code> 去传递订阅的值：</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">import</span> <span class="token punctuation">{</span>createSubscription<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'create-subscription'</span><span class="token punctuation">;</span><span class="token keyword">const</span> Subscription <span class="token operator">=</span> <span class="token function">createSubscription</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token function">getCurrentValue</span><span class="token punctuation">(</span>sourceProp<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Return the current value of the subscription (sourceProp).</span>    <span class="token keyword">return</span> sourceProp<span class="token punctuation">.</span>value<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">subscribe</span><span class="token punctuation">(</span>sourceProp<span class="token punctuation">,</span> callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">function</span> <span class="token function">handleSubscriptionChange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">callback</span><span class="token punctuation">(</span>sourceProp<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Subscribe (e.g. add an event listener) to the subscription (sourceProp).</span>    <span class="token comment" spellcheck="true">// Call callback(newValue) whenever a subscription changes.</span>    sourceProp<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>handleSubscriptionChange<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Return an unsubscribe method.</span>    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">unsubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      sourceProp<span class="token punctuation">.</span><span class="token function">unsubscribe</span><span class="token punctuation">(</span>handleSubscriptionChange<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Rather than passing the subscribable source to our ExampleComponent,</span><span class="token comment" spellcheck="true">// We could just pass the subscribed value directly:</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Subscription</span> <span class="token attr-name">source</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span>dataSource<span class="token punctuation">}</span></span><span class="token punctuation">></span></span>  <span class="token punctuation">{</span>value <span class="token operator">=</span><span class="token operator">></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ExampleComponent</span> <span class="token attr-name">subscribedValue</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span>value<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Subscription</span><span class="token punctuation">></span></span><span class="token punctuation">;</span></code></pre><blockquote><p>注意：</p><p>像 Relay/Apollo 这样的库应该手动地使用 <code>create-subscription</code> 相同的技术去管理订阅（<a href="https://gist.github.com/bvaughn/d569177d70b50b58bff69c3c4a5353f3" target="_blank" rel="noopener">参考</a>）以适合这些库的最佳实践。</p></blockquote><h4 id="基于-props-更新-state"><a href="#基于-props-更新-state" class="headerlink" title="基于 props 更新 state"></a>基于 props 更新 state</h4><p>下面是一个使用传统 <code>componentWillReceiveProps</code> 方法来更新基于 props 的 state 的示例：</p><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">// Before</span><span class="token keyword">class</span> <span class="token class-name">ExampleComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>  state <span class="token operator">=</span> <span class="token punctuation">{</span>    isScrollingDown<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token function">componentWillReceiveProps</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>currentRow <span class="token operator">!==</span> nextProps<span class="token punctuation">.</span>currentRow<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        isScrollingDown<span class="token punctuation">:</span>          nextProps<span class="token punctuation">.</span>currentRow <span class="token operator">></span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>currentRow<span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>虽然上面的代码本身没有问题，但 <code>componentWillReceiveProps</code> 经常被误用来解决当下的一些问题。因此，这个方法将会被弃用。</p><p>从 16.3 版本开始，推荐使用新的 <strong>静态方法</strong> <code>getDerivedStateFromProps</code> 来更新基于 props 的 state.(这个生命周期将在组件被创建后和每次接收到新 props 的时候被调用)：</p><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">// After</span><span class="token keyword">class</span> <span class="token class-name">ExampleComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Initialize state in constructor,</span>  <span class="token comment" spellcheck="true">// Or with a property initializer.</span>  state <span class="token operator">=</span> <span class="token punctuation">{</span>    isScrollingDown<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    lastRow<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">static</span> <span class="token function">getDerivedStateFromProps</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">,</span> prevState<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextProps<span class="token punctuation">.</span>currentRow <span class="token operator">!==</span> prevState<span class="token punctuation">.</span>lastRow<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token punctuation">{</span>        isScrollingDown<span class="token punctuation">:</span>          nextProps<span class="token punctuation">.</span>currentRow <span class="token operator">></span> prevState<span class="token punctuation">.</span>lastRow<span class="token punctuation">,</span>        lastRow<span class="token punctuation">:</span> nextProps<span class="token punctuation">.</span>currentRow<span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Return null to indicate no change to state.</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>你可能注意到上面的例子中 <code>props.currentRow</code> 被映射到 state( 作为 <code>state.lastRow</code>)。这允许 <code>getDerivedStateFromProps</code> 和 <code>componentWillReceiveProps</code> 那样可以访问上一个 props 的值。</p><p>你可能想知道为什么我们不简单地将先前的 props 作为参数传递给 <code>getDerivedStateFromProps</code>。我们在设计API时考虑过这个问题，但因为两点原因推翻这个想法：</p><ul><li><code>prevProps</code> 参数在第一次调用 <code>getDerivedStateFromProps</code> (实例化后)时会是 null。 需要在每次访问 <code>prevProps</code> 时判断 if-not-null。</li><li>在未来版本的 react 中，不传递先前的 props 到这个函数是释放内存的一步。（如果 react 不需要传递 prevProps 到生命周期，内存中就不需要保持 prevProps 的引用。）</li></ul><blockquote><p>注意：</p><p>如果你正在写一个公共组件，<a href="https://github.com/reactjs/react-lifecycles-compat" target="_blank" rel="noopener">react-lifecycles-compat</a> polyfill 允许在旧版本的 react 中使用新生命周期方法 <code>getDerivedStateFromProps</code>。</p></blockquote><h4 id="调用外部回调"><a href="#调用外部回调" class="headerlink" title="调用外部回调"></a>调用外部回调</h4><p>这是一个当内部 state 改变时调用外部回调的组件：</p><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">// Before</span><span class="token keyword">class</span> <span class="token class-name">ExampleComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>  <span class="token function">componentWillUpdate</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">,</span> nextState<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>someStatefulValue <span class="token operator">!==</span>      nextState<span class="token punctuation">.</span>someStatefulValue    <span class="token punctuation">)</span> <span class="token punctuation">{</span>      nextProps<span class="token punctuation">.</span><span class="token function">onChange</span><span class="token punctuation">(</span>nextState<span class="token punctuation">.</span>someStatefulValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>有时候，大家使用 <code>componentWillUpdate</code> 的一个误点是：认为 <code>componentDidUpdate</code> 触发的时机“太晚了”， 不能及时更新其他组件。其实不是这样。 react 确保 <code>componentDidMount</code> 和 <code>componentDidUpdate</code> 期间调用的任何 <code>setState</code> 会在用户看到UI更新之前执行完。一般来说，像这样这很容易避免级联更新，但某些情况下这是必要的（举个例子，如果你需要在测量已渲染的 DOM 元素后定位一个提示框）。</p><p>无论哪种方式，在异步模式下为了这个目的去使用 <code>componentWillUpdate</code> 是不安全的，因为外部回调可能会在一次更新中被调用多次。相反，应该使有和<code>componentDidUpdate</code> 方法替代，因为它能保证每次更新只被调用一次：</p><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">// After</span><span class="token keyword">class</span> <span class="token class-name">ExampleComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>  <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">,</span> prevState<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>someStatefulValue <span class="token operator">!==</span>      prevState<span class="token punctuation">.</span>someStatefulValue    <span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">onChange</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>someStatefulValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="副作用的-on-props-change"><a href="#副作用的-on-props-change" class="headerlink" title="副作用的 on props change"></a>副作用的 on props change</h4><p>和上面的例子相似，有时候当组件 props 改变时会有副作用。</p><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">// Before</span><span class="token keyword">class</span> <span class="token class-name">ExampleComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>  <span class="token function">componentWillReceiveProps</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>isVisible <span class="token operator">!==</span> nextProps<span class="token punctuation">.</span>isVisible<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">logVisibleChange</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">.</span>isVisible<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>类似 <code>componentWillUpdate</code>, <code>componentWillReceiveProps</code> 方法可能会在单次更新中被调用多次。因此，在这些方法里避免使用有副作用的函数是很重要的。相反，应该使有和<code>componentDidUpdate</code> 方法替代，因为它能保证每次更新只被调用一次：</p><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">// After</span><span class="token keyword">class</span> <span class="token class-name">ExampleComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>  <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">,</span> prevState<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>isVisible <span class="token operator">!==</span> prevProps<span class="token punctuation">.</span>isVisible<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">logVisibleChange</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>isVisible<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="当-props-改变时获取外部数据"><a href="#当-props-改变时获取外部数据" class="headerlink" title="当 props 改变时获取外部数据"></a>当 props 改变时获取外部数据</h4><p>这是一个当 props 改变时获取外部数据的组件示例：</p><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">// Before</span><span class="token keyword">class</span> <span class="token class-name">ExampleComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>  state <span class="token operator">=</span> <span class="token punctuation">{</span>    externalData<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_loadAsyncData</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">componentWillReceiveProps</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextProps<span class="token punctuation">.</span>id <span class="token operator">!==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>id<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>externalData<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_loadAsyncData</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_asyncRequest<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>_asyncRequest<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>externalData <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// Render loading state ...</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// Render real UI ...</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">_loadAsyncData</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>_asyncRequest <span class="token operator">=</span> <span class="token function">asyncLoadData</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>      externalData <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>_asyncRequest <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>externalData<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>推荐升级成使用 <code>componentDidUpdate</code> 更新数据。也可以使用新生命周期 <code>getDerivedStateFromProps</code> 在渲染新 props 时清理旧数据：</p><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">// After</span><span class="token keyword">class</span> <span class="token class-name">ExampleComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>  state <span class="token operator">=</span> <span class="token punctuation">{</span>    externalData<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">static</span> <span class="token function">getDerivedStateFromProps</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">,</span> prevState<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Store prevId in state so we can compare when props change.</span>    <span class="token comment" spellcheck="true">// Clear out previously-loaded data (so we don't render stale stuff).</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextProps<span class="token punctuation">.</span>id <span class="token operator">!==</span> prevState<span class="token punctuation">.</span>prevId<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token punctuation">{</span>        externalData<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>        prevId<span class="token punctuation">:</span> nextProps<span class="token punctuation">.</span>id<span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// No state update necessary</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_loadAsyncData</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">,</span> prevState<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>externalData <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_loadAsyncData</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_asyncRequest<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>_asyncRequest<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>externalData <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// Render loading state ...</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// Render real UI ...</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">_loadAsyncData</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>_asyncRequest <span class="token operator">=</span> <span class="token function">asyncLoadData</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>      externalData <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>_asyncRequest <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>externalData<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>注意：</p><p>如果你使用的 HTTP 库支持取消功能，比如 axios，只需要在 unmount 的时候简单地取消一个正在处理的请求。对于原生 Promise, 你可以用<a href="https://gist.github.com/bvaughn/982ab689a41097237f6e9860db7ca8d6" target="_blank" rel="noopener">这样的</a>解决方案。</p></blockquote><h4 id="在更新前读取-DOM-属性"><a href="#在更新前读取-DOM-属性" class="headerlink" title="在更新前读取 DOM 属性"></a>在更新前读取 DOM 属性</h4><p>这是一个在更新前读取 DOM 属性以便维护列表的滚动位置的组件示例：</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">class</span> <span class="token class-name">ScrollingList</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>  listRef <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  previousScrollHeight <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token function">componentWillUpdate</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">,</span> nextState<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Are we adding new items to the list?</span>    <span class="token comment" spellcheck="true">// Capture the current height of the list so we can adjust scroll later.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>list<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> nextProps<span class="token punctuation">.</span>list<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>previousScrollHeight <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>listRef<span class="token punctuation">.</span>scrollHeight<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">,</span> prevState<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// If previousScrollHeight is set, we've just added new items.</span>    <span class="token comment" spellcheck="true">// Adjust scroll so these new items don't push the old ones out of view.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>previousScrollHeight <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>listRef<span class="token punctuation">.</span>scrollTop <span class="token operator">+</span><span class="token operator">=</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>listRef<span class="token punctuation">.</span>scrollHeight <span class="token operator">-</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>previousScrollHeight<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>previousScrollHeight <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>setListRef<span class="token punctuation">}</span></span><span class="token punctuation">></span></span>        <span class="token punctuation">{</span><span class="token comment" spellcheck="true">/* ...contents... */</span><span class="token punctuation">}</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  setListRef <span class="token operator">=</span> ref <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>listRef <span class="token operator">=</span> ref<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在上面的示例中， 在 <code>componentWillUpdate</code> 中读取 DOM 属性。但是在异步渲染中，这可能被延迟到 “render” 阶段（像 <code>componentWillUpdate</code> and <code>render</code>）和 “commit” 阶段(像 <code>componentDidUpdate</code>)才执行。如果用户在这期间做了一些类似调整窗口大小，从 <code>componentWillUpdate</code> 中读取的 <code>scrollHeight</code> 值会是旧的。</p><p>这个问题的解决方案就是使用新的 “commit” 阶段的生命周期事件，<code>getSnapshotBeforeUpdate</code>。这个方当会在变更产生后立即被调用（比如在 DOM 被更新之前）。它可以返回一个值并作为参数传到 <code>componentDidUpdate</code>。</p><p>这两个生命周期可以像下面这样用：</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">class</span> <span class="token class-name">ScrollingList</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>  listRef <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token function">getSnapshotBeforeUpdate</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">,</span> prevState<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Are we adding new items to the list?</span>    <span class="token comment" spellcheck="true">// Capture the current height of the list so we can adjust scroll later.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>prevProps<span class="token punctuation">.</span>list<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>list<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>listRef<span class="token punctuation">.</span>scrollHeight<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">,</span> prevState<span class="token punctuation">,</span> snapshot<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// If we have a snapshot value, we've just added new items.</span>    <span class="token comment" spellcheck="true">// Adjust scroll so these new items don't push the old ones out of view.</span>    <span class="token comment" spellcheck="true">// (snapshot here is the value returned from getSnapshotBeforeUpdate)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>snapshot <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>listRef<span class="token punctuation">.</span>scrollTop <span class="token operator">+</span><span class="token operator">=</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>listRef<span class="token punctuation">.</span>scrollHeight <span class="token operator">-</span> snapshot<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>setListRef<span class="token punctuation">}</span></span><span class="token punctuation">></span></span>        <span class="token punctuation">{</span><span class="token comment" spellcheck="true">/* ...contents... */</span><span class="token punctuation">}</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  setListRef <span class="token operator">=</span> ref <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>listRef <span class="token operator">=</span> ref<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>注意：</p><p>如果你正在写一个公共组件，<a href="https://github.com/reactjs/react-lifecycles-compat" target="_blank" rel="noopener">react-lifecycles-compat</a> polyfill 允许在旧版本的 react 中使用新生命周期方法 <code>getSnapshotBeforeUpdate</code>。</p></blockquote><h4 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a>其他场景</h4><p>尽管我们试图在这篇文章中涵盖最常见的用例，我们承认我们可能错过了一些。如果这篇博客里有你使用 <code>componentWillMount</code>, <code>componentWillUpdate</code>, or <code>componentWillReceiveProps</code> 却没提到的案例，并步不确定如何迁移，可以留下评论和示例。</p><h3 id="开源维护者"><a href="#开源维护者" class="headerlink" title="开源维护者"></a>开源维护者</h3><p>开源维护者可能比较想知道这些改变对开源组件意味着什么。如果你实现了上述建议，依赖于新静态生命周期事件 <code>getDerivedStateFromProps</code> 会发生什么？ 你是否不复不发布一个新的主版本并兼容 react 16.2及更老版本？</p><p>好消息是，不需要！</p><p>当 react 16.3 发布时，我们也会发布一个新的 npm 包， <a href="https://github.com/reactjs/react-lifecycles-compat" target="_blank" rel="noopener">react-lifecycles-compat</a>。 这个包提供了 polyfill 以便你能在老版本的 react（0.14.9+）使用新的生命周期事件 <code>getDerivedStateFromProps</code> and <code>getSnapshotBeforeUpdate</code>。</p><p>要使用这个 polyfill, 请先安装依赖到你的库：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># Yarn</span>yarn add react-lifecycles-compat<span class="token comment" spellcheck="true"># NPM</span><span class="token function">npm</span> <span class="token function">install</span> react-lifecycles-compat --save</code></pre><p>接着使用新的生命周期事件更新你的组件（就像上面说的那样）。</p><p>最后，使用 polyfill 让你的组件兼容旧版本的 react:</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span>polyfill<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-lifecycles-compat'</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">ExampleComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>  <span class="token keyword">static</span> <span class="token function">getDerivedStateFromProps</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">,</span> prevState<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Your state update logic here ...</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Polyfill your component to work with older versions of React:</span><span class="token function">polyfill</span><span class="token punctuation">(</span>ExampleComponent<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> ExampleComponent<span class="token punctuation">;</span></code></pre></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;react-异步渲染的最新进展&quot;&gt;&lt;a href=&quot;#react-异步渲染的最新进展&quot; class=&quot;headerlink&quot; title=&quot;react 异步渲染的最新进展&quot;&gt;&lt;/a&gt;react 异步渲染的最新进展&lt;/h1&gt;&lt;p&gt;一年多来，react 团队在实现异步渲染上做了许多工作。上个月的冰岛 JSConf 演讲上，Dan 揭晓了一些令人兴奋的解锁异步渲染的可能性。现在我们想与您分享一些我们研究这些功能时的一些经验，以及帮助你准备用于异步渲染的组件的一些秘诀。&lt;/p&gt;
&lt;p&gt;我们了解到的最大的教训就是我们传统的一些组件生命周期倾向于鼓励不安全的实践。它们是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;componentWillMount&lt;/li&gt;
&lt;li&gt;componentWillReceiveProps&lt;/li&gt;
&lt;li&gt;componentWillUpdate&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些生命周期经常被误解或不知不觉地误用。此外，我们预料到这些潜在的滥用可能会给异步渲染造成更多问题。因此，我们将会在接下来的版本给这些生命周期添加 “&lt;code&gt;UNSAFE_&lt;/code&gt;” 前缀。（这里，“unsafe” 指的不是安全，而是想传达在这些生命周期里编程可能会在未来的 react 版本引起 bug，尤其是异步渲染开启的情况下。）
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="react" scheme="http://robin-front.github.io/tags/react/"/>
    
      <category term="async rendering" scheme="http://robin-front.github.io/tags/async-rendering/"/>
    
      <category term="lifecycle" scheme="http://robin-front.github.io/tags/lifecycle/"/>
    
      <category term="getSnapshotBeforeUpdate" scheme="http://robin-front.github.io/tags/getSnapshotBeforeUpdate/"/>
    
      <category term="getDerivedStateFromProps" scheme="http://robin-front.github.io/tags/getDerivedStateFromProps/"/>
    
  </entry>
  
  <entry>
    <title>优化关键渲染路径</title>
    <link href="http://robin-front.github.io/2018/03/13/critical-rendering-path.html"/>
    <id>http://robin-front.github.io/2018/03/13/critical-rendering-path.html</id>
    <published>2018-03-13T09:50:49.000Z</published>
    <updated>2018-03-13T09:50:49.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="优化关键渲染路径"><a href="#优化关键渲染路径" class="headerlink" title="优化关键渲染路径"></a>优化关键渲染路径</h1><p>网页优化涉及到浏览器输入网址后的每一步，这里取关注相对少的浏览器渲染这一步来看看。</p><p>浏览器渲染页面有以下五个步骤：</p><ol><li>处理 HTML 标记并构建 DOM 树。</li><li>处理 CSS 标记并构建 CSSOM 树。</li><li>将 DOM 与 CSSOM 合并成一个渲染树。</li><li>根据渲染树来布局，以计算每个节点的几何信息。</li><li>将各个节点绘制到屏幕上。</li></ol><p><em>优化关键渲染路径</em> 就是指最大限度缩短执行上述第 1 步至第 5 步耗费的总时间.</p><p>优化关键渲染路径不仅对首屏呈现有重大意义，对于渲染页面帧率，流畅用户体验很关键。<a id="more"></a></p><h2 id="HTML-的简化处理"><a href="#HTML-的简化处理" class="headerlink" title="HTML 的简化处理"></a>HTML 的简化处理</h2><p>HTML 在 SPA 盛行的情况下想要简化越来越困难，特别是复杂的大型应用，依赖于一些质量不一的 UI 组件库。随便写几个业务功能，就会生成一大堆的 div 嵌套。</p><p>首先，源头能控制当然最好，精简结构，html 语义化。</p><p>其次，我们可以将首屏定义的范围再缩小，比如PC、移动端屏幕大小的第一部分。对于 SPA，前端的首屏 html 要么是同构输出，要么是 js 生成。其实这两种情况都是可以定制的，第一时间只输出“首屏” 元素，剩下的内容延迟载入。不过，对于这样的控制比较繁琐和细节，需要针对性优化，哪些部分需要先输出，哪些部分可以延后。</p><p>再就是异步和碎片化的概念，或者叫 fiber。像 react 搞 fiber，目前是为了能及时响应用户，将 react 执行纤维化，异步化。我觉得 html 也同样可以做，一个组件一个组件地展现页面，将繁重的浏览器渲染切成一个个小块。也可以说是 PWA(Progressive Web App)。通常我们的选择是输出 loading，等一切就绪后再展示，这往往让我们肆无忌惮地在首页加载一切资源，然后让用户对着 loading 发呆。如果能正确地，分步地展现内容，相信用户能更好地接受这个过程。在 Facebook APP也能看到这种思路的实现，打开 APP 可以先看到灰色的占位符，然后由顶部开始分步加载内容，在这个过程中，仍然可以响应页面上已加载完成的组件的用户操作。</p><p><img src="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/progressive-rendering.png" alt=""></p><h2 id="css-的简化处理"><a href="#css-的简化处理" class="headerlink" title="css 的简化处理"></a>css 的简化处理</h2><p><em>CSS 是阻塞渲染的资源。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。</em></p><p>一般来说，css 都不是首屏的性能瓶颈，但它是高帧率动画的瓶颈。通过 timeline 可以观察 css 样式计算、布局、绘制、合成的性能。</p><p>css 的性能问题包括：</p><ol><li>CSS 选择器的嵌套，多层嵌套严重影响 CSS 性能，因为浏览器需要合成CSSOM，进而合成渲染树。</li><li>文档（HTML， CSS）越大，浏览器需要完成的工作就越多。</li><li>样式越复杂，绘制需要的时间就越长（例如，单色的绘制开销“较小”，而阴影的计算和渲染开销则要“大得多”）</li></ol><p>针对优化的手段：</p><ol><li>使用 BEM CSS 规范进行编写CSS</li><li>简化 css, 或异步 css，将不必要的、非当前页的css 按需加载</li><li>可以尝试将开销大的 css 属性自动提取，打包到另一个文件，延迟加载。比如非常炫的动画、阴影、渐变等。当然只是一个想法，需要进行权衡，一般没有那么大的影响，相比多一个请求代价</li><li><code>display: none;</code> 的应用，浏览器不会渲染带有些属性的 DOM 节点。可以利用它先隐藏不必要的内容，延迟展现</li></ol><h2 id="Layout-布局简化与固定"><a href="#Layout-布局简化与固定" class="headerlink" title="Layout 布局简化与固定"></a>Layout 布局简化与固定</h2><p>视觉变化时，管道对指定帧的运行通常是： </p><p>样式计算、布局、绘制、合成</p><p><div class="progress-images" style="width:1093px"><div class="progress-images--placeholder" style="padding-bottom: 15.279048490393413%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="" class="progress-images--original" data-original="https://developers.google.com/web/fundamentals/performance/rendering/images/intro/frame-full.jpg" data-thumb="/images/thumb/983172dcd72c8a0accf2e2bc47b8da4d.jpg"></div></p><p>但这个过程是可以简化的，也是实现高帧率动画的基础。</p><p>当不改变元素的几何属性（例如宽度、高度、左侧或顶部位置等），只修改“paint only”属性（例如背景图片、文字颜色或阴影等），即不会影响页面布局的属性，则浏览器会跳过布局，但仍将执行绘制。</p><p><img src="https://developers.google.com/web/fundamentals/performance/rendering/images/intro/frame-no-layout.jpg" alt=""></p><p>如果您更改一个既不要布局也不要绘制的属性，则浏览器将跳到只执行合成:</p><p><div class="progress-images" style="width:1093px"><div class="progress-images--placeholder" style="padding-bottom: 15.279048490393413%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="" class="progress-images--original" data-original="https://developers.google.com/web/fundamentals/performance/rendering/images/intro/frame-no-layout-paint.jpg" data-thumb="/images/thumb/63874f4abb39ad88b85311c3bc1c2a74.jpg"></div></p><p>可以通过 <a href="https://csstriggers.com/" target="_blank" rel="noopener">css trigger</a> 来查询 css 属性所触发的对应的渲染过程。</p><p>使用一些 3d 属性（比如 <code>translateZ(0)</code>）可以提升层的独立渲染，一定程度上可以提高绘制性能，但会增加内存和GPU的使用，<strong>如无必要，请勿提升元素</strong></p><p>综上，如果频繁改变布局，会造成回流和重绘，对 css 的性能是影响最大的，继而造成卡顿。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>html, css 的优化不像其他方面的优化，它们和业务结合比较紧密，对业务开发的意识和要求比较高，如果源头没控制好，后面工程构建上的优化也是有限的。</p><p>参考： </p><ul><li><a href="https://developers.google.com/web/fundamentals/performance/rendering/" target="_blank" rel="noopener">渲染性能</a> By <a href="https://developers.google.com/web/resources/contributors/paullewis" target="_blank" rel="noopener">Paul Lewis</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/" target="_blank" rel="noopener">关键渲染路径</a> By <a href="https://developers.google.com/web/resources/contributors/ilyagrigorik" target="_blank" rel="noopener">Ilya Grigorik</a></li></ul></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;优化关键渲染路径&quot;&gt;&lt;a href=&quot;#优化关键渲染路径&quot; class=&quot;headerlink&quot; title=&quot;优化关键渲染路径&quot;&gt;&lt;/a&gt;优化关键渲染路径&lt;/h1&gt;&lt;p&gt;网页优化涉及到浏览器输入网址后的每一步，这里取关注相对少的浏览器渲染这一步来看看。&lt;/p&gt;
&lt;p&gt;浏览器渲染页面有以下五个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;处理 HTML 标记并构建 DOM 树。&lt;/li&gt;
&lt;li&gt;处理 CSS 标记并构建 CSSOM 树。&lt;/li&gt;
&lt;li&gt;将 DOM 与 CSSOM 合并成一个渲染树。&lt;/li&gt;
&lt;li&gt;根据渲染树来布局，以计算每个节点的几何信息。&lt;/li&gt;
&lt;li&gt;将各个节点绘制到屏幕上。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;优化关键渲染路径&lt;/em&gt; 就是指最大限度缩短执行上述第 1 步至第 5 步耗费的总时间.&lt;/p&gt;
&lt;p&gt;优化关键渲染路径不仅对首屏呈现有重大意义，对于渲染页面帧率，流畅用户体验很关键。
    
    </summary>
    
      <category term="css" scheme="http://robin-front.github.io/categories/css/"/>
    
    
      <category term="css" scheme="http://robin-front.github.io/tags/css/"/>
    
      <category term="html" scheme="http://robin-front.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>构建 DOM 对象模型和 CSSDOM 对象模型</title>
    <link href="http://robin-front.github.io/2018/03/11/constructing-the-DOM-and-CSSDOM-object-model-before-browser-rendering.html"/>
    <id>http://robin-front.github.io/2018/03/11/constructing-the-DOM-and-CSSDOM-object-model-before-browser-rendering.html</id>
    <published>2018-03-11T10:16:46.000Z</published>
    <updated>2018-03-11T10:16:46.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>By <a href="https://developers.google.com/web/resources/contributors/ilyagrigorik" target="_blank" rel="noopener">Ilya Grigorik</a></p><h1 id="构建-DOM-对象模型和-CSSDOM-对象模型"><a href="#构建-DOM-对象模型和-CSSDOM-对象模型" class="headerlink" title="构建 DOM 对象模型和 CSSDOM 对象模型"></a>构建 DOM 对象模型和 CSSDOM 对象模型</h1><p>浏览器渲染页面前需要先构建 DOM 和 CSSOM 树。因此，我们需要确保尽快将 HTML 和 CSS 都提供给浏览器。</p><p>TL;DR</p><ul><li>字节 → 字符 → 令牌 → 节点 → 对象模型。</li><li>HTML 标记转换成文档对象模型 (DOM)；CSS 标记转换成 CSS 对象模型 (CSSOM)。</li><li>DOM 和 CSSOM 是独立的数据结构。</li><li>Chrome DevTools Timeline 让我们可以捕获和检查 DOM 和 CSSOM 的构建和处理开销。</li></ul><a id="more"></a><h2 id="文档对象模型-DOM"><a href="#文档对象模型-DOM" class="headerlink" title="文档对象模型 (DOM)"></a>文档对象模型 (DOM)</h2><pre class=" language-HTML"><code class="language-HTML"><html>  <head>    <meta name="viewport" content="width=device-width,initial-scale=1">    <link href="style.css" rel="stylesheet">    <title>Critical Path</title>  </head>  <body>    <p>Hello <span>web performance</span> students!</p>    <div><img src="awesome-photo.jpg"></div>  </body></html></code></pre><p><a href="https://googlesamples.github.io/web-fundamentals/fundamentals/performance/critical-rendering-path/basic_dom.html" target="_blank" rel="noopener">试一下</a></p><p>让我们从可能的最简单情况入手：一个包含一些文本和一幅图片的普通 HTML 页面。浏览器如何处理此页面？</p><p><div class="progress-images" style="width:1123px"><div class="progress-images--placeholder" style="padding-bottom: 55.3873552983081%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="" class="progress-images--original" data-original="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/full-process.png" data-thumb="/images/thumb/fdbf91b17cdc5099124ecd2c1ce7f754.png"></div></p><ol><li>转换： 浏览器从磁盘或网络读取 HTML 的原始字节，并根据文件的指定编码（例如 UTF-8）将它们转换成各个字符。</li><li>令牌化： 浏览器将字符串转换成 W3C HTML5 标准规定的各种令牌，例如，“”、“”，以及其他尖括号内的字符串。每个令牌都具有特殊含义和一组规则。</li><li>词法分析： 发出的令牌转换成定义其属性和规则的“对象”。</li><li>DOM 构建： 最后，由于 HTML 标记定义不同标记之间的关系（一些标记包含在其他标记内），创建的对象链接在一个树数据结构内，此结构也会捕获原始标记中定义的父项-子项关系：HTML 对象是 body 对象的父项，body 是 paragraph 对象的父项，依此类推。</li></ol><p><div class="progress-images" style="width:665px"><div class="progress-images--placeholder" style="padding-bottom: 42.70676691729323%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="" class="progress-images--original" data-original="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/dom-tree.png" data-thumb="/images/thumb/607da1cdba552c87cbbf3d8eff2c662f.png"></div></p><p><strong>整个流程的最终输出是我们这个简单页面的文档对象模型 (DOM)，浏览器对页面进行的所有进一步处理都会用到它。</strong></p><p>浏览器每次处理 HTML 标记时，都会完成以上所有步骤：将字节转换成字符，确定令牌，将令牌转换成节点，然后构建 DOM 树。这整个流程可能需要一些时间才能完成，有大量 HTML 需要处理时更是如此。</p><p><div class="progress-images" style="width:766px"><div class="progress-images--placeholder" style="padding-bottom: 23.49869451697128%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="" class="progress-images--original" data-original="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/dom-timeline.png" data-thumb="/images/thumb/696cdc49b659114c2d890fcba5bd5fde.png"></div></p><p>注：我们假定您对 Chrome DevTools 有着基础程度的熟悉，即您知道如何捕获网络瀑布，或记录时间线。如果您需要快速温习相关内容，请查看 <a href="https://developers.google.com/web/tools/chrome-devtools/" target="_blank" rel="noopener">Chrome DevTools</a> 文档；如果您未接触过 DevTools，我们建议您学习 Codeschool <a href="http://discover-devtools.codeschool.com/" target="_blank" rel="noopener">Discover DevTools</a> 课程。</p><p>如果您打开 Chrome DevTools 并在页面加载时记录时间线，就可以看到执行该步骤实际花费的时间。在上例中，将一堆 HTML 字节转换成 DOM 树大约需要 5 毫秒。对于较大的页面，这一过程需要的时间可能会显著增加。创建流畅动画时，如果浏览器需要处理大量 HTML，这很容易成为瓶颈。</p><p>DOM 树捕获文档标记的属性和关系，但并未告诉我们元素在渲染后呈现的外观。那是 CSSOM 的责任。</p><h2 id="CSS-对象模型-CSSOM"><a href="#CSS-对象模型-CSSOM" class="headerlink" title="CSS 对象模型 (CSSOM)"></a>CSS 对象模型 (CSSOM)</h2><p>在浏览器构建我们这个简单页面的 DOM 时，在文档的 head 部分遇到了一个 link 标记，该标记引用一个外部 CSS 样式表：style.css。由于预见到需要利用该资源来渲染页面，它会立即发出对该资源的请求，并返回以下内容：</p><pre class=" language-CSS"><code class="language-CSS">body { font-size: 16px }p { font-weight: bold }span { color: red }p span { display: none }img { float: right }</code></pre><p>我们本可以直接在 HTML 标记内声明样式（内联），但让 CSS 独立于 HTML 有利于我们将内容和设计作为独立关注点进行处理：设计人员负责处理 CSS，开发者侧重于 HTML，等等。</p><p>与处理 HTML 时一样，我们需要将收到的 CSS 规则转换成某种浏览器能够理解和处理的东西。因此，我们会重复 HTML 过程，不过是为 CSS 而不是 HTML：</p><p><div class="progress-images" style="width:1012px"><div class="progress-images--placeholder" style="padding-bottom: 6.4229249011857705%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="" class="progress-images--original" data-original="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-construction.png" data-thumb="/images/thumb/0a8ade01e15c73ea112a9a698d37e9a8.png"></div></p><p>CSS 字节转换成字符，接着转换成令牌和节点，最后链接到一个称为“CSS 对象模型”(CSSOM) 的树结构内：</p><p><div class="progress-images" style="width:582px"><div class="progress-images--placeholder" style="padding-bottom: 51.3745704467354%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="" class="progress-images--original" data-original="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-tree.png" data-thumb="/images/thumb/f72227df0a0e82907437ff6d2b132198.png"></div></p><p>CSSOM 为何具有树结构？为页面上的任何对象计算最后一组样式时，浏览器都会先从适用于该节点的最通用规则开始（例如，如果该节点是 body 元素的子项，则应用所有 body 样式），然后通过应用更具体的规则（即规则“向下级联”）以递归方式优化计算的样式。</p><p>以上面的 CSSOM 树为例进行更具体的阐述。span 标记内包含的任何置于 body 元素内的文本都将具有 16 像素字号，并且颜色为红色 — font-size 指令从 body 向下级联至 span。不过，如果某个 span 标记是某个段落 (p) 标记的子项，则其内容将不会显示。</p><p>还请注意，以上树并非完整的 CSSOM 树，它只显示了我们决定在样式表中替换的样式。每个浏览器都提供一组默认样式（也称为“User Agent 样式”），即我们不提供任何自定义样式时所看到的样式，我们的样式只是替换这些默认样式（例如<a href="http://www.iecss.com/" target="_blank" rel="noopener">默认 IE 样式</a>）。</p><p>要了解 CSS 处理所需的时间，您可以在 DevTools 中记录时间线并寻找“Recalculate Style”事件：与 DOM 解析不同，该时间线不显示单独的“Parse CSS”条目，而是在这一个事件下一同捕获解析和 CSSOM 树构建，以及计算的样式的递归计算。</p><p><img src="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-timeline.png" alt=""></p><p>我们的小样式表需要大约 0.6 毫秒的处理时间，影响页面上的 8 个元素 — 虽然不多，但同样会产生开销。不过，这 8 个元素从何而来呢？CSSOM 和 DOM 是独立的数据结构！结果证明，浏览器隐藏了一个重要步骤。接下来，让我们谈一谈将 DOM 与 CSSOM 关联在一起的<a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction" target="_blank" rel="noopener">渲染树</a>。</p><h2 id="P-S"><a href="#P-S" class="headerlink" title="P.S."></a>P.S.</h2><p>了解浏览器构建页面的原理，是性能优化的基础。比如 BEM 对 CSS 性能优化的优势，DOM 节点操作的昂贵以及如何找出性能瓶颈。</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;By &lt;a href=&quot;https://developers.google.com/web/resources/contributors/ilyagrigorik&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ilya Grigorik&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;构建-DOM-对象模型和-CSSDOM-对象模型&quot;&gt;&lt;a href=&quot;#构建-DOM-对象模型和-CSSDOM-对象模型&quot; class=&quot;headerlink&quot; title=&quot;构建 DOM 对象模型和 CSSDOM 对象模型&quot;&gt;&lt;/a&gt;构建 DOM 对象模型和 CSSDOM 对象模型&lt;/h1&gt;&lt;p&gt;浏览器渲染页面前需要先构建 DOM 和 CSSOM 树。因此，我们需要确保尽快将 HTML 和 CSS 都提供给浏览器。&lt;/p&gt;
&lt;p&gt;TL;DR&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字节 → 字符 → 令牌 → 节点 → 对象模型。&lt;/li&gt;
&lt;li&gt;HTML 标记转换成文档对象模型 (DOM)；CSS 标记转换成 CSS 对象模型 (CSSOM)。&lt;/li&gt;
&lt;li&gt;DOM 和 CSSOM 是独立的数据结构。&lt;/li&gt;
&lt;li&gt;Chrome DevTools Timeline 让我们可以捕获和检查 DOM 和 CSSOM 的构建和处理开销。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="html" scheme="http://robin-front.github.io/categories/html/"/>
    
    
      <category term="css" scheme="http://robin-front.github.io/tags/css/"/>
    
      <category term="DOM" scheme="http://robin-front.github.io/tags/DOM/"/>
    
      <category term="CSSDOM" scheme="http://robin-front.github.io/tags/CSSDOM/"/>
    
      <category term="html" scheme="http://robin-front.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>react新API——context上下文</title>
    <link href="http://robin-front.github.io/2018/02/12/reacts-new-context-api.html"/>
    <id>http://robin-front.github.io/2018/02/12/reacts-new-context-api.html</id>
    <published>2018-02-12T16:27:34.000Z</published>
    <updated>2018-02-12T16:27:34.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="React’s-⚛️-new-Context-API"><a href="#React’s-⚛️-new-Context-API" class="headerlink" title="React’s ⚛️ new Context API"></a>React’s ⚛️ new Context API</h1><p>这是一种更人性化的方式，不再是“实验性功能”，并且现在它是一级API。并且使用了 <code>render prop</code>!<a id="more"></a></p><p>你之前听说过 react 的 context API 吗？如果你听说过，你是否和其他用户一样犹豫是否直接使用它，因为你会在官方文档看到如下内容：</p><p><div class="progress-images" style="width:748px"><div class="progress-images--placeholder" style="padding-bottom: 80.61497326203208%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="" class="progress-images--original" data-original="https://cdn-images-1.medium.com/max/800/0*QFLH_BvdzY7RD6sC.png" data-thumb="/images/thumb/775edd79472e5cc06803c99f820a5ed3.png"></div></p><p>搜索的第一个内容就是“<a href="https://reactjs.org/docs/context.html#why-not-to-use-context" target="_blank" rel="noopener">为什么不要去使用 context</a>”。这不能激发使用 context API 的信心。为了考虑风险，部分提到：</p><blockquote><p>如果想让你的应用更稳定，那不要使用 context。这是一个实验性的 API，在未来发布的 react 版本中可能会被移除。</p></blockquote><h2 id="所以，为什么会想要使用-context-呢？"><a href="#所以，为什么会想要使用-context-呢？" class="headerlink" title="所以，为什么会想要使用 context 呢？"></a>所以，为什么会想要使用 context 呢？</h2><p>你是否经历过将 state 从 react 树的根组件一直传递至叶节点的痛苦呢？这种痛苦被称为“<strong>prop drilling</strong>”，并且非常烦人。你必须让不关心该状态的组件传递 props 给关心该数据的子组件。特别是当你移动组件时，这种痛苦感更强烈了。</p><p>你当然可以使用标准 javascript 模块来避免这个问题。只需要将数据放到一个单例模块中，它可以在任何地方被访问或导入。但你可能在更新数据的时候遇到一些问题（你必须实现一个事件广播让订阅者知道何时更新了数据），并且<a href="https://stackoverflow.com/a/40974748/971592" target="_blank" rel="noopener">服务端渲染也会对单例造成困扰</a>。</p><p>所以，像 redux 这类的状态管理库就应运而生了。它允许你在 react 树的任何地方获取数据。你所要做的事只是使用一个叫 <code><Provider /></code> 的东西，然后你的组件就可以通过 <code>connected</code> 神奇般地访问你的 store 数据。</p><p>如果我告诉你 <code><Provider /></code> 使用了 <code>context</code>这个实验性功能会怎么样？😱 这是真的！<code>provider</code> 组件将数据放在 context ，然后 <code>connect</code> 高阶组件从 context 读取数据。所以实际上， redux 并没有实现在任何地方访问数据… 是 context 做了这件事！</p><p>那么，现在知道为什么要使用 context 了吗？好吧。你可能已经知道并爱上它了！就算你没有直接使用 context, 你也可能通过 <a href="https://github.com/reactjs/react-redux/blob/76dd7faa90981dd2f9efa76f3e2f26ecf2c12cf7/src/components/connectAdvanced.js#L136-L143" target="_blank" rel="noopener">react-redux</a>, <a href="https://github.com/mobxjs/mobx-react/blob/dc249910c74c1b2e988a879be07f10aeaea90936/src/Provider.js#L19-L34" target="_blank" rel="noopener">MobX-react</a>, <a href="https://github.com/ReactTraining/react-router/blob/e6f9017c947b3ae49affa24cc320d0a86f765b55/packages/react-router/modules/Router.js#L23-L34" target="_blank" rel="noopener">react-router</a>, <a href="https://github.com/paypal/glamorous/blob/7468bfc76f46783cac841e20973ed119c771f3b7/src/theme-provider.js#L33-L37" target="_blank" rel="noopener">glamorous</a> 等间接地使用了它！</p><h2 id="Context-重生"><a href="#Context-重生" class="headerlink" title="Context 重生"></a>Context 重生</h2><p>尽管我们现在很喜欢 <code>context</code>, 但还记得那句“它很可能在将来的 react 版本中被移除”这句话吗？来吧，你会爱上它的！</p><p>一个多月以前， react 团队受到 <code>yarn</code>, <code>Rust</code>, <code>Ember</code> 的启发创建了 <a href="https://github.com/reactjs/rfcs" target="_blank" rel="noopener">RFCs 项目</a>。这个项目的第一个 PR 来自 Andrew Clark（react 核心团队成员）并称之为“<a href="https://github.com/reactjs/rfcs/pull/2" target="_blank" rel="noopener">新版 context</a>”。在这个提交中，Andrew 列出了新版 context 要实现的功能。这里面有一些有趣的讨论。几天后，Andrew 开了一个新 PR “新 context API”。</p><p>所以，它看起来像什么？它比旧的 context API 要直观一百万倍。这是我想到的最简单有用的例子：</p><iframe src="https://codesandbox.io/embed/n4r0qq898j" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><p>这是最简单的版本：</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">const</span> ThemeContext <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createContext</span><span class="token punctuation">(</span><span class="token string">'light'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">ThemeProvider</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>  state <span class="token operator">=</span> <span class="token punctuation">{</span>theme<span class="token punctuation">:</span> <span class="token string">'light'</span><span class="token punctuation">}</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ThemeContext.Provider</span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>theme<span class="token punctuation">}</span></span><span class="token punctuation">></span></span>        <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>children<span class="token punctuation">}</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ThemeContext.Provider</span><span class="token punctuation">></span></span>    <span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ThemeProvider</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ThemeContext.Consumer</span><span class="token punctuation">></span></span>        <span class="token punctuation">{</span>val <span class="token operator">=</span><span class="token operator">></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>val<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">}</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ThemeContext.Consumer</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ThemeProvider</span><span class="token punctuation">></span></span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>你可能注意到我在消费组件中使用了 <code>render props</code>（最佳实践！），但如果这不是你的菜，你也可以很容易地使用高阶组件或用了 context API 的其他方法去实现（这就是为什么它是最佳的）。</p><p>新的 context API 由以下几部分组件：</p><ul><li><code>React.createContext</code> 传递初始值（可选的使用位掩码功能）。这返回了一个包含 <code>Provider</code> 和 <code>Consumer</code> 的对象。</li><li><code>Provider</code> 在组件树中使用频率更高，并且接受一个 value 属性（可以是任何值）。</li><li><code>Consumer</code> 组件可以在 Provider 组件树下的任何地方使用，并接受一个“children”属性， children 必须是一个接受 value 值并返回 react 元素（JSX）的函数。</li></ul><p>看到这个API 我异常地兴奋。react 团队将会移除 context 是一个实验性功能的警告，因为它现在是这个框架的<a href="https://twitter.com/acdlite/status/957445801302618112" target="_blank" rel="noopener">一等功能</a>。这意味着开发者有希望使用 context 简单地解决 prop-drilling 问题，而不必借助 redux 这类工具来解决这个痛点，也能更好更自由地使用简单的 react 。（又或者， James Kyle<a href="https://github.com/thejameskyle/unstated" target="_blank" rel="noopener">未发布的</a>的解决方案是我们所期待的）</p><h2 id="Context-实践"><a href="#Context-实践" class="headerlink" title="Context 实践"></a>Context 实践</h2><p>关于这个新的 context API，我遇到的比较多的问题是（或者其他的 props render模式），如何组合 providers 和 consumers 组件。当你将一堆的 render prop 组件放在一起时，就会变成 <a href="https://twitter.com/acdlite/status/955955121979969537" target="_blank" rel="noopener">嵌套</a>:</p><p></p><blockquote class="twitter-tweet" data-conversation="none" data-lang="en"><p lang="en" dir="ltr">I mean come on (screen shot of actual code I’m playing with right now) <a href="https://t.co/Ucc8gaxPMp" target="_blank" rel="noopener">pic.twitter.com/Ucc8gaxPMp</a></p>— Andrew Clark (@acdlite) <a href="https://twitter.com/acdlite/status/955955121979969537?ref_src=twsrc%5Etfw" target="_blank" rel="noopener">January 24, 2018</a></blockquote><p></p><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><p>那我们如何避免这个问题？如果这让你很烦恼，那你可以像解决常规的 javascript 问题一样：使用实用函数/组件。这有个例子：</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">const</span> ThemeContext <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createContext</span><span class="token punctuation">(</span><span class="token string">'light'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">ThemeProvider</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">/* code */</span><span class="token punctuation">}</span><span class="token keyword">const</span> ThemeConsumer <span class="token operator">=</span> ThemeContext<span class="token punctuation">.</span>Consumer<span class="token keyword">const</span> LanguageContext <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createContext</span><span class="token punctuation">(</span><span class="token string">'en'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">LanguageProvider</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">/* code */</span><span class="token punctuation">}</span><span class="token keyword">const</span> LanguageConsumer <span class="token operator">=</span> LanguageContext<span class="token punctuation">.</span>Consumer<span class="token keyword">function</span> <span class="token function">AppProviders</span><span class="token punctuation">(</span><span class="token punctuation">{</span>children<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>LanguageProvider</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ThemeProvider</span><span class="token punctuation">></span></span>        <span class="token punctuation">{</span>children<span class="token punctuation">}</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ThemeProvider</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>LanguageProvider</span><span class="token punctuation">></span></span>  <span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">ThemeAndLanguageConsumer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>children<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>LanguageConsumer</span><span class="token punctuation">></span></span>      <span class="token punctuation">{</span>language <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ThemeConsumer</span><span class="token punctuation">></span></span>          <span class="token punctuation">{</span>theme <span class="token operator">=</span><span class="token operator">></span> <span class="token function">children</span><span class="token punctuation">(</span><span class="token punctuation">{</span>language<span class="token punctuation">,</span> theme<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ThemeConsumer</span><span class="token punctuation">></span></span>      <span class="token punctuation">)</span><span class="token punctuation">}</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>LanguageConsumer</span><span class="token punctuation">></span></span>  <span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>AppProviders</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ThemeAndLanguageConsumer</span><span class="token punctuation">></span></span>        <span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">{</span>theme<span class="token punctuation">,</span> language<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>theme<span class="token punctuation">}</span> and <span class="token punctuation">{</span>language<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">}</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ThemeAndLanguageConsumer</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>AppProviders</span><span class="token punctuation">></span></span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上面举例了一个常见的案例，并使用特殊的函数或组件去让这些案例更人性化。就像你平时处理问题一样，举对例子了吗？我希望有用 😅 </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>就像我上面说的，我对这个 API 非常感兴趣。它现在还未发布，但将发布在下一个版本的 react。不要担心，旧的 context API 将支持到下一个主版本号发布。所以每个人都会有足够的时间迁移。不要忘了，react 团队有超过 50,000 react 组件，很可能会发布一个 codemod 来自动升级大家的代码。</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;React’s-⚛️-new-Context-API&quot;&gt;&lt;a href=&quot;#React’s-⚛️-new-Context-API&quot; class=&quot;headerlink&quot; title=&quot;React’s ⚛️ new Context API&quot;&gt;&lt;/a&gt;React’s ⚛️ new Context API&lt;/h1&gt;&lt;p&gt;这是一种更人性化的方式，不再是“实验性功能”，并且现在它是一级API。并且使用了 &lt;code&gt;render prop&lt;/code&gt;!
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="react" scheme="http://robin-front.github.io/tags/react/"/>
    
      <category term="context" scheme="http://robin-front.github.io/tags/context/"/>
    
  </entry>
  
  <entry>
    <title>javascript 判断正负0</title>
    <link href="http://robin-front.github.io/2018/01/14/judge-positive-and-negative-0.html"/>
    <id>http://robin-front.github.io/2018/01/14/judge-positive-and-negative-0.html</id>
    <published>2018-01-14T00:47:06.000Z</published>
    <updated>2018-01-14T00:47:06.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="javascript-判断正负0"><a href="#javascript-判断正负0" class="headerlink" title="javascript 判断正负0"></a>javascript 判断正负0</h1><p>ES 2015/ ES 6 新增了一个方法用于 javascript 相等性判断 – <code>Object.is()</code>。它与之前的相等比较运算符有什么不同呢？<a id="more"></a></p><h2 id="三种不同的值比较操作"><a href="#三种不同的值比较操作" class="headerlink" title="三种不同的值比较操作"></a>三种不同的值比较操作</h2><ul><li>抽象相等比较 (==)：将执行类型转换再进行比较，特殊地：Null 与 undefined 返回 true, 任何类型与 NaN返回 false, +0与-0为true.</li><li>严格等于运算符（===）:不会执行类型转换，类型不一致返回false,特殊地：NaN与NaN为false,+0与-0为true.</li><li><code>Object.is</code>: 基本与全等（===）相同，特殊地：NaN与NaN为true,+0与-0为false.</li></ul><h2 id="0-与-0-到底是否相同"><a href="#0-与-0-到底是否相同" class="headerlink" title="+0 与 -0 到底是否相同"></a>+0 与 -0 到底是否相同</h2><p>答案是不同。</p><p>一般地，使用全等运算符（===）是比较安全的操作，但是正负零是返回true，容易让人有一种存在一种0的错觉。</p><p>在高版本的Node中，正负0的符号是区别对待的，正0显示为0，负0显示为 -0。</p><p>在除法中，<code>1/+0</code> 为 <code>+Infinity</code>, <code>1/-0</code> 为 <code>-Infinity</code>，而 <code>+Infinity === -Infinity</code> 返回 false.</p><p>同时根据 javascript 64位双精度浮点数，第 1 位是正负数符号位（sign），0代表正数，1代表负数，中间的 11 位存储指数（exponent），用来表示次方数，最后的 52 位是尾数（mantissa），超出的部分自动进一舍零。所以正负0的表示是不同的。</p><p>疑问：如果正负 0 确实是两个数，为什么全等判断中会相同？</p><p>通过查看规范，</p><pre><code>比较 x === y，x 和 y 为值，需要产出 true 或 false。比较过程如下：  - 如果 Type(x) 与 Type(y) 的结果不一致，返回 false。  - 如果 Type(x) 结果为 Undefined，返回 true。  - 如果 Type(x) 结果为 Null，返回 true。  - 如果 Type(x) 结果为 Number，则    - 如果 x 为 NaN，返回 false。    - 如果 y 为 NaN，返回 false。    - 如果 x 与 y 为同一个数字，返回 true。    - 如果 x 为 +0，y 为 -0，返回 true。    - 如果 x 为 -0，y 为 +0，返回 true。    - 返回 false。  - 如果 Type(x) 结果为 String，如果 x 与 y 为完全相同的字符序列（相同的长度和相同的字符对应相同的位置），返回 true，否则，返回 false。  - 如果 Type(x) 结果为 Boolean，如果 x 与 y 都为 true 或 false，则返回 true，否则，返回 false。  - 如果 x 和 y 引用到同一个 Object 对象，返回 true，否则，返回 false。</code></pre><p>全等运算符虽然没有作类型转换，但也是针对 <code>NaN</code>、<code>+0</code>、<code>-0</code> 作了特殊处理。</p><h2 id="区分正负零的方法"><a href="#区分正负零的方法" class="headerlink" title="区分正负零的方法"></a>区分正负零的方法</h2><p>通过以上知识点，可以总结出：</p><p>1、通过除 0 法判断：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> isNegativeZero <span class="token operator">=</span> num <span class="token operator">=</span><span class="token operator">></span> num <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token number">1</span><span class="token operator">/</span>num <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">Infinity</span><span class="token punctuation">;</span></code></pre><p>2、通过 <code>object.is</code></p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> isNegativeZero <span class="token operator">=</span> num <span class="token operator">=</span><span class="token operator">></span> Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Object.is</code> 是ES2015 新特性，与 <code>===</code> 不一样的是：它可以正确分辨 正负零 及 NaN。</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;javascript-判断正负0&quot;&gt;&lt;a href=&quot;#javascript-判断正负0&quot; class=&quot;headerlink&quot; title=&quot;javascript 判断正负0&quot;&gt;&lt;/a&gt;javascript 判断正负0&lt;/h1&gt;&lt;p&gt;ES 2015/ ES 6 新增了一个方法用于 javascript 相等性判断 – &lt;code&gt;Object.is()&lt;/code&gt;。它与之前的相等比较运算符有什么不同呢？
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://robin-front.github.io/tags/javascript/"/>
    
      <category term="基础" scheme="http://robin-front.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="isNegativeZero" scheme="http://robin-front.github.io/tags/isNegativeZero/"/>
    
  </entry>
  
  <entry>
    <title>从微信跳一跳看加密算法选择</title>
    <link href="http://robin-front.github.io/2018/01/03/through-wechat-t1t-think-about-crypto.html"/>
    <id>http://robin-front.github.io/2018/01/03/through-wechat-t1t-think-about-crypto.html</id>
    <published>2018-01-03T14:57:18.000Z</published>
    <updated>2018-01-04T15:02:18.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="通过微信小游戏跳一跳，看加密算法的选择"><a href="#通过微信小游戏跳一跳，看加密算法的选择" class="headerlink" title="通过微信小游戏跳一跳，看加密算法的选择"></a>通过微信小游戏跳一跳，看加密算法的选择</h1><p>近期微信更新，有跳一跳的游戏，并被网友找出源码并刷分，我也试了一下，成功刷了 1024。其中看到这个游戏使用了常用加密库 <code>crypto-js</code>（不支持RSA），它可以在浏览器端使用。而 nodejs 也有 <code>crypto</code> 模块，而且支持的加密算法更多。下面就来看看加密算法有哪些，并如何根据场景选择算法。<a id="more"></a></p><h2 id="常用加密算法"><a href="#常用加密算法" class="headerlink" title="常用加密算法"></a>常用加密算法</h2><h3 id="Hash-算法"><a href="#Hash-算法" class="headerlink" title="Hash 算法"></a>Hash 算法</h3><p>能计算出一个消息所对应到的，长度固定的字符串（又称消息摘要）的算法。</p><p><strong>结果值长的 Hash 算法也能用于验证文件或数据的完整性。</strong></p><p>Hash 算法通常有：<code>md5</code>,<code>sha</code>,<code>sha1</code>,<code>sha256</code>,<code>sha512</code>,<code>RSA-SHA</code>; 但 <code>crypto-js</code> 不支持 <code>RSA</code>。这里挑几个。</p><p>测试效率和结果：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> CryptoJS <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'crypto-js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span>hashs<span class="token punctuation">,</span> txt<span class="token punctuation">)</span> <span class="token punctuation">{</span>  hashs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>name <span class="token operator">=</span><span class="token operator">></span> <span class="token function">hashAlgorithm</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> txt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">hashAlgorithm</span><span class="token punctuation">(</span>algorithm<span class="token punctuation">,</span> txt<span class="token punctuation">)</span> <span class="token punctuation">{</span>  algorithm <span class="token operator">=</span> algorithm<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span>algorithm<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>algorithm<span class="token punctuation">,</span> CryptoJS<span class="token punctuation">[</span>algorithm<span class="token punctuation">]</span><span class="token punctuation">(</span>txt<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span>algorithm<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> algs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'md5'</span><span class="token punctuation">,</span> <span class="token string">'sha1'</span><span class="token punctuation">,</span> <span class="token string">'sha256'</span><span class="token punctuation">,</span> <span class="token string">'sha512'</span><span class="token punctuation">,</span> <span class="token string">'sha3'</span><span class="token punctuation">,</span> <span class="token string">'sha384'</span><span class="token punctuation">,</span> <span class="token string">'ripemd160'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">test</span><span class="token punctuation">(</span>algs<span class="token punctuation">,</span> <span class="token string">'robin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// `crypto-js`</span><span class="token comment" spellcheck="true">// MD5 8ee60a2e00c90d7e00d5069188dc115b</span><span class="token comment" spellcheck="true">// MD5: 3.229ms</span><span class="token comment" spellcheck="true">// SHA1 474ee9ee179b0ecf0bc27408079a0b15eda4c99d</span><span class="token comment" spellcheck="true">// SHA1: 0.485ms</span><span class="token comment" spellcheck="true">// SHA256 287782ef42356ef3d6551590f1ef0117b71d876df0f9b3eb58d088864770c74c</span><span class="token comment" spellcheck="true">// SHA256: 0.505ms</span><span class="token comment" spellcheck="true">// SHA512 071b38098125700fe49e65ef0059bfda1fbd110472a8d7490e0b3af6a8260712f958b9c7f27be61a8ddfe4fecb71f9e8002360f894f06dd4b1f383963d71db41</span><span class="token comment" spellcheck="true">// SHA512: 1.519ms</span><span class="token comment" spellcheck="true">// SHA3 a621609aa4b8be7efac720538c86e998ebfa1ea67e4d10fa94df74388bbf443e18d92ca5bf483b789f6b42ea4f98bb086f48664bd5c1f4df476629419fa9e8b8</span><span class="token comment" spellcheck="true">// SHA3: 1.150ms</span><span class="token comment" spellcheck="true">// SHA384 2750a9f5dadea58259fb17a3259b00a94648d40481eea91dc0e585e151e751001dc86457aa765019b0ca9721841b59f9</span><span class="token comment" spellcheck="true">// SHA384: 0.498ms</span><span class="token comment" spellcheck="true">// RIPEMD160 9ef3a5f5ede0a741e38740cc3cc3e1bfcdeaece5</span><span class="token comment" spellcheck="true">// RIPEMD160: 0.661ms</span><span class="token comment" spellcheck="true">// &lt;!--node crypto --></span><span class="token comment" spellcheck="true">// md5,8ee60a2e00c90d7e00d5069188dc115b</span><span class="token comment" spellcheck="true">// md5: 0.093ms</span><span class="token comment" spellcheck="true">// sha,0894ec72c817d851286dd9c7309db3408b1dd620</span><span class="token comment" spellcheck="true">// sha: 0.056ms</span><span class="token comment" spellcheck="true">// sha1,474ee9ee179b0ecf0bc27408079a0b15eda4c99d</span><span class="token comment" spellcheck="true">// sha1: 0.023ms</span><span class="token comment" spellcheck="true">// sha256,287782ef42356ef3d6551590f1ef0117b71d876df0f9b3eb58d088864770c74c</span><span class="token comment" spellcheck="true">// sha256: 0.029ms</span><span class="token comment" spellcheck="true">// sha512,071b38098125700fe49e65ef0059bfda1fbd110472a8d7490e0b3af6a8260712f958b9c7f27be61a8ddfe4fecb71f9e8002360f894f06dd4b1f383963d71db41</span><span class="token comment" spellcheck="true">// sha512: 0.033ms</span><span class="token comment" spellcheck="true">// RSA-SHA,0894ec72c817d851286dd9c7309db3408b1dd620</span><span class="token comment" spellcheck="true">// RSA-SHA: 0.023ms</span></code></pre><p>通常哈希算法用于登陆密码的加密。这里看到 <code>SHA1</code> 居然比 <code>MD5</code>要快，而且安全性更高，建议使用 <code>SHA1</code> 或 <code>SHA256</code>、<code>SHA512</code>, MD5 也由于字典库的出现和计算机性能的提升而变得相对不安全。</p><p>以下是维基百科的参考：</p><p><div class="progress-images" style="width:1685px"><div class="progress-images--placeholder" style="padding-bottom: 33.11572700296736%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="" class="progress-images--original" data-original="/images/201801/hash.jpeg" data-thumb="/images/thumb/9b5fd9bb515e68da97b9d9f343718f63.jpeg"></div></p><h3 id="salt-加盐"><a href="#salt-加盐" class="headerlink" title="salt 加盐"></a>salt 加盐</h3><p>由于被加密信息，很容易被使用彩虹表暴力破解，特别是 md5 这类已经出现案例的情况。另一种情况是大家的方法都是使用 md5 或 SHA1，那其实只是把明文密码变成更复杂密文，并不能很有效地防止撞库，攻击者可以直接用加密后的密文进行伪造请求进行登陆。</p><p>这时我们可以使用 salt, 把 salt 到密码的前、中、后部分，再加密，这样只要攻击者没有原始密码或你的 salt 与其他网站不同就能保证相对安全。还可以将 salt 分开、倒序、hash后插入。</p><p>例如：</p><pre class=" language-js"><code class="language-js"><span class="token function">SHA3</span><span class="token punctuation">(</span><span class="token function">SHA3</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span> <span class="token operator">+</span> salt<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>另外还有 <code>pbkdf2</code>、 <code>bcrypt</code> 算法，它是一种适应性加密算法，可以根据需要设置迭代强度，以防止日益增长的电脑性能。 <code>bcrypt(password, salt, cost)</code> cost 是毫秒。攻击者就需要花更长的时间。</p><h3 id="Hmac-密钥散列消息认证码-Keyed-hash-message-authentication-code"><a href="#Hmac-密钥散列消息认证码-Keyed-hash-message-authentication-code" class="headerlink" title="Hmac 密钥散列消息认证码(Keyed-hash message authentication code)"></a>Hmac 密钥散列消息认证码(Keyed-hash message authentication code)</h3><p>类似加盐处理，HMAC 运算利用 Hash 算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。HMAC 也可以有效防止一些类似md5的彩虹表等攻击，比如一些常见的密码直接MD5存入数据库的，可能被反向破解。因为除了密码，还有一个可以是任意值的 key。相同密码，不同的 key 生成的值是不一样的。</p><p>看一下用法：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> CryptoJS <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'crypto-js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">run</span><span class="token punctuation">(</span>hashs<span class="token punctuation">,</span> txt<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>  hashs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>name <span class="token operator">=</span><span class="token operator">></span> <span class="token function">hmacAlgorithm</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> txt<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">hmacAlgorithm</span><span class="token punctuation">(</span>algorithm<span class="token punctuation">,</span> txt<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>  algorithm <span class="token operator">=</span> algorithm<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span>algorithm<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>algorithm<span class="token punctuation">,</span> CryptoJS<span class="token punctuation">[</span><span class="token string">'Hmac'</span><span class="token operator">+</span>algorithm<span class="token punctuation">]</span><span class="token punctuation">(</span>txt<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span>algorithm<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> algs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'md5'</span><span class="token punctuation">,</span> <span class="token string">'sha1'</span><span class="token punctuation">,</span> <span class="token string">'sha256'</span><span class="token punctuation">,</span> <span class="token string">'sha512'</span><span class="token punctuation">,</span> <span class="token string">'sha3'</span><span class="token punctuation">,</span> <span class="token string">'sha384'</span><span class="token punctuation">,</span> <span class="token string">'ripemd160'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">run</span><span class="token punctuation">(</span>algs<span class="token punctuation">,</span> <span class="token string">'robin'</span><span class="token punctuation">,</span> <span class="token string">'abc'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">run</span><span class="token punctuation">(</span>algs<span class="token punctuation">,</span> <span class="token string">'robin'</span><span class="token punctuation">,</span> <span class="token string">'adaslfjklsjdsafdasflsjfklasdhgkjashdfkasdklyreoiwqurenwmehrqoewnfknoineclwqnrewqmewqlrnewqfeqrbkwviwbqovbdpcsabveiwbqvibwvwibqvkbwibvkbwibvfldsalfjdklsaflkausld'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// short key</span><span class="token comment" spellcheck="true">// MD5 97ddf30a37c08700f6b8668b1b6cc4e5</span><span class="token comment" spellcheck="true">// MD5: 4.226ms</span><span class="token comment" spellcheck="true">// SHA1 131e69c8d75cf3f5735c4320386f35dc93da2c89</span><span class="token comment" spellcheck="true">// SHA1: 2.286ms</span><span class="token comment" spellcheck="true">// SHA256 4890c6579ce63619e31452ce80d1f917143987dfc131c0f61c195066b62753e3</span><span class="token comment" spellcheck="true">// SHA256: 1.063ms</span><span class="token comment" spellcheck="true">// SHA512 64c34aff6f972dc8bef245c03198e8f3a7c9bda7bc208f01793fd03a93d89db0ca0d0235615c976d5ff331425adae7a5812c8d42b5bff30ab2e95683ad06eed8</span><span class="token comment" spellcheck="true">// SHA512: 1.937ms</span><span class="token comment" spellcheck="true">// SHA3 27dc845b20795d64d25feabcac3d4f90297f32947780886bc16f4b18de850b7ac7d5bd021788d7b17fd4ad7da06cdadf650b7bfdb916394881902759b96dc8a6</span><span class="token comment" spellcheck="true">// SHA3: 3.293ms</span><span class="token comment" spellcheck="true">// SHA384 cfe9ad71dc48deb9a778a68c8106370ead173e13fbcb77160a75ac190d2a4e201f962811d3c439f241892d4c69e604f1</span><span class="token comment" spellcheck="true">// SHA384: 2.487ms</span><span class="token comment" spellcheck="true">// RIPEMD160 30de5538bfb0063ee42da27cdffe1c9f11f7acd0</span><span class="token comment" spellcheck="true">// RIPEMD160: 1.327ms</span><span class="token comment" spellcheck="true">//  ****long key</span><span class="token comment" spellcheck="true">// MD5 6c6d9995b33e4b7c992201bf54add3c4</span><span class="token comment" spellcheck="true">// MD5: 0.244ms</span><span class="token comment" spellcheck="true">// SHA1 b71857c24215ab762033cf48a39b385eb5e299f6</span><span class="token comment" spellcheck="true">// SHA1: 0.246ms</span><span class="token comment" spellcheck="true">// SHA256 7a9cbb46c0506bf52051c32f487142696316831af3d7af258389b9d83249660e</span><span class="token comment" spellcheck="true">// SHA256: 0.280ms</span><span class="token comment" spellcheck="true">// SHA512 05d1928b5a977cfe0a1e016e193f5f9c0e7ea7243e4b233d9a77508ec9ee18c4834485eb1a8a7803f8c8eb04a7b03df390e7bbf677c57d989c2c0101b10433f1</span><span class="token comment" spellcheck="true">// SHA512: 0.750ms</span><span class="token comment" spellcheck="true">// SHA3 940fbf3853c76c70e0f50577bbc8b8252eee3d4404049e2bb2106c01419c1aa5b84a46ff0a6eedb699b3b1508e9d14915aceaaa3b037a04f6916c0c1f4e5f84c</span><span class="token comment" spellcheck="true">// SHA3: 1.589ms</span><span class="token comment" spellcheck="true">// SHA384 757946847447f8f52ade051b64cc1ad5c475c356a356cca7c81f36238ab4fce7c3af7fb69fc23eb4039aa7c7f20a077d</span><span class="token comment" spellcheck="true">// SHA384: 2.396ms</span><span class="token comment" spellcheck="true">// RIPEMD160 b92809af726d17aad164a128a19643a388213aa3</span><span class="token comment" spellcheck="true">// RIPEMD160: 0.596ms</span></code></pre><p>可以看到长短 key 算法不同，性能也不同，一般推荐 key 长度大于 哈希值长度。Node 原生模块就不测了，性能只能更好。</p><h3 id="加密与解密"><a href="#加密与解密" class="headerlink" title="加密与解密"></a>加密与解密</h3><p>上面的哈希算法严格意义上说不算加密算法，因为一般储存的也是密文，只是为了传输过程中或泄漏之后不被看到明文密码，或加大暴力破解的难度，从而降低风险。更高安全要求的就需要用到解密。可以分为对称加密和不对称加密。</p><ul><li>对称加密：加密和解密密钥相同。代表是 AES， 速度快，安全性高，最流行的加密算法之一，中文也叫 高级加密标准（Advanced Encryption Standard）。另外还有DES、3DES、Blowfish、IDEA、RC5、RC6</li><li>非对称加密： 加密和解密密钥不同。代表是 RSA， 速度慢，安全性高；还有ECC（椭圆曲线加密算法）、ElGamal、背包算法、Rabin（RSA的特例）</li></ul><p>加密与解密最重要的是密钥。</p><p>对称加密： （如何选择，就看性能和安全性的要求了）</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> CryptoJS <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'crypto-js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">run</span><span class="token punctuation">(</span>hashs<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>  hashs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>name <span class="token operator">=</span><span class="token operator">></span> <span class="token function">encrypt</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">encrypt</span><span class="token punctuation">(</span>algorithm<span class="token punctuation">,</span> txt<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> shasum <span class="token operator">=</span> CryptoJS<span class="token punctuation">[</span>algorithm<span class="token punctuation">]</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span>algorithm<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>algorithm<span class="token punctuation">,</span> shasum<span class="token punctuation">.</span><span class="token function">encrypt</span><span class="token punctuation">(</span>txt<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">.</span>ciphertext<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span>algorithm<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> algs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'AES'</span><span class="token punctuation">,</span> <span class="token string">'TripleDES'</span><span class="token punctuation">,</span> <span class="token string">'RC4'</span><span class="token punctuation">,</span> <span class="token string">'Rabbit'</span><span class="token punctuation">,</span> <span class="token string">'RabbitLegacy'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">run</span><span class="token punctuation">(</span>algs<span class="token punctuation">,</span> <span class="token string">'robin'</span><span class="token punctuation">,</span> <span class="token string">'reiki'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// output</span><span class="token comment" spellcheck="true">// AES 4fe1199d6a3aee50fd285017ba841109</span><span class="token comment" spellcheck="true">// AES: 5.589ms</span><span class="token comment" spellcheck="true">// TripleDES 90374ffa15857553</span><span class="token comment" spellcheck="true">// TripleDES: 1.739ms</span><span class="token comment" spellcheck="true">// RC4 a9a8932b19</span><span class="token comment" spellcheck="true">// RC4: 0.738ms</span><span class="token comment" spellcheck="true">// Rabbit 49fa9bd558</span><span class="token comment" spellcheck="true">// Rabbit: 1.063ms</span><span class="token comment" spellcheck="true">// RabbitLegacy 6b8d025024</span><span class="token comment" spellcheck="true">// RabbitLegacy: 1.022ms</span></code></pre><h2 id="客户端如何选择加密算法"><a href="#客户端如何选择加密算法" class="headerlink" title="客户端如何选择加密算法"></a>客户端如何选择加密算法</h2><p><strong>对于客户端，由于源码可泄露，也就相当于客户端的加密方法可暴露。以及 http 可被劫持等不安全因素。普通的加密根本没什么用。但并不是说客户端不用加密，而是要求服务端必须再次加密，或客户端采用安全系数更高的加密方式。另外也推荐升级 https。</strong></p><p>我也并不了解所有算法，但是可以看需求，看场景，抛开场景谈技术就是耍流氓。</p><p>首先是否需要解密，安全性要求如何，一般的就使用 hash 算法，要求高一点就用 hmac。</p><p>如果需要解密，还要考虑性能及密钥的安全性。</p><p>微信跳一跳为什么选 AES？</p><p><div class="progress-images" style="width:720px"><div class="progress-images--placeholder" style="padding-bottom: 72.36111111111111%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="" class="progress-images--original" data-original="/images/201801/source.jpg" data-thumb="/images/thumb/ea7c0db2323bbfa33cafb5a603c019c6.jpg"></div></p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 跳一跳 game.js 里的加密算法</span>e<span class="token punctuation">.</span>encrypt <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// sessionID 前16位</span>    i <span class="token operator">=</span> n<span class="token punctuation">.</span><span class="token keyword">default</span><span class="token punctuation">.</span>enc<span class="token punctuation">.</span>Utf8<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// base64 utf8</span>    r <span class="token operator">=</span> n<span class="token punctuation">.</span><span class="token keyword">default</span><span class="token punctuation">.</span>enc<span class="token punctuation">.</span>Utf8<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 同上</span>    a <span class="token operator">=</span> t<span class="token punctuation">;</span>    a <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> o <span class="token operator">=</span> n<span class="token punctuation">.</span><span class="token keyword">default</span><span class="token punctuation">.</span>AES<span class="token punctuation">.</span><span class="token function">encrypt</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// AES 非对称加密，a为加密内容，i是密钥，</span>        iv<span class="token punctuation">:</span> r<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// iv参数</span>        mode<span class="token punctuation">:</span> n<span class="token punctuation">.</span><span class="token keyword">default</span><span class="token punctuation">.</span>mode<span class="token punctuation">.</span>CBC<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 加密模式，AES包含ECB，CBC，CFB等加密模式，这些模式除了ECB由于没有使用IV而不太安全</span>        padding<span class="token punctuation">:</span> n<span class="token punctuation">.</span><span class="token keyword">default</span><span class="token punctuation">.</span>pad<span class="token punctuation">.</span>Pkcs7 <span class="token comment" spellcheck="true">// 加密填充，块加密的一个要面临的问题就是如何填满最后一块</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> o <span class="token operator">=</span> o<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>其实这个方法是遵循小程序文档里的加密解密指导的： <a href="https://mp.weixin.qq.com/debug/wxagame/dev/tutorial/signature.html" target="_blank" rel="noopener">用户数据的签名验证和加解密</a></p><p>首先分析上传游戏分数需要客户端加密，然后服务端解密提取分数记录。那就有对称加密和非对称加密两种。对于非对称加密，需要下发公钥，并且公钥和私钥必须配对，速度也慢，这对一个小游戏来说操作太麻烦。那就锁定对称加密。但如何传递密钥呢，所以它用了 sessionID 作为密钥，客户端和服务端都知道，并且可以每次登陆更新，安全性高。并且微信 API 使用了 https，防止一般抓包，安全性更高。</p><p>另外，对于源码，一般也会工程化构建，进行压缩，混淆。但对于源码会泄漏的情况下，又是用户本身主动抓包，还能看懂程序，游戏类型只是上传分数，这就出现了刷分的可能性。当然，分高有什么用呢，这本身只是娱乐。</p><p><div class="progress-images" style="width:720px"><div class="progress-images--placeholder" style="padding-bottom: 177.77777777777777%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="" class="progress-images--original" data-original="/images/201801/t1t.jpg" data-thumb="/images/thumb/cf0b03f50a8b654a318c9a9006e769d1.jpg"></div></p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;通过微信小游戏跳一跳，看加密算法的选择&quot;&gt;&lt;a href=&quot;#通过微信小游戏跳一跳，看加密算法的选择&quot; class=&quot;headerlink&quot; title=&quot;通过微信小游戏跳一跳，看加密算法的选择&quot;&gt;&lt;/a&gt;通过微信小游戏跳一跳，看加密算法的选择&lt;/h1&gt;&lt;p&gt;近期微信更新，有跳一跳的游戏，并被网友找出源码并刷分，我也试了一下，成功刷了 1024。其中看到这个游戏使用了常用加密库 &lt;code&gt;crypto-js&lt;/code&gt;（不支持RSA），它可以在浏览器端使用。而 nodejs 也有 &lt;code&gt;crypto&lt;/code&gt; 模块，而且支持的加密算法更多。下面就来看看加密算法有哪些，并如何根据场景选择算法。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="wechat" scheme="http://robin-front.github.io/tags/wechat/"/>
    
      <category term="crypto" scheme="http://robin-front.github.io/tags/crypto/"/>
    
      <category term="algorithm" scheme="http://robin-front.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>css counters 计数器</title>
    <link href="http://robin-front.github.io/2017/12/21/using-css-counters.html"/>
    <id>http://robin-front.github.io/2017/12/21/using-css-counters.html</id>
    <published>2017-12-21T16:43:36.000Z</published>
    <updated>2017-12-21T16:43:36.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="让-css-像编程语言一样实现计数，IE-8-也支持的-css-计数器"><a href="#让-css-像编程语言一样实现计数，IE-8-也支持的-css-计数器" class="headerlink" title="让 css 像编程语言一样实现计数，IE 8 也支持的 css 计数器"></a>让 css 像编程语言一样实现计数，IE 8 也支持的 css 计数器</h1><p><code>css counters</code> 是一个我们可以利用特定属性增减计算的变量。通过它，我们可以做一些类似编程语言的通用的迭代。</p><p>这个方式可以用于一些创造性的解决方案，包括一些重复代码的计数器。<a id="more"></a></p><p>为了控制计数器，你需要使用 <code>counter-reset</code> 和 <code>counter-increment</code> 属性，同时与 <code>counter()</code> 和 <code>counters()</code> 函数配对。如果没有地方展示计数器，这个方法就没有任何存在的价值，对此，我们可以使用简化的 <code>content</code> 属性。</p><p>表现也很简单。假设你有一个无序列表，你想要计算列表项。在 <code>ul</code> 元素上指定一个计数器，并且在 <code>li</code> 元素上增加计数。</p><h2 id="counter-reset-属性"><a href="#counter-reset-属性" class="headerlink" title="counter-reset 属性"></a>counter-reset 属性</h2><p>我们可以使用 <code>counter-reset</code> 属性定义我们的计数器变量。对于这一点，我们可以任意命名并且可选择一个计数初始值。默认起始值是 0。这个应设置在父元素。</p><h2 id="counter-increment-属性"><a href="#counter-increment-属性" class="headerlink" title="counter-increment 属性"></a>counter-increment 属性</h2><p>通过使用 <code>counter-increment</code> 属性，我们可以增加或减少我们的计数器的值。这个属性也有第二个可选参数值，可以指定每次增减的幅度。</p><h2 id="counter-函数"><a href="#counter-函数" class="headerlink" title="counter() 函数"></a>counter() 函数</h2><p><code>counter()</code> 函数主要为了展现计数器。展示的地方就是 <code>content</code> 属性，因为这是一个你可以将数据通过 css 回填到 html 的属性；第一个参数是计数器变量名，第二个参数是<a href="https://drafts.csswg.org/css-counter-styles-3/#typedef-counter-style" target="_blank" rel="noopener">计数器类型</a>（可选）。</p><blockquote><p>注意：在 css 中没有连接运算符，所以如果你想连接 content 属性里的两个值，只能值用空格。</p></blockquote><h2 id="counters-函数"><a href="#counters-函数" class="headerlink" title="counters() 函数"></a>counters() 函数</h2><p>这个函数和 <code>counter()</code> 函数一样。主要的不同是 <code>counters()</code> 你可以嵌套计数器到另一个，就像多级嵌套的 ul 列表。它有三个参数，第一个是计数器名，第二个是分隔符，第三个参数是计数器类型（可选）。</p><hr><h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><h3 id="案例1-文档-issue-自动追踪"><a href="#案例1-文档-issue-自动追踪" class="headerlink" title="案例1 - 文档 issue 自动追踪"></a>案例1 - 文档 issue 自动追踪</h3><p>当你有一些重复的元素，并且想去统计它们，这个方法可以方便你解决这个问题。</p><p>我们创建一个 <code>counter-reset</code> 在我们的 <code>.container</code> 父级元素。之后，我们给 issues 的类名设置 <code>counter-increment</code> 属性。最后，我们通过 content 属性在 <code>.issues:before</code> 元素上输出计数器的值。</p><p></p><p data-height="265" data-theme-id="0" data-slug-hash="RrKBpJ" data-default-tab="html,result" data-user="adamlaki" data-embed-version="2" data-pen-title="CSS Counter Example" class="codepen">See the Pen <a href="https://codepen.io/adamlaki/pen/RrKBpJ/" target="_blank" rel="noopener">CSS Counter Example</a> by Adam Laki (<a href="https://codepen.io/adamlaki" target="_blank" rel="noopener">@adamlaki</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script><h3 id="案例2-嵌套列表"><a href="#案例2-嵌套列表" class="headerlink" title="案例2 -  嵌套列表"></a>案例2 -  嵌套列表</h3><p>使用 <code>counters()</code> ，我们可以让嵌套列表实现文本编辑器里的效果。</p><p></p><p data-height="265" data-theme-id="0" data-slug-hash="MrjmLX" data-default-tab="css,result" data-user="robin-l" data-embed-version="2" data-pen-title="MrjmLX" class="codepen">See the Pen <a href="https://codepen.io/robin-l/pen/MrjmLX/" target="_blank" rel="noopener">MrjmLX</a> by robin-l (<a href="https://codepen.io/robin-l" target="_blank" rel="noopener">@robin-l</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script><h3 id="案例3-复选框选择计数器"><a href="#案例3-复选框选择计数器" class="headerlink" title="案例3 - 复选框选择计数器"></a>案例3 - 复选框选择计数器</h3><p>使用 input 的 <code>:checked</code> 伪类，我们可以知道复选框是否选中，因此我们也能递增我们的计数器。</p><p></p><p data-height="265" data-theme-id="0" data-slug-hash="OzRmGW" data-default-tab="css,result" data-user="robin-l" data-embed-version="2" data-pen-title="OzRmGW" class="codepen">See the Pen <a href="https://codepen.io/robin-l/pen/OzRmGW/" target="_blank" rel="noopener">OzRmGW</a> by robin-l (<a href="https://codepen.io/robin-l" target="_blank" rel="noopener">@robin-l</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script><h3 id="其他案例"><a href="#其他案例" class="headerlink" title="其他案例"></a>其他案例</h3><ul><li>Šime Vidas 发布的<a href="https://codepen.io/simevidas/pen/xpbLmV?editors=0100" target="_blank" rel="noopener">脚注例子</a></li><li>Sam Dutton 制作的<a href="https://codepen.io/samdutton/pen/xpGxbY" target="_blank" rel="noopener">有趣的行数例子</a></li></ul></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;让-css-像编程语言一样实现计数，IE-8-也支持的-css-计数器&quot;&gt;&lt;a href=&quot;#让-css-像编程语言一样实现计数，IE-8-也支持的-css-计数器&quot; class=&quot;headerlink&quot; title=&quot;让 css 像编程语言一样实现计数，IE 8 也支持的 css 计数器&quot;&gt;&lt;/a&gt;让 css 像编程语言一样实现计数，IE 8 也支持的 css 计数器&lt;/h1&gt;&lt;p&gt;&lt;code&gt;css counters&lt;/code&gt; 是一个我们可以利用特定属性增减计算的变量。通过它，我们可以做一些类似编程语言的通用的迭代。&lt;/p&gt;
&lt;p&gt;这个方式可以用于一些创造性的解决方案，包括一些重复代码的计数器。
    
    </summary>
    
      <category term="css" scheme="http://robin-front.github.io/categories/css/"/>
    
    
      <category term="css counters" scheme="http://robin-front.github.io/tags/css-counters/"/>
    
  </entry>
  
  <entry>
    <title>简洁代码与冗余代码</title>
    <link href="http://robin-front.github.io/2017/11/29/clean-code-dirty-code.html"/>
    <id>http://robin-front.github.io/2017/11/29/clean-code-dirty-code.html</id>
    <published>2017-11-29T09:49:43.000Z</published>
    <updated>2017-11-29T09:49:43.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="简洁代码与冗余代码"><a href="#简洁代码与冗余代码" class="headerlink" title="简洁代码与冗余代码"></a>简洁代码与冗余代码</h1><p>这篇文章将重点介绍适用于现代 react 软件开发的简洁代码之道。我还会谈谈 ES6/ES2015 带来的一些“语法糖”。<a id="more"></a></p><h2 id="什么是简洁代码之道，为什么我如此关心？"><a href="#什么是简洁代码之道，为什么我如此关心？" class="headerlink" title="什么是简洁代码之道，为什么我如此关心？"></a>什么是简洁代码之道，为什么我如此关心？</h2><p>简洁代码之道的一贯编码风格是让你的代码更易写、易读和易维护。经常，程序员在一个问题上花了许多时间，一旦问题被解决，就提交代码。我一直主张，你的工作并没有完成，因为你只是让你的代码“正常工作”而已。</p><p>这是一个机会来精简你的代码，通过删除死代码（僵尸代码）、重构、删除被注释的代码！努力提高可维护性。扪心自问，“6个月后其他人还能理解你的代码吗？”</p><p>简单来说，编写能让你自豪到带回家和母亲炫耀的代码。</p><p>为什么你要这么关心这个问题？因为如果你是一个好开发者，你会很懒。听我说完，我是赞扬的意思。一个好的开发者，面对同一件事要做很多遍的状况，通常会寻找一个自动解决（或更好的）方案来完成眼前的任务。所以，因为你很懒，关注简洁代码的技术将会减少你拉取代码一遍又一遍地 review 同一段代码的频率。</p><h2 id="通过嗅觉测试精简代码"><a href="#通过嗅觉测试精简代码" class="headerlink" title="通过嗅觉测试精简代码"></a>通过嗅觉测试精简代码</h2><p>精简代码应该通过嗅觉测试。不明白我是什么意思？我们都看着（自己的或别人的）代码说：“这里不太对劲。” 记住，如果感觉不太对劲，那可能真的不对劲。一起对代码深思熟虑是好的。但如果你发觉你正在把一个方形的钉子插进一个圆形的洞里，那就请停下来，退一步，并且休息一下。最多十次，你会找到更好的解决办法的。</p><h2 id="精简代码就是-DRY-（禁止重复）"><a href="#精简代码就是-DRY-（禁止重复）" class="headerlink" title="精简代码就是 DRY （禁止重复）"></a>精简代码就是 DRY （禁止重复）</h2><p>DRY 是 “Don’t repeat yourself!” 的缩写。如果一件事你做了很多遍，合并重复的代码。如果你在你代码里发现了设计模式，那是一个删除重复的迹象。有时候这意味着你站得离屏幕远远地，直到你看不清文字，也无法寻找模式。</p><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">// Dirty</span><span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>OtherComponent</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>a<span class="token punctuation">"</span></span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>colorful<span class="token punctuation">"</span></span> <span class="token attr-name">foo</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span><span class="token number">123</span><span class="token punctuation">}</span></span> <span class="token attr-name">bar</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span><span class="token number">456</span><span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>OtherComponent</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>b<span class="token punctuation">"</span></span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>colorful<span class="token punctuation">"</span></span> <span class="token attr-name">foo</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span><span class="token number">123</span><span class="token punctuation">}</span></span> <span class="token attr-name">bar</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span><span class="token number">456</span><span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">// Clean</span><span class="token keyword">const</span> MyOtherComponent <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> type <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>OtherComponent</span> <span class="token attr-name">type</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span>type<span class="token punctuation">}</span></span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>colorful<span class="token punctuation">"</span></span> <span class="token attr-name">foo</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span><span class="token number">123</span><span class="token punctuation">}</span></span> <span class="token attr-name">bar</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span><span class="token number">456</span><span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MyOtherComponent</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>a<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MyOtherComponent</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>b<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>有时候，就像上面的例子那样 —— 删除重复代码并不会减少代码量。但是，删除重复代码一般会提高可维护性。</p><p>要注意，不要在删除重复代码这件事上做得太过分了，所以要知道什么时候该说什么。</p><h2 id="简洁的代码是可预测和可测试的"><a href="#简洁的代码是可预测和可测试的" class="headerlink" title="简洁的代码是可预测和可测试的"></a>简洁的代码是可预测和可测试的</h2><p>编写单元测试不仅仅是一个好主意，它已经几乎变成强制性的。毕竟，你怎样确保新特性没有在某些地方引起一些 bugs。</p><p>许多 react 开发者依靠零配置的 <a href="https://facebook.github.io/jest/" target="_blank" rel="noopener">jest</a> 测试库，并产出覆盖报告。如果你对前后视觉对照测试感兴趣，请尝试一下 美国运通开源的 <a href="https://github.com/americanexpress/jest-image-snapshot" target="_blank" rel="noopener">Jest Image Snapshot</a>。</p><h2 id="简洁的代码能自我说明"><a href="#简洁的代码能自我说明" class="headerlink" title="简洁的代码能自我说明"></a>简洁的代码能自我说明</h2><p>你之前有遇到过吗？你写了一些代码，并确保它拥有完整的注释。将会发生这样的情况，你发现一个 bug, 所以你回去修改代码。你还记得修改注释并对应新的逻辑吗？也许记得。也许不记得。下一个看你代码的人可能已经掉进兔子洞（被绕进去了）因为他还在看以前的注释。</p><p>只给复杂的思路添加注释。不要给显而易见的代码添加注释。更少量的注释也有利于减少视觉干扰。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// Dirty</span><span class="token keyword">const</span> fetchUser <span class="token operator">=</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span>  <span class="token function">fetch</span><span class="token punctuation">(</span>buildUri<span class="token template-string"><span class="token string">`/users/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>id<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Get User DTO record from REST API</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>convertFormat<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Convert to snakeCase</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>validateUser<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Make sure the the user is valid</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>而简洁版，我们重命名函数以便更好地描述他们是做什么的，因此消除了注释的必要并减少视觉干扰。这限制了代码与注释不匹配的潜在混乱。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// Clean</span><span class="token keyword">const</span> fetchUser <span class="token operator">=</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span>  <span class="token function">fetch</span><span class="token punctuation">(</span>buildUri<span class="token template-string"><span class="token string">`/users/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>id<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>snakeToCamelCase<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>validateUser<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="命名的重要性"><a href="#命名的重要性" class="headerlink" title="命名的重要性"></a>命名的重要性</h2><p>在我前面的文章 <a href="http://americanexpress.io/faccs-are-an-antipattern" target="_blank" rel="noopener">子组件的函数是一种反模式</a>, 我强调了命名的重要性。我们应该严肃思考变量名、函数名、甚至文件名。</p><p>下面是一些指南：</p><ul><li>布尔值变量、或返回布尔值的函数，应该以 “is”, “has”, “should” 开头。</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// Dirty</span><span class="token keyword">const</span> done <span class="token operator">=</span> current <span class="token operator">>=</span> goal<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Clean</span><span class="token keyword">const</span> isComplete <span class="token operator">=</span> current <span class="token operator">>=</span> goal<span class="token punctuation">;</span></code></pre><ul><li>函数名应该描述函数的功能是什么，而不是怎样实现这个功能。换句话说，不要在命名中暴露实现细节。为什么？因为不知道哪一天你就会换一种实现，而你不应该为重构实现方式而去更改业务代码。举个例子，今天你可能通过 REST API 加载你的配置，但可能明天你又改成用 javascipt 实现。</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// Dirty</span><span class="token keyword">const</span> loadConfigFromServer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Clean</span><span class="token keyword">const</span> loadConfig <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id="简洁代码遵循成熟的设计模式和最佳实践"><a href="#简洁代码遵循成熟的设计模式和最佳实践" class="headerlink" title="简洁代码遵循成熟的设计模式和最佳实践"></a>简洁代码遵循成熟的设计模式和最佳实践</h2><p>计算机普及很长时间了。多年来，程序员在解决某些问题的时候发现模式。被称为 设计模式。换句话说，它是随着时间推移被证明的有用的算法。你可以站在这些巨人的肩上，以便避免再犯这些错误。</p><p>然后有一些最佳实践，它们和设计模式很类似，但更广义，不具体指编码算法。它们可能涉及到类似“你应该在编码时使用 lint 工具” 或者 “当你写一个类库时，请包含 react 作为 <code>peerDependency</code>”。</p><ul><li>将函数功能缩小，每一个都职责单一。这个叫做职责单一原则。确保每个函数做好并只做一件事。意思是你可以将一个复杂的组件拆分成许多小的部分。这也会让代码更易测试。</li><li>注意抽象接口。换句话说，不要强制让你的业务代码使用私有变量或私有方法。</li><li>遵循严格的 linting 规则，它会帮助你编写简洁、风格统一的代码。</li></ul><h2 id="简洁的代码不一定要花费更长时间"><a href="#简洁的代码不一定要花费更长时间" class="headerlink" title="简洁的代码不一定要花费更长时间"></a>简洁的代码不一定要花费更长时间</h2><p>我听到编写简洁的代码会降低工作效率。真是一派胡言。是的，为了冲刺，一开始你需要放慢脚步，但是写了几行代码后，你的步伐会越来越快。</p><p>并且不要考虑将来再“重构”它，并花时间修复来自 code review 的评论。如果你将代码拆分成小模块，每个都职责单一，很可能将来大部分模块都不会碰。这就是通过“写下它，忘了它”来了省时间。</p><h2 id="冗余代码-VS-简洁代码的实践例子"><a href="#冗余代码-VS-简洁代码的实践例子" class="headerlink" title="冗余代码 VS. 简洁代码的实践例子"></a>冗余代码 VS. 简洁代码的实践例子</h2><p>看看下面的代码。继续看，并返回到前面我所讲的内容。你有看到什么模式吗？注意到 <code>Thingie</code> 组件和 <code>ThingieWithTitle</code> 组件除了 <code>Title</code> 组件之外都完全相同。这满足了 DRY 的条件。</p><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">// Dirty</span><span class="token keyword">import</span> Title <span class="token keyword">from</span> <span class="token string">'./Title'</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">const</span> Thingie <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> description <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>thingie<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>description-wrapper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Description</span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span>description<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">const</span> ThingieWithTitle <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> title<span class="token punctuation">,</span> description <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Title</span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span>title<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>description-wrapper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Description</span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span>description<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这里允许我们传递 <code>children</code> 到 <code>Thingie</code>, 然后创建一个 <code>ThingieWithTitle</code> 包裹 <code>Thingie</code>，传递 <code>Title</code> 作为它的子节点。</p><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">// Clean</span><span class="token keyword">import</span> Title <span class="token keyword">from</span> <span class="token string">'./Title'</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">const</span> Thingie <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> description<span class="token punctuation">,</span> children <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>thingie<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token punctuation">{</span>children<span class="token punctuation">}</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>description-wrapper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Description</span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span>description<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">const</span> ThingieWithTitle <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> title<span class="token punctuation">,</span> <span class="token operator">...</span>others <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span>  <span class="token operator">&lt;</span>Thingie <span class="token punctuation">{</span><span class="token operator">...</span>others<span class="token punctuation">}</span><span class="token operator">></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Title</span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span>title<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Thingie</span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>看下面的代码段。它默认使用 <code>icon-large</code> 作为 <code>className</code> 的声明值。</p><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">// Dirty</span><span class="token keyword">const</span> Icon <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> className<span class="token punctuation">,</span> onClick <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> additionalClasses <span class="token operator">=</span> className <span class="token operator">||</span> <span class="token string">'icon-large'</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span>      <span class="token attr-name">className</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span><span class="token template-string"><span class="token string">`icon-hover </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>additionalClasses<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">}</span></span>      <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span>onClick<span class="token punctuation">}</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>这里我们使用 ES6 默认语法，用字符串来替换未定义的值。这也允许我们使用箭头函数，并消除 return 的使用。</p><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">// Clean</span><span class="token keyword">const</span> Icon <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> className <span class="token operator">=</span> <span class="token string">'icon-large'</span><span class="token punctuation">,</span> onClick <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">className</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span><span class="token template-string"><span class="token string">`icon-hover </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>className<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">}</span></span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span>onClick<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>下面是更简洁的版本，默认值通过 react 设置。</p><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">// Cleaner</span><span class="token keyword">const</span> Icon <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> className<span class="token punctuation">,</span> onClick <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">className</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span><span class="token template-string"><span class="token string">`icon-hover </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>className<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">}</span></span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span>onClick<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>Icon<span class="token punctuation">.</span>defaultProps <span class="token operator">=</span> <span class="token punctuation">{</span>  className<span class="token punctuation">:</span> <span class="token string">'icon-large'</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>为什么这样更简洁？为什么这样更好？三个版本做的不是同样一件事吗？对于大部分情况来说，确实是的。但是，让 react 设置默认值的好处是会产生更高效的代码。默认 props 基于类的组件生命周期,同时允许你使用 <code>propTypes</code> 检查默认值。但还有一个好处：简化组件自身的默认逻辑。</p><p>举个例子，你可以这样做，在一个变量里存储所有默认的 props。我不建议你这样做，我只是说你可以有这种做法。</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">import</span> defaultProps <span class="token keyword">from</span> <span class="token string">'./defaultProps'</span><span class="token punctuation">;</span><span class="token operator">...</span>Icon<span class="token punctuation">.</span>defaultProps <span class="token operator">=</span> defaultProps<span class="token punctuation">.</span>Icon<span class="token punctuation">;</span></code></pre><h2 id="从-render-函数中分离状态"><a href="#从-render-函数中分离状态" class="headerlink" title="从 render 函数中分离状态"></a>从 render 函数中分离状态</h2><p>在 render 函数中混合你的状态数据加载逻辑会让组件变得更复杂。相反，写一个职责单一的状态容器组件去加载数据。然后用另一个职责单一的组件去显示数据。这叫做 <a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" target="_blank" rel="noopener">容器模式</a>。</p><p>下面这个例子，用户数据在同一个组件中加载和显示。</p><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">// Dirty</span><span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>  state <span class="token operator">=</span> <span class="token punctuation">{</span> loading<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token punctuation">{</span> loading<span class="token punctuation">,</span> user <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">;</span>    <span class="token keyword">return</span> loading      <span class="token operator">?</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>Loading<span class="token operator">...</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>      <span class="token punctuation">:</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>            First name<span class="token punctuation">:</span> <span class="token punctuation">{</span>user<span class="token punctuation">.</span>firstName<span class="token punctuation">}</span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>            First name<span class="token punctuation">:</span> <span class="token punctuation">{</span>user<span class="token punctuation">.</span>lastName<span class="token punctuation">}</span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>          <span class="token operator">...</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">fetchUser</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>id<span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> loading<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> user <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在简洁版本，关注点 —— 数据加载，显示加载动画，和显示数据被分离了。不仅让代码更容易理解。而且很容易独立地测试每个关注点。同时 <code>RenderUser</code> 是一个无状态组件。结果是可预测的。</p><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">// Clean</span><span class="token keyword">import</span> RenderUser <span class="token keyword">from</span> <span class="token string">'./RenderUser'</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>  state <span class="token operator">=</span> <span class="token punctuation">{</span> loading<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token punctuation">{</span> loading<span class="token punctuation">,</span> user <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">;</span>    <span class="token keyword">return</span> loading <span class="token operator">?</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Loading</span> <span class="token punctuation">/></span></span> <span class="token punctuation">:</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>RenderUser</span> <span class="token attr-name">user</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span>user<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">fetchUser</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>id<span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>user <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> loading<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> user <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="使用无状态组件-SFC"><a href="#使用无状态组件-SFC" class="headerlink" title="使用无状态组件 SFC"></a>使用无状态组件 SFC</h2><p>无状态组件（SFC）在 React v0.14.0 的时候被推出。它们被用来大大简化一个仅用于渲染的组件。但很多开发者还没有放下过去。举个例子，下面这个组件具备转换成 SFC 的条件。</p><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">// Dirty</span><span class="token keyword">class</span> <span class="token class-name">TableRowWrapper</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>        <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>children<span class="token punctuation">}</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>简洁版清理了很多冗余版本的干扰的东西。通过 react 的核心优化，有可能使用更少的内存，没有实例被创建。</p><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">// Clean</span><span class="token keyword">const</span> TableRowWrapper <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> children <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>    <span class="token punctuation">{</span>children<span class="token punctuation">}</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="Rest-spread-…操作符"><a href="#Rest-spread-…操作符" class="headerlink" title="Rest/spread (…操作符)"></a>Rest/spread (…操作符)</h2><p>大约一年前，在我心中 <code>Object.assign</code> 将会变成每个人最好的新朋友。但是，时代变了，ES2016/ES7 的 <a href="https://github.com/tc39/proposal-object-rest-spread" target="_blank" rel="noopener">rest/spread spec</a> 来了。</p><p>看一个给组件传递 props 的案例。你想在组件内使用 <code>className</code>，但把剩余的 props 传递给子组件。你可能会这样做。</p><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">// Dirty</span><span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> others <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> props<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">delete</span> others<span class="token punctuation">.</span>className<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">className</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>className<span class="token punctuation">}</span></span><span class="token punctuation">></span></span>      <span class="token punctuation">{</span>React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>MyOtherComponent<span class="token punctuation">,</span> others<span class="token punctuation">)</span><span class="token punctuation">}</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>不够优雅，不是么？但使用 rest/spread, 就像看到一块蛋糕一样。</p><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">// Clean</span><span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> className<span class="token punctuation">,</span> <span class="token operator">...</span>others <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">className</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span>className<span class="token punctuation">}</span></span><span class="token punctuation">></span></span>    <span class="token operator">&lt;</span>MyOtherComponent <span class="token punctuation">{</span><span class="token operator">...</span>others<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="适时使用解构"><a href="#适时使用解构" class="headerlink" title="适时使用解构"></a>适时使用解构</h2><p>ES6 有一个概念叫 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="noopener">destructure</a>解构赋值。它允许你取出 object 或 array 里的某个值。</p><h3 id="object-destructuring-对象解构"><a href="#object-destructuring-对象解构" class="headerlink" title="object destructuring 对象解构"></a>object destructuring 对象解构</h3><p>比如，给 <code>componentWillReceiveProps</code> 传递了 <code>newProps</code>，我们给 <code>state.active</code> 设置一个新的 <code>active</code> 值。</p><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">// Dirty</span><span class="token function">componentWillReceiveProps</span><span class="token punctuation">(</span>newProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    active<span class="token punctuation">:</span> newProps<span class="token punctuation">.</span>active  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在简洁版本中，我们将解构 <code>newProps</code> 里的 <code>active</code>， 不仅不再需要引用 <code>newProps.active</code>, 而且可以只使用对象中的属性名 <code>setState</code>:</p><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">// Clean</span><span class="token function">componentWillReceiveProps</span><span class="token punctuation">(</span><span class="token punctuation">{</span> active <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> active <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="array-destructuring-数组解构"><a href="#array-destructuring-数组解构" class="headerlink" title="array destructuring 数组解构"></a>array destructuring 数组解构</h3><p>经常忽视 ES6 的数组解构特性。下面这个例子，它从 <code>local</code> 取出一个值,比如 “es-US”, 拆分并赋值给 <code>language</code>(en) 和 <code>country</code>(US)</p><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">// Dirty</span><span class="token keyword">const</span> splitLocale <span class="token operator">=</span> locale<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'-'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> language <span class="token operator">=</span> splitLocale<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> country <span class="token operator">=</span> splitLocale<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Clean</span><span class="token keyword">const</span> <span class="token punctuation">[</span>language<span class="token punctuation">,</span> country<span class="token punctuation">]</span> <span class="token operator">=</span> locale<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'-'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我希望我让你看到编写简洁代码的好处，并可以应用这里呈现的实际例子。一旦你拥抱简洁代码，它将成为你的第二天性。你和未来的你将会感激“写下它，忘了它”的生活方式。</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简洁代码与冗余代码&quot;&gt;&lt;a href=&quot;#简洁代码与冗余代码&quot; class=&quot;headerlink&quot; title=&quot;简洁代码与冗余代码&quot;&gt;&lt;/a&gt;简洁代码与冗余代码&lt;/h1&gt;&lt;p&gt;这篇文章将重点介绍适用于现代 react 软件开发的简洁代码之道。我还会谈谈 ES6/ES2015 带来的一些“语法糖”。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="react" scheme="http://robin-front.github.io/tags/react/"/>
    
      <category term="best practices" scheme="http://robin-front.github.io/tags/best-practices/"/>
    
  </entry>
  
  <entry>
    <title>Dynamic import() 与 静态 import 相比较，有哪些不同</title>
    <link href="http://robin-front.github.io/2017/11/27/dynamic-import.html"/>
    <id>http://robin-front.github.io/2017/11/27/dynamic-import.html</id>
    <published>2017-11-27T10:56:29.000Z</published>
    <updated>2017-11-27T10:56:29.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="Dynamic-import-有哪些特点"><a href="#Dynamic-import-有哪些特点" class="headerlink" title="Dynamic import() 有哪些特点"></a>Dynamic import() 有哪些特点</h1><blockquote><p>Dynamic <strong>import()</strong>  已被 Chrome 63 和 Safari Technology Preview 24 支持。</p></blockquote><p><a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener">Dynamic <strong><code>import()</code></strong></a> 采用 类函数 的方法来塑造 <code>import</code>，相比 static <code>import</code> 解锁了新功能。这篇文章对比了两者并概览新功能。<a id="more"></a></p><h2 id="Static-import（概括）"><a href="#Static-import（概括）" class="headerlink" title="Static import（概括）"></a>Static import（概括）</h2><p>九月份，Chrome 61 发布并支持在 <a href="https://jakearchibald.com/2017/es-modules-in-browsers/" target="_blank" rel="noopener">modules</a> 中使用 ES2015 <code>import</code> 声明。</p><p>仔细看下面这个模块，位于 <code>./utils.mjs</code>:</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// Default export</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hi from the default export!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Named export `doStuff`</span><span class="token keyword">export</span> <span class="token keyword">const</span> doStuff <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Doing stuff…'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>下面是使用 静态 <code>import</code> 引入 <code>./utils.mjs</code> 模块：</p><pre class=" language-html"><script type="module"><code class="language-html"><script type="module">  import * as module from './utils.mjs';  module.default();  // → logs 'Hi from the default export!'  module.doStuff();  // → logs 'Doing stuff…'</script></code></pre><blockquote><p><strong>注意：</strong> 上面这个例子使用 <strong>.mjs</strong> 来标识这是一个模块文件而不是普通脚本。在网页端，文件扩展名并不是问题，只要服务端设置了正确的 MIME 类型（比如给 javascript 文件设置 Content-Type:text/javascript）在 HTTP header。<strong>.mjs</strong> 在其他一些平台上特别有用，如 Node.js 这类没有 MIME 类型或其他 Hooks 如 <strong>type=”module”</strong> 来确定模块或普通脚本。我们在这里使用相同的扩展名来保持跨平台的一致性，并清楚地区分模块和普通脚本。</p></blockquote><p>这个导入模块的语法形式是 <strong>静态</strong> 声明：它只接受字符串作为模块标识符，并通过运行前的 “linking” 过程将模块绑定到本地作用域。静态 <code>import</code> 语法只能用于文件顶部。静态<code>import</code> 支持一些重要的用例，如：<code>static analysis</code>, <code>bundling tools</code>, 和 <code>tree-shaking</code>。</p><p>在一些案例中，下面这些特性会非常有用：</p><ul><li>请求时导入模块（或有条件地）</li><li>运行时计算模块标识符</li><li>在普通脚本中导入模块（而不是在模块中导入）</li></ul><p>但是这些用 静态 <code>import</code> 都无法做到。</p><h2 id="Dynamic-import-🔥"><a href="#Dynamic-import-🔥" class="headerlink" title="Dynamic import() 🔥"></a>Dynamic import() 🔥</h2><p><a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener">Dynamic <strong><code>import()</code></strong></a> 采用 类函数 的方法来塑造满足这些用例的 <code>import</code>。<code>import(moduleSpecifier)</code> 为请求模块的模块名称空间返回一个 promise。它是在获取，实例化和评估模块的所有依赖关系之后创建的，模块本身也是。</p><p>下面是如何使用 动态 import，并使用 <code>./utils.mjs</code> 模块：</p><pre class=" language-html"><script type="module"><code class="language-html"><script type="module">  const moduleSpecifier = './utils.mjs';  import(moduleSpecifier)    .then((module) => {      module.default();      // → logs 'Hi from the default export!'      module.doStuff();      // → logs 'Doing stuff…'    });</script></code></pre><blockquote><p><strong>注意：</strong> 尽管 <strong>import()</strong> 看起来像一个函数调用，但它只是恰好被规定为使用括号的一种 <em>语法</em> （类似于 <strong>super()</strong>）。这意味着 <strong>import</strong> 不会继承 <strong>Function.prototype</strong> ，所以不能使用 <strong>call</strong> 和 <strong>apply</strong>。像 <strong>const importAlias = import</strong> 这样的代码也不能运行 —— <strong>import</strong> 甚至不是一个 object 对象！但是这在实践中并不重要。</p></blockquote><p>下面是一个例子，展示了如何在一个小型单页应用的导航上使用 动态 <code>import()</code> 启用懒加载模块：</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>My library<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nav</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>books.html<span class="token punctuation">"</span></span> <span class="token attr-name">data-entry-module</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>books<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Books<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>movies.html<span class="token punctuation">"</span></span> <span class="token attr-name">data-entry-module</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>movies<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Movies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>video-games.html<span class="token punctuation">"</span></span> <span class="token attr-name">data-entry-module</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>video-games<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Video Games<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nav</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span><span class="token punctuation">></span></span>This is a placeholder for the content that will be loaded on-demand.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span>  const main = document.querySelector('main');  const links = document.querySelectorAll('nav > a');  for (const link of links) {    link.addEventListener('click', async (event) => {      event.preventDefault();      try {        const module = await import(`/${link.dataset.entryModule}.mjs`);        // The module exports a function named `loadPageInto`.        module.loadPageInto(main);      } catch (error) {        main.textContent = error.message;      }    });  }<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>当正确使用 动态 <code>import()</code> 开启懒加载功能时将会非常强大。为了演示目的，<a href="https://twitter.com/addyosmani" target="_blank" rel="noopener">Addy</a> 修改了一个 <a href="https://hnpwa-vanilla.firebaseapp.com/" target="_blank" rel="noopener">Hacker News PWA</a> 示例，在首次加载时静态地导入所有依赖，包括评论。<a href="https://dynamic-import.firebaseapp.com/" target="_blank" rel="noopener">升级版</a> 使用 动态 <code>import()</code>延迟加载评论，避免加载，解析和编译成本，直到用户确实需要它们。</p><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>静态 <code>import</code> 和动态 <code>import()</code> 都很有用。它们都有各自的特点和使用场景。使用静态 <code>import</code> 来初始绘制依赖关系，尤其是首屏内容。另一种情况，考虑到按需加载则使用动态 <code>import()</code>。</p><blockquote><p>译者注：static import 是没有括号的，dynamic import() 是带括号的。不注意的可能会混淆。用法的区别：</p><ul><li>static import: <code>import $ from 'jquery'</code> 有声明提升，一般只放在头部位置</li><li>dynamic import(): <code>const $ = import('jquery')</code> 可以放在任何位置</li></ul></blockquote></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Dynamic-import-有哪些特点&quot;&gt;&lt;a href=&quot;#Dynamic-import-有哪些特点&quot; class=&quot;headerlink&quot; title=&quot;Dynamic import() 有哪些特点&quot;&gt;&lt;/a&gt;Dynamic import() 有哪些特点&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Dynamic &lt;strong&gt;import()&lt;/strong&gt;  已被 Chrome 63 和 Safari Technology Preview 24 支持。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/tc39/proposal-dynamic-import&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dynamic &lt;strong&gt;&lt;code&gt;import()&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt; 采用 类函数 的方法来塑造 &lt;code&gt;import&lt;/code&gt;，相比 static &lt;code&gt;import&lt;/code&gt; 解锁了新功能。这篇文章对比了两者并概览新功能。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="dynamic import" scheme="http://robin-front.github.io/tags/dynamic-import/"/>
    
      <category term="es6" scheme="http://robin-front.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>使用 react 16 portal 做一些很酷的事情</title>
    <link href="http://robin-front.github.io/2017/11/16/using-a-react-16-portal-to-do-something-cool.html"/>
    <id>http://robin-front.github.io/2017/11/16/using-a-react-16-portal-to-do-something-cool.html</id>
    <published>2017-11-16T07:31:59.000Z</published>
    <updated>2017-11-16T07:31:59.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>React 16 已经发布了，其中一个很有趣的是添加了 “Portals”。</p><p>Portals 可以让你在父组件外渲染 react 受控 DOM 节点。<a href="https://reactjs.org/docs/portals.html" target="_blank" rel="noopener">react doc</a> 也使用了一个模态框的例子很好地解释了它。用也做 tooltips 也很合适（这是我<a href="https://codepen.io/davidgilbertson/pen/ooXVyw" target="_blank" rel="noopener">早前做的一个例子</a>）。</p><p>但这些都并不是很有趣，让我们做一些更不可思议的事情…<a id="more"></a></p><p>因为所有 portal 做的，都是将一个元素放到其他元素上，你并没有被限制放在 <em>当前</em> document 的任何地方。你可以添加到另一个 document 的 body 中，可能是完全不同浏览器窗口的一个 document。</p><p>下面我有一个基本的页面（左边），包含一个计数器及深红色按钮。另一个窗口（右边）同样是 react app 的一部分。</p><p>右边的窗口是属于 <em>同一个 React app</em> 这个事实应该让你感到惊讶。</p><p><div class="progress-images" style="width:1799px"><div class="progress-images--placeholder" style="padding-bottom: 45.46970539188438%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/2000/1*ogsV-9IGNtaVjne2fb_oEA.png" class="progress-images--original" data-original="https://cdn-images-1.medium.com/max/2000/1*ogsV-9IGNtaVjne2fb_oEA.png" data-thumb="/images/thumb/c7a8b493bc1baf96cb1771b7b9c52729.png"></div></p><p>上面图片中能看到的所有东西（除了树）都是在下面代码展示的同一个组件中：</p><script src="https://gist.github.com/davidgilbertson/69a8c158ca9b5e202d083408dbabdf49.js"></script><p>你已经成功了，<code><MyWindowPortal></code> 有一点特殊，里面的所有东西都会被渲染到另一个 window 下。</p><p>尤其是，<code><MyWindowPortal></code> 做了两件事。</p><ul><li>1、 当组件渲染时打开一个浏览器窗口。</li><li>2、 创建一个 <code>portal</code> 并将 <code>props.children</code> 添加到新窗口的 body。</li></ul><p>这不是最酷的事情吗？</p><p>我是多么兴奋，必须得冷静一下。</p><p>…</p><p>I saw a duck!</p><p>…</p><p>上面提到的 body中的组件就是下面这样。 React 16 新增的部分 <code>ReactDOM.createPortal</code> 在 11 行 —— 那就是黑魔法。</p><script src="https://gist.github.com/davidgilbertson/de5e5b84373ee60d91525ab37278913e.js"></script><p>那有意义吗？组件并没有返回什么，只是做了一些其他事情。</p><p>换一个角度来想可能是这样的：按理来说，一个父组件对子组件说：“嘿，渲染 DOM， 然后把结果添加到我这里。”，然后子组件照做了。但是这次，任性的子组件说，“不！我要将东东渲染到另一个窗口，然后写一篇关于它的博客。”</p><p>现在，我知道你在想什么。</p><p>你有点渴，并且想知道你是否该喝点水了。是的，去吧。</p><p>另一件你可能在想的事情是：将一些 DOM 注入到无样式的空白窗口有什么好处？可能 Craigslist 或 Wikipedia 也不知道。但你的网站很美，任何时候都不能弹出小窗口。</p><p>好吧，好消息来了，大家注意了！</p><p><div class="progress-images" style="width:1000px"><div class="progress-images--placeholder" style="padding-bottom: 47.6%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/1000/1*eU-7ArIucnG5OreaPIJlEg.png" class="progress-images--original" data-original="https://cdn-images-1.medium.com/max/1000/1*eU-7ArIucnG5OreaPIJlEg.png" data-thumb="/images/thumb/2a2397e0536311544d216d421882f44c.png"></div></p><p>起初，我还在想是否有一个简单的方式将样式复制到新窗口。然后我想起我的生活只是被一些毫无意义的事件填充，它们唯一的目的只是让我分心，阻止我内心的空虚寂寞冷。</p><p>所以亲自写这个函数就是乐趣！</p><p>看下面：</p><script src="https://gist.github.com/davidgilbertson/ed3c8bb8569bc64b094b87aa88bed5fa.js"></script><p>事实上，我并不是很了解 <code>styleSheet</code>。我期待从评论中得知有什么奇技淫巧。</p><p>现在我可以在打开新窗口的时候很简单地复制样式，像这样：</p><script src="https://gist.github.com/davidgilbertson/4937ac726094735ab44e295f3113df53.js"></script><iframe height="265" scrolling="no" title="React Portal Chat Window" src="//codepen.io/davidgilbertson/embed/xPVMqp/?height=265&theme-id=0&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/davidgilbertson/pen/xPVMqp/" target="_blank" rel="noopener">React Portal Chat Window</a> by David Gilbertson (<a href="https://codepen.io/davidgilbertson" target="_blank" rel="noopener">@davidgilbertson</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</iframe><p>我不认为这能在 Medium app 的 iOS/Android 平台上运行，所以请在浏览器打开。</p><p>好了，我认为这篇文章该结束了。</p><p>Bye!</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React 16 已经发布了，其中一个很有趣的是添加了 “Portals”。&lt;/p&gt;
&lt;p&gt;Portals 可以让你在父组件外渲染 react 受控 DOM 节点。&lt;a href=&quot;https://reactjs.org/docs/portals.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;react doc&lt;/a&gt; 也使用了一个模态框的例子很好地解释了它。用也做 tooltips 也很合适（这是我&lt;a href=&quot;https://codepen.io/davidgilbertson/pen/ooXVyw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;早前做的一个例子&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;但这些都并不是很有趣，让我们做一些更不可思议的事情…
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="react" scheme="http://robin-front.github.io/tags/react/"/>
    
      <category term="portal" scheme="http://robin-front.github.io/tags/portal/"/>
    
  </entry>
  
  <entry>
    <title>react 组件设计模式</title>
    <link href="http://robin-front.github.io/2017/11/09/react-component-patterns.html"/>
    <id>http://robin-front.github.io/2017/11/09/react-component-patterns.html</id>
    <published>2017-11-09T23:10:26.000Z</published>
    <updated>2017-11-09T23:10:26.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="react-component-模式"><a href="#react-component-模式" class="headerlink" title="react component 模式"></a>react component 模式</h1><blockquote><p>有状态组件（Stateful）和无状态组件（Stateless）、容器组件（Container）与展示组件（Presentational）、高阶组件（HOC）、渲染回调（Render Callbacks）等</p></blockquote><p>我在工作中使用 React 有一段时间了——一个 facebook 使用 js 渲染用户界面的框架——刚开始的时候我想知道一些概念。这些文字是尝试总结我实践这么久以来学到的一些模式——可能对于刚开始进入组件世界的开发者有用。<a id="more"></a></p><h2 id="有状态-Stateful-与-无状态-Stateless-组件"><a href="#有状态-Stateful-与-无状态-Stateless-组件" class="headerlink" title="有状态(Stateful) 与 无状态(Stateless) 组件"></a>有状态(Stateful) 与 无状态(Stateless) 组件</h2><p>就像有状态和无状态的 web 服务一样， React 组件也能在用户使用时保存和操作状态（有状态）。或只是一个简单的组件，按受 props 并返回需要显示的内容（无状态）。</p><p>一个简单的 <em>无状态</em> 按钮组件只接受 props:</p><p><div class="progress-images" style="width:1300px"><div class="progress-images--placeholder" style="padding-bottom: 21.846153846153847%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/1600/1*fgZOSwpdU7MMNxltRcXAcQ.png" class="progress-images--original" data-original="https://cdn-images-1.medium.com/max/1600/1*fgZOSwpdU7MMNxltRcXAcQ.png" data-thumb="/images/thumb/4ca32dcd9352f11d9792ccab8b6a8d20.png"></div></p><p>而下面是一个 <strong>有状态</strong> 的计数组件（使用了 <code>Button</code> 组件）：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*TYPgsZUZMoo7lW7xv4gxYw.png" alt="https://cdn-images-1.medium.com/max/1600/1*TYPgsZUZMoo7lW7xv4gxYw.png"></p><p>就像你所看到的，最后一个组件的 constructor 保持了一个组件的 state, 而第一个组件则是一个简单组件，只通过 props 渲染了文字。这个关注分离可能非常简单，但是让 <code>Button</code> 组件高度复用。</p><h2 id="容器-Container-与-展示-Presentational-组件"><a href="#容器-Container-与-展示-Presentational-组件" class="headerlink" title="容器(Container) 与 展示(Presentational) 组件"></a>容器(Container) 与 展示(Presentational) 组件</h2><p>当使用外部数据运行时，我们可以把这个组件分成这两个新类别。<strong>容器组件</strong> 负责获取数据，存在在 react 作用域外部，就像连接 <em>Redux</em> 或 <em>Relay</em> ———— 而 <strong>展示组件</strong> 则不依赖 react 应用的其他部分，仅仅取决于它自身的 state 和接收的 props。让我们拿用户列表作为展示组件的例子：</p><p><div class="progress-images" style="width:1300px"><div class="progress-images--placeholder" style="padding-bottom: 27.076923076923077%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/1600/1*wbih6jbxJiIgNOXgRpcROA.png" class="progress-images--original" data-original="https://cdn-images-1.medium.com/max/1600/1*wbih6jbxJiIgNOXgRpcROA.png" data-thumb="/images/thumb/995106ca2c07d7f6d492c6893634c4c7.png"></div></p><p>这个列表可以使用我们的 <strong>容器组件</strong> 更新：</p><p><div class="progress-images" style="width:1300px"><div class="progress-images--placeholder" style="padding-bottom: 48%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/1600/1*TJxCVhawM2e99dZsxu11oA.png" class="progress-images--original" data-original="https://cdn-images-1.medium.com/max/1600/1*TJxCVhawM2e99dZsxu11oA.png" data-thumb="/images/thumb/aec772426f5e32ac182cec7e376b8ccc.png"></div></p><p>这种方法将数据获取与渲染分离，同时让 <code>UserList</code> 高度复用。如果你想进一步学习这种模式，这里有<a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" target="_blank" rel="noopener">一篇文章</a>解释地很好。</p><h2 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h2><p>高阶组件————或叫 HOC。当你想要重用逻辑的时候非常感兴趣。他们是 javascript 函数，将一个组件作为参数，并返回新组件。</p><p>假设你需要做一个可伸缩的的菜单组件，当用户点的时候，展示它里面的内容。所以，为了替代在父级组件上控制 state，你可以简单地创建一个通用的 <strong>高阶组件</strong> 来处理它：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*qchJXtrHlR46phKFDDJeeQ.png" alt="https://cdn-images-1.medium.com/max/1600/1*qchJXtrHlR46phKFDDJeeQ.png"></p><p>这种方式允许我们将逻辑应用通过装饰模式（decorator）应用在 <code>ToggleableMenu</code> 组件上。</p><p><div class="progress-images" style="width:1300px"><div class="progress-images--placeholder" style="padding-bottom: 37.53846153846154%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/1600/1*RQuGzKKbT7R9OIDBzhO8gg.png" class="progress-images--original" data-original="https://cdn-images-1.medium.com/max/1600/1*RQuGzKKbT7R9OIDBzhO8gg.png" data-thumb="/images/thumb/579a01e9a4764307b68d17d171295eee.png"></div></p><p>现在我们可以任意传递子级到 <code>ToggleableMenu</code> 组件了：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*rWCZQqL0Rbizbrw_yjgxgA.png" alt="https://cdn-images-1.medium.com/max/1600/1*rWCZQqL0Rbizbrw_yjgxgA.png"></p><p>如果你熟悉使用 <code>redux</code> 的 <code>connect</code> 或 react router 的 <code>withRouter</code> 函数，那你已经在用 <strong>HOCs</strong> 了。</p><h2 id="渲染回调（Render-Callbacks）"><a href="#渲染回调（Render-Callbacks）" class="headerlink" title="渲染回调（Render Callbacks）"></a>渲染回调（Render Callbacks）</h2><p>另一种让组件逻辑复用的很棒的方法是 将组件子级转换成函数。这也是为什么 <strong>渲染回调（Render Callbacks）</strong> 也叫作 <strong>Function as Child Components</strong>。我们可以拿可伸展的菜单高阶组件作为例子，并使用 <strong>渲染回调</strong> 重写它。</p><p><div class="progress-images" style="width:1300px"><div class="progress-images--placeholder" style="padding-bottom: 55.84615384615385%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/1600/1*Ul-ubPnaOFtY4mTeM5PW3A.png" class="progress-images--original" data-original="https://cdn-images-1.medium.com/max/1600/1*Ul-ubPnaOFtY4mTeM5PW3A.png" data-thumb="/images/thumb/505d31f2ac14e7885754660885ae9a91.png"></div></p><p>现在我们可以传递一个函数作为 <code>Toggleable</code> 的子组件：</p><p><div class="progress-images" style="width:1300px"><div class="progress-images--placeholder" style="padding-bottom: 45.38461538461539%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/1600/1*cwoZiIT3Gcau5lDwyCQzQw.png" class="progress-images--original" data-original="https://cdn-images-1.medium.com/max/1600/1*cwoZiIT3Gcau5lDwyCQzQw.png" data-thumb="/images/thumb/2030a4be34f2d63c15b032146ffe59fe.png"></div></p><p>上面的代码已经使用函数作为子级，但，如果我们想要像高阶组件的例子那样复用它（多个菜单），我们可以简单地使用 <code>Toggleable</code> 逻辑创建一个新组件：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*DVfPDwHw_eH9dUeX9w5GEg.png" alt="https://cdn-images-1.medium.com/max/1600/1*DVfPDwHw_eH9dUeX9w5GEg.png"></p><p>我们的新产品 <code>ToggleableMenu</code> 组件已经准备好了：</p><p><div class="progress-images" style="width:1300px"><div class="progress-images--placeholder" style="padding-bottom: 55.84615384615385%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/1600/1*hzpuJMAMTRQZK_vKCK_jhQ.png" class="progress-images--original" data-original="https://cdn-images-1.medium.com/max/1600/1*hzpuJMAMTRQZK_vKCK_jhQ.png" data-thumb="/images/thumb/f07301cabbc19e2e61656fca399a97d2.png"></div></p><p>这种方式真的非常有用，当我们需要更改渲染内容而不用管 state 操作时：就像你所看到的，我们可以将渲染逻辑移动到 <code>ToggleableMenu</code> 的子级函数中，但却保持我们 <code>Toggleable</code> 组件的 state 逻辑！</p><h2 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h2><p>上面的例子只是一些可以用在 react 编程中的基础模式，如果你真的想深入这个主题，我建议你看看这些了不起的文章：</p><ul><li><a href="https://www.youtube.com/watch?v=YaZg8wg39QQ" target="_blank" rel="noopener">React Component Patterns by Michael Chan</a></li><li><a href="https://github.com/chantastic/reactpatterns.com" target="_blank" rel="noopener">React Patterns</a></li><li><a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" target="_blank" rel="noopener">Presentational and Container Components</a></li><li><a href="https://medium.com/@franleplant/react-higher-order-components-in-depth-cf9032ee6c3e" target="_blank" rel="noopener">React Higher Order Components in depth</a></li><li><a href="https://medium.com/merrickchristensen/function-as-child-components-5f3920a9ace9" target="_blank" rel="noopener">Function as Child Components</a></li><li><a href="https://github.com/acdlite/recompose" target="_blank" rel="noopener">Recompose</a></li><li><a href="https://github.com/paypal/downshift" target="_blank" rel="noopener">Downshift</a></li></ul></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;react-component-模式&quot;&gt;&lt;a href=&quot;#react-component-模式&quot; class=&quot;headerlink&quot; title=&quot;react component 模式&quot;&gt;&lt;/a&gt;react component 模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;有状态组件（Stateful）和无状态组件（Stateless）、容器组件（Container）与展示组件（Presentational）、高阶组件（HOC）、渲染回调（Render Callbacks）等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我在工作中使用 React 有一段时间了——一个 facebook 使用 js 渲染用户界面的框架——刚开始的时候我想知道一些概念。这些文字是尝试总结我实践这么久以来学到的一些模式——可能对于刚开始进入组件世界的开发者有用。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="React" scheme="http://robin-front.github.io/tags/React/"/>
    
      <category term="Components" scheme="http://robin-front.github.io/tags/Components/"/>
    
      <category term="Higher Order ComponentsRender" scheme="http://robin-front.github.io/tags/Higher-Order-ComponentsRender/"/>
    
      <category term="Callback" scheme="http://robin-front.github.io/tags/Callback/"/>
    
      <category term="patterns" scheme="http://robin-front.github.io/tags/patterns/"/>
    
      <category term="设计模式" scheme="http://robin-front.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>javascript 事件循环是如何工作的以及使用async／await提升异步编程的5种方式</title>
    <link href="http://robin-front.github.io/2017/11/06/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-async-and-await.html"/>
    <id>http://robin-front.github.io/2017/11/06/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-async-and-await.html</id>
    <published>2017-11-06T10:40:21.000Z</published>
    <updated>2017-11-06T10:40:21.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="javascript-事件循环是如何工作的以及使用async／await提升异步编程的5种方式"><a href="#javascript-事件循环是如何工作的以及使用async／await提升异步编程的5种方式" class="headerlink" title="javascript 事件循环是如何工作的以及使用async／await提升异步编程的5种方式"></a>javascript 事件循环是如何工作的以及使用async／await提升异步编程的5种方式</h1><p>这次我们将通过回顾在单线程环境中编程的缺点来扩展先前的第一篇文章，以及如何克服它来建立一个令人惊叹的 javascript UIs。像以往一样，在文章的最后，我会分享使用 async/await 写简洁代码的 5 个小贴士。<a id="more"></a></p><h2 id="为什么单线程是一个限制？"><a href="#为什么单线程是一个限制？" class="headerlink" title="为什么单线程是一个限制？"></a>为什么单线程是一个限制？</h2><p>在我们推出的<a href="https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf" target="_blank" rel="noopener">第一篇文章</a>, 我们仔细思考了这个问题，<em>当我们调用了一个非常耗时的函数时发生了什么</em>。</p><p>想象一下，例如浏览器中运行着一个复杂的图像变换算法。</p><p>当调用栈执行函数时，浏览器不能做任何其他事——它被阻塞了。这意味着浏览器不能渲染，不能执行其他代码，暂时卡住了。那问题也来了————你的UI界面也不再顺畅和高效。</p><p>你的应用被卡住了。</p><p>它很丑陋，完全毁了你的用户体验：</p><p><div class="progress-images" style="width:461px"><div class="progress-images--placeholder" style="padding-bottom: 61.388286334056396%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*MCt4ZC0dMVhJsgo1u6lpYw.jpeg" class="progress-images--original" data-original="https://cdn-images-1.medium.com/max/800/1*MCt4ZC0dMVhJsgo1u6lpYw.jpeg" data-thumb="/images/thumb/57e0fd4489669d056d2fba909da9a1d4.jpeg"></div></p><h2 id="javascript-程序的组成部分"><a href="#javascript-程序的组成部分" class="headerlink" title="javascript 程序的组成部分"></a>javascript 程序的组成部分</h2><p>你可能会把你的 javascript 应用写在单个 <code>.js</code> 文件里，但你的程序肯定包含着好几块，只有其只一块正在执行，其他的会稍后执行。最常见的块就是函数。</p><p>问题是，大多数新开发者似乎都觉得，这个 <em>稍后执行</em> 并不是严格地在 <em>当前执行</em> 之后立即执行。换句话说，任务当前不能立即完成，通过定义，将会异步完成。意味着不会出现上面所说的阻塞行为，就像你所期望或希望发生的那样。</p><p>让我们看看下面的例子：</p><script src="https://gist.github.com/zlatkov/7a8b43e4fb8059bc810aa6aa4941148e.js"></script><p>你可能已经意识到，标准的 <code>Ajax</code> 事件不会同步完成。意味着当执行代码 <code>ajax(...)</code> 的时候，并不会立即返回值并赋值给变量 <code>response</code>。</p><p>一个简单的方法就是使用一个叫 回调函数（callback）的函数去等待异步函数返回的结果。</p><script src="https://gist.github.com/zlatkov/cbd87df9ff2922512609a36d4155274a.js"></script><p>提醒一下：你实际可以发起一个 <strong>同步</strong> 的 <code>Ajax</code> 请求。但永远不要这样做。如果你发送一个同步 Ajax 请求, 你 javascript 应用的 UI 就会被阻塞————用户将不能点击，输入数据，导航或滚动。这会阻碍用户交互，非常糟糕的体验。</p><p>就像下面这样，但请永远不要这样做，不要毁了网页：</p><script src="https://gist.github.com/zlatkov/1b834ae5eb037f46347d71d4c497d43c.js"></script><p>我们只是用 Ajax 请求做一个例子，你可以异步执行任意一段代码。</p><p>可以通过 <code>setTimeout(callback, milliseconds)</code> 函数来做到。<code>setTimeout</code> 函数建立一个延后发生的事件。就像这样：</p><script src="https://gist.github.com/zlatkov/688a0b41ae10e45bd202d02bb12df264.js"></script><p>将会输出</p><pre><code>firstthirdsecond</code></pre><h2 id="剖析事件循环"><a href="#剖析事件循环" class="headerlink" title="剖析事件循环"></a>剖析事件循环</h2><p>我们会从一个奇怪的要求开始————尽管允许异步编码（就像刚刚讨论的<code>setTimeout</code>），直到 ES6， javascript从未有过真正直接的异步的概念。javascript 引擎在执行单一代码块的时刻不会再做任何事情。</p><p>关于javascript 引擎（google专用的V8引擎）的更多细节，请查看我们<a href="https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e" target="_blank" rel="noopener">之前的文章</a>.</p><p>那么，谁让 javascript 引擎执行程序块呢？现实中，javascript 引擎并不是孤立运行的————它运行在一个 <em>宿主</em> 环境中，对于大多数开发者来说，典型的是网页浏览器或者 Node.js。事实上，javascript 被嵌入到各种设备中，从机器人到小灯泡。每个设备代表 javascript 引擎的不同的宿主环境类型。</p><p>在所有环境中，不变的是拥有共同的称为 <strong>事件循环</strong> 的内置机制，控制处理多个程序块的执行时机。</p><p>这意味着 JS 引擎只是在执行环境中按需调用任意代码。它（执行JS代码的）是一个事件调度的环境。</p><p>那，举个例子，当你的 JS 程序发起一个 Ajax 请求去从服务器中获取一些数据，你在一个函数里设置了“响应”的代码（称为“回调函数”），JS 引擎告诉宿主环境：“嘿，我现在会暂停执行，但当网络请求完成时，并返回一些数据，请回来调用这个函数。”</p><p>浏览器会监听网络响应，并在拿到数据时返回给你，它会通过插入到 <em>事件循环</em> 中来调度回调函数。</p><p>让我们看看下面的图表：</p><p><div class="progress-images" style="width:800px"><div class="progress-images--placeholder" style="padding-bottom: 75%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*FA9NGxNB6-v1oI2qGEtlRQ.png" class="progress-images--original" data-original="https://cdn-images-1.medium.com/max/800/1*FA9NGxNB6-v1oI2qGEtlRQ.png" data-thumb="/images/thumb/e1dc7dd58418688dd89da9931a70d19f.png"></div></p><p>你可以在<a href="https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf" target="_blank" rel="noopener">以前的文章</a>阅读到更多关于堆内存和调用栈的讨论。</p><p>这些 web APIs 是什么？本质上来讲，它们是无法访问的线程，你只能利用它。它们只是浏览器的并发访问的一部分。如果你是 Node.js 开发者，它们是 C++ APIs。</p><p>那么，<em>事件循环</em> 到底是什么呢？</p><p><div class="progress-images" style="width:478px"><div class="progress-images--placeholder" style="padding-bottom: 33.89121338912134%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*KGBiAxjeD9JT2j6KDo0zUg.png" class="progress-images--original" data-original="https://cdn-images-1.medium.com/max/800/1*KGBiAxjeD9JT2j6KDo0zUg.png" data-thumb="/images/thumb/b5fc1a74616dedcbdd258b59f484c0b5.png"></div></p><p>事件循环有一个简单的工作————监视调用栈和回调队列。如果调用栈清空了，它会获取队列里的第一个事件放入调用栈，高效地运行。</p><p>在事件循环中，像这样的一个迭代被称为 <strong>tick</strong>。每个事件都只是一个回调函数。</p><script src="https://gist.github.com/zlatkov/6d2e3006addd24cd73e5b576312a1c98.js"></script><p>让我们一起“执行”这段代码，然后看看发生了什么：</p><p>1、状态是清空的。浏览器控制台是清空的，调用栈也是空的。</p><p><div class="progress-images" style="width:800px"><div class="progress-images--placeholder" style="padding-bottom: 75%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*9fbOuFXJHwhqa6ToCc_v2A.png" class="progress-images--original" data-original="https://cdn-images-1.medium.com/max/800/1*9fbOuFXJHwhqa6ToCc_v2A.png" data-thumb="/images/thumb/0a5a1bf7dde6d94e5cb7fc8782203309.png"></div></p><p>2、<code>console.log('Hi')</code>被添加进调用栈。</p><p><div class="progress-images" style="width:800px"><div class="progress-images--placeholder" style="padding-bottom: 75%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*dvrghQCVQIZOfNC27Jrtlw.png" class="progress-images--original" data-original="https://cdn-images-1.medium.com/max/800/1*dvrghQCVQIZOfNC27Jrtlw.png" data-thumb="/images/thumb/fd7e5a8cc6af29c7ee94c6e238ec5bf6.png"></div></p><p>3、<code>console.log('Hi')</code>被执行。</p><p><div class="progress-images" style="width:800px"><div class="progress-images--placeholder" style="padding-bottom: 75%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*yn9Y4PXNP8XTz6mtCAzDZQ.png" class="progress-images--original" data-original="https://cdn-images-1.medium.com/max/800/1*yn9Y4PXNP8XTz6mtCAzDZQ.png" data-thumb="/images/thumb/1bb3d050dffc7cae7fc6056fa4d8710f.png"></div></p><p>4、 <code>console.log('Hi')</code> 被移出调用栈。</p><p><div class="progress-images" style="width:800px"><div class="progress-images--placeholder" style="padding-bottom: 75%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*iBedryNbqtixYTKviPC1tA.png" class="progress-images--original" data-original="https://cdn-images-1.medium.com/max/800/1*iBedryNbqtixYTKviPC1tA.png" data-thumb="/images/thumb/ca9048f39d23fc3b5a5e4ea4f6f646a3.png"></div></p><p>5、<code>setTimeout(function cb1() { ... })</code>被添加进调用栈。</p><p><div class="progress-images" style="width:800px"><div class="progress-images--placeholder" style="padding-bottom: 75%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*HIn-BxIP38X6mF_65snMKg.png" class="progress-images--original" data-original="https://cdn-images-1.medium.com/max/800/1*HIn-BxIP38X6mF_65snMKg.png" data-thumb="/images/thumb/511ca0ecbe567b78c52ff896548dc0b3.png"></div></p><p>6、 <code>setTimeout(function cb1() { ... })</code>被执行。浏览器通过 web api 创建了一个定时器。它将为你处理倒计时。</p><p><div class="progress-images" style="width:800px"><div class="progress-images--placeholder" style="padding-bottom: 75%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*vd3X2O_qRfqaEpW4AfZM4w.png" class="progress-images--original" data-original="https://cdn-images-1.medium.com/max/800/1*vd3X2O_qRfqaEpW4AfZM4w.png" data-thumb="/images/thumb/946b607053424b8f2fec7dee0b7a105d.png"></div></p><p>7、<code>setTimeout(function cb1() { ... })</code>被执行完毕并移出调用栈。</p><p><div class="progress-images" style="width:800px"><div class="progress-images--placeholder" style="padding-bottom: 75%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*_nYLhoZPKD_HPhpJtQeErA.png" class="progress-images--original" data-original="https://cdn-images-1.medium.com/max/800/1*_nYLhoZPKD_HPhpJtQeErA.png" data-thumb="/images/thumb/46739d065e5a3c69dd57f206c4a4cb12.png"></div></p><p>8、<code>console.log('Bye')</code>被添加进调用栈。</p><p><div class="progress-images" style="width:800px"><div class="progress-images--placeholder" style="padding-bottom: 75%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*1NAeDnEv6DWFewX_C-L8mg.png" class="progress-images--original" data-original="https://cdn-images-1.medium.com/max/800/1*1NAeDnEv6DWFewX_C-L8mg.png" data-thumb="/images/thumb/85b1ddd8b93902d5a4cd6d07d28d7a2c.png"></div></p><p>9、<code>console.log('Bye')</code>被执行。</p><p><div class="progress-images" style="width:800px"><div class="progress-images--placeholder" style="padding-bottom: 75%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*UwtM7DmK1BmlBOUUYEopGQ.png" class="progress-images--original" data-original="https://cdn-images-1.medium.com/max/800/1*UwtM7DmK1BmlBOUUYEopGQ.png" data-thumb="/images/thumb/564df4f07dad2fed697f717d9f7393ae.png"></div></p><p>10、<code>console.log('Bye')</code>被移出调用栈。</p><p><div class="progress-images" style="width:800px"><div class="progress-images--placeholder" style="padding-bottom: 75%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*-vHNuJsJVXvqq5dLHPt7cQ.png" class="progress-images--original" data-original="https://cdn-images-1.medium.com/max/800/1*-vHNuJsJVXvqq5dLHPt7cQ.png" data-thumb="/images/thumb/9bd7ee3ff0f77505a15dd7c5a9e49383.png"></div></p><p>11、在 <em>至少</em> 5000毫秒之后，定时器完成，并将 <code>cb1</code> 回调推入回调队列。</p><p><div class="progress-images" style="width:800px"><div class="progress-images--placeholder" style="padding-bottom: 75%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*eOj6NVwGI2N78onh6CuCbA.png" class="progress-images--original" data-original="https://cdn-images-1.medium.com/max/800/1*eOj6NVwGI2N78onh6CuCbA.png" data-thumb="/images/thumb/142487cbb107d8a375f7c53bf56e059f.png"></div></p><p>12、事件循环从回调队列里取出 <code>cb1</code> 并推入调用栈。</p><p><div class="progress-images" style="width:800px"><div class="progress-images--placeholder" style="padding-bottom: 75%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*jQMQ9BEKPycs2wFC233aNg.png" class="progress-images--original" data-original="https://cdn-images-1.medium.com/max/800/1*jQMQ9BEKPycs2wFC233aNg.png" data-thumb="/images/thumb/dbbecbf25985f2e5c16dedf359b6ab99.png"></div></p><p>13、<code>cb1</code> 被执行，并添加 <code>console.log('cb1')</code> 到调用栈。</p><p><div class="progress-images" style="width:800px"><div class="progress-images--placeholder" style="padding-bottom: 75%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*hpyVeL1zsaeHaqS7mU4Qfw.png" class="progress-images--original" data-original="https://cdn-images-1.medium.com/max/800/1*hpyVeL1zsaeHaqS7mU4Qfw.png" data-thumb="/images/thumb/39ba74e92ab2f872db54e4653bf62be4.png"></div></p><p>14、<code>console.log('cb1')</code> 被执行。</p><p><div class="progress-images" style="width:800px"><div class="progress-images--placeholder" style="padding-bottom: 75%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*lvOtCg75ObmUTOxIS6anEQ.png" class="progress-images--original" data-original="https://cdn-images-1.medium.com/max/800/1*lvOtCg75ObmUTOxIS6anEQ.png" data-thumb="/images/thumb/e02b23c788674fae6846c354e17b2200.png"></div></p><p>15、<code>console.log('cb1')</code> 被移出调用栈。</p><p><div class="progress-images" style="width:800px"><div class="progress-images--placeholder" style="padding-bottom: 75%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*Jyyot22aRkKMF3LN1bgE-w.png" class="progress-images--original" data-original="https://cdn-images-1.medium.com/max/800/1*Jyyot22aRkKMF3LN1bgE-w.png" data-thumb="/images/thumb/d242a15ed34913df6c77643fa980c9ac.png"></div></p><p>16、<code>cb1</code> 被移出调用栈。</p><p><div class="progress-images" style="width:800px"><div class="progress-images--placeholder" style="padding-bottom: 75%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*t2Btfb_tBbBxTvyVgKX0Qg.png" class="progress-images--original" data-original="https://cdn-images-1.medium.com/max/800/1*t2Btfb_tBbBxTvyVgKX0Qg.png" data-thumb="/images/thumb/2e9ad02973ebd6609706bb85185fcfcd.png"></div></p><p>快速回顾一下：</p><p><div class="progress-images" style="width:800px"><div class="progress-images--placeholder" style="padding-bottom: 75%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/800/1*TozSrkk92l8ho6d8JxqF_w.gif" class="progress-images--original" data-original="https://cdn-images-1.medium.com/max/800/1*TozSrkk92l8ho6d8JxqF_w.gif" data-thumb="/images/thumb/9174ae7f1b869ec044521df5e9d438a8.gif"></div></p><p>有趣的是 ES6 指定了 事件循环如何工作，意味着技术上来讲，事件循环是在 JS 引擎的职责范围内的，它将不再扮演宿主环境的角色。这一变化的一个主要原因是 ES6 Promise 的介绍说：因为后者需要直接访问和细粒度地控制事件队列循环的调度操作。（稍后我们会更详细地讨论它们）</p><h2 id="setTimeout-…-如何工作"><a href="#setTimeout-…-如何工作" class="headerlink" title="setTimeout(…) 如何工作"></a>setTimeout(…) 如何工作</h2><p>值得注意地的， <code>setTimeout(…)</code> 并不会自动将回调函数添加进事件循环队列。它只是设定一个定时器。当定时器到期时，运行环境将回调事件推入事件循环。所以未来 <code>tick</code> 会取出回调并执行它。看一眼这个代码：</p><script src="https://gist.github.com/zlatkov/9345a7c43b2407ddd1c52a6173a97dd9.js"></script><p>它并不意味着 <code>myCallback</code> 将会在1000毫秒的时候立即执行，而是在1000毫秒后，<code>myCallback</code> 被添加进事件循环队列。但是，队列里可能已经有其他事件被更早地添加进来————你的回调必须等待。</p><p>有相当多的文章和教程在开始使用异步js时建议使用 <code>setTimeout(callback, 0)</code>。现在你知道事件循环是怎么回事以及 setTimeout 如何工作：调用第二个参数为 0 的 setTimeout 只是推迟执行回调函数直至调用栈清空。</p><p>看一下下面的代码：</p><script src="https://gist.github.com/zlatkov/b12986d07676bc17fe51398847ebc917.js"></script><p>尽管定时器设置为 0ms, 但浏览器控制台的结果是：</p><pre><code>HiByecallback</code></pre><h2 id="ES6-里的-Jobs-是什么？"><a href="#ES6-里的-Jobs-是什么？" class="headerlink" title="ES6 里的 Jobs 是什么？"></a>ES6 里的 Jobs 是什么？</h2><p>在 ES6 介绍中，出现了一个新概念 “Jobs Queue”。它是事件循环之上的一层。当你处理 Promise 异步操作的时候，你几乎经常碰到它（我们也会谈谈它）。</p><p>我们先来谈谈这个概念，以便稍后讨论异步 Promise 表现的时候，你能理解那些行为是如何被调度和处理的。</p><p>想像一下，Job Queue 是一个附属于事件队列中每一个 tick 结尾的队列。某些异步行为可能会发生在事件循环的某一刻，却不会引起一个全新的事件添加到事件循环队列中。但会添加一个项目（也叫Job）到当前 tick 的 Job Queue。</p><p>这意味着你可以添加一个功能，让它稍后执行。并且你可以放心，它刚好会在其他事件之前，在那之后执行。</p><p>一个 Job 也能引起其他的 Job 添加到相同的队列后面。理论上，Job “循环”也是有可能产生的（一个不断添加其他 Jobs的Job之类）。这样需要资源的程序就必须移动到事件循环的下一个 tick。概念上看，这就类似于需要长时候运行或死循环（就像 <code>while (true) ..</code>）。</p><p>Job 就像 <code>setTimeout(callback, 0)</code> 的 <code>hack</code>，但通过引入一个更加明确的概念来实现：稍后执行，但尽可能快。</p><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>正如你所知道的，回调函数是迄今为止 javascript 程序中最常见的表达和管理异步的方式。的确，回调是 javascript 语言中最基本的异步模式。无数的JS程序，甚至是即使是非常复杂的一个，也不会少了最基础的回调异步模式。</p><p>除了回调，其他的不会没有缺点。许多开发者尝试寻找更好的异步模式。但是，如果不能很好地理解引擎下的工作原理，就不可能有效地使用任何抽象概念。</p><p>在接下来的章节，我们将探索这些抽象概念，深入地展示为什么更复杂的异步模式（这将在随后的帖子中讨论）是必须的，甚至是推荐的。</p><h2 id="嵌套回调"><a href="#嵌套回调" class="headerlink" title="嵌套回调"></a>嵌套回调</h2><p>看下面的代码：</p><script src="https://gist.github.com/zlatkov/cf5d201413729777fa6b8d5af1f8eaa4.js"></script><p>我们有三个函数嵌套在一起，每一个就代表异步系列的一步。</p><p>这种代码经常被称为“回调地狱（callback hell）”。但“回调地狱”实际上与嵌套、缩进没什么关系。这是一个更深入的问题。</p><p>首先，我们等待“点击”事件，然后等待定时器被触发，然后等待 Ajax 请求响应数据，在这一点，它可能会再次重复。</p><p>粗略地看，这段代码似乎自然而然地将异步映射为连续的步骤：</p><script src="https://gist.github.com/zlatkov/c279bb1865ad3a8ff8c890d842b105c1.js"></script><p>然后我们有：</p><script src="https://gist.github.com/zlatkov/8c9c5601ba6b35adf652b7a6797d1a14.js"></script><p>再然后有：</p><script src="https://gist.github.com/zlatkov/250ccf280b4f191f87bca3a0b8337a41.js"></script><p>最后我们有：</p><script src="https://gist.github.com/zlatkov/6dc48448f85e010542ac9ba86482f38d.js"></script><p>这样用连续的方式表达异步看起来更自然，不是吗？这种方式一定行得通，对吧？</p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>看一下这个代码：</p><script src="https://gist.github.com/zlatkov/bf8888880822b83e4a9c1bfc4b21c6a9.js"></script><p>这非常简单：将 <code>x</code> 和 <code>y</code> 的值相加然后输出在控制台。但是，如果 <code>x</code> 和 <code>y</code> 的值在用于表达式之前丢失了，或还不确定怎么办呢？让我们想象一下，我们有两个函数 <code>loadx</code> 和 <code>loady</code> 分别从服务端加载 <code>x</code> 和 <code>y</code> 的值。然后，有一个函数 <code>sum</code> 会在 <code>x</code> 和 <code>y</code> 都获取到值的时候相加。</p><p>代码看起来可能是这样的（非常丑陋，不是吗）：</p><script src="https://gist.github.com/zlatkov/1ffa6e00a2750217f1a168fe36deda08.js"></script><p>这里有一些非常值得注意的事情——在上面的代码段中，我们假设 <code>x</code> 和 <code>y</code> 都是未来值，并且我们表达了一个操作函数 <code>sum</code> 并不关心 <code>x</code>或<code>y</code>或两者是否都可用。</p><p>当然，这种基于回调的方式不尽人意。这只是首先的一小步，为了更好地理解为什么不需要关心 <em>未来值</em> 何时可用这方面。</p><h2 id="Promise-Value"><a href="#Promise-Value" class="headerlink" title="Promise Value"></a>Promise Value</h2><p>让我们粗略地看一下，如何使用 Promise 来表达 <code>x + y</code>:</p><script src="https://gist.github.com/zlatkov/e7098be769383bac5336c54d952beb53.js"></script><p>这个代码段中有两层 Promise.</p><p><code>fetchX()</code> 和 <code>fetchY()</code> 被直接调用，并且他们的返回值被传递到 <code>sum(...)</code> 。潜在的值可能在现在或稍后准备好，但每个 Promise 规定了它们的表现是相同的。我们以独立的方式分析 <code>x</code> 和 <code>y</code>的值。它们是未来的值，有一段期限。</p><p>第二层是<code>sum(...)</code> 创建的 Promise(来源于 <code>Promise.all([ ... ])</code>)。我们等待着调用 <code>then(...)</code> .当 <code>sum(...)</code> 操作符完成时，我们相加的未来的值已经准备好，并且可以输出。我们为了等待 <code>x</code> 和<code>y</code> 值，在 <code>sum(...)</code>中隐藏了逻辑。</p><p><strong>注意：</strong> 在<code>sum(…)</code>之中，调用 <code>Promise.all([ … ])</code> 创建一个 Promise （等待 <code>promiseX</code> 和 <code>promiseY</code> 完成）。调用链 <code>.then(...)</code> 创建另一个 Promise，立即返回 <code>values[0] + values[1]</code> （相加的结果）。<code>sum(...)</code> 后面调用的 <code>then(...)</code> 实际上是第二个Promise 返回的，而不是第一个 <code>Promise.all([ ... ])</code> 返回的。同样，我们没有链接第二个 <code>then(...)</code>, 它也同样已经创建了另一个 Promise。这一 Promise 链的内容将在本章结尾详细解释。</p><p>使用 Promise, <code>then(...)</code> 实际上可以传入两个函数，第一个对应完成状态，第二个是对应失败状态。</p><script src="https://gist.github.com/zlatkov/33582dc127209706688796092e268772.js"></script><p>如果在获取 <code>x</code> 或 <code>y</code> 的时候发生错误，或者在相加的时候出错，<code>sum(...)</code> 会返回失败，并且传入 <code>then(...)</code> 的第二个错误处理函数会收到 Promise 返回的值。</p><p>因为 Promise 封装了依赖时间的状态——等待底层值的完成或失败——从外部看，Promise 本身是依赖时间的，因此 Promise 可以以可预测的方式组合起来，而不用考虑时间和结果。</p><p>此外，一旦 Promise 解决了，它将永入停留在那个状态——它这时变成一个 <em>不可变的</em> 值——并且根据需要可以观察多次。</p><p>链式调用 Promise 真的非常有用：</p><script src="https://gist.github.com/zlatkov/f94c8e16cbbb8b8940744b348c70de14.js"></script><p>调用 <code>delay(2000)</code> 创建一个 Promise 将会在 2000ms 后达到条件，然后从第一个 <code>then(...)</code> 成功回调返回，这会造成第二个 <code>then(...)</code> 会等待 2000ms 的 Promise.</p><p><strong>注意：</strong> 因为 Promise 从外部看来如果被解决了是无法再改变的，现在把值传到任何一部分都是安全的，它不能被恶意或意外地修改。尤其是关系到多个 Promise 遵守协议。一方不可能影响另一方遵守协议的能力。不变性听起来关系到学术性的话题。但它实际上是 Promise 设计的最基本也是最重要的部分，不应该随便错过。</p><h2 id="用还是不用-Promise"><a href="#用还是不用-Promise" class="headerlink" title="用还是不用 Promise"></a>用还是不用 Promise</h2><p>关于 Promise 有一个很重要的细节就是要知道某个值是否是 Promise。换句话说，某个值表现得像 Promise 吗？</p><p>我们知道，Promise 通过 <code>new Promise(…)</code> 语法构造，然后你认为 <code>p instanceof Promise</code> 足以检查它是否是一个 Promise。但，并不完全是。</p><p>主要是因为你可以有通过其他的浏览窗口接收一个 Promise 值（比如：iframe），它有它所属的 Promise， 不同于当前窗口的，并且检测是否是 Promise 实例会返回失败。</p><p>此外，一个类库或框架可能会选择自己使用的 Promise 实现版本，而不是使用 ES6 原生实现的 Promise。通过类库使用 Promise 可能在不支持 Promise 的浏览器上工作得很好。</p><h2 id="被吞掉的异常"><a href="#被吞掉的异常" class="headerlink" title="被吞掉的异常"></a>被吞掉的异常</h2><p>如果任何时候创建一个 Promise ，或正在监听它决策的时候，发生了意外错误，比如 <code>TypeError</code> 或者 <code>ReferenceError</code>, 异常将会被捕获，并且这个 Promise 将会被强制变成失败状态。</p><p>举个例子：</p><script src="https://gist.github.com/zlatkov/ba13f1f0a37b0156417bc389785d37ea.js"></script><p>但如果一个 Promise 还没有变成成功状态，却在观察期间发生了异常会怎样呢（在 <code>then(...)</code> 注册了回调）？尽管这个异常可以捕获，但它的处理方式可能让你有点吃惊。让我们挖得更深一点。</p><script src="https://gist.github.com/zlatkov/2ab398f4d3eeccb80556de844de2cd92.js"></script><p>这看起来发生在 <code>foo.bar()</code> 的异常确实被吞掉了。虽然事实并没有。有一些更深的东西发生了错误，但是，我们并没有监听到。<code>p.then(…)</code> 返回另一个 Promise，而且这个 Promise 会因为 <code>TypeError</code> 变成失败状态。</p><h2 id="处理未捕获的异常"><a href="#处理未捕获的异常" class="headerlink" title="处理未捕获的异常"></a>处理未捕获的异常</h2><p>还有其他一些许多人认为 <em>更好</em> 的解决办法。</p><p>一个普遍的建议就是 Promise 应该添加一个 <code>done(…)</code>，意味着 Promise 链式调用已“完成”。<code>done(…)</code> 不会再创建并返回一个 Promise，所以传递回调函数到 <code>done(..)</code> 显然不能与不存在的 Promise 连接上报异常。</p><p>你可能期望发现任何未捕获的错误的情况：任何 <code>done(..)</code> 中的异常都会抛出全局的未捕获的错误（基本都会出现在控制台）：</p><script src="https://gist.github.com/zlatkov/ae156463adf288ca0ac9da9e8964fa18.js"></script><h2 id="ES8-有什么变化？Async-await"><a href="#ES8-有什么变化？Async-await" class="headerlink" title="ES8 有什么变化？Async/await"></a>ES8 有什么变化？Async/await</h2><p>javascript ES8 推出了 <code>async/await</code> 让 Promise 的工作更容易更简单。我们简要地看看 <code>async/await</code> 提供了什么并利用它们写一些异步代码。</p><p>那么，让我们来看看 <code>async/await</code> 是如何工作的。</p><p>你可以使用 <code>async</code> 声明定义一个异步函数。这样的函数返回一个<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction" target="_blank" rel="noopener">异步函数对象</a>。<code>AsyncFunction</code> 对象代表异步函数执行代码，并包含在那个宿主函数中。</p><p>当异步函数被调用时，它返回一个 <code>Promise</code>。当异步函数返回一个值时，那就不是一个 <code>Promise</code>。<code>Promise</code> 会被自动创建，并且会通过返回值来完成状态。当 <code>async</code> 抛出异常，<code>Promise</code> 将抛出值并变成失败状态。</p><p>一个 <code>async</code> 函数可以包含一个 <code>await</code> 表达式，它会暂停执行函数内的代码并等待 Promise 返回结果，然后继续执行异步函数并返回结果。</p><p>你可以认为 <code>Promise</code> 与 Java中的<code>Future</code>或者 <code>C#</code> 的任务。</p><blockquote><p>使用 <code>async/await</code> 的目的是为了简化使用 Promise 的行为。</p></blockquote><p>看下面的代码：</p><script src="https://gist.github.com/zlatkov/8f74044b900d1ea4d365ca3992b50ea3.js"></script><p>同样的，异步函数内抛出异常相当于普通函数抛出一个被拒绝的 Promise：</p><script src="https://gist.github.com/zlatkov/159929de0c27b2ddfc9c8e100ce51b43.js"></script><p><code>await</code> 语句只有用在 <code>async</code> 函数内，并允许你在 Promise 进行同步等待。如果我们要在 <code>async</code> 函数外使用 Promise, 我们仍要使用 <code>then</code> 来执行回调：</p><script src="https://gist.github.com/zlatkov/448a79cab54330c062a13a84ebb06cf7.js"></script><p>你也可以使用“异步函数表达式”来定义异步函数。一个异步函数表达式和一个异步函数声明很类似，几乎有相同的语法。他们之前主要的不同就是函数名。异步函数表达式可以省略函数名，创建一个匿名函数。异步函数表达式可以被当成 IIFE（自执行函数）来使用，一经定义就执行。</p><p>看下这个：</p><script src="https://gist.github.com/zlatkov/0873db2fd9f5883a2e1bae414e43a5cc.js"></script><p>更重要的地，<code>async/await</code> 在主流浏览器中的支持情况：</p><p><img src="https://cdn-images-1.medium.com/max/800/0*z-A-JIe5OWFtgyd2." alt="If this compatibility is not what you are after, there are also several JS transpilers like Babel and TypeScript."></p><p>最后，最重要的是不要盲目地选择“最新”的写法去实现异步函数。本质是要理解异步 javascript 的内部原理。了解它为什么如此关键，并深入理解你的选择的内部原理。每种方法都有优缺点，就像编程中的其他部分一样。</p><h1 id="编写高可维护性，健壮的代码的5个提示"><a href="#编写高可维护性，健壮的代码的5个提示" class="headerlink" title="编写高可维护性，健壮的代码的5个提示"></a>编写高可维护性，健壮的代码的5个提示</h1><h2 id="1、-简洁的代码"><a href="#1、-简洁的代码" class="headerlink" title="1、 简洁的代码"></a>1、 简洁的代码</h2><p>使用 async/await 允许你写很少的代码。每次你使用 async/await 跳过一些不必须要步骤：写 <code>.then</code> 时，创建一个匿名函数去处理回应，给返回值命名。例如：</p><script src="https://gist.github.com/zlatkov/b66f922b26bb6d5fd701c7ba40ac81d7.js"></script><p>与：</p><script src="https://gist.github.com/zlatkov/f506c8de2c73ba1c4c9ec78c5871816c.js"></script><h2 id="2、错误处理"><a href="#2、错误处理" class="headerlink" title="2、错误处理"></a>2、错误处理</h2><p>Async/await 让处理同步和异步错误使用相同的方法——广为人知的 <code>try/catch</code>。</p><script src="https://gist.github.com/zlatkov/c5fc0706d2d37ce3bb9db75e8a991807.js"></script><p>与：</p><script src="https://gist.github.com/zlatkov/1f858a186da7d19fab77893e34e46adc.js"></script><h2 id="3、条件语句"><a href="#3、条件语句" class="headerlink" title="3、条件语句"></a>3、条件语句</h2><p>使用 <code>async/await</code> 写条件句更简单：</p><script src="https://gist.github.com/zlatkov/30e8c04023639ed289a5d107b6989269.js"></script><p>与：</p><script src="https://gist.github.com/zlatkov/3dea9285325304af9a73aceb3beb6742.js"></script><h2 id="4、堆栈帧"><a href="#4、堆栈帧" class="headerlink" title="4、堆栈帧"></a>4、堆栈帧</h2><p>与 <code>async/await</code> 不同，Promise 抛出的错误栈并没有包含错误发生在哪里。</p><script src="https://gist.github.com/zlatkov/8e728cc4d6ad1e302454e957fcce0580.js"></script><p>与：</p><script src="https://gist.github.com/zlatkov/7282966e52cab3eee85794d5e8df6928.js"></script><h2 id="5、调试"><a href="#5、调试" class="headerlink" title="5、调试"></a>5、调试</h2><p>如果你使用过 Promise, 你一定知道调试它们是一个噩梦。例如，如果你在一个 <code>.then</code> 打了个断点，并且使用调试快捷键操作，像“stop-over”，调试器并不会移动到下一个 <code>.then</code> ，因为它只是同步代码的“一步”。使用 <code>async/await</code> 你可以精确地定位到每一步 <code>await</code>，就好像他们是正常的同步函数一样。</p><p>书写异步函数不仅对应用程序很重要，对类库也同样如此。</p><p>举个例子： <a href="https://www.sessionstack.com/?utm_source=medium&utm_medium=blog&utm_content=Post-4-eventloop-outro" target="_blank" rel="noopener">Sessionstak</a> 类记录了网页上发生的所有事情。所有 DOM 操作，用户交互，javascript 异常，堆栈跟踪，失败的网络请求，以及调试信息。</p><p>这一切都发生在生产环境下却不影响用户体验。我们必须高度优化我们的代码，让它们尽可能地异步，这样就可以增加事件循环处理事件的数量。</p><p>也不止是类库，当你在 SessionStack 重播用户的会话时，我们必须在发生问题时，将用户浏览器的状态重现出来，我们必须重建整个状态，允许你在时间轴上向后或向前跳跃。为了让这成为可能，我们大量使用了异步javascript提供的机会。</p><p>这里有一个<a href="https://www.sessionstack.com/?utm_source=medium&utm_medium=blog&utm_content=Post-4-eventloop-GetStarted" target="_blank" rel="noopener">免费的计划</a>让你来体验一下。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*xSEaWHGqqlcF8g5H." alt="https://cdn-images-1.medium.com/max/800/0*xSEaWHGqqlcF8g5H."></p><p>参考：</p><ul><li><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch2.md" target="_blank" rel="noopener">https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch2.md</a></li><li><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch3.md" target="_blank" rel="noopener">https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch3.md</a></li><li><a href="http://nikgrozev.com/2017/10/01/async-await/" target="_blank" rel="noopener">http://nikgrozev.com/2017/10/01/async-await/</a></li></ul></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;javascript-事件循环是如何工作的以及使用async／await提升异步编程的5种方式&quot;&gt;&lt;a href=&quot;#javascript-事件循环是如何工作的以及使用async／await提升异步编程的5种方式&quot; class=&quot;headerlink&quot; title=&quot;javascript 事件循环是如何工作的以及使用async／await提升异步编程的5种方式&quot;&gt;&lt;/a&gt;javascript 事件循环是如何工作的以及使用async／await提升异步编程的5种方式&lt;/h1&gt;&lt;p&gt;这次我们将通过回顾在单线程环境中编程的缺点来扩展先前的第一篇文章，以及如何克服它来建立一个令人惊叹的 javascript UIs。像以往一样，在文章的最后，我会分享使用 async/await 写简洁代码的 5 个小贴士。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="tutorial" scheme="http://robin-front.github.io/tags/tutorial/"/>
    
      <category term="web development" scheme="http://robin-front.github.io/tags/web-development/"/>
    
      <category term="programming" scheme="http://robin-front.github.io/tags/programming/"/>
    
      <category term="asynchronous" scheme="http://robin-front.github.io/tags/asynchronous/"/>
    
      <category term="events loop" scheme="http://robin-front.github.io/tags/events-loop/"/>
    
      <category term="promise" scheme="http://robin-front.github.io/tags/promise/"/>
    
      <category term="async await" scheme="http://robin-front.github.io/tags/async-await/"/>
    
  </entry>
  
  <entry>
    <title>你可能并不需要 redux</title>
    <link href="http://robin-front.github.io/2017/10/25/you-might-not-need-redux.html"/>
    <id>http://robin-front.github.io/2017/10/25/you-might-not-need-redux.html</id>
    <published>2017-10-25T17:04:54.000Z</published>
    <updated>2017-10-25T17:04:54.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="你可能并不需要-redux"><a href="#你可能并不需要-redux" class="headerlink" title="你可能并不需要 redux"></a>你可能并不需要 redux</h1><p><strong>人们常常在真正需要用到 redux 之前就选择了它。</strong> “如果我们的应用没有使用 redux，变得不好扩展怎么办？” 后来，开发者们又都皱着眉头指头他们的代码间接地评论 redux.“为什么实现一个小功能需要更改三个文件？” 为什么一定要用 redux 呢!<a id="more"></a></p><p>大家痛苦地指责 <code>redux</code>, <code>react</code>, 函数式编程、 不变性等这些东西，我能理解他们。我们很自然地会拿 redux 和不需要‘按模板’来更新 state 的实现方式进行比较，并得出 redux 只会让事情变复杂的结论。某种程度上看，redux 是被设计成这样的。</p><p>redux 做了一个权衡，它要求你：</p><ul><li>将应用的状态抽象成简单对象或数组。</li><li>将系统的变化抽象成简单对象。</li><li>将处理逻辑抽象成纯函数。</li></ul><p>不管是不是应用在 react 应用程序上，这些限制都是必需的。事实上，这些都是很严格的约束。就算只是在你应用程序的一部分中使用，也应该认真考虑它。</p><p>有人会问，你有充分的理由解释为什么要做这些限制吗？</p><p>这些限制对我很有吸引力，因为它们让我的应用拥有以下优点：</p><ul><li><a href="https://egghead.io/lessons/javascript-redux-persisting-the-state-to-the-local-storage?course=building-react-applications-with-idiomatic-redux" target="_blank" rel="noopener">将 state 存储在本地，并用它启动，开箱即用</a></li><li><a href="http://redux.js.org/docs/recipes/ServerRendering.html" target="_blank" rel="noopener">在服务端预渲染 state，并随 html 发送到客户端，从它启动，开箱即用</a></li><li><a href="https://github.com/dtschust/redux-bug-reporter" target="_blank" rel="noopener">序列化用户交互并触发它，以及进行状态快照，自动 bugs 上报，以便让开发者重现 errors</a></li><li><a href="https://github.com/philholden/redux-swarmlog" target="_blank" rel="noopener">通过网络传递 action 对象，而不会对写代码的方式产生大的影响</a></li><li><a href="http://redux.js.org/docs/recipes/ImplementingUndoHistory.html" target="_blank" rel="noopener">保持重做历史和实现可预测的变化，而不会对写法产生剧大的影响</a></li><li><a href="https://github.com/gaearon/redux-devtools" target="_blank" rel="noopener">开发环境中可以随意穿梭在历史的各个状态中，并在代码更改时根据交互历史重新计算当前状态，一种 TDD 驱动</a></li><li><a href="https://github.com/romseguy/redux-devtools-chart-monitor" target="_blank" rel="noopener">为开发工具提供全面的检测和控制能力，以便产品开发者为他们的 app 构建自定义开发工具</a></li><li><a href="https://youtu.be/gvVpSezT5_M?t=11m51s" target="_blank" rel="noopener">当复用大部分业务逻辑的同时，也提供备用 UI</a></li></ul><p>如果你正在开发<a href="https://hyperterm.org/" target="_blank" rel="noopener">可扩展的 terminal</a>, <a href="https://hacks.mozilla.org/2016/09/introducing-debugger-html/" target="_blank" rel="noopener">javascript 调试器</a>, 或<a href="https://twitter.com/necolas/status/727538799966715904" target="_blank" rel="noopener">某些类型的 webapp</a>, redux 可能很值得一试，或者至少借鉴它的一些思想（顺便提一下，这些并<a href="https://github.com/evancz/elm-architecture-tutorial" target="_blank" rel="noopener">不是</a> <a href="https://github.com/omcljs/om" target="_blank" rel="noopener">新事物</a>）。</p><p><strong>但是，如果你只是在学习 react, 那么不要把 redux 当成你的首选。</strong></p><p>相反，学会 <a href="https://facebook.github.io/react/docs/thinking-in-react.html" target="_blank" rel="noopener">思考 react</a>, 如果你发现你真的需要它，或者你想尝试一些新东西，那就重新考虑 redux 吧。但是一定要谨慎对待它，就像对待固执已见的工具一样。</p><p><strong>如果你对 redux 的方式感到压力。这是一个信号，可能你的队友太认真了。</strong> 它只是你工具箱里的一个工具，一个<a href="https://www.youtube.com/watch?v=uvAXVMwHJXU" target="_blank" rel="noopener">疯狂</a> 的<a href="https://www.youtube.com/watch?v=xsSnOQynTHs" target="_blank" rel="noopener">实验</a>。</p><p><strong>最后，不要忘记，你可以不用 redux,而实现 redux 的思想。</strong></p><p>举个例子，考虑一个带有 local state 的 react 组件:</p><script src="https://gist.github.com/gaearon/a9bbb73d57b6e4cc17d7b50807b62f9a.js"></script><p>看上去很好。严格地说，它没有达到高度复用。</p><p><strong>但是，这样使用 Local state 就很好。</strong></p><p>权衡之下，redux 提供解耦，将“发生了什么交互”与“数据如何改变”解耦。</p><p>举个例子，可以从我们的组件中提取出一个 reducer:</p><script src="https://gist.github.com/gaearon/64e2c4adce2b4918c96c3db2b44d8f68.js"></script><p>注意，我们没有运行 npm install 却应用了 redux ! 哇哦！</p><p>你的状态组件是否也需要这样写呢？可能不需要。除非你有计划地从这种解耦方式中获益。有计划是我们的一种说法，这是关键。</p><p><a href="http://redux.js.org/" target="_blank" rel="noopener">redux 库</a>本身只是“安装” reducer 和单个全局 store 对象的工具集。你可以只使用部分或者全部功能，这取决于你。</p><p><strong>但，如果你付出了什么，一定要确保你有所收获。</strong></p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;你可能并不需要-redux&quot;&gt;&lt;a href=&quot;#你可能并不需要-redux&quot; class=&quot;headerlink&quot; title=&quot;你可能并不需要 redux&quot;&gt;&lt;/a&gt;你可能并不需要 redux&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;人们常常在真正需要用到 redux 之前就选择了它。&lt;/strong&gt; “如果我们的应用没有使用 redux，变得不好扩展怎么办？” 后来，开发者们又都皱着眉头指头他们的代码间接地评论 redux.“为什么实现一个小功能需要更改三个文件？” 为什么一定要用 redux 呢!
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="react" scheme="http://robin-front.github.io/tags/react/"/>
    
      <category term="redux" scheme="http://robin-front.github.io/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 ios11 webview 的 viewport</title>
    <link href="http://robin-front.github.io/2017/09/21/Understanding-the-WebView-Viewport-in-iOS-11.html"/>
    <id>http://robin-front.github.io/2017/09/21/Understanding-the-WebView-Viewport-in-iOS-11.html</id>
    <published>2017-09-21T11:34:30.000Z</published>
    <updated>2017-09-21T11:34:30.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="深入理解-ios11-webview-的-viewport"><a href="#深入理解-ios11-webview-的-viewport" class="headerlink" title="深入理解 ios11 webview 的 viewport"></a>深入理解 ios11 webview 的 viewport</h1><p>ios11 带来了一些新的东西，凭直觉，围绕状态栏区域的展现对于程序员使用的像 Apache Cordova 或 Ionic 这样的工具显得尤为重要。尤其是，这个改动影响到所有为 ios11 构建的、基于 web 的、使用了固定标题栏的 app 之中。这篇文章帮助你理解 ios11 webview 的 viewport。</p><p><strong>注： 现有的 app 可以继续正常工作，因为原有的 viewport 表现并没有被改变。这个改变只影响那些使用 xcode9 来为 ios11 构建的应用。</strong></p><p>为了理解这个改动，我们需要先了解一下背景知识。<a id="more"></a></p><h2 id="状态栏和安全区域"><a href="#状态栏和安全区域" class="headerlink" title="状态栏和安全区域"></a>状态栏和安全区域</h2><p>在 ios 的早期版本中，状态栏是屏幕顶部的不可触摸的黑色长条。它是系统 UI 的一部分，而 app 运行在它的下面。</p><p>随着 ios7 的发布，一切发生了改变。它变成了一个透明的状态栏，从而显示了 app 导航栏的颜色。对于像 Cordova 这样显示在 webview 的 app, 意味着通常需要检测是否 ios 并添加 <code>padding-top: 20px</code> 到固定的头部导航, 以便正确填充那部分空间。</p><p>后来发布的较新版本的 ios 添加了一些小修订。包含了一些新功能，比如当有电话呼入或在后台使用定位功能时顶部会展示额外的状态栏。</p><p>在原生应用方面，存在大量的导航栏和自动布局指南。会有一些布局指示在屏幕的顶部或底部以便自动调整高度，让状态栏不会遮住应用。如果在顶部设置了 UINavigationBar， ios 会自动在状态栏拓展它的颜色。对于 web，很不幸，没有等价的办法。</p><h2 id="iOS11-的改变"><a href="#iOS11-的改变" class="headerlink" title="iOS11 的改变"></a>iOS11 的改变</h2><p><div class="progress-images" style="width:1118px"><div class="progress-images--placeholder" style="padding-bottom: 85.86762075134168%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="The default viewport behaviour in iOS 11 on an iPhone 8." class="progress-images--original" data-original="https://ayogo.com/wp-content/uploads/2017/09/iphone8-viewport-auto-crop-zop.png" data-thumb="/images/thumb/92bd8bcef5beaed7bb879bd0b64bdcfa.png"></div></p><p>ios11 和先前版本的不同之处在于， webview 内容现在重视安全区域了。这意味着，如果设置头部栏 <code>top: 0</code>, 它会渲染在屏幕顶部的<code>20px</code>之下，也就是状态栏下面。当向下浏览时，会移到状态栏后面。当向上浏览时，又会移动状态栏下面与状态栏部对齐。（留下尴尬的20像素空白）</p><p>可以看看下面剪辑的视频中了解到有多么糟糕：</p><video src="https://cdn.css-tricks.com/wp-content/uploads/2017/09/ios11-viewport.mp4" width="300" height="330" controls name="fitvid0"></video><h2 id="为什么苹果公司会改成这个样子"><a href="#为什么苹果公司会改成这个样子" class="headerlink" title="为什么苹果公司会改成这个样子"></a>为什么苹果公司会改成这个样子</h2><p>如果你看过 iPhone X 的设计，就知道它这样改动是有道理的： iPhone X 的屏幕顶部有个为摄像头和话筒留出的不规则区域。如果真的渲染到屏幕顶部，就会被麦克风挡住。</p><p>通过对齐状态栏底部，可以确保头部栏可以一直被访问。</p><p>酷！…除了现在 app 上面滑动内容时在状态栏底下留下的尴尬的空白。</p><h2 id="iOS11-解决方案"><a href="#iOS11-解决方案" class="headerlink" title="iOS11 解决方案"></a>iOS11 解决方案</h2><p>值得庆幸的是，Apple 给我们提供了一个通过设置 viewport meta 标签的解决方案。更幸运的是，它还向下兼容旧的，过期的 UIWebView。</p><p>我们正在找的 viewport 选项就是 <code>viewport-fit</code>,它有三个可选值：</p><ul><li>contain： 这意味着 iOS11 下，固定栏会被包含在安全区域内。</li><li>cover： 这意味着固定栏是相对 viewport 固定的，就算会被立大状态栏遮蔽。这就回到了 iOS10 的表现。</li><li>auto： 这和 contain 选项的表现是一样的。</li></ul><p>所以为了恢复到固定在屏幕的最顶端，就像 iOS10 一样在状态栏下面。可以添加 <code>viewport-fit=cover</code> 到 viewport meta 标签。</p><p><div class="progress-images" style="width:1118px"><div class="progress-images--placeholder" style="padding-bottom: 85.86762075134168%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="" class="progress-images--original" data-original="https://ayogo.com/wp-content/uploads/2017/09/iphone8-viewport-cover-crop-zop.png" data-thumb="/images/thumb/4fb4a207fdc6a936ad5378813a0694f3.png"></div></p><h2 id="iPhone-X"><a href="#iPhone-X" class="headerlink" title="iPhone X"></a>iPhone X</h2><p>但 iPhone X 的小刘海怎么办？这个状态栏不再是 <code>20px</code> 高，并且因为里面有摄像头和扬声器，头部栏会完全无法访问。同样要注意固定在屏幕底部的页脚，它会被麦克风遮住。</p><p><strong>注：如果有启动脚本，应用将只会运行在 iPhone X 的全屏幕上。现有的 app 会在顶部和底部有黑色区域。</strong></p><p><div class="progress-images" style="width:300px"><div class="progress-images--placeholder" style="padding-bottom: 88%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="" class="progress-images--original" data-original="https://ayogo.com/wp-content/uploads/2017/09/iphonex-viewport-cover-crop-zop-300x264.png" data-thumb="/images/thumb/d80803b5de61648476d8dd01e9574ee4.png"></div></p><p>幸运的是，Apple 给出了一个关于安全区域的 css 指南。他们添加一个类似 css 变量，叫做 css 常数。可以把它看做是系统的 css 变量并且不可覆盖。可以在 css 中通过<code>constant()</code> 函数来调用它们，并且已向 css 标准化工作小组提案。</p><p>这四个布局常量是：</p><ul><li>constant(safe-area-inset-top): viewport 顶部插入的安全区域（使用 css 像素）</li><li>constant(safe-area-inset-bottom): viewport 底部插入的安全区域（使用 css 像素）</li><li>constant(safe-area-inset-left): viewport 左边插入的安全区域（使用 css 像素）</li><li>constant(safe-area-inset-right): viewport 右边插入的安全区域（使用 css 像素）</li></ul><p>这是 Apple 给我们的最后一个礼物，也是向下兼容的。</p><h2 id="css-constants-的例子"><a href="#css-constants-的例子" class="headerlink" title="css constants 的例子"></a>css constants 的例子</h2><p>假设有一个头部固定栏，现在 iOS10 下的 css 如下：</p><pre class=" language-css"><code class="language-css"><span class="token selector">header </span><span class="token punctuation">{</span>    <span class="token property">position</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span>    <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">right</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">44</span>px<span class="token punctuation">;</span>    <span class="token property">padding-top</span><span class="token punctuation">:</span> <span class="token number">20</span>px<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* Status bar height */</span><span class="token punctuation">}</span></code></pre><p>为了调整自适应 iPhone X 和 iOS11 设备，会添加 <code>viewport-fit=cover</code> 选项到 viewport meta 标签上，并且更改 css， 引用 css constant。</p><pre class=" language-css"><code class="language-css"><span class="token selector">header </span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* ... */</span>    <span class="token comment" spellcheck="true">/* Status bar height on iOS 10 */</span>    <span class="token property">padding-top</span><span class="token punctuation">:</span> <span class="token number">20</span>px<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Status bar height on iOS 11+ */</span>    <span class="token property">padding-top</span><span class="token punctuation">:</span> <span class="token function">constant</span><span class="token punctuation">(</span>safe-area-inset-top<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>重要的是，要保留回退值，因为旧设备不能解释 css <code>constant()</code> 语法。别外，也可以在 css <code>calc()</code> 表达式中使用 constants.</p><p><div class="progress-images" style="width:300px"><div class="progress-images--placeholder" style="padding-bottom: 88%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="" class="progress-images--original" data-original="https://ayogo.com/wp-content/uploads/2017/09/iphonex-viewport-constants-crop-zop-300x264.png" data-thumb="/images/thumb/81658b96ea2aad572bc6549e415e4afe.png"></div></p><p>记住，你也会想要在屏幕底部做这件事的。</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;深入理解-ios11-webview-的-viewport&quot;&gt;&lt;a href=&quot;#深入理解-ios11-webview-的-viewport&quot; class=&quot;headerlink&quot; title=&quot;深入理解 ios11 webview 的 viewport&quot;&gt;&lt;/a&gt;深入理解 ios11 webview 的 viewport&lt;/h1&gt;&lt;p&gt;ios11 带来了一些新的东西，凭直觉，围绕状态栏区域的展现对于程序员使用的像 Apache Cordova 或 Ionic 这样的工具显得尤为重要。尤其是，这个改动影响到所有为 ios11 构建的、基于 web 的、使用了固定标题栏的 app 之中。这篇文章帮助你理解 ios11 webview 的 viewport。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注： 现有的 app 可以继续正常工作，因为原有的 viewport 表现并没有被改变。这个改变只影响那些使用 xcode9 来为 ios11 构建的应用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了理解这个改动，我们需要先了解一下背景知识。
    
    </summary>
    
      <category term="css" scheme="http://robin-front.github.io/categories/css/"/>
    
    
      <category term="ios11" scheme="http://robin-front.github.io/tags/ios11/"/>
    
      <category term="viewport" scheme="http://robin-front.github.io/tags/viewport/"/>
    
      <category term="css-constant" scheme="http://robin-front.github.io/tags/css-constant/"/>
    
      <category term="viewport-fit" scheme="http://robin-front.github.io/tags/viewport-fit/"/>
    
  </entry>
  
  <entry>
    <title>IphoneX 的缺口（小刘海）及其css样式解决方案</title>
    <link href="http://robin-front.github.io/2017/09/21/the-notch-and-css.html"/>
    <id>http://robin-front.github.io/2017/09/21/the-notch-and-css.html</id>
    <published>2017-09-21T10:23:04.000Z</published>
    <updated>2017-09-21T10:23:04.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="IphoneX-的缺口（小刘海）及其css样式解决方案"><a href="#IphoneX-的缺口（小刘海）及其css样式解决方案" class="headerlink" title="IphoneX 的缺口（小刘海）及其css样式解决方案"></a>IphoneX 的缺口（小刘海）及其css样式解决方案</h1><p>苹果公司的 IphoneX 拥有了全面屏，只保留了‘小刘海’给摄像头和一些传感设备。结果就是让屏幕设计陷入尴尬的境地，就像限制网页有一个“安全区域”和白色边缘条。虽然没有太多的黑魔法去消除它，但给 <code>body</code> 设置一个 <code>background-color</code> 属性也可以做到。或者扩展网页以覆盖整个屏幕（该死的缺口），可以给 viewport 的 meta 标签添加 <code>viewport-fit=cover</code>。</p><p><div class="progress-images" style="width:1000px"><div class="progress-images--placeholder" style="padding-bottom: 66.4%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1000,f_auto,q_auto/v1505590717/iphonex-safari_njxeiw.png" class="progress-images--original" data-original="https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1000,f_auto,q_auto/v1505590717/iphonex-safari_njxeiw.png" data-thumb="/images/thumb/4aca354ea71414917ae504ea1d85726e.png"></div><a id="more"></a></p><pre class=" language-html"><meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"><code class="language-html"><meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"></code></pre><p>然后，由你自己决定如何处理安全区域的重叠。这里有一些新的 css 可以帮助适配它。<a href="http://stephenradford.me/removing-the-white-bars-in-safari-on-iphone-x/" target="_blank" rel="noopener">Stephen Radford documents</a></p><blockquote><p>为了适配缺口，可以引入 ios 11 版本包含的一些常量，这些常量需要使用了 <code>viewport-fit=cover</code> 才会生效。</p><ul><li>safe-area-inset-top</li><li>safe-area-inset-right</li><li>safe-area-inset-left</li><li>safe-area-inset-bottom</li></ul><p>这些常量可以被用在 <code>margin</code>, <code>padding</code>, 或者绝对定位的 <code>top</code>, <code>left</code> 等属性上。</p><pre class=" language-css"><code class="language-css"><span class="token property">padding</span><span class="token punctuation">:</span> <span class="token function">constant</span><span class="token punctuation">(</span>safe-area-inset-top<span class="token punctuation">)</span> <span class="token function">constant</span><span class="token punctuation">(</span>safe-area-inset-right<span class="token punctuation">)</span> <span class="token function">constant</span><span class="token punctuation">(</span>safe-area-inset-bottom<span class="token punctuation">)</span> <span class="token function">constant</span><span class="token punctuation">(</span>safe-area-inset-left<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></blockquote><p>还有另外一个尴尬的局面关于缺口，安全区域和 fixed 定位。<a href="https://ayogo.com/blog/ios11-viewport/" target="_blank" rel="noopener">Darryl Pogue reports:</a></p><blockquote><p>ios 11与早期的版本不太一样，它现在遵守安全区域这一规则。这意味着，如果你有一个 header bar， 并且设置 <code>position: fixed;top: 0;</code>，它初始化时会渲染在顶部的 <code>20px</code> 下面：对齐顶部状态栏的底部。当你向下浏览网页，它会隐藏状态栏。如果向上滚动，状态栏又来跑出来（留下尴尬的20px间隙）。</p></blockquote><video src="https://cdn.css-tricks.com/wp-content/uploads/2017/09/ios11-viewport.mp4" controls name="fitvid0"></video><p>幸运的是这也很容易解决。只需要添加 <code>viewport-fit=cover</code> 到 <code>meta viewport</code> 标签上。</p><p>如果覆盖了全屏幕，那可能需要耍点小聪明去避免挡住内容。</p><p></p><blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">I think I’ve fixed the notch issue in landscape 🍾 <a href="https://twitter.com/hashtag/iphoneX?src=hash" target="_blank" rel="noopener">#iphoneX</a> <a href="https://t.co/hGytyO3DRV" target="_blank" rel="noopener">pic.twitter.com/hGytyO3DRV</a></p>— Vojta Stavik (@vojtastavik) <a href="https://twitter.com/vojtastavik/status/907911237983449088" target="_blank" rel="noopener">September 13, 2017</a></blockquote><p></p><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IphoneX-的缺口（小刘海）及其css样式解决方案&quot;&gt;&lt;a href=&quot;#IphoneX-的缺口（小刘海）及其css样式解决方案&quot; class=&quot;headerlink&quot; title=&quot;IphoneX 的缺口（小刘海）及其css样式解决方案&quot;&gt;&lt;/a&gt;IphoneX 的缺口（小刘海）及其css样式解决方案&lt;/h1&gt;&lt;p&gt;苹果公司的 IphoneX 拥有了全面屏，只保留了‘小刘海’给摄像头和一些传感设备。结果就是让屏幕设计陷入尴尬的境地，就像限制网页有一个“安全区域”和白色边缘条。虽然没有太多的黑魔法去消除它，但给 &lt;code&gt;body&lt;/code&gt; 设置一个 &lt;code&gt;background-color&lt;/code&gt; 属性也可以做到。或者扩展网页以覆盖整个屏幕（该死的缺口），可以给 viewport 的 meta 标签添加 &lt;code&gt;viewport-fit=cover&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1000,f_auto,q_auto/v1505590717/iphonex-safari_njxeiw.png&quot; alt=&quot;https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1000,f_auto,q_auto/v1505590717/iphonex-safari_njxeiw.png&quot;&gt;
    
    </summary>
    
      <category term="css" scheme="http://robin-front.github.io/categories/css/"/>
    
    
      <category term="viewport" scheme="http://robin-front.github.io/tags/viewport/"/>
    
      <category term="css" scheme="http://robin-front.github.io/tags/css/"/>
    
      <category term="iphoneX" scheme="http://robin-front.github.io/tags/iphoneX/"/>
    
      <category term="notch" scheme="http://robin-front.github.io/tags/notch/"/>
    
  </entry>
  
  <entry>
    <title>如何处理4种常见的内存泄露</title>
    <link href="http://robin-front.github.io/2017/09/19/how-to-handle-4-common-memory-leaks.html"/>
    <id>http://robin-front.github.io/2017/09/19/how-to-handle-4-common-memory-leaks.html</id>
    <published>2017-09-19T09:38:51.000Z</published>
    <updated>2017-09-19T09:38:51.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="如何处理4种常见的内存泄露"><a href="#如何处理4种常见的内存泄露" class="headerlink" title="如何处理4种常见的内存泄露"></a>如何处理4种常见的内存泄露</h1><h2 id="什么是内存泄露"><a href="#什么是内存泄露" class="headerlink" title="什么是内存泄露"></a>什么是内存泄露</h2><p>本质上来说，内存泄露可以被定义为 <strong>当内存不再被应用使用，却因为某些原因没有被操作系统回收或释放到自由内存池</strong></p><p><div class="progress-images" style="width:450px"><div class="progress-images--placeholder" style="padding-bottom: 97.11111111111111%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://cdn-images-1.medium.com/max/1600/1*0B-dAUOH7NrcCDP6GhKHQw.jpeg" class="progress-images--original" data-original="https://cdn-images-1.medium.com/max/1600/1*0B-dAUOH7NrcCDP6GhKHQw.jpeg" data-thumb="/images/thumb/c2d4dd80c76174aad0e3954b5efc5c22.jpeg"></div></p><p>编程语言支持多种不同的内存管理。某些内存是否在使用实际上是不可判定的。换句话说，只要开发者才清楚哪些内存块是可以被操作系统回收。</p><p>某些编程语言提供一些特性帮助开发者进行内存回收。其他的期望开发者完全明白哪些内存是无用的。维基有一系列关于内存管理的好文章。<a id="more"></a></p><h2 id="四种常见的内存泄露"><a href="#四种常见的内存泄露" class="headerlink" title="四种常见的内存泄露"></a>四种常见的内存泄露</h2><h3 id="1-全局变量"><a href="#1-全局变量" class="headerlink" title="1. 全局变量"></a>1. 全局变量</h3><p>javascript 通过一个有趣的方式处理未声明的变量：引用未声明的变量会在全局对象里创建一个变量。在浏览器中，全局对象是<code>window</code>, 换句话说：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    bar <span class="token operator">=</span> <span class="token string">"some text"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>等价于：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    window<span class="token punctuation">.</span>bar <span class="token operator">=</span> <span class="token string">"some text"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>如果 <code>bar</code> 预想中是 <code>foo</code> 函数作用域内的局部变量，但又忘记使用 <code>var</code> 去声明，那么预料之外的全局变量就被创建了。</p><p>在这个例子中，一个简单的字符串泄露不会有多大害处，但这种写法当然会有更糟情况。</p><p>另一个意外创建全局变量的方式是通过 <code>this</code>：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>var1 <span class="token operator">=</span> <span class="token string">"potential accidental global"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Foo called on its own, this points to the global object (window)</span><span class="token comment" spellcheck="true">// rather than being undefined.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>为了防止这种情况发生，需要在 javascript 文件的开头添加 <code>'use strict'</code>.这会使用严格模式解析javascript以防止意外的全局变量。<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noopener">了解更多javascript严格模式的执行情况</a></p></blockquote><p>尽管我们在谈论意外的全局变量，但仍然会有无数的明确的全局变量。这些被定义为不可回收的（除非指定为null或重新分配）。特别是应该关注用于临时存储和处理大量数据的全局变量。如果必须要用全局变量去存储大量数据，当你处理完之后，<strong>请勿必记得指定为null或重新全配</strong></p><h3 id="2-被遗忘的定时器和回调"><a href="#2-被遗忘的定时器和回调" class="headerlink" title="2. 被遗忘的定时器和回调"></a>2. 被遗忘的定时器和回调</h3><p>在 javascript 中使用 <code>setInterval</code> 非常常见。</p><p>大部分类库提供观察者和其他调用回调的工具，小心地引用那些 <strong>拥有会变得不可访问的实例</strong> 的回调。<code>setInterval</code> 的例子，尽管这很常见：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> serverData <span class="token operator">=</span> <span class="token function">loadData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> renderer <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'renderer'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>renderer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        renderer<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>serverData<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//This will be executed every ~5 seconds.</span></code></pre><p>这个例子说明了定时器会发生的事：定时器引用了不再需要的node节点和数据。</p><p>被 <code>renderer</code> 引用的对象在将来某个时刻可能会被删除，让整个内部块都变得不必要了。但是，因为定时器还在运行，所以处理程序不能被回收（定时器需要被停止才能回收）。如果定时处理程序不能被回收，那么相关的一切都不能被回收。这意味着可能存储着大量数据的 <code>serverData</code> 也不能被回收。</p><p>观察者的例子中，很重要的一点是当不在需要的时候，必须明确移除他们（或者让相关的对象变得不可访问）。</p><p>在过去，这对于某些不能很好地管理内存的浏览器（像IE6）是非常重要的。如今，大部分浏览器有能力并且会回收不可访问的观察者处理程序，就算有时监听器没有被明确地移除。这仍然是很好的做法，不管怎样，在对象被处理掉之前明确地移除观察者。举个实例：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> element <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'launch-button'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">onClick</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>   counter<span class="token operator">++</span><span class="token punctuation">;</span>   element<span class="token punctuation">.</span>innerHtml <span class="token operator">=</span> <span class="token string">'text '</span> <span class="token operator">+</span> counter<span class="token punctuation">;</span><span class="token punctuation">}</span>element<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> onClick<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Do stuff</span>element<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> onClick<span class="token punctuation">)</span><span class="token punctuation">;</span>element<span class="token punctuation">.</span>parentNode<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Now when element goes out of scope,</span><span class="token comment" spellcheck="true">// both element and onClick will be collected even in old browsers // that don't handle cycles well.</span></code></pre><p>框架或类库，比如 jQuery 在删除 node 节点的时候就移除了监听事件（当使用它的API的时候），这是类库内部处理的，为了防止内存泄露产生。就算在有问题的浏览器下运行，比如…对，IE6 ：）</p><h3 id="闭包（closure）"><a href="#闭包（closure）" class="headerlink" title="闭包（closure）"></a>闭包（closure）</h3><p>javascript 开发一个关键点是 <strong>闭包</strong>： 一个内部函数可以访问（封闭的）外部函数的变量。由于 javascript 运行环境的实现，以下方式很可能造成内存泄露：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> theThing <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">var</span> replaceThing <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> originalThing <span class="token operator">=</span> theThing<span class="token punctuation">;</span>  <span class="token keyword">var</span> unused <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>originalThing<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// a reference to 'originalThing'</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"hi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  theThing <span class="token operator">=</span> <span class="token punctuation">{</span>    longStr<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'*'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    someMethod<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"message"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">setInterval</span><span class="token punctuation">(</span>replaceThing<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这段代码做了一件事：每次调用 <code>replaceThing</code> 时，<code>theThing</code> 指向了一个包含大数据和闭包（someMethod）的新对象，同时， <code>unused</code> 也指向一个引用了 <code>originalThing</code>（<code>theThing</code> 指向前一次 <code>replaceThing</code> 调用） 的闭包，已经有点混乱了，啊哈？重点是，<strong>一旦为一个具有相同父级作用域的闭包创建作用域，作用域是共享的</strong></p><p>这种情况下， 为闭包 <code>someMethod</code> 创建的作用域与 <code>unused</code> 共享。<code>unused</code> 有一个指向 <code>originalThing</code> 的引用。尽管 <code>unused</code> 从未被使用，但是 <code>someMethod</code> 可以通过 <code>theThing</code> 也就是 <code>replaceThing</code> 外围的作用域（例如：全局范围内）调用。与此同时 <code>someMethod</code> 与 <code>unused</code> 共享闭包作用域，<code>unused</code> 引用 <code>originalThing</code> 迫使它保持在内存中（在两个闭包共享的作用域范围）。这阻止了它被回收。</p><p>当这段代码反复地运行时，可以观察到内存使用率稳定地增长。GC 运行时也并未减少。本质上，一个闭包链被创建了（通过根作用域的 <code>theThing</code> 变量）。而每一个闭包作用域附带着引用了大数据，结果就是内存泄露。</p><p>这个问题被 Meteor 团队发现并发表了<a href="https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156" target="_blank" rel="noopener">著名的文章描述这个问题</a>。</p><h3 id="4-额外的-DOM-引用"><a href="#4-额外的-DOM-引用" class="headerlink" title="4. 额外的 DOM 引用"></a>4. 额外的 DOM 引用</h3><p>有时在数据结构中引用 DOM 节点很有用。假设你想迅速地更新一个表格中的几行内容。可能感觉在字典中或数据中引用 DOM row 是有意义的。在这种情况发生时，两个对相同 DOM 的引用被保持：一个在 DOM 树，另一个在字典中。如果将来某个时间点，你想删除这几行表格，你要确保这两个者失去引用。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> elements <span class="token operator">=</span> <span class="token punctuation">{</span>    button<span class="token punctuation">:</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    image<span class="token punctuation">:</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'image'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">doStuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    image<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'http://example.com/image_name.png'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">removeImage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// The image is a direct child of the body element.</span>    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'image'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// At this point, we still have a reference to #button in the</span>    <span class="token comment" spellcheck="true">//global elements object. In other words, the button element is</span>    <span class="token comment" spellcheck="true">//still in memory and cannot be collected by the GC.</span><span class="token punctuation">}</span></code></pre><p>这里还有额外的点需要注意，当涉及到 DOM 树或子节点的引用。比如说在 javascript 代码中引用了表格的某个格子（一个<code><td></code>标签）。某天你决定删除表格但还保持着单元格的引用。直观的假设就是 GC 会回收表格，但保留单元格。事实上，这是不可能的：单元格是表格的子节点，它保持着对父级表格的引用。javascript 代码保持单元格的引用导致 <strong>整个表格被保留在内存中</strong>。所以请谨慎考虑引用 DOM 元素。</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;如何处理4种常见的内存泄露&quot;&gt;&lt;a href=&quot;#如何处理4种常见的内存泄露&quot; class=&quot;headerlink&quot; title=&quot;如何处理4种常见的内存泄露&quot;&gt;&lt;/a&gt;如何处理4种常见的内存泄露&lt;/h1&gt;&lt;h2 id=&quot;什么是内存泄露&quot;&gt;&lt;a href=&quot;#什么是内存泄露&quot; class=&quot;headerlink&quot; title=&quot;什么是内存泄露&quot;&gt;&lt;/a&gt;什么是内存泄露&lt;/h2&gt;&lt;p&gt;本质上来说，内存泄露可以被定义为 &lt;strong&gt;当内存不再被应用使用，却因为某些原因没有被操作系统回收或释放到自由内存池&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*0B-dAUOH7NrcCDP6GhKHQw.jpeg&quot; alt=&quot;https://cdn-images-1.medium.com/max/1600/1*0B-dAUOH7NrcCDP6GhKHQw.jpeg&quot;&gt;&lt;/p&gt;
&lt;p&gt;编程语言支持多种不同的内存管理。某些内存是否在使用实际上是不可判定的。换句话说，只要开发者才清楚哪些内存块是可以被操作系统回收。&lt;/p&gt;
&lt;p&gt;某些编程语言提供一些特性帮助开发者进行内存回收。其他的期望开发者完全明白哪些内存是无用的。维基有一系列关于内存管理的好文章。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="memory leaks" scheme="http://robin-front.github.io/tags/memory-leaks/"/>
    
  </entry>
  
  <entry>
    <title>避免大型，复杂的布局和布局颠覆</title>
    <link href="http://robin-front.github.io/2017/08/30/avoid-large-complex-layouts-and-layout-thrashing.html"/>
    <id>http://robin-front.github.io/2017/08/30/avoid-large-complex-layouts-and-layout-thrashing.html</id>
    <published>2017-08-30T10:11:00.000Z</published>
    <updated>2017-08-30T10:11:00.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="避免大型，复杂的布局和布局颠覆"><a href="#避免大型，复杂的布局和布局颠覆" class="headerlink" title="避免大型，复杂的布局和布局颠覆"></a>避免大型，复杂的布局和布局颠覆</h1><p>布局是浏览器查找元素的几何信息：其大小和页面中的位置。每个元素将基于所使用的CSS，元素的内容或父元素显示或隐式的大小调整信息。该过程在 Chrome，Opera，Safari 和 Internet Explorer中称为“布局”。在 Firefox 中，它被称为 Reflow （回流），但是这个过程的作用是相同的。</p><p>类似于 style 计算，布局成本的直接相关是：</p><ul><li>需要布局的元素数量。</li><li>这些布局的复杂性。<a id="more"></a></li></ul><p>TL; DR</p><ul><li>布局通常作用于整个文档。</li><li>DOM 元素的数量将影响性能; 您应尽可能避免触发布局。</li><li>评估布局模型性能; 新的Flexbox通常比旧版Flexbox或基于浮动的布局模型更快。</li><li>避免强制同步布局和布局颠覆; 先读取样式值，然后再进行样式更改。</li></ul><h2 id="尽可能避免布局"><a href="#尽可能避免布局" class="headerlink" title="尽可能避免布局"></a>尽可能避免布局</h2><p>当您更改样式时，浏览器将检查以查看是否有任何更改需要计算布局，并为该渲染树进行更新。对“几何属性”的更改，如宽度，高度，左侧或顶部都需要布局。</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">20</span>px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">20</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 改变宽高 * 触发 layout. */</span><span class="token selector"><span class="token class">.box--expanded</span> </span><span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">350</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>布局几乎总是作用于整个文档</strong>。如果你有很多元素，那么需要很长时间来确定它们的位置和尺寸。</p><p>如果不可能避免布局，那么关键是再次使用 Chrome DevTools 来查看花费多长时间，并确定布局是否是瓶颈的原因。首先，打开 DevTools，转到“时间轴”选项卡，点击记录并与您的网站进行交互。当您停止录制时，您会看到您的网站执行的细目：</p><p><div class="progress-images" style="width:1202px"><div class="progress-images--placeholder" style="padding-bottom: 69.80033277870216%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="" class="progress-images--original" data-original="https://developers.google.com/web/fundamentals/performance/rendering/images/avoid-large-complex-layouts-and-layout-thrashing/big-layout.jpg" data-thumb="/images/thumb/619ac561ceef622993b071cefc8d19e1.jpg"></div></p><p>当在上面的例子中挖掘每一帧时，我们看到在布局中花费了超过20毫秒，当我们的屏幕在动画中有16ms时，这太高了。您还可以看到，DevTools 会告诉您 DOM 树的大小（在这种情况下为1,618个元素），以及需要多少个节点进行布局。</p><blockquote><p>注意：想要明确列出哪些 CSS 属性触发布局(layout)，绘画(paint)或复合(composite)？查看<a href="https://csstriggers.com/" target="_blank" rel="noopener">CSS触发器</a>。</p></blockquote><h2 id="在旧的布局模型上使用-flexbox"><a href="#在旧的布局模型上使用-flexbox" class="headerlink" title="在旧的布局模型上使用 flexbox"></a>在旧的布局模型上使用 flexbox</h2><p>网络上有一系列的布局模式，其中一些比其他模型更受广泛支持。最旧的 CSS 布局模型允许我们在屏幕上进行相对，绝对地定位元素和浮动元素。</p><p>下面的截图显示了在1,300个盒子上使用浮点数时的布局成本。诚然，这是一个例证，因为大多数应用程序将使用各种方法来定位元素。</p><p><div class="progress-images" style="width:1394px"><div class="progress-images--placeholder" style="padding-bottom: 68.00573888091822%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="" class="progress-images--original" data-original="https://developers.google.com/web/fundamentals/performance/rendering/images/avoid-large-complex-layouts-and-layout-thrashing/layout-float.jpg" data-thumb="/images/thumb/6862e2bf9999c25216d4c8dad8aa46e9.jpg"></div></p><p>如果我们更新样本以使用 Flexbox，这是Web平台上最近的一个补充，我们得到了一个不同的图片：</p><p><div class="progress-images" style="width:1394px"><div class="progress-images--placeholder" style="padding-bottom: 64.8493543758967%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="" class="progress-images--original" data-original="https://developers.google.com/web/fundamentals/performance/rendering/images/avoid-large-complex-layouts-and-layout-thrashing/layout-flex.jpg" data-thumb="/images/thumb/c4364bf86313b1b18dfcec2457b32029.jpg"></div></p><p>现在，在相同数量的元素和相同的视觉外观的布局中，我们花费更少的时间（在这种情况下，3.5ms对14ms）。重要的是要记住，对于某些浏览器环境，您可能无法选择 Flexbox，因为它比<a href="http://caniuse.com/#search=flexbox" target="_blank" rel="noopener">浮动布局更不受支持</a>，但您应该至少应该调查布局模型对您的性能的影响，并将其最小化执行成本</p><p>无论您是否选择Flexbox，您仍然应该 <strong>尝试避免</strong> 在应用程序的高压点 <strong>完全触发布局</strong>！</p><h2 id="避免强制同步布局"><a href="#避免强制同步布局" class="headerlink" title="避免强制同步布局"></a>避免强制同步布局</h2><p>运送一个框架到屏幕有这样的顺序：</p><p><div class="progress-images" style="width:1093px"><div class="progress-images--placeholder" style="padding-bottom: 15.279048490393413%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="" class="progress-images--original" data-original="https://developers.google.com/web/fundamentals/performance/rendering/images/avoid-large-complex-layouts-and-layout-thrashing/frame.jpg" data-thumb="/images/thumb/5201bbdcfdf03442dbe3c590bb8d9550.jpg"></div></p><p>首先 JavaScript 运行，然后进行风格计算，然后进行布局。然而，可以强制浏览器使用 JavaScript 更早地执行布局。它被称为 <strong>强制同步布局</strong>。</p><p>要记住的第一件事是，由于 JavaScript 运行，所有旧的布局值都是已知的，可供您查询。所以如果你想在下一帧之前写出一个元素的高度（我们称之为“box”），你可以编写一些这样的代码：</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// Schedule our function to run at the start of the frame.</span><span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span>logBoxHeight<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">logBoxHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Gets the height of the box in pixels and logs it out.</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>box<span class="token punctuation">.</span>offsetHeight<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>如果您在要求其高度之前更改了 box 的样式，那么事情会变得有问题：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">logBoxHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  box<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'super-big'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Gets the height of the box in pixels</span>  <span class="token comment" spellcheck="true">// and logs it out.</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>box<span class="token punctuation">.</span>offsetHeight<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>现在，为了回答高度问题，浏览器必须首先应用样式更改（因为添加了 <code>super-big</code> 类），然后运行布局。只有这样才能恢复正确的高度。这是不必要的和潜在的昂贵的工作。</p><p>因此，您应该始终批评这类的样式读取，并首先执行（浏览器可以使用上一帧的布局值），然后执行任何写操作：</p><p>完成上述功能将是：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">logBoxHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Gets the height of the box in pixels</span>  <span class="token comment" spellcheck="true">// and logs it out.</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>box<span class="token punctuation">.</span>offsetHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>  box<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'super-big'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在大多数情况下，您不应该需要应用样式，然后查询值; 使用最后一帧的值应该是足够的。过早地运行 style 计算和布局是浏览器同步和布局潜在的瓶颈，这不是您通常想要做的事情。</p><h2 id="避免布局颠覆"><a href="#避免布局颠覆" class="headerlink" title="避免布局颠覆"></a>避免布局颠覆</h2><p>有一种方法可以使强制同步布局更加糟糕：<em>快速连续地做很多事情</em>。看看这段代码：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">resizeAllParagraphsToMatchBlockWidth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Puts the browser into a read-write-read-write cycle.</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> paragraphs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    paragraphs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>width <span class="token operator">=</span> box<span class="token punctuation">.</span>offsetWidth <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>此代码循环遍历一组段落，并设置每个段落的宽度以匹配名为“box”的元素的宽度。它看起来很无害，但问题是循环的每次迭代读取一个样式值（<code>box.offsetWidth</code>），然后立即使用它来更新一个paragraph（<code>paragraphs[i].style.width</code>）的宽度。在循环的下一个迭代中，浏览器必须考虑到 <code>offsetWidth</code> 上一次请求（在上一次迭代中）样式已经改变的事实，因此它必须应用样式更改并运行布局。这将在每一次迭代中发生！</p><p>此示例的解决方法是缓存读取值，然后写值：</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// Read.</span><span class="token keyword">var</span> width <span class="token operator">=</span> box<span class="token punctuation">.</span>offsetWidth<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">resizeAllParagraphsToMatchBlockWidth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> paragraphs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Now write.</span>    paragraphs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>width <span class="token operator">=</span> width <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>如果您想保证安全性，您应该检查<a href="https://github.com/wilsonpage/fastdom" target="_blank" rel="noopener">FastDOM</a>，这将自动为您分配读取和写入数据，并且应防止您意外触发强制同步布局或布局颠覆。</p><p>【翻译原文】:<a href="https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing?hl=en" target="_blank" rel="noopener">Avoid Large, Complex Layouts and Layout Thrashing</a></p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;避免大型，复杂的布局和布局颠覆&quot;&gt;&lt;a href=&quot;#避免大型，复杂的布局和布局颠覆&quot; class=&quot;headerlink&quot; title=&quot;避免大型，复杂的布局和布局颠覆&quot;&gt;&lt;/a&gt;避免大型，复杂的布局和布局颠覆&lt;/h1&gt;&lt;p&gt;布局是浏览器查找元素的几何信息：其大小和页面中的位置。每个元素将基于所使用的CSS，元素的内容或父元素显示或隐式的大小调整信息。该过程在 Chrome，Opera，Safari 和 Internet Explorer中称为“布局”。在 Firefox 中，它被称为 Reflow （回流），但是这个过程的作用是相同的。&lt;/p&gt;
&lt;p&gt;类似于 style 计算，布局成本的直接相关是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要布局的元素数量。&lt;/li&gt;
&lt;li&gt;这些布局的复杂性。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="layout" scheme="http://robin-front.github.io/tags/layout/"/>
    
      <category term="css" scheme="http://robin-front.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>使用 requestIdleCallback</title>
    <link href="http://robin-front.github.io/2017/08/25/using-requestIdleCallback.html"/>
    <id>http://robin-front.github.io/2017/08/25/using-requestIdleCallback.html</id>
    <published>2017-08-25T15:40:26.000Z</published>
    <updated>2017-08-25T15:40:26.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="使用-requestIdleCallback"><a href="#使用-requestIdleCallback" class="headerlink" title="使用 requestIdleCallback"></a>使用 requestIdleCallback</h1><p>许多网站和应用程序都有很多脚本来执行。您的 JavaScript 通常需要尽快运行，但同时您不希望它阻碍用户那条路。如果您在用户滚动页面时发送分析数据，或者在轻触按钮时将元素附加到 DOM，则您的 Web 应用程序将无法响应，从而导致用户体验不佳。</p><p><div class="progress-images" style="width:2850px"><div class="progress-images--placeholder" style="padding-bottom: 51.01754385964912%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://developers.google.com/web/updates/images/2015-08-27-using-requestidlecallback/main.png" class="progress-images--original" data-original="https://developers.google.com/web/updates/images/2015-08-27-using-requestidlecallback/main.png" data-thumb="/images/thumb/9009bca11399f2a3cafdffa8e974b9f8.png"></div></p><p>好消息是，现在有一个 API 可以帮助：<code>requestIdleCallback</code>。以同样的方式，<code>requestAnimationFrame</code> 我们可以正确地安排动画，并最大限度地提高 60fps 的机会，<code>requestIdleCallback</code> 当一个框架结束时，或当用户处于非活动状态时，可以安排工作。这意味着有机会在用户不使用的情况下进行工作。它可用于 Chrome 47！这是一个实验性的功能，规格还在不断变化，所以将来会发生变化。<a id="more"></a></p><h2 id="检查-requestIdleCallback-支持"><a href="#检查-requestIdleCallback-支持" class="headerlink" title="检查 requestIdleCallback 支持"></a>检查 requestIdleCallback 支持</h2><p>这是早期的 <code>requestIdleCallback</code>，所以在使用它之前，您应该检查它是否可用：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'requestIdleCallback'</span> <span class="token keyword">in</span> window<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Use requestIdleCallback to schedule work.</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Do what you’d do today.</span><span class="token punctuation">}</span></code></pre><p>你也可以 polyfill 它的行为，这需要回到 <code>setTimeout</code>：</p><pre class=" language-js"><code class="language-js">window<span class="token punctuation">.</span>requestIdleCallback <span class="token operator">=</span> window<span class="token punctuation">.</span>requestIdleCallback <span class="token operator">||</span>  <span class="token keyword">function</span> <span class="token punctuation">(</span>cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> start <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        didTimeout<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        timeRemaining<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">50</span> <span class="token operator">-</span> <span class="token punctuation">(</span>Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>window<span class="token punctuation">.</span>cancelIdleCallback <span class="token operator">=</span> window<span class="token punctuation">.</span>cancelIdleCallback <span class="token operator">||</span>  <span class="token keyword">function</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">clearTimeout</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><p>使用 <code>setTimeout</code> 不是很好，因为它不知道 <code>requestIdleCallback</code> 的空闲时间是如何工作的，但是如果 <code>requestIdleCallback</code> 不可用的话，你可以直接调用你的回调，你没有比这更差的方式。有了垫片，<code>requestIdleCallback</code> 就可以使用，你将被默认重定向到直接调用，这是很棒的。</p><p>现在，我们假设它存在。</p><h2 id="使用requestIdleCallback"><a href="#使用requestIdleCallback" class="headerlink" title="使用requestIdleCallback"></a>使用requestIdleCallback</h2><p>调用 <code>requestIdleCallback</code> 非常类似于 <code>requestAnimationFrame</code>, 它需要回调函数作为其第一个参数：</p><pre class=" language-js"><code class="language-js"><span class="token function">requestIdleCallback</span><span class="token punctuation">(</span>myNonEssentialWork<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>当 <code>myNonEssentialWork</code> 被调用时，它将被赋予一个 <code>deadline</code>, 它是一个包含函数的对象，该函数返回一个数字，指示您的工作剩余多少时间：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> myNonEssentialWork <span class="token punctuation">(</span>deadline<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>deadline<span class="token punctuation">.</span><span class="token function">timeRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token function">doWorkIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>timeRemaining</code> 可以调用该函数来获取最新值。当 <code>timeRemaining()</code> 返回零时，您可以安排另一个 <code>requestIdleCallback</code>, 如果您还有更多的工作要做：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> myNonEssentialWork <span class="token punctuation">(</span>deadline<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>deadline<span class="token punctuation">.</span><span class="token function">timeRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> tasks<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token function">doWorkIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>tasks<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token function">requestIdleCallback</span><span class="token punctuation">(</span>myNonEssentialWork<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="调用你的任务"><a href="#调用你的任务" class="headerlink" title="调用你的任务"></a>调用你的任务</h2><p>如果浏览器真的很忙，你该怎么办？您可能会担心您的回调可能永远不会被调用。嗯，虽然 <code>requestIdleCallback</code> 类似 <code>requestAnimationFrame</code>，但它也有所不同，它需要一个可选的第二个参数：具有 <code>timeout</code> 属性的 <code>options</code> 对象。此超时（如果设置）为浏览器提供了必须执行回调的时间（以毫秒为单位）：</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// Wait at most two seconds before processing events.</span><span class="token function">requestIdleCallback</span><span class="token punctuation">(</span>processPendingAnalyticsEvents<span class="token punctuation">,</span> <span class="token punctuation">{</span> timeout<span class="token punctuation">:</span> <span class="token number">2000</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果您的回调由于超时触发而执行，您会注意到两件事情：</p><ul><li><code>timeRemaining()</code> 将返回零。</li><li>对象的 <code>didTimeout</code> 属性 <code>deadline</code> 将为 <code>true</code>。</li></ul><p>如果你看到这 <code>didTimeout</code> 是真的，你很可能只想运行这个工作并完成它：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> myNonEssentialWork <span class="token punctuation">(</span>deadline<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Use any remaining time, or, if timed out, just run through the tasks.</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>deadline<span class="token punctuation">.</span><span class="token function">timeRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">||</span> deadline<span class="token punctuation">.</span>didTimeout<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>         tasks<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token function">doWorkIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>tasks<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token function">requestIdleCallback</span><span class="token punctuation">(</span>myNonEssentialWork<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>由于潜在的中断，这种超时可能会导致您的用户（工作可能会导致您的应用程序变得无响应或janky）设置此参数时要谨慎。在哪里可以让浏览器决定何时调用回调。</p><h2 id="使用-requestIdleCallback-发送分析数据"><a href="#使用-requestIdleCallback-发送分析数据" class="headerlink" title="使用 requestIdleCallback 发送分析数据"></a>使用 requestIdleCallback 发送分析数据</h2><p>让我们来看看 <code>requestIdleCallback</code> 发送分析数据。在这种情况下，我们可能会想跟踪一个事件，比如说 - 点击导航菜单。不过，由于通常在萤幕上设定动画，我们希望避免立即将此事件发送到 Google Analytics（分析）。我们将创建一系列事件来发送和请求在将来的某个时间发送它们：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> eventsToSend <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">function</span> onNavOpenClick <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Animate the menu.</span>  menu<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'open'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Store the event for later.</span>  eventsToSend<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>    <span class="token punctuation">{</span>      category<span class="token punctuation">:</span> <span class="token string">'button'</span><span class="token punctuation">,</span>      action<span class="token punctuation">:</span> <span class="token string">'click'</span><span class="token punctuation">,</span>      label<span class="token punctuation">:</span> <span class="token string">'nav'</span><span class="token punctuation">,</span>      value<span class="token punctuation">:</span> <span class="token string">'open'</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">schedulePendingEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>现在我们需要使用 <code>requestIdleCallback</code> 来处理任何待处理的事件：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">schedulePendingEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Only schedule the rIC if one has not already been set.</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>isRequestIdleCallbackScheduled<span class="token punctuation">)</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  isRequestIdleCallbackScheduled <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'requestIdleCallback'</span> <span class="token keyword">in</span> window<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Wait at most two seconds before processing events.</span>    <span class="token function">requestIdleCallback</span><span class="token punctuation">(</span>processPendingAnalyticsEvents<span class="token punctuation">,</span> <span class="token punctuation">{</span> timeout<span class="token punctuation">:</span> <span class="token number">2000</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token function">processPendingAnalyticsEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在这里，您可以看到我设置了2秒的超时时间，但这个值取决于你的应用程序。对于分析数据，有意义的是，将使用超时时间来确保数据在合理的时间内报告，而不仅仅是在将来的某个时间点。</p><p>最后我们需要编写 <code>requestIdleCallback</code> 将执行的函数。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> processPendingAnalyticsEvents <span class="token punctuation">(</span>deadline<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Reset the boolean so future rICs can be set.</span>  isRequestIdleCallbackScheduled <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// If there is no deadline, just run as long as necessary.</span>  <span class="token comment" spellcheck="true">// This will be the case if requestIdleCallback doesn’t exist.</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> deadline <span class="token operator">===</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span>    deadline <span class="token operator">=</span> <span class="token punctuation">{</span> timeRemaining<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> Number<span class="token punctuation">.</span>MAX_VALUE <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Go for as long as there is time remaining and work to do.</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>deadline<span class="token punctuation">.</span><span class="token function">timeRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> eventsToSend<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> evt <span class="token operator">=</span> eventsToSend<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ga</span><span class="token punctuation">(</span><span class="token string">'send'</span><span class="token punctuation">,</span> <span class="token string">'event'</span><span class="token punctuation">,</span>        evt<span class="token punctuation">.</span>category<span class="token punctuation">,</span>        evt<span class="token punctuation">.</span>action<span class="token punctuation">,</span>        evt<span class="token punctuation">.</span>label<span class="token punctuation">,</span>        evt<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Check if there are more events still to send.</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>eventsToSend<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token function">schedulePendingEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>对于这个例子，我假设如果 <code>requestIdleCallback</code> 不存在分析数据应该立即发送。然而，在生产应用程序中，延迟发送超时可能会更好，以确保它不会与任何交互冲突，并导致 jank。</p><h2 id="使用-requestIdleCallback-进行-DOM-更改"><a href="#使用-requestIdleCallback-进行-DOM-更改" class="headerlink" title="使用 requestIdleCallback 进行 DOM 更改"></a>使用 <code>requestIdleCallback</code> 进行 DOM 更改</h2><p>另一种 <code>requestIdleCallback</code> 真正有助于表现的情况是当您进行非必要的 DOM 更改时，例如将项目添加到不断增长的惰性列表的末尾。我们来看一下如何将 requestIdleCallback 实际应用在一个典型的框架。</p><p><div class="progress-images" style="width:717px"><div class="progress-images--placeholder" style="padding-bottom: 43.23570432357043%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://developers.google.com/web/updates/images/2015-08-27-using-requestidlecallback/frame.jpg" class="progress-images--original" data-original="https://developers.google.com/web/updates/images/2015-08-27-using-requestidlecallback/frame.jpg" data-thumb="/images/thumb/01aabf6a7a49da7b4f5d3a0384d364ac.jpg"></div></p><p>浏览器可能太忙，无法在给定的框架中运行任何回调，所以您不应该期望在框架结尾处有任何空闲时间来执行任何更多的工作。这使得它不同于 <code>setImmediate</code> 这类每帧都运行的东西。</p><p>如果回调在框架结束时被触发，它将被调度到当前帧已经提交之后，这意味着将应用样式更改，并且重要的是布局计算。如果我们在空闲回调内部进行 DOM 更改，这些布局计算将无效。如果有任何读取下一帧布局的事件，例如 <code>getBoundingClientRect</code>，<code>clientWidth</code>等等，浏览器将不得不进行<a href="https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing#avoid-forced-synchronous-layouts" target="_blank" rel="noopener">强制同步布局</a>，这是一个潜在的性能瓶颈。</p><p>不要在空闲回调中 DOM 更改的另一个原因是更改 DOM 的时间影响是不可预测的，因此我们可以很容易地超过浏览器提供的期限。</p><p>最好的做法是只能在 <code>requestAnimationFrame</code> 回调内部进行 DOM 更改，因为它是由浏览器安排的那种类型的工作。这意味着我们的代码将需要使用一个文档片段，然后可以将其附加在下一个 <code>requestAnimationFrame</code> 回调中。如果您正在使用 VDOM 库，则可以使用 <code>requestIdleCallback</code> 进行更改，但是您可以在下一个回调中应用 DOM 修补程序 <code>requestAnimationFrame</code>，而不是空闲回调。</p><p>所以考虑到这一点，让我们来看看代码：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> processPendingElements <span class="token punctuation">(</span>deadline<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// If there is no deadline, just run as long as necessary.</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> deadline <span class="token operator">===</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span>    deadline <span class="token operator">=</span> <span class="token punctuation">{</span> timeRemaining<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> Number<span class="token punctuation">.</span>MAX_VALUE <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>documentFragment<span class="token punctuation">)</span>    documentFragment <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createDocumentFragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Go for as long as there is time remaining and work to do.</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>deadline<span class="token punctuation">.</span><span class="token function">timeRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> elementsToAdd<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Create the element.</span>    <span class="token keyword">var</span> elToAdd <span class="token operator">=</span> elementsToAdd<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>elToAdd<span class="token punctuation">.</span>tag<span class="token punctuation">)</span><span class="token punctuation">;</span>    el<span class="token punctuation">.</span>textContent <span class="token operator">=</span> elToAdd<span class="token punctuation">.</span>content<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Add it to the fragment.</span>    documentFragment<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Don't append to the document immediately, wait for the next</span>    <span class="token comment" spellcheck="true">// requestAnimationFrame callback.</span>    <span class="token function">scheduleVisualUpdateIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Check if there are more events still to send.</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>elementsToAdd<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token function">scheduleElementCreation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在这里我创建元素并使用该 <code>textContent</code> 属性来填充它，但是您的元素创建代码可能会更多的操作！在创建元素后 <code>scheduleVisualUpdateIfNeeded</code>，调用该元素将会建立一个单独的 <code>requestAnimationFrame</code> 回调，然后依次将文档片段附加到正文中：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">scheduleVisualUpdateIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>isVisualUpdateScheduled<span class="token punctuation">)</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  isVisualUpdateScheduled <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span>appendDocumentFragment<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">appendDocumentFragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Append the fragment and reset.</span>  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>documentFragment<span class="token punctuation">)</span><span class="token punctuation">;</span>  documentFragment <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>一切顺利，我们现在将把项目附加到 DOM 时看起来更少 jank。优秀！</p><h2 id="常问问题"><a href="#常问问题" class="headerlink" title="常问问题"></a>常问问题</h2><ul><li>是否有 polyfill？ 可悲的是，没有。如果你想要透明的重定向到 <code>setTimeout</code>，那就有一个 <code>shim</code> 。该API存在的原因是因为它在Web平台中插入了非常真实的差距。但是没有JavaScript API来确定框架结束时的空闲时间，所以最多只能做出猜测。像 <code>setTimeout</code>，<code>setInterval</code> 或者 <code>setImmediate</code> 这样的 API 可以用于调度工作，但是并不是按照 <code>requestIdleCallback</code> 这样的方式避开用户交互。</li><li>如果我设置 <code>timeout</code>，会发生什么？ 如果 <code>timeRemaining()</code> 返回零，但是您选择运行更长时间，您可以这样做，而不用担心浏览器停止工作。但是，浏览器为您提供了最终期限，以确保您的用户顺利体验，因此除非有非常好的理由，否则您应始终遵守最终期限。</li><li><code>timeRemaining()</code> 会返回有最大值吗？ 是的，现在是 <code>50ms</code> 。在尝试维护响应式应用程序时，所有对用户交互的响应应保持在 100ms 以下。如果用户在 50ms 窗口中进行交互，在大多数情况下应允许空闲回调完成，并且浏览器可以响应用户的交互。您可能会得到多个空闲的回调（如果浏览器确定有足够的时间来运行它们），那么它们将被一个个安排。</li><li>有没有什么工作我不应该在 <code>requestIdleCallback</code> 里执行？ 理想情况下，您所做的工作应该是具有相对可预测特征的小块（微任务）。例如，特别是更改 DOM 将具有不可预测的执行时间，因为它将触发样式计算，布局，绘画和合成。因此，您应该仅在上述 requestAnimationFrame 回调中进行 DOM 更改。要注意的另一件事是解决（或拒绝）Promises，因为在空闲回调完成后回调将立即执行，即使没有更多的时间剩余。</li><li>我会总是在一帧结束时被执行 <code>requestIdleCallback</code> ？不，不总是。浏览器将在帧结束时的空闲时间或用户处于非活动状态的时段内调度回调。您不应该期望每帧调用回调，并且如果要求它在给定的时间范围内运行，则应该使用超时。</li><li>我可以有多个 <code>requestIdleCallback</code> 回调吗？ 是的，你可以拥有非常多个 <code>requestAnimationFrame</code> 回调。值得记住的是，如果你的第一个回调使用了它在回调期间的剩余时间，那么任何其他回调都不会有更多的时间。然后，其他回调将不得不等待浏览器下一个空闲，才能运行。根据您要完成的工作，可能会有一个空闲的回调，并将工作分配到那里。或者，您可以使用超时时间来确保回调都有机会执行。</li><li>如果我在另一个内部设置一个新的空闲回调，会发生什么？ 新的空闲回调将被安排尽快运行，从下一个帧开始（而不是当前的）。</li></ul><h2 id="利用空闲"><a href="#利用空闲" class="headerlink" title="利用空闲"></a>利用空闲</h2><p><code>requestIdleCallback</code> 是一个非常棒的方法，以确保您可以运行您的代码，但没有阻碍用户的交互。使用起来很简单，非常灵活。但仍然属于早期，而且规范还没有完全解决，所以你所提供的任何反馈都是值得欢迎的。</p><p>【翻译原文】:<a href="https://developers.google.com/web/updates/2015/08/using-requestidlecallback" target="_blank" rel="noopener">useing requestIdleCallback</a></p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用-requestIdleCallback&quot;&gt;&lt;a href=&quot;#使用-requestIdleCallback&quot; class=&quot;headerlink&quot; title=&quot;使用 requestIdleCallback&quot;&gt;&lt;/a&gt;使用 requestIdleCallback&lt;/h1&gt;&lt;p&gt;许多网站和应用程序都有很多脚本来执行。您的 JavaScript 通常需要尽快运行，但同时您不希望它阻碍用户那条路。如果您在用户滚动页面时发送分析数据，或者在轻触按钮时将元素附加到 DOM，则您的 Web 应用程序将无法响应，从而导致用户体验不佳。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://developers.google.com/web/updates/images/2015-08-27-using-requestidlecallback/main.png&quot; alt=&quot;https://developers.google.com/web/updates/images/2015-08-27-using-requestidlecallback/main.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;好消息是，现在有一个 API 可以帮助：&lt;code&gt;requestIdleCallback&lt;/code&gt;。以同样的方式，&lt;code&gt;requestAnimationFrame&lt;/code&gt; 我们可以正确地安排动画，并最大限度地提高 60fps 的机会，&lt;code&gt;requestIdleCallback&lt;/code&gt; 当一个框架结束时，或当用户处于非活动状态时，可以安排工作。这意味着有机会在用户不使用的情况下进行工作。它可用于 Chrome 47！这是一个实验性的功能，规格还在不断变化，所以将来会发生变化。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="performance" scheme="http://robin-front.github.io/tags/performance/"/>
    
      <category term="optimization" scheme="http://robin-front.github.io/tags/optimization/"/>
    
      <category term="requestIdleCallback" scheme="http://robin-front.github.io/tags/requestIdleCallback/"/>
    
  </entry>
  
  <entry>
    <title>IntersectionObserver API</title>
    <link href="http://robin-front.github.io/2017/08/24/intersectionobserver.html"/>
    <id>http://robin-front.github.io/2017/08/24/intersectionobserver.html</id>
    <published>2017-08-24T09:59:34.000Z</published>
    <updated>2017-08-24T09:59:34.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="IntersectionObserver"><a href="#IntersectionObserver" class="headerlink" title="IntersectionObserver"></a>IntersectionObserver</h1><p>假设你想追踪 DOM 里的一个元素是否进入 <a href="https://en.wikipedia.org/wiki/Viewport" target="_blank" rel="noopener">viewport</a> 的可视区。你做这件事可能是因为你想在这个时机 lazyload 图片或者你需要知道用户是否真的在看一个某个广告横幅。你可以通过添加 <code>scroll</code> 事件钩子或使用定时器去调用元素的 <code>getBoundingClientRect()</code> 方法。然而，这种方法真的很慢，因为每次调用 <code>getBoundingClientRect()</code> <a href="https://gist.github.com/paulirish/5d52fb081b3570c81e3a" target="_blank" rel="noopener">会造成浏览器 re-layout 当前页面</a> 并会在你的页面造成很大的卡顿和闪烁。 <code>iframe</code> 里的元素是否可见这样的事情几乎很难做到。 基于单一源模型，浏览器不会让你访问包含 <code>iframe</code> 的页面的任何数据。这是频繁使用 <code>iframe</code> 加载广告的常见问题。</p><p>为了让可见度测试更有效率， <a href="https://wicg.github.io/IntersectionObserver/" target="_blank" rel="noopener">IntersectionObserver</a> 被设计出来了。<code>IntersectionObserver</code> 让你知道观察的元素何时进入或退出浏览器 <code>viewport</code>。<a id="more"></a></p><p><div class="progress-images" style="width:320px"><div class="progress-images--placeholder" style="padding-bottom: 202.8125%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://developers.google.com/web/updates/images/2016/04/intersectionobserver/iframe.gif" class="progress-images--original" data-original="https://developers.google.com/web/updates/images/2016/04/intersectionobserver/iframe.gif" data-thumb="/images/thumb/6551e1db99f0503ca8d04871ccf802d8.gif"></div></p><h2 id="如何创建一个-IntersectionObserver"><a href="#如何创建一个-IntersectionObserver" class="headerlink" title="如何创建一个 IntersectionObserver"></a>如何创建一个 IntersectionObserver</h2><p>API 相当简单，例子一看就懂：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> io <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span>    entries <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>entries<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 使用默认选项，详细在下面会介绍 */</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 开始观察一个元素</span>io<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 停止观察一个元素</span><span class="token comment" spellcheck="true">// io.unobserve(element);</span><span class="token comment" spellcheck="true">// 禁用整个 IntersectionObserver</span><span class="token comment" spellcheck="true">// io.disconnect();</span></code></pre><p>使用默认选项，回调会在元素进入和完全退出 <code>viewport</code> 的时候触发。</p><p>如果你需要观察多个元素，建议在同一个 <code>IntersectionObserver</code> 实例上多次调用 <code>observe()</code> 来观察多个元素，这也是允许的调用方式。</p><p>回调函数回传的参数是一个数组对象 <a href="https://wicg.github.io/IntersectionObserver/#intersection-observer-entry" target="_blank" rel="noopener"><code>IntersectionObserverEntry</code></a> 。每个这样的对象都包含了每个观察元素的最新数据。</p><pre class=" language-ruby"><code class="language-ruby">🔽<span class="token punctuation">[</span><span class="token constant">IntersectionObserverEntry</span><span class="token punctuation">]</span>  🔽 <span class="token number">0</span><span class="token punctuation">:</span> <span class="token constant">IntersectionObserverEntry</span>       time<span class="token punctuation">:</span> <span class="token number">3893.92</span>    🔽 rootBounds<span class="token punctuation">:</span> <span class="token constant">ClientRect</span>        bottom<span class="token punctuation">:</span> <span class="token number">920</span>        height<span class="token punctuation">:</span> <span class="token number">1024</span>        left<span class="token punctuation">:</span> <span class="token number">0</span>        right<span class="token punctuation">:</span> <span class="token number">1024</span>        top<span class="token punctuation">:</span> <span class="token number">0</span>        width<span class="token punctuation">:</span> <span class="token number">920</span>    🔽 boundingClientRect<span class="token punctuation">:</span> <span class="token constant">ClientRect</span>       <span class="token operator">/</span><span class="token operator">/</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    🔽 intersectionRect<span class="token punctuation">:</span> <span class="token constant">ClientRect</span>       <span class="token operator">/</span><span class="token operator">/</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>      intersectionRatio<span class="token punctuation">:</span> <span class="token number">0.54</span>    🔽 target<span class="token punctuation">:</span> div<span class="token comment" spellcheck="true">#observee</span>       <span class="token operator">/</span><span class="token operator">/</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><ul><li><a href="https://wicg.github.io/IntersectionObserver/#dom-intersectionobserverentry-rootbounds" target="_blank" rel="noopener"><code>rootBounds</code></a> 是对 root 元素调用 <code>getBoundingClientRect</code> 的结果，默认 root 元素是 viewport 。</li><li><a href="https://wicg.github.io/IntersectionObserver/#dom-intersectionobserverentry-boundingclientrect" target="_blank" rel="noopener"><code>boundingClientRect</code></a> 是被观察元素调用 <code>getBoundingClientRect</code> 的结果。</li><li><a href="https://wicg.github.io/IntersectionObserver/#dom-intersectionobserverentry-intersectionrect" target="_blank" rel="noopener"><code>intersectionRect</code></a> 是两个矩形的交叉部分，可能有效地告诉你被观察的元素的哪一部分是可见的。</li><li><a href="https://wicg.github.io/IntersectionObserver/#dom-intersectionobserverentry-intersectionratio" target="_blank" rel="noopener"><code>intersectionRatio</code></a> 是最相关的，告诉你元素有百分之几是可见的。</li></ul><p>有了这些信息，你现在可以实现元素进入 viewport 前及时加载的特性。非常有用。</p><p><div class="progress-images" style="width:886px"><div class="progress-images--placeholder" style="padding-bottom: 98.87133182844244%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://developers.google.com/web/updates/images/2016/04/intersectionobserver/intersectratio.png" class="progress-images--original" data-original="https://developers.google.com/web/updates/images/2016/04/intersectionobserver/intersectratio.png" data-thumb="/images/thumb/fb2b57edb4e60431c87acec39acc29fc.png"></div></p><p><code>IntersectionObservers</code> 是异步推送他们的数据，而回调是运行在主线程的。另外，规范提到 <code>IntersectionObserver</code> 应该使用 <a href="https://wicg.github.io/IntersectionObserver/#queue-intersection-observer-task" target="_blank" rel="noopener"><code>requestIdleCallback()</code></a>。 这意味着调用回调函数的优先级是非常低的，只会在浏览器有空闲的时候调用。这是有意设计的。</p><h2 id="Scrolling-divs"><a href="#Scrolling-divs" class="headerlink" title="Scrolling divs"></a>Scrolling divs</h2><p>我并不喜欢在 div 中滚动元素, 但我不会用 <code>scroll</code> 判定, 而是用 <code>IntersectionObserver</code>。 <a href="https://wicg.github.io/IntersectionObserver/#dictdef-intersectionobserverinit" target="_blank" rel="noopener"><code>option</code></a> 对象有一个 <a href="https://wicg.github.io/IntersectionObserver/#dom-intersectionobserverinit-root" target="_blank" rel="noopener"><code>root</code></a> 选项让你定义一个代替 viewport 的 root 元素。需要记住的是，要保证 root 元素是所有被观察元素的祖先。</p><h2 id="重叠所有元素"><a href="#重叠所有元素" class="headerlink" title="重叠所有元素"></a>重叠所有元素</h2><p>不！那是糟糕的开发者！请注意使用用户的 CPU 周期。让我们考虑一下无限滚动的例子： 在脚本中，添加一个哨兵来观察和回收是明智的选择。你应该在无限滚动的最后一个元素添加哨兵。当哨兵快要进入 viewport 的时候，在回调函数中加载数据，创建接下来的元素，并添加到哨兵之前的 DOM 结构中。如果重复利用哨兵，不需要再调用 <code>observe()</code>， <code>IntersectionObserver</code> 仍然会继续工作。</p><p><img src="https://developers.google.com/web/updates/images/2016/04/intersectionobserver/infinitescroller.png" alt="https://developers.google.com/web/updates/images/2016/04/intersectionobserver/infinitescroller.png"></p><h3 id="更多地更新与回调调用"><a href="#更多地更新与回调调用" class="headerlink" title="更多地更新与回调调用"></a>更多地更新与回调调用</h3><p>就像前面提到的，当被监听元素进入或离开 viewport 的时候，回调函数会分别单次触发。 这让<code>IntersectionObserver</code> 可以给你这个问题的答案，“元素 X 是否在视图中？”。但在某些场景中，这还不够。</p><p><a href="https://wicg.github.io/IntersectionObserver/#dom-intersectionobserverinit-threshold" target="_blank" rel="noopener"><code>theshold</code></a> 选项登场。它允许你定义一个 <a href="https://wicg.github.io/IntersectionObserver/#dom-intersectionobserverentry-intersectionratio" target="_blank" rel="noopener"><code>intersectionRatio</code></a> 阈值数组。当达到每一个 <code>intersectionRatio</code> 值时，回调函数都会被调用。<code>theshold</code> 默认值是 <code>[0]</code>，就是我们解释的默认表现。当设定 <code>theshold</code> 为 <code>[0, 0.25, 0.5, 0.75, 1]</code>, 我们会在元素每四分之一的部分进入 viewport 时得到通知。</p><p><div class="progress-images" style="width:320px"><div class="progress-images--placeholder" style="padding-bottom: 202.8125%;"></div><img src="/js/lazyload-plugin/loading.svg" alt="https://developers.google.com/web/updates/images/2016/04/intersectionobserver/threshold.gif" class="progress-images--original" data-original="https://developers.google.com/web/updates/images/2016/04/intersectionobserver/threshold.gif" data-thumb="/images/thumb/e487b37fcc28012db95042b162af5a72.gif"></div></p><h3 id="还有其他问题吗？"><a href="#还有其他问题吗？" class="headerlink" title="还有其他问题吗？"></a>还有其他问题吗？</h3><p>到现在为止，还有一个选项没有被提到。<a href="https://wicg.github.io/IntersectionObserver/#dom-intersectionobserverinit-rootmargin" target="_blank" rel="noopener"><code>rootMargin</code></a> 允许你指定 <code>root</code> 元素的 <code>margin</code>，有效地允许你增加或缩减实际的交叉区域。<code>margin</code> 使用 css-style 的规则， <code>10px 20px 30px 40px</code> 分别表示上、右、下、左。总的来说，<code>IntersectionObserver</code> 的选项总结如下：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span>entries <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">/* … */</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// The root to use for intersection.</span>  <span class="token comment" spellcheck="true">// If not provided, use the top-level document’s viewport.</span>  root<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// Same as margin, can be 1, 2, 3 or 4 components, possibly negative lengths.  </span>  <span class="token comment" spellcheck="true">// If an explicit root element is specified, components may be percentages of the</span>  <span class="token comment" spellcheck="true">// root element size.  If no explicit root element is specified, using a percentage</span>  <span class="token comment" spellcheck="true">// is an error.</span>  rootMargin<span class="token punctuation">:</span> <span class="token string">"0px"</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// Threshold(s) at which to trigger callback, specified as a ratio, or list of</span>  <span class="token comment" spellcheck="true">// ratios, of (visible area / total area) of the observed element (hence all</span>  <span class="token comment" spellcheck="true">// entries must be in the range [0, 1]).  Callback will be invoked when the visible</span>  <span class="token comment" spellcheck="true">// ratio of the observed element crosses a threshold in the list.</span>  threshold<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="iframe-魔法"><a href="#iframe-魔法" class="headerlink" title="iframe 魔法"></a>iframe 魔法</h3><p><code>IntersectionObserver</code> 被设计时明确考虑广告服务和网络社交服务，可能经常会用到 <code>iframe</code> 和有益于知道他们是否在看。如果观察 <code>iframe</code> 中的元素，那么滚动 <code>iframe</code> 和滚动父页面都可以在适当的时候触发回调函数。对于后者， <code>rootBounds</code> 将被设置为 <code>null</code> 以避免数据源泄漏。</p><h2 id="IntersectionObserver-不是什么？"><a href="#IntersectionObserver-不是什么？" class="headerlink" title="IntersectionObserver 不是什么？"></a><code>IntersectionObserver</code> 不是什么？</h2><p>需要知道的是， <code>IntersectionObserver</code> 是被故意设置成不完美和低延迟的。使用它们努力实现像滚动动画之类是注定会失败的。因为严格地说，当你获得数据时，数据已经过时了。这里有更多的关于 <code>IntersectionObserver</code> <a href="https://github.com/WICG/IntersectionObserver/blob/gh-pages/explainer.md" target="_blank" rel="noopener">原始用例</a>。</p><h2 id="可以在-callback-中做多少事情"><a href="#可以在-callback-中做多少事情" class="headerlink" title="可以在 callback 中做多少事情"></a>可以在 <code>callback</code> 中做多少事情</h2><p>在回调中花太多时候会让你的应用滞后，和常见的实践一样。</p><h2 id="使用-IntersectionObserver"><a href="#使用-IntersectionObserver" class="headerlink" title="使用 IntersectionObserver"></a>使用 IntersectionObserver</h2><p>对于 <code>IntersectionObserver</code>，浏览器的支持仍然很弱，所以它不会马上被普遍应用。同时，<a href="https://github.com/WICG/IntersectionObserver" target="_blank" rel="noopener">WICG</a> 的 polyfill 也被建立起来。显然，使用 polyfill 不如原生实现的效率好。</p><blockquote><p>Except as otherwise noted, the content of this page is licensed under the Creative Commons Attribution 3.0 License, and code samples are licensed under the Apache 2.0 License. For details, see our Site Policies. Java is a registered trademark of Oracle and/or its affiliates.上次更新日期：六月 5, 2017</p></blockquote><p>【翻译原文】： <a href="https://developers.google.com/web/updates/2016/04/intersectionobserver" target="_blank" rel="noopener">intersectionobserver</a></p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IntersectionObserver&quot;&gt;&lt;a href=&quot;#IntersectionObserver&quot; class=&quot;headerlink&quot; title=&quot;IntersectionObserver&quot;&gt;&lt;/a&gt;IntersectionObserver&lt;/h1&gt;&lt;p&gt;假设你想追踪 DOM 里的一个元素是否进入 &lt;a href=&quot;https://en.wikipedia.org/wiki/Viewport&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;viewport&lt;/a&gt; 的可视区。你做这件事可能是因为你想在这个时机 lazyload 图片或者你需要知道用户是否真的在看一个某个广告横幅。你可以通过添加 &lt;code&gt;scroll&lt;/code&gt; 事件钩子或使用定时器去调用元素的 &lt;code&gt;getBoundingClientRect()&lt;/code&gt; 方法。然而，这种方法真的很慢，因为每次调用 &lt;code&gt;getBoundingClientRect()&lt;/code&gt; &lt;a href=&quot;https://gist.github.com/paulirish/5d52fb081b3570c81e3a&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;会造成浏览器 re-layout 当前页面&lt;/a&gt; 并会在你的页面造成很大的卡顿和闪烁。 &lt;code&gt;iframe&lt;/code&gt; 里的元素是否可见这样的事情几乎很难做到。 基于单一源模型，浏览器不会让你访问包含 &lt;code&gt;iframe&lt;/code&gt; 的页面的任何数据。这是频繁使用 &lt;code&gt;iframe&lt;/code&gt; 加载广告的常见问题。&lt;/p&gt;
&lt;p&gt;为了让可见度测试更有效率， &lt;a href=&quot;https://wicg.github.io/IntersectionObserver/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IntersectionObserver&lt;/a&gt; 被设计出来了。&lt;code&gt;IntersectionObserver&lt;/code&gt; 让你知道观察的元素何时进入或退出浏览器 &lt;code&gt;viewport&lt;/code&gt;。
    
    </summary>
    
      <category term="javascript" scheme="http://robin-front.github.io/categories/javascript/"/>
    
    
      <category term="lazyload" scheme="http://robin-front.github.io/tags/lazyload/"/>
    
      <category term="performance" scheme="http://robin-front.github.io/tags/performance/"/>
    
      <category term="optimization" scheme="http://robin-front.github.io/tags/optimization/"/>
    
      <category term="IntersectionObserver" scheme="http://robin-front.github.io/tags/IntersectionObserver/"/>
    
  </entry>
  
</feed>
