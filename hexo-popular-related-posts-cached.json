[{"version":"2.0.6","hash":"2a2be5f14bce14eb204169aa5c0f0082","ngwHash":"0","cachedDate":1524068089298,"gaData":[{"updated":"Sun Jul 23 2017 10:42:17 GMT+0000 (UTC)","title":"桂林山水最强徒步攻略-大圩古镇-奇峰镇-会仙镇-葡萄镇至兴坪古镇20公里经典徒步路线","path":"2017/07/23/Daxu-village-Huixian-wetland-Putao-Xingping-of-Guilin.html","eyeCatchImage":null,"excerpt":"<blockquote>\n<p>我可不是一个酒店享受者，我的玩法是 don’t stop, keep your step.</p>\n</blockquote>\n<h1 id=\"桂林山水最强徒步攻略-大圩古镇-奇峰镇-会仙镇-葡萄镇至兴坪古镇20公里经典徒步路线\"><a href=\"#桂林山水最强徒步攻略-大圩古镇-奇峰镇-会仙镇-葡萄镇至兴坪古镇20公里经典徒步路线\" class=\"headerlink\" title=\"桂林山水最强徒步攻略-大圩古镇-奇峰镇-会仙镇-葡萄镇至兴坪古镇20公里经典徒步路线\"></a>桂林山水最强徒步攻略-大圩古镇-奇峰镇-会仙镇-葡萄镇至兴坪古镇20公里经典徒步路线</h1><p>对于每个地方并不打算去两次的人来说（除了一些体验特别好的地方），一次性打包看完一个地方所有感兴趣的地点是最合适的。所以，每次去完，总是把一个市，甚至一个省的攻略都做完了。或许也是一种强迫症吧。</p>\n<p>其实国内很多景点都是坑，网上照片基本都不是原片。写攻略是为了方便别人，也是为坑了别人一起，哈哈，顺便记录。","date":"2017-07-23T10:42:17.000Z","pv":0,"totalPV":0,"categories":"travel","tags":["travel"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Mon Nov 21 2016 11:19:22 GMT+0000 (UTC)","title":"Debounce and Throttle 的可视化解释","path":"2016/11/17/Debounce-and-Throttle-explain-visualizatly.html","eyeCatchImage":null,"excerpt":"<h1 id=\"Debounce-and-Throttle-的可視化解釋\"><a href=\"#Debounce-and-Throttle-的可視化解釋\" class=\"headerlink\" title=\"Debounce and Throttle 的可視化解釋\"></a>Debounce and Throttle 的可視化解釋</h1><p>Debounce 和 Throttle是两个概念，我们可以在 JavaScript 中使用，以提高我们对执行功能的控制，在事件处理的时候特别有用。</p>","date":"2016-11-17T10:22:22.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["debounce","throttle"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Wed Mar 16 2016 16:09:49 GMT+0000 (UTC)","title":"快速上手 Flow 静态类型检查器","path":"2016/03/16/Flow-the-type-checker.html","eyeCatchImage":null,"excerpt":null,"date":"2016-03-16T16:09:49.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["Flow"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Thu Aug 11 2016 19:51:56 GMT+0000 (UTC)","title":"用Git-Hooks进行自动部署,让提交发布自动化","path":"2016/08/11/Git-Hooks.html","eyeCatchImage":null,"excerpt":"<p>之前了解的自动化部署都是<code>jekins</code>这样集成化的成熟的工具。最近因为有朋友提交代码时，不想登陆服务器拉取代码，才了解到 <code>git hooks</code>。看来还是git使用不到位。之前一直都是本地开发并提交代码，测试时，人工登陆测试服务器去拉取最新代码。","date":"2016-08-11T19:51:56.000Z","pv":0,"totalPV":0,"categories":"git","tags":["git"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Thu Apr 14 2016 23:39:02 GMT+0000 (UTC)","title":"Node全局对象：global、process和Buffer","path":"2016/04/14/Node-global-object-global-process-and-Buffer.html","eyeCatchImage":null,"excerpt":"<h1 id=\"Node全局对象：global、process和Buffer\"><a href=\"#Node全局对象：global、process和Buffer\" class=\"headerlink\" title=\"Node全局对象：global、process和Buffer\"></a>Node全局对象：global、process和Buffer</h1><p><code>global</code>对象，也是<code>Node</code>的全局命名空间；\n<code>process</code>对象，它提供了一些关键功能，例如对三种标准I/O流的封装，以及将同步函数转换为异步回调的功能；\n<code>Buffer</code>类，它提供了存储和操作原始数据的功能，同样它也是全局可见的","date":"2016-04-14T23:39:02.000Z","pv":0,"totalPV":0,"categories":"Node","tags":["Node"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Wed Apr 13 2016 23:15:44 GMT+0000 (UTC)","title":"Node与REPL","path":"2016/04/13/REPL-of-node.html","eyeCatchImage":null,"excerpt":"<p>这几个月，搜芽前端团队搞了<code>Reactjs+Redux</code>项目，在很多时候，比如部署，都需要使用<code>Node</code>，苦于我的肤浅，于是决定补一下功课。最近都会记录一些 <code>Node</code>相关的笔记。","date":"2016-04-13T23:15:44.000Z","pv":0,"totalPV":0,"categories":"Node","tags":["Node"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Thu Jun 01 2017 18:16:43 GMT+0000 (UTC)","title":"RXJS我该选用哪个操作符之-创建篇","path":"2017/06/01/RXJS-should-i-choose-operator-of-creating.html","eyeCatchImage":null,"excerpt":"<p>RXJS该怎么上手？这么多操作符该用哪个？RXJS比较强大，操作符众多，想熟悉需要比较长时间的运用，所以大部分新手都比较疑惑应该使用哪些操作符去实现自己的数据流的操作。</p>\n<p>更多详情请翻阅 <a href=\"https://robin-front.github.io/RxJS-doc-chinese\">RXJS中文翻译文档</a></p>\n<h1 id=\"我该选用哪个操作符-创建操作符\"><a href=\"#我该选用哪个操作符-创建操作符\" class=\"headerlink\" title=\"我该选用哪个操作符? - 创建操作符\"></a>我该选用哪个操作符? - 创建操作符</h1><p>使用此页面查找<a href=\"https://robin-front.github.io/RxJS-doc-chinese/content/observable/observable_methods/index.html\"><code>Observable</code></a>符合您需求的类型创建操作：","date":"2017-06-01T18:16:43.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["RxJS"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Thu Jun 01 2017 17:54:53 GMT+0000 (UTC)","title":"RXJS我该选用哪个操作符之-实例操作符篇","path":"2017/06/01/RXJS-should-i-choose-operator-of-instance.html","eyeCatchImage":null,"excerpt":"<p>RXJS比较强大，操作符众多，想熟悉需要比较长时间的运用，所以大部分新手都比较疑惑应该使用哪些操作符去实现自己的数据流的操作。</p>\n<p>更多详情请翻阅 <a href=\"https://robin-front.github.io/RxJS-doc-chinese\">RXJS中文翻译文档</a></p>\n<h1 id=\"我该选用哪个操作符-实例操作符\"><a href=\"#我该选用哪个操作符-实例操作符\" class=\"headerlink\" title=\"我该选用哪个操作符? - 实例操作符\"></a>我该选用哪个操作符? - 实例操作符</h1><p>使用此页面通过类型查找<a href=\"https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md\" target=\"_blank\" rel=\"noopener\"><code>Observable</code></a> 适合您需要的实例运算符：","date":"2017-06-01T17:54:53.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["RxJS"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Mon Mar 14 2016 00:15:07 GMT+0000 (UTC)","title":"React应用性能优化之IMMUTABLE.JS","path":"2016/03/14/React-optimize-with-Immutable-js.html","eyeCatchImage":null,"excerpt":"<h1 id=\"React应用性能优化之IMMUTABLE-JS\"><a href=\"#React应用性能优化之IMMUTABLE-JS\" class=\"headerlink\" title=\"React应用性能优化之IMMUTABLE.JS\"></a>React应用性能优化之IMMUTABLE.JS</h1><p>前一篇文章记录了React应用的性能优化点，今天还有个更闪耀的 Immutable.js。</p>\n<h2 id=\"Immutable-js\"><a href=\"#Immutable-js\" class=\"headerlink\" title=\"Immutable.js\"></a>Immutable.js</h2><p>Immutable.js 本身和 React.js 没有必然的联系。它的意义在于它弥补了Javascript没有不可变数据结构的问题。","date":"2016-03-14T00:15:07.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["Immutable","react"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Thu Mar 10 2016 22:32:13 GMT+0000 (UTC)","title":"React应用性能优化之shouldComponentUpdate与key","path":"2016/03/10/React-optimize-with-shouldComponentUpdate-and-key.html","eyeCatchImage":null,"excerpt":"<h1 id=\"React应用性能优化之shouldComponentUpdate与key\"><a href=\"#React应用性能优化之shouldComponentUpdate与key\" class=\"headerlink\" title=\"React应用性能优化之shouldComponentUpdate与key\"></a>React应用性能优化之shouldComponentUpdate与key</h1><p>虽然React 的 vDom diff算法能保证最小程度的 DOM 改变，但当组件树嵌套得非常深时，就不得不需要渲染一个新的虚拟 DOM 来让应用运行得更加高效。</p>\n<p>下面看看加速应用程序的两种简单的配置方法：","date":"2016-03-10T22:32:13.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["react","shouldComponentUpdate"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Tue Apr 19 2016 22:38:50 GMT+0000 (UTC)","title":"React-v15.0升级指南","path":"2016/04/19/React-v15-0-upgrade-guide.html","eyeCatchImage":null,"excerpt":"<h1 id=\"React-v15-0升级指南\"><a href=\"#React-v15-0升级指南\" class=\"headerlink\" title=\"React-v15.0升级指南\"></a>React-v15.0升级指南</h1>","date":"2016-04-19T22:38:50.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["react"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Fri May 05 2017 16:51:51 GMT+0000 (UTC)","title":"RxJS事件桥接","path":"2017/05/05/RxJS-events-binding.html","eyeCatchImage":null,"excerpt":"<h1 id=\"事件桥接\"><a href=\"#事件桥接\" class=\"headerlink\" title=\"事件桥接\"></a>事件桥接</h1><p>RxJS 提供工厂方法来桥接 DOM 或 Node.js 中已存在的异步数据源，所以，你可以使用丰富的创作、过滤和资源管理功能对RxJS提供的任何类型的数据流进行操作。这篇文章探讨 <a href=\"https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/fromevent.md\" target=\"_blank\" rel=\"noopener\"><code>fromEvent</code></a> 和 <a href=\"https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators/fromeventpattern.md\" target=\"_blank\" rel=\"noopener\"><code>fromEventPattern</code></a>操作符，它允许导入一个 DOM 或者普通事件到 RxJS 的数据流。每次引发事件时，一个 <code>OnNext</code> 消息将传递到数据流。然后，可以像其他任何数据流一样操作事件数据流。</p>\n<p>RxJS 不打算取代现有的异步编程模型如 <code>Promises</code> 或 <code>callbacks</code>。但是，当你尝试组合事件， RxJS的工厂方法会提供简便的方法给你，你完全感受不到当前使用了何种编程模式。这真的很方便维护（比如取消订阅）和筛选（比如选择合适的数据）数据源。在本节和下节中，你可以尝试 RxJS 的这些特性如何协助你完成异步编程。</p>\n<p>自然，RxJS 支持一批库和他们的勾子函数去使用他们的事件系统，比如 <a href=\"http://jquery.com/\" target=\"_blank\" rel=\"noopener\">jQuery</a>, <a href=\"http://zeptojs.com/\" target=\"_blank\" rel=\"noopener\">Zepto.js</a>, <a href=\"https://angularjs.org/\" target=\"_blank\" rel=\"noopener\">AngularJS</a>, <a href=\"http://emberjs.com/\" target=\"_blank\" rel=\"noopener\">Ember.js</a> 和 <a href=\"http://backbonejs.org\" target=\"_blank\" rel=\"noopener\">Backbone.js</a>。这种行为，不管怎样只能重写本地绑定。默认情况下， RxJS 也支持 <a href=\"http://nodejs.org\" target=\"_blank\" rel=\"noopener\">Node.js</a> <code>EventEmitter</code> 的事件勾子。","date":"2017-05-05T16:51:51.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["RxJS","bridging","event"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Thu Sep 21 2017 11:34:30 GMT+0000 (UTC)","title":"深入理解 ios11 webview 的 viewport","path":"2017/09/21/Understanding-the-WebView-Viewport-in-iOS-11.html","eyeCatchImage":null,"excerpt":"<h1 id=\"深入理解-ios11-webview-的-viewport\"><a href=\"#深入理解-ios11-webview-的-viewport\" class=\"headerlink\" title=\"深入理解 ios11 webview 的 viewport\"></a>深入理解 ios11 webview 的 viewport</h1><p>ios11 带来了一些新的东西，凭直觉，围绕状态栏区域的展现对于程序员使用的像 Apache Cordova 或 Ionic 这样的工具显得尤为重要。尤其是，这个改动影响到所有为 ios11 构建的、基于 web 的、使用了固定标题栏的 app 之中。这篇文章帮助你理解 ios11 webview 的 viewport。</p>\n<p><strong>注： 现有的 app 可以继续正常工作，因为原有的 viewport 表现并没有被改变。这个改变只影响那些使用 xcode9 来为 ios11 构建的应用。</strong></p>\n<p>为了理解这个改动，我们需要先了解一下背景知识。","date":"2017-09-21T11:34:30.000Z","pv":0,"totalPV":0,"categories":"css","tags":["ios11","viewport","css-constant","viewport-fit"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Tue May 30 2017 09:52:45 GMT+0000 (UTC)","title":"JSX是什么鬼(WTF-is-JSX)","path":"2017/05/30/WTF-JSX.html","eyeCatchImage":null,"excerpt":"<h1 id=\"JSX是什么鬼-WTF-is-JSX\"><a href=\"#JSX是什么鬼-WTF-is-JSX\" class=\"headerlink\" title=\"JSX是什么鬼(WTF-is-JSX)\"></a>JSX是什么鬼(WTF-is-JSX)</h1><p>JSX实际上很简单：只需要花1分钟阅读这个，你会明白有关这个有趣的替代模板的一切。","date":"2017-05-30T09:52:45.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["react","JSX"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Wed Jun 28 2017 11:11:47 GMT+0000 (UTC)","title":"Web Animations API 入门教程总结回顾","path":"2017/06/28/Web-Animations-API-Tutorial-Conclusion.html","eyeCatchImage":null,"excerpt":"<h2 id=\"Web-Animations-API-入门教程总结回顾\"><a href=\"#Web-Animations-API-入门教程总结回顾\" class=\"headerlink\" title=\"Web Animations API 入门教程总结回顾\"></a>Web Animations API 入门教程总结回顾</h2><p>这是 Web Animations API 入门教程系列的总结部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与<a href=\"https://twitter.com/dancwilson\" target=\"_blank\" rel=\"noopener\">@dancwilson</a>联系。</p>\n<p>我们已经涵盖了相当多的知识面，希望能够解决有关Web Animations API是什么（而不是什么）的问题。要总结这个系列，我们将回顾一下我们已经讨论过的内容，并看看尚未实现的内容。","date":"2017-06-28T11:11:47.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["Web Animations"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Mon Jun 26 2017 11:25:31 GMT+0000 (UTC)","title":"Web Animations API 入门教程第1部分:创建一个基本的动画","path":"2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation.html","eyeCatchImage":null,"excerpt":"<h2 id=\"Web-Animations-API-入门教程第1部分-创建一个基本的动画\"><a href=\"#Web-Animations-API-入门教程第1部分-创建一个基本的动画\" class=\"headerlink\" title=\"Web Animations API 入门教程第1部分:创建一个基本的动画\"></a>Web Animations API 入门教程第1部分:创建一个基本的动画</h2><p>这是 Web Animations API 入门教程系列的第1部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与<a href=\"https://twitter.com/dancwilson\" target=\"_blank\" rel=\"noopener\">@dancwilson</a>联系。</p>\n<p>我们之前初步看了下 Web Animations API，但是我们没有得到任何真正的细节，所以现在我们来看看。</p>\n<p>WAAPI（Web Animations API, 以下均简称WAAPI）为您提供更多的控制比您可能已经习惯使用的CSS动画，但在我们进入这些演示之前，我们需要设置基本目标：如何通过此API创建基本动画？","date":"2017-06-26T11:25:31.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["Web Animations"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Mon Jun 26 2017 17:51:00 GMT+0000 (UTC)","title":"Web Animations API入门教程第2部分：动画和时间线控制","path":"2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation.html","eyeCatchImage":null,"excerpt":"<h2 id=\"Web-Animations-API入门教程第2部分：动画和时间线控制\"><a href=\"#Web-Animations-API入门教程第2部分：动画和时间线控制\" class=\"headerlink\" title=\"Web Animations API入门教程第2部分：动画和时间线控制\"></a>Web Animations API入门教程第2部分：动画和时间线控制</h2><p>这是 Web Animations API 入门教程系列的第2部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与<a href=\"https://twitter.com/dancwilson\" target=\"_blank\" rel=\"noopener\">@dancwilson</a>联系。</p>\n<p>现在我们了解如何使用Web Animations API <a href=\"https://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation/\">创建基本动画</a>，让我们来谈谈状态（states），控制(controls)，回调(callback)和时间轴(timelines)。","date":"2017-06-26T17:51:00.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["Web Animations"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Tue Jun 27 2017 10:17:19 GMT+0000 (UTC)","title":"Web Animations API 入门教程第3部分: 多个Animations对象","path":"2017/06/27/Web-Animations-API-Tutorial-Part-3-Multiple-Animations.html","eyeCatchImage":null,"excerpt":"<h2 id=\"Web-Animations-API-入门教程第3部分-多个Animations对象\"><a href=\"#Web-Animations-API-入门教程第3部分-多个Animations对象\" class=\"headerlink\" title=\"Web Animations API 入门教程第3部分: 多个Animations对象\"></a>Web Animations API 入门教程第3部分: 多个Animations对象</h2><p>这是 Web Animations API 入门教程系列的第3部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与<a href=\"https://twitter.com/dancwilson\" target=\"_blank\" rel=\"noopener\">@dancwilson</a>联系。</p>\n<p>在我们讨论<a href=\"http://robin-front.github.io/2017/06/26/Web-Animations-API-Tutorial-Part-2-The-Animation/\">动画和时间线控制</a>之后，让我们来讨论多个动画。","date":"2017-06-27T10:17:19.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["Web Animations"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Tue Jun 27 2017 11:24:55 GMT+0000 (UTC)","title":"Web Animations API 入门教程第4部分: GroupEffects & SequenceEffects","path":"2017/06/27/Web-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects.html","eyeCatchImage":null,"excerpt":"<h2 id=\"Web-Animations-API-入门教程第4部分-GroupEffects-amp-SequenceEffects\"><a href=\"#Web-Animations-API-入门教程第4部分-GroupEffects-amp-SequenceEffects\" class=\"headerlink\" title=\"Web Animations API 入门教程第4部分: GroupEffects &amp; SequenceEffects\"></a>Web Animations API 入门教程第4部分: GroupEffects &amp; SequenceEffects</h2><p>这是 Web Animations API 入门教程系列的第4部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与<a href=\"https://twitter.com/dancwilson\" target=\"_blank\" rel=\"noopener\">@dancwilson</a>联系。</p>\n<p>让我们继续讨论Web动画API中的多个动画，通过讨论今天在polyfill中提供的几个部分来提供分组和排序。","date":"2017-06-27T11:24:55.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["Web Animations"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Wed Jun 28 2017 09:59:47 GMT+0000 (UTC)","title":"Web Animations API 入门教程第5部分: 可爱的运动路径","path":"2017/06/28/Web-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path.html","eyeCatchImage":null,"excerpt":"<h2 id=\"Web-Animations-API-入门教程第5部分-可爱的运动路径\"><a href=\"#Web-Animations-API-入门教程第5部分-可爱的运动路径\" class=\"headerlink\" title=\"Web Animations API 入门教程第5部分: 可爱的运动路径\"></a>Web Animations API 入门教程第5部分: 可爱的运动路径</h2><p>这是 Web Animations API 入门教程系列的第5部分。</p>\n<p>重要信息：自撰写本文以来，运动路径的规范（和Chromium实现）已经发生了重大变化。以下在概念上仍然有效，但是属性名称和更多内容已经改变。截至2016年10月，请查看<a href=\"https://codepen.io/danwilson/post/css-motion-paths-2016\" target=\"_blank\" rel=\"noopener\">CSS运动路径</a>。</p>\n<p>最后，沿着路径动画…不再仅仅是SVG的领域。","date":"2017-06-28T09:59:47.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["Web Animations"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Thu Apr 07 2016 01:03:50 GMT+0000 (UTC)","title":"webpack-config","path":"2016/04/07/Webpack-config.html","eyeCatchImage":null,"excerpt":"<p>不得不说，<code>webpack</code> 配置确实烦琐了一些，很多人都使用<code>gulp</code>的插件<code>gulp-webpack</code>来做其他事情。","date":"2016-04-07T01:03:50.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["webpack","前端构建"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Fri Aug 11 2017 17:57:53 GMT+0000 (UTC)","title":"通过动图简单通俗地了解Flexbox的工作原理（一）","path":"2017/03/13/an-animated-guide-to-flexbox-1.html","eyeCatchImage":null,"excerpt":"<h1 id=\"Flexbox-的工作原理是怎样的，让我们通过彩色的动态图来了解。\"><a href=\"#Flexbox-的工作原理是怎样的，让我们通过彩色的动态图来了解。\" class=\"headerlink\" title=\"Flexbox 的工作原理是怎样的，让我们通过彩色的动态图来了解。\"></a>Flexbox 的工作原理是怎样的，让我们通过彩色的动态图来了解。</h1><p>Flexbox 承诺将我们从平庸的 css 中解救出来（比如垂直对齐）。</p>\n<p>好吧，Flexbox 确实实现了这一目标。但是掌握它这种新模式是一个挑战。</p>\n<p>所以，让我们做一些动图来看看 Flexbox 是如何工作的，以便我们可以用它来构建更好的布局。</p>\n<p>Flexbox 的基本原理就是让布局灵活直观。</p>\n<p>为了做到这一点，让容器自己决定如何平均分配子节点，包括子节点的大小和它们之间的间隔。</p>\n<p>这些原理听起来不错。不过还是让我们来看看实践中是怎样的。</p>\n<p>这篇文章中，我们将深入介绍 Flexbox 的 5 个最常见的基本属性。我们将探索它们做了什么，我们可以怎样使用，以及它们的真实表现。","date":"2017-03-13T08:31:42.000Z","pv":0,"totalPV":0,"categories":"css","tags":["Flexbox"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Mon Mar 13 2017 11:31:42 GMT+0000 (UTC)","title":"通过动图简单通俗地了解Flexbox的工作原理（二）","path":"2017/03/13/an-animated-guide-to-flexbox-2.html","eyeCatchImage":null,"excerpt":"<p>本文译自 <a href=\"https://medium.freecodecamp.com/even-more-about-how-flexbox-works-explained-in-big-colorful-animated-gifs-a5a74812b053#.iwqlenuqq\" target=\"_blank\" rel=\"noopener\">Scott Domes</a></p>\n<p>Flex属性是一个复合属性，而大部分教程中都只设置一个值，但其实它包含了 <code>flex-basis</code>、<code>flex-grow</code>、<code>flex-shrink</code>.\n让我们深入了解Flexbox - 以及如何利用它来构建适应性强和漂亮的布局.","date":"2017-03-13T11:31:42.000Z","pv":0,"totalPV":0,"categories":"css","tags":["Flexbox"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Wed Apr 18 2018 16:11:18 GMT+0000 (UTC)","title":"angularJS自定义指令","path":"2015/10/17/angular-comorized-directive.html","eyeCatchImage":null,"excerpt":"<h1 id=\"angularJS自定义指令\"><a href=\"#angularJS自定义指令\" class=\"headerlink\" title=\"angularJS自定义指令\"></a>angularJS自定义指令</h1><h2 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h2><p>可以简单理解成特定DOM元素上执行的函数，它可以拓展元素的功能。</p>\n<p>一个定义指令的基本格式如下：</p>\n<pre><code>angular.module(&#39;myApp&#39;, [])\n    .directive(&#39;myDirective&#39;, function(){\n        return {\n        //指令的配置项\n        }\n    });\n</code></pre><p>directive() 方法可以接受两个参数：","date":"2015-10-17T00:31:51.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["angularJS","directive"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Sun Mar 19 2017 14:40:21 GMT+0000 (UTC)","title":"RxJS的动画简介","path":"2017/03/19/animated-intro-rxjs.html","eyeCatchImage":null,"excerpt":"<p>本文译自 <a href=\"https://css-tricks.com/animated-intro-rxjs/\" target=\"_blank\" rel=\"noopener\">An Animated Intro to RxJS</a></p>\n<p>你可能听说过RxJS，ReactiveX，或反应式编程，或者甚至只听过函数式编程。这些术语在谈论最新和最前沿的前端技术时变得越来越突出。如果你像我一样，当你第一次尝试学习它时，你感到很困惑。","date":"2017-03-19T14:40:21.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["RxJS"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Sun Jun 25 2017 11:53:30 GMT+0000 (UTC)","title":"让我们谈谈 Web Animations API","path":"2017/06/25/animations-intro.html","eyeCatchImage":null,"excerpt":"<p>这是 Web Animations API 入门教程系列的总结部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与<a href=\"https://twitter.com/dancwilson\" target=\"_blank\" rel=\"noopener\">@dancwilson</a>联系。</p>\n<p>2014年夏天，Google宣布通过<a href=\"https://www.polymer-project.org/0.5/platform/web-animations.html\" target=\"_blank\" rel=\"noopener\">Polymer</a>在网页中展示Material设计…使用polyfill技术支持即将推出的标准Web Animations API。</p>\n<p>我没有听说过这个API，但是我很感兴趣，特别是因为它谈到了<code>MotionPath</code>(运动路径)效果。这还没有实现（你会在<a href=\"https://robin-front.github.io/2017/06/28/Web-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path/\">第5部分</a>发现这是什么），但是它的目标是提供一种组合CSS，JS和SVG的动画方式，让我感兴趣。一年以后，Chrome和Firefox开始实施，polyfill的进步是稳定的，现在是认真看待它的时候了。</p>\n<p>但是很少有人在谈论WAAPI！我希望开始一系列突出浏览器（和polyfill）功能的帖子，探索为什么我们想要这个API，并找出细微差别。希望我们也能让更多的人讨论和使用这个API。","date":"2017-06-25T11:53:30.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["Web Animations"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Mon Jul 03 2017 11:02:06 GMT+0000 (UTC)","title":"Array数组的indexOf、includes vs for-loop性能比较","path":"2017/07/03/arr-of-indexOf-vs-includes-and-for-loop.html","eyeCatchImage":null,"excerpt":"<h1 id=\"Array数组的indexOf、includes-vs-for-loop性能比较\"><a href=\"#Array数组的indexOf、includes-vs-for-loop性能比较\" class=\"headerlink\" title=\"Array数组的indexOf、includes vs for-loop性能比较\"></a>Array数组的indexOf、includes vs for-loop性能比较</h1><p>最近遇到一道算法题，然后有些人会使用 <code>includes</code>、<code>indexOf</code> 去判断是否存在另一个数。这让我不禁思考，这和 <code>for loop</code>有什么区别，能减少时间复杂度吗？我一开始也不是很清楚，但我可以找文档，找标准。我的第一判断是 <code>includes</code> 完全和 <code>for loop</code>没有区别的，只是es6 标准规范提供的语法糖，而 <code>indexOf</code> 还是有一定效率的。带着疑惑，查看 MDN 和 <a href=\"http://www.ecma-international.org/ecma-262\" target=\"_blank\" rel=\"noopener\">ecma-262</a>","date":"2017-07-03T11:02:06.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["Array","indexOf","includes","loop"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Wed Aug 30 2017 10:11:00 GMT+0000 (UTC)","title":"避免大型，复杂的布局和布局颠覆","path":"2017/08/30/avoid-large-complex-layouts-and-layout-thrashing.html","eyeCatchImage":null,"excerpt":"<h1 id=\"避免大型，复杂的布局和布局颠覆\"><a href=\"#避免大型，复杂的布局和布局颠覆\" class=\"headerlink\" title=\"避免大型，复杂的布局和布局颠覆\"></a>避免大型，复杂的布局和布局颠覆</h1><p>布局是浏览器查找元素的几何信息：其大小和页面中的位置。每个元素将基于所使用的CSS，元素的内容或父元素显示或隐式的大小调整信息。该过程在 Chrome，Opera，Safari 和 Internet Explorer中称为“布局”。在 Firefox 中，它被称为 Reflow （回流），但是这个过程的作用是相同的。</p>\n<p>类似于 style 计算，布局成本的直接相关是：</p>\n<ul>\n<li>需要布局的元素数量。</li>\n<li>这些布局的复杂性。","date":"2017-08-30T10:11:00.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["layout","css"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Fri Apr 08 2016 08:36:38 GMT+0000 (UTC)","title":"babel-loader配置","path":"2016/04/08/babel-loader-configure.html","eyeCatchImage":null,"excerpt":null,"date":"2016-04-08T08:36:38.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["webpack","loader","babel-loader"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Tue Jul 04 2017 11:27:55 GMT+0000 (UTC)","title":"css3中background-position 的四值语法","path":"2017/07/04/background-position-of-css3-about-four-value-syntax.html","eyeCatchImage":null,"excerpt":"<h1 id=\"css3中background-position的四值语法\"><a href=\"#css3中background-position的四值语法\" class=\"headerlink\" title=\"css3中background-position的四值语法\"></a>css3中background-position的四值语法</h1><p>刨根问底，每个css属性都要知道它的所有值实在不容易。今天看看 <code>background-position</code>.</p>\n<p>background-positionCSS中的属性允许您在其容器内移动背景图像（或渐变）。","date":"2017-07-04T11:27:55.000Z","pv":0,"totalPV":0,"categories":"css","tags":["background","css3"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Sat Jul 22 2017 08:30:22 GMT+0000 (UTC)","title":"Borawan island、Pagbilao Beach 和 Dampalitan island旅行预算指南——一个周末三个沙滩","path":"2017/07/22/borawan-island-Pagbilao-beach-and-Dampalitan-island.html","eyeCatchImage":null,"excerpt":"<blockquote>\n<p>一个孩子的冒险故事\n————讲故事的人</p>\n</blockquote>\n<h1 id=\"假期旅行之菲律宾系列之一-————-Borawan岛、Pagbilao岛、Dampalitan岛\"><a href=\"#假期旅行之菲律宾系列之一-————-Borawan岛、Pagbilao岛、Dampalitan岛\" class=\"headerlink\" title=\"假期旅行之菲律宾系列之一 ———— Borawan岛、Pagbilao岛、Dampalitan岛\"></a>假期旅行之菲律宾系列之一 ———— Borawan岛、Pagbilao岛、Dampalitan岛</h1><p>坐落在奎松南部的边缘，布尔戈斯（Padre Burgos）和帕格比洛（Pagbilao）的城镇面向泰巴巴斯湾（Tayabas Bay），这是分离大陆吕宋岛和马林杜克岛（Marinduque）的通道。马尼拉市区的这一边只有四到五个小时的路程，甚至远远近于 Pangasinan和碧瑶（Baguio）。","date":"2017-07-22T08:30:22.000Z","pv":0,"totalPV":0,"categories":"travel","tags":["travel","philippine"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Thu Apr 06 2017 11:21:26 GMT+0000 (UTC)","title":"Coverage针对js和css的代码覆盖检测-Chrome_devtools的新功能","path":"2017/04/06/check-coverage-of-js-and-css-used-in-Chrome-devtools.html","eyeCatchImage":null,"excerpt":"<h1 id=\"Coverage针对js和css的代码覆盖检测-Chrome-devtools的新功能\"><a href=\"#Coverage针对js和css的代码覆盖检测-Chrome-devtools的新功能\" class=\"headerlink\" title=\"Coverage针对js和css的代码覆盖检测-Chrome_devtools的新功能\"></a>Coverage针对js和css的代码覆盖检测-Chrome_devtools的新功能</h1><p>也许你之前用过一些像 <code>css usage</code>、<code>css used</code> 这样的浏览器插件去检测代码覆盖率。但现在，Chrome的实验版本<a href=\"https://www.google.com/chrome/browser/canary.html\" target=\"_blank\" rel=\"noopener\">Canary</a>终于实现了代码覆盖率检测，这意味着它将很快普及到正式版本。这是一个令人兴奋的功能，在使用JavaScript和CSS时非常有用，所以我会做一个快速的演示，并探索它如何使用。</p>","date":"2017-04-06T11:21:26.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["coverage","Chrome_devtools"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Fri Apr 22 2016 00:02:56 GMT+0000 (UTC)","title":"子进程child_process让Node.js具备命令行的功能","path":"2016/04/22/child-process-make-Node-js-have-bash-feature.html","eyeCatchImage":null,"excerpt":"<p>在<code>Node</code>中使用子进程的目的，正是希望从<code>Node</code>应用程序中通过命令行的方式访问计算机资源。","date":"2016-04-22T00:02:56.000Z","pv":0,"totalPV":0,"categories":"Node","tags":["Node","child_process"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Wed Nov 29 2017 09:49:43 GMT+0000 (UTC)","title":"简洁代码与冗余代码","path":"2017/11/29/clean-code-dirty-code.html","eyeCatchImage":null,"excerpt":"<h1 id=\"简洁代码与冗余代码\"><a href=\"#简洁代码与冗余代码\" class=\"headerlink\" title=\"简洁代码与冗余代码\"></a>简洁代码与冗余代码</h1><p>这篇文章将重点介绍适用于现代 react 软件开发的简洁代码之道。我还会谈谈 ES6/ES2015 带来的一些“语法糖”。","date":"2017-11-29T09:49:43.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["react","best practices"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Thu Jan 12 2017 17:49:14 GMT+0000 (UTC)","title":"比较instanceof与isPrototypeOf","path":"2017/01/12/compare-instanceof-with-isPrototypeof.html","eyeCatchImage":null,"excerpt":"<h1 id=\"比较instanceof与isPrototypeOf\"><a href=\"#比较instanceof与isPrototypeOf\" class=\"headerlink\" title=\"比较instanceof与isPrototypeOf\"></a>比较instanceof与isPrototypeOf</h1><p>在javascript中，instanceof 和 isPrototypeOf 都可以判断一个原型是否在另一个实例的原型链中，那他们有什么区别呢，为什么说 isPrototypeOf 可以替代 instanceof 。","date":"2017-01-12T17:49:14.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["instanceof","isPrototypeOf"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Wed Jun 14 2017 23:28:54 GMT+0000 (UTC)","title":"Flow和TypeScript之间的区别和优劣","path":"2017/06/14/compare-with-Flow-and-TypeScript.html","eyeCatchImage":null,"excerpt":"<h1 id=\"Flow和TypeScript之间的区别和优劣\"><a href=\"#Flow和TypeScript之间的区别和优劣\" class=\"headerlink\" title=\"Flow和TypeScript之间的区别和优劣\"></a>Flow和TypeScript之间的区别和优劣</h1><p>采用Flow＆TypeScript, 两者上手流程之间的比较。</p>\n<p>让我们想象一下我们想要采用一种类型检查器的场景…</p>","date":"2017-06-14T23:28:54.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["Flow","TypeScript"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Sun Mar 11 2018 10:16:46 GMT+0000 (UTC)","title":"构建 DOM 对象模型和 CSSDOM 对象模型","path":"2018/03/11/constructing-the-DOM-and-CSSDOM-object-model-before-browser-rendering.html","eyeCatchImage":null,"excerpt":"<p>By <a href=\"https://developers.google.com/web/resources/contributors/ilyagrigorik\" target=\"_blank\" rel=\"noopener\">Ilya Grigorik</a></p>\n<h1 id=\"构建-DOM-对象模型和-CSSDOM-对象模型\"><a href=\"#构建-DOM-对象模型和-CSSDOM-对象模型\" class=\"headerlink\" title=\"构建 DOM 对象模型和 CSSDOM 对象模型\"></a>构建 DOM 对象模型和 CSSDOM 对象模型</h1><p>浏览器渲染页面前需要先构建 DOM 和 CSSOM 树。因此，我们需要确保尽快将 HTML 和 CSS 都提供给浏览器。</p>\n<p>TL;DR</p>\n<ul>\n<li>字节 → 字符 → 令牌 → 节点 → 对象模型。</li>\n<li>HTML 标记转换成文档对象模型 (DOM)；CSS 标记转换成 CSS 对象模型 (CSSOM)。</li>\n<li>DOM 和 CSSOM 是独立的数据结构。</li>\n<li>Chrome DevTools Timeline 让我们可以捕获和检查 DOM 和 CSSOM 的构建和处理开销。</li>\n</ul>","date":"2018-03-11T10:16:46.000Z","pv":0,"totalPV":0,"categories":"html","tags":["css","DOM","CSSDOM","html"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Thu May 04 2017 18:06:14 GMT+0000 (UTC)","title":"使用RxJS创建和订阅单一数据流","path":"2017/05/04/creating_and_subscribing_to_simple_observable_sequences.html","eyeCatchImage":null,"excerpt":"<p><a href=\"https://robin-front.gitbooks.io/rxjs-doc-chinese/content/content/getting_started_with_rxjs/creating_and_querying_observable_sequences/creating_and_subscribing_to_simple_observable_sequences.html\" target=\"_blank\" rel=\"noopener\">来自</a></p>\n<h1 id=\"创建和订阅单一可观察序列\"><a href=\"#创建和订阅单一可观察序列\" class=\"headerlink\" title=\"创建和订阅单一可观察序列\"></a>创建和订阅单一可观察序列</h1><p>你不需要去实现 <code>Observable</code> 类去创建一个可观察序列。 同样的，你也不需要去实现 <code>Observer</code> 去订阅数据流。通过安装 Rx 库，你可以利用 <code>Observable</code>类型，它提供了许多操作符来根据零个，一个或多个元素去创建一个数据流。另外， RxJS 还提供 <code>subscribe</code> 方法允许你使用 <code>onNext</code>, <code>onError</code> 和 <code>onCompleted</code> 函数。</p>","date":"2017-05-04T18:06:14.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["RxJS"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Tue Mar 13 2018 09:50:49 GMT+0000 (UTC)","title":"优化关键渲染路径","path":"2018/03/13/critical-rendering-path.html","eyeCatchImage":null,"excerpt":"<h1 id=\"优化关键渲染路径\"><a href=\"#优化关键渲染路径\" class=\"headerlink\" title=\"优化关键渲染路径\"></a>优化关键渲染路径</h1><p>网页优化涉及到浏览器输入网址后的每一步，这里取关注相对少的浏览器渲染这一步来看看。</p>\n<p>浏览器渲染页面有以下五个步骤：</p>\n<ol>\n<li>处理 HTML 标记并构建 DOM 树。</li>\n<li>处理 CSS 标记并构建 CSSOM 树。</li>\n<li>将 DOM 与 CSSOM 合并成一个渲染树。</li>\n<li>根据渲染树来布局，以计算每个节点的几何信息。</li>\n<li>将各个节点绘制到屏幕上。</li>\n</ol>\n<p><em>优化关键渲染路径</em> 就是指最大限度缩短执行上述第 1 步至第 5 步耗费的总时间.</p>\n<p>优化关键渲染路径不仅对首屏呈现有重大意义，对于渲染页面帧率，流畅用户体验很关键。","date":"2018-03-13T09:50:49.000Z","pv":0,"totalPV":0,"categories":"css","tags":["css","html"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Fri Jun 02 2017 17:46:03 GMT+0000 (UTC)","title":"如何调试Node.js|使用谷歌chrome浏览器调试Node.js","path":"2017/06/02/debugging-Node-js-with-google-chrome.html","eyeCatchImage":null,"excerpt":"<h1 id=\"如何调试Node-js-使用谷歌chrome浏览器调试Node-js\"><a href=\"#如何调试Node-js-使用谷歌chrome浏览器调试Node-js\" class=\"headerlink\" title=\"如何调试Node.js|使用谷歌chrome浏览器调试Node.js\"></a>如何调试Node.js|使用谷歌chrome浏览器调试Node.js</h1><p>如何调试 Node.js, 还在使用 console.log 来调试 Node.js 吗，可以像调试前端页面一样调试 Node.js!</p>\n<p>调试是从软件应用程序中识别和删除错误的任务，而不仅仅是打印代码中的值。本文介绍如何使用最新的Google Chrome DevTools高效地调试Node.js程序。","date":"2017-06-02T17:46:03.000Z","pv":0,"totalPV":0,"categories":"Node","tags":["Node","debug","chrome"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Mon Jul 10 2017 16:30:11 GMT+0000 (UTC)","title":"不要混用 import 和 require","path":"2017/07/10/dont-mixin-import-and-require.html","eyeCatchImage":null,"excerpt":"<p>import 是 ES6 规范语法之一。而 require 属于CommonJS规范的一部分。</p>\n<p>目前来说，使用现代浏览器还无法支持 import，一般都会搭配 babel 使用，而 babel 会把 import 转换成 CommonJS 的 require.</p>\n<p>但是，我们不能混用 import 和 require。有时候会看下如下代码：","date":"2017-07-10T16:30:11.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["import","require"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Thu Jun 22 2017 17:48:00 GMT+0000 (UTC)","title":"css 动画和 Web Animation API(WAAPI)对比","path":"2017/06/22/css-animations-vs-web-animations-api.html","eyeCatchImage":null,"excerpt":"<h1 id=\"css-动画和-Web-Animation-API-WAAPI-对比\"><a href=\"#css-动画和-Web-Animation-API-WAAPI-对比\" class=\"headerlink\" title=\"css 动画和 Web Animation API(WAAPI)对比\"></a>css 动画和 Web Animation API(WAAPI)对比</h1><p>有一个JavaScript的动画原生API，称为<code>Web Animation API</code>。我们在这篇文章中称之为<code>WAAPI</code>。MDN有很好的<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API\" target=\"_blank\" rel=\"noopener\">文档</a>，Dan Wilson 有一个伟大的<a href=\"http://danielcwilson.com/blog/2015/07/animations-part-1/\" target=\"_blank\" rel=\"noopener\">系列文章</a>。</p>\n<p>在本文中，我们将比较WAAPI和CSS中完成的动画。","date":"2017-06-22T17:48:00.000Z","pv":0,"totalPV":0,"categories":"css","tags":["Web Animations","css3"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Mon Nov 27 2017 10:56:29 GMT+0000 (UTC)","title":"Dynamic import() 与 静态 import 相比较，有哪些不同","path":"2017/11/27/dynamic-import.html","eyeCatchImage":null,"excerpt":"<h1 id=\"Dynamic-import-有哪些特点\"><a href=\"#Dynamic-import-有哪些特点\" class=\"headerlink\" title=\"Dynamic import() 有哪些特点\"></a>Dynamic import() 有哪些特点</h1><blockquote>\n<p>Dynamic <strong>import()</strong>  已被 Chrome 63 和 Safari Technology Preview 24 支持。</p>\n</blockquote>\n<p><a href=\"https://github.com/tc39/proposal-dynamic-import\" target=\"_blank\" rel=\"noopener\">Dynamic <strong><code>import()</code></strong></a> 采用 类函数 的方法来塑造 <code>import</code>，相比 static <code>import</code> 解锁了新功能。这篇文章对比了两者并概览新功能。","date":"2017-11-27T10:56:29.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["dynamic import","es6"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Fri Nov 25 2016 11:05:19 GMT+0000 (UTC)","title":"由lodash引出数组Array的slice方法性能探究","path":"2016/11/25/explore-lodash-and-slice-of-Array-slice-peformance.html","eyeCatchImage":null,"excerpt":"<h1 id=\"由lodash引出数组Array的slice方法性能探究\"><a href=\"#由lodash引出数组Array的slice方法性能探究\" class=\"headerlink\" title=\"由lodash引出数组Array的slice方法性能探究\"></a>由lodash引出数组Array的slice方法性能探究</h1><p><code>lodash</code> 源码中，发现数组截取操作并没有直接使用<code>array</code>的<code>slice</code>方法，而是写了个 <code>baseSlice</code> 方法，更重要的是 <code>baseSlice</code> 方法里，也并没有使用 <code>slice</code> 方法，而是使用循环索引的方式去实现。这让我陷入思考，难道原生Array的<code>slice</code>方法还不如循环快？</p>","date":"2016-11-25T11:05:19.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["lodash","array","slice"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Wed Apr 18 2018 16:11:18 GMT+0000 (UTC)","title":"git 分支","path":"2015/10/10/git-branch.html","eyeCatchImage":null,"excerpt":null,"date":"2015-10-10T22:16:01.000Z","pv":0,"totalPV":0,"categories":"git","tags":["git"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Mon May 16 2016 20:57:45 GMT+0000 (UTC)","title":"git 小记","path":"2016/05/16/git-mardown.html","eyeCatchImage":null,"excerpt":"<p>有一些不太常用的git命令记录下","date":"2016-05-16T20:57:45.000Z","pv":0,"totalPV":0,"categories":"git","tags":["git"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Wed Apr 18 2018 16:11:18 GMT+0000 (UTC)","title":"git ssh-key 及多帐户设置","path":"2015/09/30/git-ssh-key-and-multiple-accounts-configs.html","eyeCatchImage":null,"excerpt":"<h1 id=\"git-ssh-key-及多帐户设置\"><a href=\"#git-ssh-key-及多帐户设置\" class=\"headerlink\" title=\"git ssh-key 及多帐户设置\"></a>git ssh-key 及多帐户设置</h1><p>在使用git的时候，我们在管理远程分支之前需要在本机上创建ssh-key密钥对，并把其中的公钥添加到github中。</p>\n<h2 id=\"首个帐户\"><a href=\"#首个帐户\" class=\"headerlink\" title=\"首个帐户\"></a>首个帐户</h2><p>如果你只会在你的计算机使用一个远程的Git服务器，并且账号是一个，比较简单，生成key的时候也没有太大注意的地方，直接运行如下的第一步然后按回车就可以了</p>\n<ol>\n<li>在 gitbash上运行  <code>ssh-keygen -t  rsa  -C  &quot;Github账户邮箱&quot;</code></li>\n<li>接下来会提示输入key的名字 默认名字为<code>id_rsa</code> ,默认不改直接回车就行了</li>\n<li>然后会提示输入口令，这里口令与Github中的密码无关，随便输入可以为空，为空直接回车。</li>\n<li><p>如果在第二步中的没有重新命名的话，则忽略此步骤，<code>ssh agent</code>默认只读取<code>id_rsa</code>，为了让SSH识别新的私钥，需将其添加到SSH agent中,如第二步改的名字为<code>robin</code>, 则执行：<code>ssh-add id_rsa</code>如果出现<code>Could not open a connection to your authentication agent</code>的错误，就试着先用以下命令：</p>","date":"2015-09-30T11:40:01.000Z","pv":0,"totalPV":0,"categories":"git","tags":["git"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Wed Apr 18 2018 16:11:18 GMT+0000 (UTC)","title":"gulp 4.0的变化","path":"2015/10/09/gulp-4.0.html","eyeCatchImage":null,"excerpt":"<h2 id=\"升级日志\"><a href=\"#升级日志\" class=\"headerlink\" title=\"升级日志\"></a>升级日志</h2><p>先来看看新版有什么不同（<a href=\"https://github.com/gulpjs/gulp/blob/4.0/CHANGELOG.md\" target=\"_blank\" rel=\"noopener\">官方升级日志</a>）：</p>\n<ul>\n<li><p>新的任务系统（基于 bach，替换掉了原先基于 orchestrator 的任务系统）</p>\n<ul>\n<li>移除 gulp.reset</li>\n<li>gulp.task 不再支持三个参数的用法</li>\n<li>gulp.task 用字符串注册的任务必须是直接在命令行中调用的任务</li>\n<li>gulp.task 可以接受单参数语法，这个参数必须是一个命名函数，函数名会被作为任务名</li>\n<li>添加了 gulp.series 和 gulp.parallel 方法用于组合任务</li>\n<li>添加了 gulp.tree 方法用于获取任务树，传入 { deep: true } 参数可以得到一个 archy 兼容的节点列表</li>\n<li>添加了 gulp.registry 方法以定制注册表。</li>\n</ul>\n</li>\n</ul>","date":"2015-10-09T15:23:51.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["前端构建","gulp"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Mon Nov 06 2017 10:40:21 GMT+0000 (UTC)","title":"javascript 事件循环是如何工作的以及使用async／await提升异步编程的5种方式","path":"2017/11/06/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-async-and-await.html","eyeCatchImage":null,"excerpt":"<h1 id=\"javascript-事件循环是如何工作的以及使用async／await提升异步编程的5种方式\"><a href=\"#javascript-事件循环是如何工作的以及使用async／await提升异步编程的5种方式\" class=\"headerlink\" title=\"javascript 事件循环是如何工作的以及使用async／await提升异步编程的5种方式\"></a>javascript 事件循环是如何工作的以及使用async／await提升异步编程的5种方式</h1><p>这次我们将通过回顾在单线程环境中编程的缺点来扩展先前的第一篇文章，以及如何克服它来建立一个令人惊叹的 javascript UIs。像以往一样，在文章的最后，我会分享使用 async/await 写简洁代码的 5 个小贴士。","date":"2017-11-06T10:40:21.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["tutorial","web development","programming","asynchronous","events loop","promise","async await"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Fri Jan 13 2017 10:19:27 GMT+0000 (UTC)","title":"js遍历Object对象可枚举属性、不可枚举属性、原型链属性和自身属性","path":"2017/01/13/how-to-enumerate-object-properties.html","eyeCatchImage":null,"excerpt":"<h1 id=\"js遍历Object对象可枚举属性、不可枚举属性、原型链属性和自身属性\"><a href=\"#js遍历Object对象可枚举属性、不可枚举属性、原型链属性和自身属性\" class=\"headerlink\" title=\"js遍历Object对象可枚举属性、不可枚举属性、原型链属性和自身属性\"></a>js遍历Object对象可枚举属性、不可枚举属性、原型链属性和自身属性</h1><p>利用hasOwnProperty、getOwnPropertyNames、Object.keys、for…in遍历对象的可枚举属性、不可枚举属性、原型链上的属性和自身属性。","date":"2017-01-13T10:19:27.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["getOwnPropertyNames","hasOwnProperty","Object.keys"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Wed Jun 08 2016 23:53:10 GMT+0000 (UTC)","title":"正确检测Javascript数据类型","path":"2016/06/08/how-to-get-Javascript-type-of-variables-correctly.html","eyeCatchImage":null,"excerpt":"<h1 id=\"如何正确检测Javascript数据类型\"><a href=\"#如何正确检测Javascript数据类型\" class=\"headerlink\" title=\"如何正确检测Javascript数据类型\"></a>如何正确检测Javascript数据类型</h1>","date":"2016-06-08T23:53:10.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["javascript","typeof"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Tue Sep 19 2017 09:38:51 GMT+0000 (UTC)","title":"如何处理4种常见的内存泄露","path":"2017/09/19/how-to-handle-4-common-memory-leaks.html","eyeCatchImage":null,"excerpt":"<h1 id=\"如何处理4种常见的内存泄露\"><a href=\"#如何处理4种常见的内存泄露\" class=\"headerlink\" title=\"如何处理4种常见的内存泄露\"></a>如何处理4种常见的内存泄露</h1><h2 id=\"什么是内存泄露\"><a href=\"#什么是内存泄露\" class=\"headerlink\" title=\"什么是内存泄露\"></a>什么是内存泄露</h2><p>本质上来说，内存泄露可以被定义为 <strong>当内存不再被应用使用，却因为某些原因没有被操作系统回收或释放到自由内存池</strong></p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*0B-dAUOH7NrcCDP6GhKHQw.jpeg\" alt=\"https://cdn-images-1.medium.com/max/1600/1*0B-dAUOH7NrcCDP6GhKHQw.jpeg\"></p>\n<p>编程语言支持多种不同的内存管理。某些内存是否在使用实际上是不可判定的。换句话说，只要开发者才清楚哪些内存块是可以被操作系统回收。</p>\n<p>某些编程语言提供一些特性帮助开发者进行内存回收。其他的期望开发者完全明白哪些内存是无用的。维基有一系列关于内存管理的好文章。","date":"2017-09-19T09:38:51.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["memory leaks"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Thu Aug 24 2017 09:59:34 GMT+0000 (UTC)","title":"IntersectionObserver API","path":"2017/08/24/intersectionobserver.html","eyeCatchImage":null,"excerpt":"<h1 id=\"IntersectionObserver\"><a href=\"#IntersectionObserver\" class=\"headerlink\" title=\"IntersectionObserver\"></a>IntersectionObserver</h1><p>假设你想追踪 DOM 里的一个元素是否进入 <a href=\"https://en.wikipedia.org/wiki/Viewport\" target=\"_blank\" rel=\"noopener\">viewport</a> 的可视区。你做这件事可能是因为你想在这个时机 lazyload 图片或者你需要知道用户是否真的在看一个某个广告横幅。你可以通过添加 <code>scroll</code> 事件钩子或使用定时器去调用元素的 <code>getBoundingClientRect()</code> 方法。然而，这种方法真的很慢，因为每次调用 <code>getBoundingClientRect()</code> <a href=\"https://gist.github.com/paulirish/5d52fb081b3570c81e3a\" target=\"_blank\" rel=\"noopener\">会造成浏览器 re-layout 当前页面</a> 并会在你的页面造成很大的卡顿和闪烁。 <code>iframe</code> 里的元素是否可见这样的事情几乎很难做到。 基于单一源模型，浏览器不会让你访问包含 <code>iframe</code> 的页面的任何数据。这是频繁使用 <code>iframe</code> 加载广告的常见问题。</p>\n<p>为了让可见度测试更有效率， <a href=\"https://wicg.github.io/IntersectionObserver/\" target=\"_blank\" rel=\"noopener\">IntersectionObserver</a> 被设计出来了。<code>IntersectionObserver</code> 让你知道观察的元素何时进入或退出浏览器 <code>viewport</code>。","date":"2017-08-24T09:59:34.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["lazyload","performance","optimization","IntersectionObserver"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Fri Jul 14 2017 17:31:57 GMT+0000 (UTC)","title":"npx是什么，为什么需要npx?","path":"2017/07/14/introducing-npx-an-npm-package-runner.html","eyeCatchImage":null,"excerpt":"<h1 id=\"介绍npx：一个npm包运行\"><a href=\"#介绍npx：一个npm包运行\" class=\"headerlink\" title=\"介绍npx：一个npm包运行\"></a>介绍npx：一个npm包运行</h1><p>NPM升级到最新版本，<a href=\"https://github.com/npm/npm/releases/tag/v5.2.0\" target=\"_blank\" rel=\"noopener\">npm@5.2.0</a>，你可能会发现，它会安装一个新的二进制包跟着 <code>npm</code>：<a href=\"https://npm.im/npx\" target=\"_blank\" rel=\"noopener\">npx</a>。</p>\n<p><code>npx</code> 是一个工具，旨在帮助整理从npm注册软件包的体验 - 和 使得npm非常容易地安装和管理托管在注册表上的依赖关系是 同样的方式，<code>npx</code>使 npm 很方便使用CLI工具和其他被托管的可执行文件。它大大简化了一些事情，到目前为止，需要一些与普通的npm有关的步骤：</p>","date":"2017-07-14T17:31:57.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["npm","npx"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Wed Apr 18 2018 16:11:18 GMT+0000 (UTC)","title":"javascript 获取本周和本月或任意月的时间段","path":"2015/10/30/javascript-get-the-time-period-of-the-week-and-this-month-or-any-month.html","eyeCatchImage":null,"excerpt":"<h1 id=\"javascript-获取本周和本月或任意月的时间段\"><a href=\"#javascript-获取本周和本月或任意月的时间段\" class=\"headerlink\" title=\"javascript 获取本周和本月或任意月的时间段\"></a>javascript 获取本周和本月或任意月的时间段</h1><p>最近有功能从两个时间段变成单个select选择了，但后端不想改接口。只好适配一下，把今天、本周、本月及过去的月份转换一下。</p>\n<p>首先，更改一下select菜单，动态取出过去的月份，添加options。","date":"2015-10-30T23:36:01.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["javascript"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Sun Jan 14 2018 00:47:06 GMT+0000 (UTC)","title":"javascript 判断正负0","path":"2018/01/14/judge-positive-and-negative-0.html","eyeCatchImage":null,"excerpt":"<h1 id=\"javascript-判断正负0\"><a href=\"#javascript-判断正负0\" class=\"headerlink\" title=\"javascript 判断正负0\"></a>javascript 判断正负0</h1><p>ES 2015/ ES 6 新增了一个方法用于 javascript 相等性判断 – <code>Object.is()</code>。它与之前的相等比较运算符有什么不同呢？","date":"2018-01-14T00:47:06.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["javascript","基础","isNegativeZero"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Tue Apr 10 2018 12:32:20 GMT+0000 (UTC)","title":"keep-alive vs http2","path":"2018/04/10/keep-alive-vs-http2.html","eyeCatchImage":null,"excerpt":"<p>我们经常谈论 http2 与 http1.1，却经常忽视一些细节的区别。最近谈到 keep-alive 与 http2 链路复用的区别。虽然我知道 http2 的多路复用技术是源自通信工程里的时分复用，但对 keep-alive 的复用却有些模糊。下面看来这些技术之间的进化。","date":"2018-04-10T12:32:20.000Z","pv":0,"totalPV":0,"categories":"http","tags":["http","http2","keep-alive","HOL blocking"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Fri Aug 18 2017 10:14:15 GMT+0000 (UTC)","title":"使用 intersection observer 延迟加载图片","path":"2017/08/18/lazy-loading-images-using-intersection-observer.html","eyeCatchImage":null,"excerpt":"<h1 id=\"使用-intersection-observer-延迟加载图片\"><a href=\"#使用-intersection-observer-延迟加载图片\" class=\"headerlink\" title=\"使用 intersection observer 延迟加载图片\"></a>使用 intersection observer 延迟加载图片</h1><p>如果您还没有看过，Paul Lewis 组织了一个令人敬畏的视频系列，演示如何构建媒体播放器以及拥有非常棒的特性的 Progressive Web Apps。他在YouTube上建立了<a href=\"https://www.youtube.com/playlist?list=PLNYkxOF6rcIBykcJ7bvTpqU7vt-oey72J\" target=\"_blank\" rel=\"noopener\">一系列视频</a>，这些视频是在他建立网站的每一部分的过程中发生的。观看开发者展示他们工作的视频绝对是我最喜欢学习新事物的方法之一！</p>","date":"2017-08-18T10:14:15.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["lazyload","performance","optimization","IntersectionObserver"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Mon Mar 20 2017 11:04:39 GMT+0000 (UTC)","title":"Lerp的应用-利用简单线性插值来平滑动画效果","path":"2017/03/20/lerp-application-uses-simple-linear-interpolation-to-smooth-animation-effects.html","eyeCatchImage":null,"excerpt":"<h2 id=\"Lerp的应用-利用简单线性插值来平滑动画效果\"><a href=\"#Lerp的应用-利用简单线性插值来平滑动画效果\" class=\"headerlink\" title=\"Lerp的应用-利用简单线性插值来平滑动画效果\"></a>Lerp的应用-利用简单线性插值来平滑动画效果</h2><p>上一篇的 <a href=\"https://robin-front.github.io/2017/03/19/RxJS%E7%9A%84%E5%8A%A8%E7%94%BB%E7%AE%80%E4%BB%8B/\">RxJS的动画简介</a> 里提到一个动画平滑的小技巧, 这里展示几个例子，它真的很简单却很有用。</p>\n<p><code>Lerp</code>是两点之间的线性插值的别称。这是一个实现起来相当简单的效果，但可以真正改善你的动画的外观，如果你将一个对象从点A移动到点B.","date":"2017-03-20T11:04:39.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["animate"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Sat Apr 02 2016 15:44:00 GMT+0000 (UTC)","title":"采用非直进式合并（git-merge-no-ff）","path":"2016/04/02/make-fast-forwarding-be-off-by-default-in-git.html","eyeCatchImage":null,"excerpt":"<h1 id=\"采用非直进式合并（git-merge-no-ff）\"><a href=\"#采用非直进式合并（git-merge-no-ff）\" class=\"headerlink\" title=\"采用非直进式合并（git-merge-no-ff）\"></a>采用非直进式合并（git-merge-no-ff）</h1><p>使用Git当合并一个分支是一个相当常见的操作。在某些情况下，Git会默认将尝试在快进模式合并一个分支。如果不使用快进合并有什么不同？","date":"2016-04-02T15:44:00.000Z","pv":0,"totalPV":0,"categories":"git","tags":["git"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Tue Jul 18 2017 15:25:02 GMT+0000 (UTC)","title":"高性能 react：3种加快应用程序的新工具","path":"2017/07/18/make-react-fast-again-tools-and-techniques-for-speeding-up-your-react-app.html","eyeCatchImage":null,"excerpt":"<h1 id=\"高性能-react：3种加快应用程序的新工具\"><a href=\"#高性能-react：3种加快应用程序的新工具\" class=\"headerlink\" title=\"高性能 react：3种加快应用程序的新工具\"></a>高性能 react：3种加快应用程序的新工具</h1><p>react 通常很快，但很容易造成导致性能问题的小错误。缓慢的组件安装，深层组件树和不必要的渲染循环可以快速添加到一个感觉缓慢的应用程序。</p>\n<p>幸运的是，有很多工具，有些甚至内置于 React，这有助于诊断性能问题。在这篇文章中，我将强调使 React 应用程序更快速的工具和技术。每个部分还有一个互动，（希望）有趣的演示！","date":"2017-07-18T15:25:02.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["react","tools"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Sat Jul 22 2017 11:29:35 GMT+0000 (UTC)","title":"马萨萨海滩(masasa beach) 旅行预算指南","path":"2017/07/22/masasa-beach-travel-guide.html","eyeCatchImage":null,"excerpt":"<h1 id=\"假期旅行之菲律宾系列之二-——-马萨萨海滩-masasa-beach\"><a href=\"#假期旅行之菲律宾系列之二-——-马萨萨海滩-masasa-beach\" class=\"headerlink\" title=\"假期旅行之菲律宾系列之二 —— 马萨萨海滩(masasa beach)\"></a>假期旅行之菲律宾系列之二 —— 马萨萨海滩(masasa beach)</h1><p>马萨沙滩可以说是 Tingloy 最好的海滩，这是 Batangas 唯一不在大陆吕宋岛上。它的主要岛屿是鱼形马里卡班（Maricaban），位于 Calumpang 半岛的一角，将巴拉扬湾（Balayan Bay）与八打雁湾（Batangas Bay）分开。</p>\n<p>事实是，这里的沙滩不像你在长滩岛或巴拉望岛所期望的那样像白色珍珠，但是马萨沙滩在缺乏亮度的沙滩中展现出波浪的气息。它的水晶般清澈，浅水散发出美丽的绿松石闪光，即使远距离也能吸引您的注意。","date":"2017-07-22T11:29:35.000Z","pv":0,"totalPV":0,"categories":"travel","tags":["travel","philippine"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Thu Jun 01 2017 10:15:45 GMT+0000 (UTC)","title":"npm@5发布有哪些改进","path":"2017/06/01/npm-5-published.html","eyeCatchImage":null,"excerpt":"<h1 id=\"npm-5发布有哪些改进\"><a href=\"#npm-5发布有哪些改进\" class=\"headerlink\" title=\"npm@5发布有哪些改进\"></a>npm@5发布有哪些改进</h1><p>从今天开始，如果您输入“<code>npm install npm@latest -g</code>”，那么您将被更新为npm版本5。另外，在所有<a href=\"https://medium.com/@nodejs/node-js-8-big-improvements-for-the-debugging-and-native-module-ecosystem-58454861f2fc\" target=\"_blank\" rel=\"noopener\">Node.js 8</a>的新安装中都捆绑了<code>npm@5</code> ，它已经替代了<code>Node.js 7</code>在Node Project的当前版本中。</p>\n<p>在过去一年半的时间里，我们一直在努力解决大量的痛点，其中有些是创建npm以来就已经存在的。今天的发布是对npm速度，一致性和用户体验的最大改进。</p>\n<p>发布说明中有什么新内容和更改内容的明确列表，但这里有一些亮点：","date":"2017-06-01T10:15:45.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["npm"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Wed Apr 18 2018 16:11:18 GMT+0000 (UTC)","title":"前端批量压缩图片","path":"2015/10/08/optimize-images-with-font-end.html","eyeCatchImage":null,"excerpt":"<h1 id=\"前端批量压缩图片\"><a href=\"#前端批量压缩图片\" class=\"headerlink\" title=\"前端批量压缩图片\"></a>前端批量压缩图片</h1><p>前端切图的时候，png 图片都比较大，一直使用的是 <a href=\"https://tinypng.com/\" target=\"_blank\" rel=\"noopener\">Tinypng</a> 来压缩 png 图片，小图标sprite之后，图片数量还是至少在 20 以上，操作甚是麻烦。后来在使用 gulp 的时候，发现了一个批量压缩图片的神器 —— <a href=\"https://pngquant.org/\" target=\"_blank\" rel=\"noopener\">pngquant</a> 。","date":"2015-10-08T14:31:51.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["前端构建"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Wed May 04 2016 22:04:27 GMT+0000 (UTC)","title":"pm2一个带有负载均衡功能的Node应用的进程管理器","path":"2016/05/04/pm2-Node-process-manager.html","eyeCatchImage":null,"excerpt":"<h1 id=\"pm2一个带有负载均衡功能的Node应用的进程管理器\"><a href=\"#pm2一个带有负载均衡功能的Node应用的进程管理器\" class=\"headerlink\" title=\"pm2一个带有负载均衡功能的Node应用的进程管理器\"></a>pm2一个带有负载均衡功能的Node应用的进程管理器</h1><p>PM2是一个提供了内置的负载均衡的Node.js应用程序进程管理器。它可以让你保持应用程序永远在线，无需停机地重启应用，也有助于系统管理员工作。","date":"2016-05-04T22:04:27.000Z","pv":0,"totalPV":0,"categories":"Node","tags":["Node"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Sat Apr 09 2016 22:47:09 GMT+0000 (UTC)","title":"postCSS-loader配置,让css随心所欲","path":"2016/04/09/postCSS-loader-configs.html","eyeCatchImage":null,"excerpt":"<h1 id=\"postCSS-loader配置-让css随心所欲\"><a href=\"#postCSS-loader配置-让css随心所欲\" class=\"headerlink\" title=\"postCSS-loader配置,让css随心所欲\"></a>postCSS-loader配置,让css随心所欲</h1><p>组件必不可少的一部分就是 <code>css</code>，这里看下关于 <code>css</code>的一些 <code>loaders</code>。","date":"2016-04-09T22:47:09.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["webpack","前端构建","loaders"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Sun Apr 10 2016 00:43:12 GMT+0000 (UTC)","title":"postCSS 常用插件","path":"2016/04/10/postCSS-plugins.html","eyeCatchImage":null,"excerpt":"<h1 id=\"postCSS常用插件\"><a href=\"#postCSS常用插件\" class=\"headerlink\" title=\"postCSS常用插件\"></a>postCSS常用插件</h1><p>PostCSS拥有非常多的插件，诸如自动为CSS添加浏览器前缀的插件autoprefixer、当前移动端最常用的px转rem插件px2rem，还有支持尚未成为CSS标准但特定可用的插件cssnext，还有很多很多。就连著名的Bootstrap在下一个版本Bootstrap 5也将使用PostCSS作为样式的基础。</p>\n<p>一句话来概括PostCSS：CSS编译器能够做到的事情，它也可以做到，而且能够做得更好","date":"2016-04-10T00:43:12.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["前端构建","loader","postCSS"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Mon Jul 17 2017 15:23:17 GMT+0000 (UTC)","title":"优化 react 让它快如闪电——你是电，你是光，你是唯一的神话","path":"2017/07/17/react-at-light-speed.html","eyeCatchImage":null,"excerpt":"<h1 id=\"光速-React\"><a href=\"#光速-React\" class=\"headerlink\" title=\"光速 React\"></a>光速 React</h1><h2 id=\"Vixlet-团队优化性能的经验教训\"><a href=\"#Vixlet-团队优化性能的经验教训\" class=\"headerlink\" title=\"Vixlet 团队优化性能的经验教训\"></a>Vixlet 团队优化性能的经验教训</h2><p>在过去一年多，我们 <a href=\"http://www.vixlet.com\" target=\"_blank\" rel=\"noopener\">Vixlet</a> 的 web 团队已经着手于一个激动人心的项目：将我们的整个 web 应用迁移到 <code>React</code> + <code>Redux</code> 架构。对于整个团队来说，这是不断成长中的机会，在整个过程中，我们在这方面面临一些挑战。</p>\n<p>因为我们的 web-app 可能有非常大的 feed 视图，包括成百上千的媒体、文本、视频、链接元素，我们花了相当多的时间寻找能充分利用 <code>React</code> 性能的方法。在这里，我们将分享我们这一路学到的一些经验教训。</p>\n<p><strong>声明</strong>：<strong>下面讲的做法和方法更适用于我们具体应用的性能需求。然而，像所有的开发者建议的那样，最重要的是要考虑到你的应用程序和团队的实际需求。React 是一个开箱即用的框架，所以你可能不需要像我们一样细致地优化性能。话虽如此，我们还是希望你能在这篇文章里找到一些有用的信息。</strong>","date":"2017-07-17T15:23:17.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["react"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Thu Jul 06 2017 16:24:53 GMT+0000 (UTC)","title":"react性能优化：提取子组件中额外的事件绑定","path":"2017/07/06/react-pattern-extract-child-components-to-avoid-binding.html","eyeCatchImage":null,"excerpt":"<h1 id=\"react性能优化：提取子组件中额外的事件绑定\"><a href=\"#react性能优化：提取子组件中额外的事件绑定\" class=\"headerlink\" title=\"react性能优化：提取子组件中额外的事件绑定\"></a>react性能优化：提取子组件中额外的事件绑定</h1><p>我们经常在快要完成一个<code>react</code>中型应用时，发现页面并没有想象中那么流畅。 react 理论性能是不错的，但是对开发者要求也很高，一些不易注意的点很容易造成性能问题。正所谓“烂泥扶不上墙”。</p>\n<p>下面看看子组件的事件绑定写法对性能的影响。","date":"2017-07-06T16:24:53.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["react"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Mon Jul 17 2017 17:12:02 GMT+0000 (UTC)","title":"Redux 并不慢，只是你使用姿势不对 —— 一份优化指南","path":"2017/07/17/react-redux-optimization.html","eyeCatchImage":null,"excerpt":"<h1 id=\"Redux-并不慢，只是你使用姿势不对-——-一份优化指南\"><a href=\"#Redux-并不慢，只是你使用姿势不对-——-一份优化指南\" class=\"headerlink\" title=\"Redux 并不慢，只是你使用姿势不对 —— 一份优化指南\"></a>Redux 并不慢，只是你使用姿势不对 —— 一份优化指南</h1><p><em>如何优化使用了 Redux 的 react 应用程序并不是显而易见的。但实际上相当简单。这是一个简短的指南，以及一些例子。</em></p>\n<p>当优化使用 Redux 的 react 应用程序时，我经常听到有人说 Redux 缓慢。在99％的情况下，性能不佳的原因（适用于任何其他框架）与不必要的渲染相关联，因为 DOM 更新是昂贵的！在本文中，您将学习如何在使用 Redux 绑定 react 时避免不必要的 <code>render</code>。</p>\n<p>通常，我们使用<a href=\"https://github.com/reactjs/react-redux\" target=\"_blank\" rel=\"noopener\">官方 react 绑定的 Redux</a> 的 <a href=\"https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options\" target=\"_blank\" rel=\"noopener\">connect</a> 高阶组件， 当您的 Redux <code>store</code> 更新时，react 组件就会更新。这是一个将组件包装在另一个组件中的函数，该组件订阅了 Redux <code>store</code> 中的更改，并渲染 <code>store</code>，这就是它的子节点更新的原因。","date":"2017-07-17T17:12:02.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["react","redux"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Thu Nov 09 2017 23:10:26 GMT+0000 (UTC)","title":"react 组件设计模式","path":"2017/11/09/react-component-patterns.html","eyeCatchImage":null,"excerpt":"<h1 id=\"react-component-模式\"><a href=\"#react-component-模式\" class=\"headerlink\" title=\"react component 模式\"></a>react component 模式</h1><blockquote>\n<p>有状态组件（Stateful）和无状态组件（Stateless）、容器组件（Container）与展示组件（Presentational）、高阶组件（HOC）、渲染回调（Render Callbacks）等</p>\n</blockquote>\n<p>我在工作中使用 React 有一段时间了——一个 facebook 使用 js 渲染用户界面的框架——刚开始的时候我想知道一些概念。这些文字是尝试总结我实践这么久以来学到的一些模式——可能对于刚开始进入组件世界的开发者有用。","date":"2017-11-09T23:10:26.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["React","Components","Higher Order ComponentsRender","Callback","patterns","设计模式"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Mon Apr 18 2016 22:16:27 GMT+0000 (UTC)","title":"react-router动态路由与webpack分片thunks","path":"2016/04/18/react-router-and-Webpack-thunks.html","eyeCatchImage":null,"excerpt":"<h1 id=\"react-router动态路由与webpack分片thunks\"><a href=\"#react-router动态路由与webpack分片thunks\" class=\"headerlink\" title=\"react-router动态路由与webpack分片thunks\"></a>react-router动态路由与webpack分片thunks</h1><p>对于大型应用来说，一个首当其冲的问题就是所需加载的 JavaScript 的大小。程序应当只加载当前渲染页所需的 JavaScript。有些开发者将这种方式称之为“代码分拆” — 将所有的代码分拆成多个小包，在用户浏览过程中按需加载。</p>\n<p>对于底层细节的修改不应该需要它上面每一层级都进行修改。举个例子，为一个照片浏览页添加一个路径不应该影响到首页加载的 JavaScript 的大小。也不能因为多个团队共用一个大型的路由配置文件而造成合并时的冲突。</p>\n<p>路由是个非常适于做代码分拆的地方：它的责任就是配置好每个 view。","date":"2016-04-18T22:16:27.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["react","react-router","router"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Mon Feb 12 2018 16:27:34 GMT+0000 (UTC)","title":"react新API——context上下文","path":"2018/02/12/reacts-new-context-api.html","eyeCatchImage":null,"excerpt":"<h1 id=\"React’s-⚛️-new-Context-API\"><a href=\"#React’s-⚛️-new-Context-API\" class=\"headerlink\" title=\"React’s ⚛️ new Context API\"></a>React’s ⚛️ new Context API</h1><p>这是一种更人性化的方式，不再是“实验性功能”，并且现在它是一级API。并且使用了 <code>render prop</code>!","date":"2018-02-12T16:27:34.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["react","context"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Mon Jul 24 2017 17:05:01 GMT+0000 (UTC)","title":"像 google 一样通过缩短 css 类名和作用域隔离来压缩优化 css 包的大小","path":"2017/07/24/reducing-css-bundle-size-by-cutting-the-class-names-and-using-scope-isolation.html","eyeCatchImage":null,"excerpt":"<h1 id=\"像-google-一样通过缩短-css-类名和作用域隔离来压缩优化-css-包的大小\"><a href=\"#像-google-一样通过缩短-css-类名和作用域隔离来压缩优化-css-包的大小\" class=\"headerlink\" title=\"像 google 一样通过缩短 css 类名和作用域隔离来压缩优化 css 包的大小\"></a>像 google 一样通过缩短 css 类名和作用域隔离来压缩优化 css 包的大小</h1><blockquote>\n<h2 id=\"就像-google-的做法一样\"><a href=\"#就像-google-的做法一样\" class=\"headerlink\" title=\"就像 google 的做法一样\"></a>就像 google 的做法一样</h2></blockquote>\n<p>今年年初，我已经退出咨询公司并开始构建 <a href=\"https://go2cinema.com/\" target=\"_blank\" rel=\"noopener\">GO2CINEMA</a> - 一个 <em>快速，简单和安全</em> 的方式来预订英国的电影票的网站。我做了一个辉煌的工作，使其快速，简单和安全。在其中某个阶段，我一直痴迷于关键渲染路径的优化。⚡️</p>\n<p>我已经使用 <a href=\"https://github.com/gajus/usus\" target=\"_blank\" rel=\"noopener\">ūsus</a> 解决了 HTML 的预渲染。ūsus 渲染单页应用程序（SPA）的 HTML，并<a href=\"https://medium.com/@gajus/pre-rendering-spa-for-seo-and-improved-perceived-page-loading-speed-47075aa16d24\" target=\"_blank\" rel=\"noopener\">内嵌了用于呈现页面的 CSS</a>。但是，我并不喜欢在每个 HTML 文档内嵌 70 KB 的 css，特别是其中大部分是 CSS 类名。</p>","date":"2017-07-24T17:05:01.000Z","pv":0,"totalPV":0,"categories":"css","tags":["react","webpack","css","minifier"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Sat Mar 05 2016 10:18:26 GMT+0000 (UTC)","title":"Fetch POST 接收不到数据，注意 content-type 的设置","path":"2016/03/05/resolve-fetch-post-no-response.html","eyeCatchImage":null,"excerpt":null,"date":"2016-03-05T10:18:26.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["fetch","content-type","POST"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Mon Mar 07 2016 00:58:03 GMT+0000 (UTC)","title":"搜索命令之locate、whereis、which、find、grep","path":"2016/03/07/search-command-locate-whereis-which-find-grep.html","eyeCatchImage":null,"excerpt":"<h1 id=\"搜索命令之locate、whereis、which、find、grep\"><a href=\"#搜索命令之locate、whereis、which、find、grep\" class=\"headerlink\" title=\"搜索命令之locate、whereis、which、find、grep\"></a>搜索命令之locate、whereis、which、find、grep</h1><h3 id=\"whereis\"><a href=\"#whereis\" class=\"headerlink\" title=\"whereis\"></a>whereis</h3><p>搜索命令所在路径及帮助文档所在位置</p>\n<p>选项：\n-b 只查找可执行文件\n-m 只查找帮助文件","date":"2016-03-07T00:58:03.000Z","pv":0,"totalPV":0,"categories":"linux","tags":["linux"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Fri Mar 04 2016 22:47:41 GMT+0000 (UTC)","title":"如何少埋坑-艾神分享会","path":"2016/03/04/share-from-mr.ai.html","eyeCatchImage":null,"excerpt":"<p>又很久没有记录东西了，真是个不自律的人- -！</p>\n<p>去年十月进入搜芽，感觉搜芽是一个共同成长的公司，有一种亲切感。这算是我第一次进一个前端团队比较大的公司，很多想法在分享与讨论中迸发。","date":"2016-03-04T22:47:41.000Z","pv":0,"totalPV":0,"categories":"workflow","tags":["review"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Thu Sep 21 2017 10:23:04 GMT+0000 (UTC)","title":"IphoneX 的缺口（小刘海）及其css样式解决方案","path":"2017/09/21/the-notch-and-css.html","eyeCatchImage":null,"excerpt":"<h1 id=\"IphoneX-的缺口（小刘海）及其css样式解决方案\"><a href=\"#IphoneX-的缺口（小刘海）及其css样式解决方案\" class=\"headerlink\" title=\"IphoneX 的缺口（小刘海）及其css样式解决方案\"></a>IphoneX 的缺口（小刘海）及其css样式解决方案</h1><p>苹果公司的 IphoneX 拥有了全面屏，只保留了‘小刘海’给摄像头和一些传感设备。结果就是让屏幕设计陷入尴尬的境地，就像限制网页有一个“安全区域”和白色边缘条。虽然没有太多的黑魔法去消除它，但给 <code>body</code> 设置一个 <code>background-color</code> 属性也可以做到。或者扩展网页以覆盖整个屏幕（该死的缺口），可以给 viewport 的 meta 标签添加 <code>viewport-fit=cover</code>。</p>\n<p><img src=\"https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1000,f_auto,q_auto/v1505590717/iphonex-safari_njxeiw.png\" alt=\"https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1000,f_auto,q_auto/v1505590717/iphonex-safari_njxeiw.png\">","date":"2017-09-21T10:23:04.000Z","pv":0,"totalPV":0,"categories":"css","tags":["viewport","css","iphoneX","notch"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Thu Jan 04 2018 15:02:18 GMT+0000 (UTC)","title":"从微信跳一跳看加密算法选择","path":"2018/01/03/through-wechat-t1t-think-about-crypto.html","eyeCatchImage":null,"excerpt":"<h1 id=\"通过微信小游戏跳一跳，看加密算法的选择\"><a href=\"#通过微信小游戏跳一跳，看加密算法的选择\" class=\"headerlink\" title=\"通过微信小游戏跳一跳，看加密算法的选择\"></a>通过微信小游戏跳一跳，看加密算法的选择</h1><p>近期微信更新，有跳一跳的游戏，并被网友找出源码并刷分，我也试了一下，成功刷了 1024。其中看到这个游戏使用了常用加密库 <code>crypto-js</code>（不支持RSA），它可以在浏览器端使用。而 nodejs 也有 <code>crypto</code> 模块，而且支持的加密算法更多。下面就来看看加密算法有哪些，并如何根据场景选择算法。","date":"2018-01-03T14:57:18.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["wechat","crypto","algorithm"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Tue Jul 04 2017 17:57:51 GMT+0000 (UTC)","title":"如何使用Memoize来缓存JavaScript函数结果并加快代码的速度","path":"2017/07/04/understanding-memoize-in-javascript.html","eyeCatchImage":null,"excerpt":"<p><code>Function</code> 是编程的组成部分。它们有助于为我们的代码增加模块化和可重用性。</p>\n<p>将程序划分为大块是很常见的功能，我们稍后可以使用这些功能来执行一些有用的操作。</p>\n<p>有时，多次调用功能可能会变得昂贵（比如，计算一个数字的阶乘的函数）。但是有一种方法可以优化这些功能，使它们执行得更快：<strong>缓存</strong>。","date":"2017-07-04T17:57:51.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["Memoize"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Wed Apr 04 2018 00:31:44 GMT+0000 (UTC)","title":"react 异步渲染的最新进展","path":"2018/04/04/update-on-async-rendering.html","eyeCatchImage":null,"excerpt":"<h1 id=\"react-异步渲染的最新进展\"><a href=\"#react-异步渲染的最新进展\" class=\"headerlink\" title=\"react 异步渲染的最新进展\"></a>react 异步渲染的最新进展</h1><p>一年多来，react 团队在实现异步渲染上做了许多工作。上个月的冰岛 JSConf 演讲上，Dan 揭晓了一些令人兴奋的解锁异步渲染的可能性。现在我们想与您分享一些我们研究这些功能时的一些经验，以及帮助你准备用于异步渲染的组件的一些秘诀。</p>\n<p>我们了解到的最大的教训就是我们传统的一些组件生命周期倾向于鼓励不安全的实践。它们是：</p>\n<ul>\n<li>componentWillMount</li>\n<li>componentWillReceiveProps</li>\n<li>componentWillUpdate</li>\n</ul>\n<p>这些生命周期经常被误解或不知不觉地误用。此外，我们预料到这些潜在的滥用可能会给异步渲染造成更多问题。因此，我们将会在接下来的版本给这些生命周期添加 “<code>UNSAFE_</code>” 前缀。（这里，“unsafe” 指的不是安全，而是想传达在这些生命周期里编程可能会在未来的 react 版本引起 bug，尤其是异步渲染开启的情况下。）","date":"2018-04-04T00:31:44.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["react","async rendering","lifecycle","getSnapshotBeforeUpdate","getDerivedStateFromProps"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Thu Jun 30 2016 22:41:14 GMT+0000 (UTC)","title":"使用ApplicationCache离线缓存做一个h5离线应用","path":"2016/06/30/use-ApplicationCache-to-build-html5-offline-web-app.html","eyeCatchImage":null,"excerpt":"<h1 id=\"使用ApplicationCache离线缓存做一个h5离线应用\"><a href=\"#使用ApplicationCache离线缓存做一个h5离线应用\" class=\"headerlink\" title=\"使用ApplicationCache离线缓存做一个h5离线应用\"></a>使用ApplicationCache离线缓存做一个h5离线应用</h1><p>原生app可以离线操作，在以前是相对web app的优势，web必须联网才能刷新使用。虽然所有浏览器都有缓存机制，但它们并不一定总能起到预期的作用。HTML5 使用 ApplicationCache 接口解决了由离线带来的部分难题。即使用户在离线状态下按了刷新按钮，您的应用也会正常加载和运行。","date":"2016-06-30T22:41:14.000Z","pv":0,"totalPV":0,"categories":"html","tags":["ApplicationCache","html5"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Mon Jun 05 2017 16:24:16 GMT+0000 (UTC)","title":"使用RXJS组合、过滤和映射数据流的值","path":"2017/06/05/use-RXJS-compose-filter-and-map-stream.html","eyeCatchImage":null,"excerpt":"<h1 id=\"使用RXJS组合、过滤和映射数据流的值\"><a href=\"#使用RXJS组合、过滤和映射数据流的值\" class=\"headerlink\" title=\"使用RXJS组合、过滤和映射数据流的值\"></a>使用RXJS组合、过滤和映射数据流的值</h1><h2 id=\"查询可观测序列\"><a href=\"#查询可观测序列\" class=\"headerlink\" title=\"查询可观测序列\"></a>查询可观测序列</h2><p>在<a href=\"https://robin-front.github.io/RxJS-doc-chinese/content/getting_started_with_rxjs/creating_and_querying_observable_sequences/bridging_to_events.md\">事件桥接</a> 一文中，我们将现有的DOM和Node.js事件转换成可观察的序列以订阅它们。在本主题中，我们将把可观察序列的父级class视为IObservable对象，其中Rx组件提供通用LINQ操作符来操作这些对象。大多数操作符获取可观察的序列并对其执行一些逻辑并输出另一个可观测序列。另外，从代码示例可以看出，甚至可以在源序列上使用多个运算符，最终将结果序列调整到您的确切需求。","date":"2017-06-05T16:24:16.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["RxJS"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Wed Jan 11 2017 09:13:00 GMT+0000 (UTC)","title":"javascript通过Vibration API实现手机振动反馈提高用户体验","path":"2017/01/10/use-javascript-vibration-feedback-to-improve-user-experience.html","eyeCatchImage":null,"excerpt":"<h1 id=\"javascript通过Vibration-API实现手机振动反馈提高用户体验\"><a href=\"#javascript通过Vibration-API实现手机振动反馈提高用户体验\" class=\"headerlink\" title=\"javascript通过Vibration API实现手机振动反馈提高用户体验\"></a>javascript通过Vibration API实现手机振动反馈提高用户体验</h1><p>目前大多数的移动设备均具备\b硬件能力支持振动，让软件代码通过使设备摇晃来向用户提供物理反馈。Vibration API \b为 Web应用程序提供访问此硬件的能力。如果设备不支持，则不会产生任何效果。","date":"2017-01-10T13:35:00.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["html5","Vibration"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Thu Oct 20 2016 17:35:22 GMT+0000 (UTC)","title":"使用 npm shrinkwrap 来管理项目依赖","path":"2016/10/20/use-npm-shrinkwrap-to-manage-reference-projects.html","eyeCatchImage":null,"excerpt":"<h1 id=\"使用-npm-shrinkwrap-来管理项目依赖\"><a href=\"#使用-npm-shrinkwrap-来管理项目依赖\" class=\"headerlink\" title=\"使用 npm shrinkwrap 来管理项目依赖\"></a>使用 npm shrinkwrap 来管理项目依赖</h1><p>管理依赖是一个复杂软件开发过程中必定会遇到的问题。</p>\n<p>在Node.js项目开发的时候，我们也经常需要安装和升级对应的依赖。虽然 npm 以及语意化的版本号 (semantic versioning, semver) 让开发过程中依赖的获取和升级变得非常容易， 但不严格的版本号限制，也带来了版本号的不确定性。主要的问题可能有三个：</p>\n<ul>\n<li>npm 建议使用 semver 的应用程序版本，但这也完全依赖第三方包遵守这一规则。如果你依赖于的包不遵循 semver ，或者依赖的包的新版本有重大更改（而你使用了 ^ 的宽泛版本安装），这潜在可能是会导致问题的。</li>\n<li>另一个问题的出现是由于 npm 安装依赖的机制。npm 的安装包是有层次结构的，手动控制要安装的软件包的版本号可以实现，但是你只能在 package.json 使用精确的版本号控制你的直接依赖包，但那些多层以上的依赖就没办法控制了；一个第三方包不严谨的版本依赖生命可能破坏你的依赖管理。</li>\n<li>在开发阶段执行得到的版本，和后续部署时得到的可能是不一致的，更不可控的是，你依赖的第三方包也有这样的情况会导致潜在的上线风险。</li>\n</ul>\n<p>如果要控制上线的风险，我们就必需要解决这个问题，这时候，就需要使用 npm shrinkwrap 这个命令来解决问题。","date":"2016-10-20T17:35:22.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["npm","shrinkwrap"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Thu Nov 16 2017 07:31:59 GMT+0000 (UTC)","title":"使用 react 16 portal 做一些很酷的事情","path":"2017/11/16/using-a-react-16-portal-to-do-something-cool.html","eyeCatchImage":null,"excerpt":"<p>React 16 已经发布了，其中一个很有趣的是添加了 “Portals”。</p>\n<p>Portals 可以让你在父组件外渲染 react 受控 DOM 节点。<a href=\"https://reactjs.org/docs/portals.html\" target=\"_blank\" rel=\"noopener\">react doc</a> 也使用了一个模态框的例子很好地解释了它。用也做 tooltips 也很合适（这是我<a href=\"https://codepen.io/davidgilbertson/pen/ooXVyw\" target=\"_blank\" rel=\"noopener\">早前做的一个例子</a>）。</p>\n<p>但这些都并不是很有趣，让我们做一些更不可思议的事情…","date":"2017-11-16T07:31:59.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["react","portal"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Thu Dec 21 2017 16:43:36 GMT+0000 (UTC)","title":"css counters 计数器","path":"2017/12/21/using-css-counters.html","eyeCatchImage":null,"excerpt":"<h1 id=\"让-css-像编程语言一样实现计数，IE-8-也支持的-css-计数器\"><a href=\"#让-css-像编程语言一样实现计数，IE-8-也支持的-css-计数器\" class=\"headerlink\" title=\"让 css 像编程语言一样实现计数，IE 8 也支持的 css 计数器\"></a>让 css 像编程语言一样实现计数，IE 8 也支持的 css 计数器</h1><p><code>css counters</code> 是一个我们可以利用特定属性增减计算的变量。通过它，我们可以做一些类似编程语言的通用的迭代。</p>\n<p>这个方式可以用于一些创造性的解决方案，包括一些重复代码的计数器。","date":"2017-12-21T16:43:36.000Z","pv":0,"totalPV":0,"categories":"css","tags":["css counters"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Fri Aug 25 2017 15:40:26 GMT+0000 (UTC)","title":"使用 requestIdleCallback","path":"2017/08/25/using-requestIdleCallback.html","eyeCatchImage":null,"excerpt":"<h1 id=\"使用-requestIdleCallback\"><a href=\"#使用-requestIdleCallback\" class=\"headerlink\" title=\"使用 requestIdleCallback\"></a>使用 requestIdleCallback</h1><p>许多网站和应用程序都有很多脚本来执行。您的 JavaScript 通常需要尽快运行，但同时您不希望它阻碍用户那条路。如果您在用户滚动页面时发送分析数据，或者在轻触按钮时将元素附加到 DOM，则您的 Web 应用程序将无法响应，从而导致用户体验不佳。</p>\n<p><img src=\"https://developers.google.com/web/updates/images/2015-08-27-using-requestidlecallback/main.png\" alt=\"https://developers.google.com/web/updates/images/2015-08-27-using-requestidlecallback/main.png\"></p>\n<p>好消息是，现在有一个 API 可以帮助：<code>requestIdleCallback</code>。以同样的方式，<code>requestAnimationFrame</code> 我们可以正确地安排动画，并最大限度地提高 60fps 的机会，<code>requestIdleCallback</code> 当一个框架结束时，或当用户处于非活动状态时，可以安排工作。这意味着有机会在用户不使用的情况下进行工作。它可用于 Chrome 47！这是一个实验性的功能，规格还在不断变化，所以将来会发生变化。","date":"2017-08-25T15:40:26.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["performance","optimization","requestIdleCallback"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Mon Aug 08 2016 17:08:53 GMT+0000 (UTC)","title":"webpack-sourcemap选项应该选哪个","path":"2016/08/08/webpack-sourcemap-options.html","eyeCatchImage":null,"excerpt":"<h1 id=\"webpack-sourcemap选项应该选哪个\"><a href=\"#webpack-sourcemap选项应该选哪个\" class=\"headerlink\" title=\"webpack-sourcemap选项应该选哪个\"></a>webpack-sourcemap选项应该选哪个</h1><p>使用 webpack 也有一段时间了，但是每次看到别的项目配置，还是会去浏览一遍。这次刚好看到一个 <code>devtool: &#39;#eval-source-map&#39;</code>，就有些好奇，之前都是默认使用 <code>#source-map</code> 并没有过多去注意它。google一下，发现这个 devtool 选项还不少，那我们到底选哪个呢，它们有哪些区别。","date":"2016-08-08T17:08:53.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["webpack","前端构建","sourcemap"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Thu Jun 22 2017 15:35:55 GMT+0000 (UTC)","title":"webpack3官方正式发布,亮点:作用域提升，“魔法注释”，以及更多新特性！","path":"2017/06/21/webpack3-publish-scope-hoisting-magic-comments-and-more.html","eyeCatchImage":null,"excerpt":"<h1 id=\"作用域提升，“魔法注释”，以及更多新特性！\"><a href=\"#作用域提升，“魔法注释”，以及更多新特性！\" class=\"headerlink\" title=\"作用域提升，“魔法注释”，以及更多新特性！\"></a>作用域提升，“魔法注释”，以及更多新特性！</h1><p><a href=\"https://medium.com/webpack/webpack-3-official-release-15fd2dd8f07b\" target=\"_blank\" rel=\"noopener\">原文</a></p>\n<p>在我们发布了 webpack v2 之后，我们曾向社区做了一些承诺。 我们承诺，我们将提供用户投票的功能。 此外，我们承诺我们的发布周期会 <strong>更快，更稳定</strong>。</p>\n<p>这次没有 beta 版本，完全向下兼容。我们承诺让你们、让 webpack 成长的社区更轻松的使用。webpack 团队自豪地宣布，今天我们已经发布了 webpack 3.0.0！ 现在就可以下载或升级！</p>\n<pre><code class=\"bash\">npm install webpack@3.0.0 --save-dev\n</code></pre>\n<p>或者使用</p>\n<pre><code class=\"bash\">yarn add webpack@3.0.0 --dev\n</code></pre>\n<p><em>从 webpack 2 迁移到 3，只需要执行升级命令，在使用上没有任何差别。我们将这次升级标记为版本的重大升级，是因为内部的突破性变化可能会影响某些插件的使用。</em></p>\n<p><strong>到目前为止，98%的升级的用户都没有遇到任何不兼容！</strong>","date":"2017-06-21T15:35:55.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["webpack","前端构建"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Wed Apr 05 2017 17:06:03 GMT+0000 (UTC)","title":"学习RxJS需要知道的奇淫技巧","path":"2017/04/05/what-you-need-to-know-about-RxJS.html","eyeCatchImage":null,"excerpt":"<h1 id=\"学习RxJS需要知道的奇淫技巧\"><a href=\"#学习RxJS需要知道的奇淫技巧\" class=\"headerlink\" title=\"学习RxJS需要知道的奇淫技巧\"></a>学习RxJS需要知道的奇淫技巧</h1><h3 id=\"尝试画珠宝图\"><a href=\"#尝试画珠宝图\" class=\"headerlink\" title=\"尝试画珠宝图\"></a>尝试画珠宝图</h3><p>为你想创建的流画一个珠宝图。 通过画珠宝图，你将会很清楚你应该使用哪些操作符。</p>\n<p>珠宝图就是每个珠宝表示当前的一个事件或状态。珠宝图需要包含输入和输出流。</p>\n<p><img src=\"https://raw.githubusercontent.com/Reactive-Extensions/RxJS/master/doc/designguidelines/images/throttleWithTimeout.png\" alt=\"throttleWithSelector\"></p>","date":"2017-04-05T17:06:03.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["RxJS"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Thu Jun 01 2017 10:48:00 GMT+0000 (UTC)","title":"Marko和react,preact,vue相比快在哪里","path":"2017/06/01/why-Marko-faster-than-react-preact-vue.html","eyeCatchImage":null,"excerpt":"<h1 id=\"Marko和react-preact-vue相比快在哪里\"><a href=\"#Marko和react-preact-vue相比快在哪里\" class=\"headerlink\" title=\"Marko和react,preact,vue相比快在哪里\"></a>Marko和react,preact,vue相比快在哪里</h1><p>在eBay，我们正在使用<code>[Marko](http://markojs.com/)</code>每天处理超过十亿的请求，这就要求我们精简我们的开源UI库Marko。我们大大优化了Marko ，以实现快速渲染，<a href=\"http://www.ebaytechblog.com/2014/12/08/async-fragments-rediscovering-progressive-html-rendering-with-marko/\" target=\"_blank\" rel=\"noopener\">高级性能技术</a>，并实现了最小的页面重量（〜10kb gzipped）。性能只是一个方面，因为我们还必须扩展Marko以支持数百个团队的开发，从而允许开发人员有效地创建可维护和强大的Web应用程序。</p>\n<p>我们已经创建了我们自己的<a href=\"https://github.com/marko-js/isomorphic-ui-benchmarks\" target=\"_blank\" rel=\"noopener\">benchMarks</a>进行比较，也已经将Marko添加到<a href=\"https://github.com/raxjs/server-side-rendering-comparison/pull/11\" target=\"_blank\" rel=\"noopener\">其他基准测试</a>中，但是基准测试并不总是值得信赖的。尽管我们尽可能公平地对待我们的基准，但最重要的是在现实世界的应用中的表现，而不是专注于微观基准。这就是V8团队转而采用新的方法来衡量和理解现实JavaScript性能的一个原因。</p>\n<p>同样，我们已经观察过我们的开发人员实际开发中如何编写他们的Marko组件，并且发现了可以进一步优化的模式。而不是关注本文中的基准测试，我想关注我们应用于Marko的优化细节。","date":"2017-06-01T10:48:00.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["Marko"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Tue Apr 04 2017 17:48:15 GMT+0000 (UTC)","title":"为什么选择 RxJS?","path":"2017/04/04/why-rxjs.html","eyeCatchImage":null,"excerpt":"<h2 id=\"Why-RxJS\"><a href=\"#Why-RxJS\" class=\"headerlink\" title=\"Why RxJS?\"></a>Why RxJS?</h2><p>你可能会问，为什么选择 RxJS?  为什么不是 Promises? Promises 可以很好地解决异步操作，像使用 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\" target=\"_blank\" rel=\"noopener\">XMLHttpRequest</a> 去查询服务器, 它预期会返回值并且最终完成请求。  <code>The Reactive Extensions</code> 统一了 <code>JavaScript</code> 中的 <code>Promises</code>, <code>callbacks</code> 以及事件数据，比如 DOM输入, <code>Web Workers</code>, <code>Web Sockets</code>. 一旦我们统一了这些概念，就可以进行各种各样的组合.</p>","date":"2017-04-04T17:48:15.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["RxJS"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Tue Jul 11 2017 16:02:47 GMT+0000 (UTC)","title":"为什么我停止使用多个显示器","path":"2017/07/11/why-should-stopped-using-multiple-monitors.html","eyeCatchImage":null,"excerpt":"<p>许多开发人员认为多个显示器可以提高生产力。研究证明是这样，对吧？那么，请记住，许多这些研究是由戴尔和NEC等监控制造商委托进行的。🤔</p>\n<p>尽管多个显示器使您看起来像一个重度的计算机使用者，但我在几年前卖了我的多显示器，并切换到一个监视器。而且我并不是一个人。</p>\n<p>下面就是为什么。","date":"2017-07-11T16:02:47.000Z","pv":0,"totalPV":0,"categories":"workflow","tags":["performance"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Fri Jul 28 2017 09:17:36 GMT+0000 (UTC)","title":"你可能不知道的JSON用法及误区","path":"2017/07/28/you-may-dont-know-JSON.html","eyeCatchImage":null,"excerpt":"<h1 id=\"再谈-JSON-你可能不知道的一些-JSON-用法及误区\"><a href=\"#再谈-JSON-你可能不知道的一些-JSON-用法及误区\" class=\"headerlink\" title=\"再谈 JSON, 你可能不知道的一些 JSON 用法及误区\"></a>再谈 JSON, 你可能不知道的一些 JSON 用法及误区</h1><p>最近也是看到很多人在讨论 <code>JSON</code>, 但有些点说得不太准确，翻翻犀牛书，再次复习一下。</p>\n<h2 id=\"JSON-stringify-value-replacer-space\"><a href=\"#JSON-stringify-value-replacer-space\" class=\"headerlink\" title=\"JSON.stringify(value [, replacer [, space]])\"></a>JSON.stringify(value [, replacer [, space]])</h2><p>第一个参数一般是对象（Object）或数组（Array），或 <code>javascript</code> 基本值。</p>\n<h3 id=\"误区：不支持的值都会被忽略\"><a href=\"#误区：不支持的值都会被忽略\" class=\"headerlink\" title=\"误区：不支持的值都会被忽略\"></a>误区：不支持的值都会被忽略</h3><p><strong>首先 JSON 只能序列化可枚举的值，其次 <code>undefined</code>，<code>NaN</code>，<code>Infinity</code>，<code>function</code>, <code>Date</code>, <code>RegExp</code>, <code>Error</code> 这些值或对象都是不支持的，但并不是这些值都会被忽略。</strong>","date":"2017-07-28T09:17:36.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["JSON"],"internalLinks":[],"keywords":[],"keywordsLength":0},{"updated":"Wed Oct 25 2017 17:04:54 GMT+0000 (UTC)","title":"你可能并不需要 redux","path":"2017/10/25/you-might-not-need-redux.html","eyeCatchImage":null,"excerpt":"<h1 id=\"你可能并不需要-redux\"><a href=\"#你可能并不需要-redux\" class=\"headerlink\" title=\"你可能并不需要 redux\"></a>你可能并不需要 redux</h1><p><strong>人们常常在真正需要用到 redux 之前就选择了它。</strong> “如果我们的应用没有使用 redux，变得不好扩展怎么办？” 后来，开发者们又都皱着眉头指头他们的代码间接地评论 redux.“为什么实现一个小功能需要更改三个文件？” 为什么一定要用 redux 呢!","date":"2017-10-25T17:04:54.000Z","pv":0,"totalPV":0,"categories":"javascript","tags":["react","redux"],"internalLinks":[],"keywords":[],"keywordsLength":0}]}]