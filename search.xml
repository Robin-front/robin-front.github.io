<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[keep-alive vs http2]]></title>
    <url>%2F2018%2F04%2F10%2Fkeep-alive-vs-http2.html</url>
    <content type="text"><![CDATA[我们经常谈论 http2 与 http1.1，却经常忽视一些细节的区别。最近谈到 keep-alive 与 http2 链路复用的区别。虽然我知道 http2 的多路复用技术是源自通信工程里的时分复用，但对 keep-alive 的复用却有些模糊。下面看来这些技术之间的进化。 keep-alive 有很多文章都说 http2 相比 http1.1 增加了连接复用。这句话其实是不准确的。 在 HTTP 1.1 中 所有的连接默认都是持续连接，除非特殊声明不支持。 而在 http1.0 中，官方没有支持 keep-alive, 通常会手动在请求头中添加 Connection: Keep-Alive。 keep-alive 就是 TCP 连接复用的开端。改善的效果就是不再重新建立TCP连接，省去 三次握手 的时间。如下图： 优势有： 较少的CPU和内存的使用（由于同时打开的连接的减少了） 允许请求和应答的HTTP管线化 降低拥塞控制 （TCP连接减少了） 减少了后续请求的延迟（无需再进行握手） 报告错误无需关闭TCP连接 http pipelining有些文章中会有一个误区，就是TCP连接必须等一个请求响应完成后，才能复用。这是不对的，但其实可以注意上面优势里提到到 http pipelining，如下图： HTTP1.1 中，一个TCP连接里是可以同时发送（实际有先后，但可以在响应前）多个请求的。但它是有序的，遵循先进先出，服务端只能按顺序响应请求（如果前面的请求没有响应完成或需要很长时间，后面的请求就会被阻塞），所以可能发生 队头阻塞（HOL blocking），造成延迟。 连续的 GET 和 HEAD 请求总可以管线化的。一个连续的幂等请求，如 GET，HEAD，PUT，DELETE，是否可以被管线化取决于一连串请求是否依赖于其他的。 所以keep-alive 的劣势也很明显： Keep-Alive可能会极大的影响服务器性能，因为它在文件被请求之后还保持了不必要的连接很长时间 可能发生队头阻塞（HOL blocking），造成延迟 HTTP2HTTP2 主要解决的问题也是 TCP连接复用。但它比 keep-alive 更彻底，类似于通信工程里的时分复用，多个请求可以同时发送（不分先后），同时响应，解决了 队头阻塞（HOL blocking）的问题，极大提高效率。 keep-alive 的 HTTP pipelining 相当于单线程的，而 HTTP2 相当于并发。 HTTP2 的优点： 对HTTP头字段进行数据压缩(即HPACK算法)； HTTP/2 服务端推送(Server Push)； 请求管线化； 修复HTTP/1.0版本以来未修复的 队头阻塞 问题； 对数据传输采用多路复用，让多个请求合并在同一 TCP 连接内。 后三个优点其实都是 多路复用 带来的优点。]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>http2</tag>
        <tag>keep-alive</tag>
        <tag>HOL blocking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react 异步渲染的最新进展]]></title>
    <url>%2F2018%2F04%2F04%2Fupdate-on-async-rendering.html</url>
    <content type="text"><![CDATA[react 异步渲染的最新进展一年多来，react 团队在实现异步渲染上做了许多工作。上个月的冰岛 JSConf 演讲上，Dan 揭晓了一些令人兴奋的解锁异步渲染的可能性。现在我们想与您分享一些我们研究这些功能时的一些经验，以及帮助你准备用于异步渲染的组件的一些秘诀。 我们了解到的最大的教训就是我们传统的一些组件生命周期倾向于鼓励不安全的实践。它们是： componentWillMount componentWillReceiveProps componentWillUpdate 这些生命周期经常被误解或不知不觉地误用。此外，我们预料到这些潜在的滥用可能会给异步渲染造成更多问题。因此，我们将会在接下来的版本给这些生命周期添加 “UNSAFE_” 前缀。（这里，“unsafe” 指的不是安全，而是想传达在这些生命周期里编程可能会在未来的 react 版本引起 bug，尤其是异步渲染开启的情况下。） 逐步迁移之路react 遵循语义版本控制，所以这个改变将是逐步的。我们当前的计划是： 16.3：介绍不安全的生命周期别名，UNSAFE_componentWillMount, UNSAFE_componentWillReceiveProps, 和 UNSAFE_componentWillUpdate。 (旧的生命周期名和新的别名会在这个版本同时有效。) 之后的 16.x 版本： 对 componentWillMount, componentWillReceiveProps, and componentWillUpdate 开启警告提示。（旧的生命周期名和新的别名会在这个版本同时有效，但旧的名称在开发模式下将会有 log 警告） 17.0: 完全移除 componentWillMount, componentWillReceiveProps, and componentWillUpdate。（从这个版本开始，只有新的 “UNSAFE_” 生命周期名称有效） 注意，如果你是一个 react 应用开发者，你还不需要对传统的方法做任何改变。即将发布的 16.3 版本主要的意图是，让开源项目维护人员在任何弃用警告之前更新其库。这些警告还不会生效，直到之后的16.x版本 我们在 Facebook 维护着超过 50，000 个 react 组件， 并且我们并没有计划立即重写它们。我们明白迁移需要时间。我们会带领 react 社区的每一个人逐步迁移。 从旧的生命周期迁移如果你想要在 react 16.3 版本使用上面介绍的新 APIs（或者如果你是一个维护者，想提前更新你的库），这里有一些示例希望能帮助你从另一个角度思考组件。之后，我们计划添加一些“秘诀” 到我们的文档中，以此展示如何以避免有问题的生命周期的方式编写普通业务。 在开始之前，快速回顾一下 16.3 版本所计划的生命周期的变更： 添加以下别名： UNSAFE_componentWillMount, UNSAFE_componentWillReceiveProps, and UNSAFE_componentWillUpdate（新旧生命周期同时支持） 介绍两个新的生命周期， 静态方法 getDerivedStateFromProps and getSnapshotBeforeUpdate. 新生命周期： getDerivedStateFromPropsclass Example extends React.Component { static getDerivedStateFromProps(nextProps, prevState) { // ... } } 这个新的静态生命周期方法 getDerivedStateFromProps 是在组件实例化之后被调用，同时接收新的 props 作为参数。它可以返回一个对象去更新 state, 或者返回 null 来表明这个新的 props 不需要更新任何 state。 和 componentDidUpdate 一起，这个新生命周期应该覆盖传统的 componentWillReceiveProps 方法的所有用例。 新生命周期： getSnapshotBeforeUpdateclass Example extends React.Component { getSnapshotBeforeUpdate(prevProps, prevState) { // ... } } 这个新生命周期 getSnapshotBeforeUpdate 会在突变之前（比如DOM更新之前）调用。这个方法的返回值将会作为第三个参数传递到 componentDidUpdate。 （这个生命周期并不常用，但对于 rerender 期间手动保留滚动位置非常有用。） 与 componentDidUpdate 一起，这个新生命周期应该覆盖传统的 componentWillUpdate 方法的所有用例。 在这个 gist 里可以找到它们的类型签名。 下面我们用一些示例展示如何使用这两个新的生命周期。 新生命周期示例初始化 state这个例子展示了一个组件在 componentWillMount 里面调用了 setState: // Before class ExampleComponent extends React.Component { state = {}; componentWillMount() { this.setState({ currentColor: this.props.defaultColor, palette: 'rgb', }); } } 简单地将 state 初始化移动到 constructor 或者 属性初始化的位置来重构这个组件，看起来像这样： // After class ExampleComponent extends React.Component { state = { currentColor: this.props.defaultColor, palette: 'rgb', }; } 获取外部数据下面是一个组件在 componentWillMount 里面获取数据的例子： // Before class ExampleComponent extends React.Component { state = { externalData: null, }; componentWillMount() { this._asyncRequest = asyncLoadData().then( externalData => { this._asyncRequest = null; this.setState({externalData}); } ); } componentWillUnmount() { if (this._asyncRequest) { this._asyncRequest.cancel(); } } render() { if (this.state.externalData === null) { // Render loading state ... } else { // Render real UI ... } } } 上面的代理在服务端渲染（外部数据还没有用到）和即将到来的异步渲染模式（请求可能发送多次）两种情况下都会有问题。 对于大部分情况，推荐将数据获取移到 componentDidMount: // After class ExampleComponent extends React.Component { state = { externalData: null, }; componentDidMount() { this._asyncRequest = asyncLoadData().then( externalData => { this._asyncRequest = null; this.setState({externalData}); } ); } componentWillUnmount() { if (this._asyncRequest) { this._asyncRequest.cancel(); } } render() { if (this.state.externalData === null) { // Render loading state ... } else { // Render real UI ... } } } 这里普遍的误解是，在 componentWillMount 里获取数据可以避免渲染空的状态。在实际中，这从来都是不对的，因为 react 总是在 componentWillMount 之后立即执行 render。如果数据在 componentWillMount 调用的时候还不可用，那么第一次 render 也仍然显示加载状态，而不管你在哪里获取数据。这就是为什么在绝大多数情况下，将数据获取移到 componentDidMount 是感受不到差别的。 注意： 一些高级用例(比如像 Relay 这样的库)可能想要预读取异步数据。这个示例展示了它是如何成为可能的。 从长远来看，这个在 react 组件中获取数据的典例将可能基于冰岛 JSConf 介绍的 “suspense” API。简单的数据获取方案和像 Apollo、 Relay这样的库将可以使用这个钩子。这比上面任何一个解决方案都更简洁，但在 16.3 版本发布时还不能敲定。 需要支持服务端渲染的时候，当前很有必要提供同步的数据 —— componentWillMount 经常被用于这个目的，但 constructor 其实可以替代它。即将到来的 suspense APIs 将会让服务端和客户端的异步数据获取尽可能地清晰。 添加事件监听（或订阅）下面是一个在 mounting 订阅事件的组件示例: // Before class ExampleComponent extends React.Component { componentWillMount() { this.setState({ subscribedValue: this.props.dataSource.value, }); // This is not safe; it can leak! this.props.dataSource.subscribe( this.handleSubscriptionChange ); } componentWillUnmount() { this.props.dataSource.unsubscribe( this.handleSubscriptionChange ); } handleSubscriptionChange = dataSource => { this.setState({ subscribedValue: dataSource.value, }); }; } 不幸的是， 这会造成服务端（componentWillUnmount 永远都不会被调用）和异步渲染（在渲染完成之前可能会被中断，造成 componentWillUnmount 没有被调用）的内存泄漏。 有人经常假设 componentWillMount 和 componentWillUnmount 是对应存在的，这其实不能保证。只有 componentDidMount 被调用之后，react 才能保证 componentWillUnmount 会在清除时被调用。 因此，推荐在 componentDidMount 中添加事件监听和订阅。 // After class ExampleComponent extends React.Component { state = { subscribedValue: this.props.dataSource.value, }; componentDidMount() { // Event listeners are only safe to add after mount, // So they won't leak if mount is interrupted or errors. this.props.dataSource.subscribe( this.handleSubscriptionChange ); // External values could change between render and mount, // In some cases it may be important to handle this case. if ( this.state.subscribedValue !== this.props.dataSource.value ) { this.setState({ subscribedValue: this.props.dataSource.value, }); } } componentWillUnmount() { this.props.dataSource.unsubscribe( this.handleSubscriptionChange ); } handleSubscriptionChange = dataSource => { this.setState({ subscribedValue: dataSource.value, }); }; } 有时更新订阅以便响应属性变化是很重要的。如果你使用 redux or mobx， 这些库的容器组件应该做这些事。对于应用作者，我们创建了一个小巧的库，create-subscription 来帮助做这些事。它将会和 react v16.3 一起发布。 比起上面那样传递一个可订阅的 dataSource 属性，我们也可以使用 create-subscription 去传递订阅的值： import {createSubscription} from 'create-subscription'; const Subscription = createSubscription({ getCurrentValue(sourceProp) { // Return the current value of the subscription (sourceProp). return sourceProp.value; }, subscribe(sourceProp, callback) { function handleSubscriptionChange() { callback(sourceProp.value); } // Subscribe (e.g. add an event listener) to the subscription (sourceProp). // Call callback(newValue) whenever a subscription changes. sourceProp.subscribe(handleSubscriptionChange); // Return an unsubscribe method. return function unsubscribe() { sourceProp.unsubscribe(handleSubscriptionChange); }; }, }); // Rather than passing the subscribable source to our ExampleComponent, // We could just pass the subscribed value directly: &lt;Subscription source={dataSource}> {value => &lt;ExampleComponent subscribedValue={value} />} &lt;/Subscription>; 注意： 像 Relay/Apollo 这样的库应该手动地使用 create-subscription 相同的技术去管理订阅（参考）以适合这些库的最佳实践。 基于 props 更新 state下面是一个使用传统 componentWillReceiveProps 方法来更新基于 props 的 state 的示例： // Before class ExampleComponent extends React.Component { state = { isScrollingDown: false, }; componentWillReceiveProps(nextProps) { if (this.props.currentRow !== nextProps.currentRow) { this.setState({ isScrollingDown: nextProps.currentRow > this.props.currentRow, }); } } } 虽然上面的代码本身没有问题，但 componentWillReceiveProps 经常被误用来解决当下的一些问题。因此，这个方法将会被弃用。 从 16.3 版本开始，推荐使用新的 静态方法 getDerivedStateFromProps 来更新基于 props 的 state.(这个生命周期将在组件被创建后和每次接收到新 props 的时候被调用)： // After class ExampleComponent extends React.Component { // Initialize state in constructor, // Or with a property initializer. state = { isScrollingDown: false, lastRow: null, }; static getDerivedStateFromProps(nextProps, prevState) { if (nextProps.currentRow !== prevState.lastRow) { return { isScrollingDown: nextProps.currentRow > prevState.lastRow, lastRow: nextProps.currentRow, }; } // Return null to indicate no change to state. return null; } } 你可能注意到上面的例子中 props.currentRow 被映射到 state( 作为 state.lastRow)。这允许 getDerivedStateFromProps 和 componentWillReceiveProps 那样可以访问上一个 props 的值。 你可能想知道为什么我们不简单地将先前的 props 作为参数传递给 getDerivedStateFromProps。我们在设计API时考虑过这个问题，但因为两点原因推翻这个想法： prevProps 参数在第一次调用 getDerivedStateFromProps (实例化后)时会是 null。 需要在每次访问 prevProps 时判断 if-not-null。 在未来版本的 react 中，不传递先前的 props 到这个函数是释放内存的一步。（如果 react 不需要传递 prevProps 到生命周期，内存中就不需要保持 prevProps 的引用。） 注意： 如果你正在写一个公共组件，react-lifecycles-compat polyfill 允许在旧版本的 react 中使用新生命周期方法 getDerivedStateFromProps。 调用外部回调这是一个当内部 state 改变时调用外部回调的组件： // Before class ExampleComponent extends React.Component { componentWillUpdate(nextProps, nextState) { if ( this.state.someStatefulValue !== nextState.someStatefulValue ) { nextProps.onChange(nextState.someStatefulValue); } } } 有时候，大家使用 componentWillUpdate 的一个误点是：认为 componentDidUpdate 触发的时机“太晚了”， 不能及时更新其他组件。其实不是这样。 react 确保 componentDidMount 和 componentDidUpdate 期间调用的任何 setState 会在用户看到UI更新之前执行完。一般来说，像这样这很容易避免级联更新，但某些情况下这是必要的（举个例子，如果你需要在测量已渲染的 DOM 元素后定位一个提示框）。 无论哪种方式，在异步模式下为了这个目的去使用 componentWillUpdate 是不安全的，因为外部回调可能会在一次更新中被调用多次。相反，应该使有和componentDidUpdate 方法替代，因为它能保证每次更新只被调用一次： // After class ExampleComponent extends React.Component { componentDidUpdate(prevProps, prevState) { if ( this.state.someStatefulValue !== prevState.someStatefulValue ) { this.props.onChange(this.state.someStatefulValue); } } } 副作用的 on props change和上面的例子相似，有时候当组件 props 改变时会有副作用。 // Before class ExampleComponent extends React.Component { componentWillReceiveProps(nextProps) { if (this.props.isVisible !== nextProps.isVisible) { logVisibleChange(nextProps.isVisible); } } } 类似 componentWillUpdate, componentWillReceiveProps 方法可能会在单次更新中被调用多次。因此，在这些方法里避免使用有副作用的函数是很重要的。相反，应该使有和componentDidUpdate 方法替代，因为它能保证每次更新只被调用一次： // After class ExampleComponent extends React.Component { componentDidUpdate(prevProps, prevState) { if (this.props.isVisible !== prevProps.isVisible) { logVisibleChange(this.props.isVisible); } } } 当 props 改变时获取外部数据这是一个当 props 改变时获取外部数据的组件示例： // Before class ExampleComponent extends React.Component { state = { externalData: null, }; componentDidMount() { this._loadAsyncData(this.props.id); } componentWillReceiveProps(nextProps) { if (nextProps.id !== this.props.id) { this.setState({externalData: null}); this._loadAsyncData(nextProps.id); } } componentWillUnmount() { if (this._asyncRequest) { this._asyncRequest.cancel(); } } render() { if (this.state.externalData === null) { // Render loading state ... } else { // Render real UI ... } } _loadAsyncData(id) { this._asyncRequest = asyncLoadData(id).then( externalData => { this._asyncRequest = null; this.setState({externalData}); } ); } } 推荐升级成使用 componentDidUpdate 更新数据。也可以使用新生命周期 getDerivedStateFromProps 在渲染新 props 时清理旧数据： // After class ExampleComponent extends React.Component { state = { externalData: null, }; static getDerivedStateFromProps(nextProps, prevState) { // Store prevId in state so we can compare when props change. // Clear out previously-loaded data (so we don't render stale stuff). if (nextProps.id !== prevState.prevId) { return { externalData: null, prevId: nextProps.id, }; } // No state update necessary return null; } componentDidMount() { this._loadAsyncData(this.props.id); } componentDidUpdate(prevProps, prevState) { if (this.state.externalData === null) { this._loadAsyncData(this.props.id); } } componentWillUnmount() { if (this._asyncRequest) { this._asyncRequest.cancel(); } } render() { if (this.state.externalData === null) { // Render loading state ... } else { // Render real UI ... } } _loadAsyncData(id) { this._asyncRequest = asyncLoadData(id).then( externalData => { this._asyncRequest = null; this.setState({externalData}); } ); } } 注意： 如果你使用的 HTTP 库支持取消功能，比如 axios，只需要在 unmount 的时候简单地取消一个正在处理的请求。对于原生 Promise, 你可以用这样的解决方案。 在更新前读取 DOM 属性这是一个在更新前读取 DOM 属性以便维护列表的滚动位置的组件示例： class ScrollingList extends React.Component { listRef = null; previousScrollHeight = null; componentWillUpdate(nextProps, nextState) { // Are we adding new items to the list? // Capture the current height of the list so we can adjust scroll later. if (this.props.list.length &lt; nextProps.list.length) { this.previousScrollHeight = this.listRef.scrollHeight; } } componentDidUpdate(prevProps, prevState) { // If previousScrollHeight is set, we've just added new items. // Adjust scroll so these new items don't push the old ones out of view. if (this.previousScrollHeight !== null) { this.listRef.scrollTop += this.listRef.scrollHeight - this.previousScrollHeight; this.previousScrollHeight = null; } } render() { return ( &lt;div ref={this.setListRef}> {/* ...contents... */} &lt;/div> ); } setListRef = ref => { this.listRef = ref; }; } 在上面的示例中， 在 componentWillUpdate 中读取 DOM 属性。但是在异步渲染中，这可能被延迟到 “render” 阶段（像 componentWillUpdate and render）和 “commit” 阶段(像 componentDidUpdate)才执行。如果用户在这期间做了一些类似调整窗口大小，从 componentWillUpdate 中读取的 scrollHeight 值会是旧的。 这个问题的解决方案就是使用新的 “commit” 阶段的生命周期事件，getSnapshotBeforeUpdate。这个方当会在变更产生后立即被调用（比如在 DOM 被更新之前）。它可以返回一个值并作为参数传到 componentDidUpdate。 这两个生命周期可以像下面这样用： class ScrollingList extends React.Component { listRef = null; getSnapshotBeforeUpdate(prevProps, prevState) { // Are we adding new items to the list? // Capture the current height of the list so we can adjust scroll later. if (prevProps.list.length &lt; this.props.list.length) { return this.listRef.scrollHeight; } return null; } componentDidUpdate(prevProps, prevState, snapshot) { // If we have a snapshot value, we've just added new items. // Adjust scroll so these new items don't push the old ones out of view. // (snapshot here is the value returned from getSnapshotBeforeUpdate) if (snapshot !== null) { this.listRef.scrollTop += this.listRef.scrollHeight - snapshot; } } render() { return ( &lt;div ref={this.setListRef}> {/* ...contents... */} &lt;/div> ); } setListRef = ref => { this.listRef = ref; }; } 注意： 如果你正在写一个公共组件，react-lifecycles-compat polyfill 允许在旧版本的 react 中使用新生命周期方法 getSnapshotBeforeUpdate。 其他场景尽管我们试图在这篇文章中涵盖最常见的用例，我们承认我们可能错过了一些。如果这篇博客里有你使用 componentWillMount, componentWillUpdate, or componentWillReceiveProps 却没提到的案例，并步不确定如何迁移，可以留下评论和示例。 开源维护者开源维护者可能比较想知道这些改变对开源组件意味着什么。如果你实现了上述建议，依赖于新静态生命周期事件 getDerivedStateFromProps 会发生什么？ 你是否不复不发布一个新的主版本并兼容 react 16.2及更老版本？ 好消息是，不需要！ 当 react 16.3 发布时，我们也会发布一个新的 npm 包， react-lifecycles-compat。 这个包提供了 polyfill 以便你能在老版本的 react（0.14.9+）使用新的生命周期事件 getDerivedStateFromProps and getSnapshotBeforeUpdate。 要使用这个 polyfill, 请先安装依赖到你的库： # Yarn yarn add react-lifecycles-compat # NPM npm install react-lifecycles-compat --save 接着使用新的生命周期事件更新你的组件（就像上面说的那样）。 最后，使用 polyfill 让你的组件兼容旧版本的 react: import React from 'react'; import {polyfill} from 'react-lifecycles-compat'; class ExampleComponent extends React.Component { static getDerivedStateFromProps(nextProps, prevState) { // Your state update logic here ... } } // Polyfill your component to work with older versions of React: polyfill(ExampleComponent); export default ExampleComponent;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>async rendering</tag>
        <tag>lifecycle</tag>
        <tag>getSnapshotBeforeUpdate</tag>
        <tag>getDerivedStateFromProps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优化关键渲染路径]]></title>
    <url>%2F2018%2F03%2F13%2Fcritical-rendering-path.html</url>
    <content type="text"><![CDATA[优化关键渲染路径网页优化涉及到浏览器输入网址后的每一步，这里取关注相对少的浏览器渲染这一步来看看。 浏览器渲染页面有以下五个步骤： 处理 HTML 标记并构建 DOM 树。 处理 CSS 标记并构建 CSSOM 树。 将 DOM 与 CSSOM 合并成一个渲染树。 根据渲染树来布局，以计算每个节点的几何信息。 将各个节点绘制到屏幕上。 优化关键渲染路径 就是指最大限度缩短执行上述第 1 步至第 5 步耗费的总时间. 优化关键渲染路径不仅对首屏呈现有重大意义，对于渲染页面帧率，流畅用户体验很关键。 HTML 的简化处理HTML 在 SPA 盛行的情况下想要简化越来越困难，特别是复杂的大型应用，依赖于一些质量不一的 UI 组件库。随便写几个业务功能，就会生成一大堆的 div 嵌套。 首先，源头能控制当然最好，精简结构，html 语义化。 其次，我们可以将首屏定义的范围再缩小，比如PC、移动端屏幕大小的第一部分。对于 SPA，前端的首屏 html 要么是同构输出，要么是 js 生成。其实这两种情况都是可以定制的，第一时间只输出“首屏” 元素，剩下的内容延迟载入。不过，对于这样的控制比较繁琐和细节，需要针对性优化，哪些部分需要先输出，哪些部分可以延后。 再就是异步和碎片化的概念，或者叫 fiber。像 react 搞 fiber，目前是为了能及时响应用户，将 react 执行纤维化，异步化。我觉得 html 也同样可以做，一个组件一个组件地展现页面，将繁重的浏览器渲染切成一个个小块。也可以说是 PWA(Progressive Web App)。通常我们的选择是输出 loading，等一切就绪后再展示，这往往让我们肆无忌惮地在首页加载一切资源，然后让用户对着 loading 发呆。如果能正确地，分步地展现内容，相信用户能更好地接受这个过程。在 Facebook APP也能看到这种思路的实现，打开 APP 可以先看到灰色的占位符，然后由顶部开始分步加载内容，在这个过程中，仍然可以响应页面上已加载完成的组件的用户操作。 css 的简化处理CSS 是阻塞渲染的资源。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。 一般来说，css 都不是首屏的性能瓶颈，但它是高帧率动画的瓶颈。通过 timeline 可以观察 css 样式计算、布局、绘制、合成的性能。 css 的性能问题包括： CSS 选择器的嵌套，多层嵌套严重影响 CSS 性能，因为浏览器需要合成CSSOM，进而合成渲染树。 文档（HTML， CSS）越大，浏览器需要完成的工作就越多。 样式越复杂，绘制需要的时间就越长（例如，单色的绘制开销“较小”，而阴影的计算和渲染开销则要“大得多”） 针对优化的手段： 使用 BEM CSS 规范进行编写CSS 简化 css, 或异步 css，将不必要的、非当前页的css 按需加载 可以尝试将开销大的 css 属性自动提取，打包到另一个文件，延迟加载。比如非常炫的动画、阴影、渐变等。当然只是一个想法，需要进行权衡，一般没有那么大的影响，相比多一个请求代价 display: none; 的应用，浏览器不会渲染带有些属性的 DOM 节点。可以利用它先隐藏不必要的内容，延迟展现 Layout 布局简化与固定视觉变化时，管道对指定帧的运行通常是： 样式计算、布局、绘制、合成 但这个过程是可以简化的，也是实现高帧率动画的基础。 当不改变元素的几何属性（例如宽度、高度、左侧或顶部位置等），只修改“paint only”属性（例如背景图片、文字颜色或阴影等），即不会影响页面布局的属性，则浏览器会跳过布局，但仍将执行绘制。 如果您更改一个既不要布局也不要绘制的属性，则浏览器将跳到只执行合成: 可以通过 css trigger 来查询 css 属性所触发的对应的渲染过程。 使用一些 3d 属性（比如 translateZ(0)）可以提升层的独立渲染，一定程度上可以提高绘制性能，但会增加内存和GPU的使用，如无必要，请勿提升元素 综上，如果频繁改变布局，会造成回流和重绘，对 css 的性能是影响最大的，继而造成卡顿。 总结html, css 的优化不像其他方面的优化，它们和业务结合比较紧密，对业务开发的意识和要求比较高，如果源头没控制好，后面工程构建上的优化也是有限的。 参考： 渲染性能 By Paul Lewis 关键渲染路径 By Ilya Grigorik]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建 DOM 对象模型和 CSSDOM 对象模型]]></title>
    <url>%2F2018%2F03%2F11%2Fconstructing-the-DOM-and-CSSDOM-object-model-before-browser-rendering.html</url>
    <content type="text"><![CDATA[By Ilya Grigorik 构建 DOM 对象模型和 CSSDOM 对象模型浏览器渲染页面前需要先构建 DOM 和 CSSOM 树。因此，我们需要确保尽快将 HTML 和 CSS 都提供给浏览器。 TL;DR 字节 → 字符 → 令牌 → 节点 → 对象模型。 HTML 标记转换成文档对象模型 (DOM)；CSS 标记转换成 CSS 对象模型 (CSSOM)。 DOM 和 CSSOM 是独立的数据结构。 Chrome DevTools Timeline 让我们可以捕获和检查 DOM 和 CSSOM 的构建和处理开销。 文档对象模型 (DOM) Critical Path Hello web performance students! 试一下 让我们从可能的最简单情况入手：一个包含一些文本和一幅图片的普通 HTML 页面。浏览器如何处理此页面？ 转换： 浏览器从磁盘或网络读取 HTML 的原始字节，并根据文件的指定编码（例如 UTF-8）将它们转换成各个字符。 令牌化： 浏览器将字符串转换成 W3C HTML5 标准规定的各种令牌，例如，“”、“”，以及其他尖括号内的字符串。每个令牌都具有特殊含义和一组规则。 词法分析： 发出的令牌转换成定义其属性和规则的“对象”。 DOM 构建： 最后，由于 HTML 标记定义不同标记之间的关系（一些标记包含在其他标记内），创建的对象链接在一个树数据结构内，此结构也会捕获原始标记中定义的父项-子项关系：HTML 对象是 body 对象的父项，body 是 paragraph 对象的父项，依此类推。 整个流程的最终输出是我们这个简单页面的文档对象模型 (DOM)，浏览器对页面进行的所有进一步处理都会用到它。 浏览器每次处理 HTML 标记时，都会完成以上所有步骤：将字节转换成字符，确定令牌，将令牌转换成节点，然后构建 DOM 树。这整个流程可能需要一些时间才能完成，有大量 HTML 需要处理时更是如此。 注：我们假定您对 Chrome DevTools 有着基础程度的熟悉，即您知道如何捕获网络瀑布，或记录时间线。如果您需要快速温习相关内容，请查看 Chrome DevTools 文档；如果您未接触过 DevTools，我们建议您学习 Codeschool Discover DevTools 课程。 如果您打开 Chrome DevTools 并在页面加载时记录时间线，就可以看到执行该步骤实际花费的时间。在上例中，将一堆 HTML 字节转换成 DOM 树大约需要 5 毫秒。对于较大的页面，这一过程需要的时间可能会显著增加。创建流畅动画时，如果浏览器需要处理大量 HTML，这很容易成为瓶颈。 DOM 树捕获文档标记的属性和关系，但并未告诉我们元素在渲染后呈现的外观。那是 CSSOM 的责任。 CSS 对象模型 (CSSOM)在浏览器构建我们这个简单页面的 DOM 时，在文档的 head 部分遇到了一个 link 标记，该标记引用一个外部 CSS 样式表：style.css。由于预见到需要利用该资源来渲染页面，它会立即发出对该资源的请求，并返回以下内容： body { font-size: 16px } p { font-weight: bold } span { color: red } p span { display: none } img { float: right } 我们本可以直接在 HTML 标记内声明样式（内联），但让 CSS 独立于 HTML 有利于我们将内容和设计作为独立关注点进行处理：设计人员负责处理 CSS，开发者侧重于 HTML，等等。 与处理 HTML 时一样，我们需要将收到的 CSS 规则转换成某种浏览器能够理解和处理的东西。因此，我们会重复 HTML 过程，不过是为 CSS 而不是 HTML： CSS 字节转换成字符，接着转换成令牌和节点，最后链接到一个称为“CSS 对象模型”(CSSOM) 的树结构内： CSSOM 为何具有树结构？为页面上的任何对象计算最后一组样式时，浏览器都会先从适用于该节点的最通用规则开始（例如，如果该节点是 body 元素的子项，则应用所有 body 样式），然后通过应用更具体的规则（即规则“向下级联”）以递归方式优化计算的样式。 以上面的 CSSOM 树为例进行更具体的阐述。span 标记内包含的任何置于 body 元素内的文本都将具有 16 像素字号，并且颜色为红色 — font-size 指令从 body 向下级联至 span。不过，如果某个 span 标记是某个段落 (p) 标记的子项，则其内容将不会显示。 还请注意，以上树并非完整的 CSSOM 树，它只显示了我们决定在样式表中替换的样式。每个浏览器都提供一组默认样式（也称为“User Agent 样式”），即我们不提供任何自定义样式时所看到的样式，我们的样式只是替换这些默认样式（例如默认 IE 样式）。 要了解 CSS 处理所需的时间，您可以在 DevTools 中记录时间线并寻找“Recalculate Style”事件：与 DOM 解析不同，该时间线不显示单独的“Parse CSS”条目，而是在这一个事件下一同捕获解析和 CSSOM 树构建，以及计算的样式的递归计算。 我们的小样式表需要大约 0.6 毫秒的处理时间，影响页面上的 8 个元素 — 虽然不多，但同样会产生开销。不过，这 8 个元素从何而来呢？CSSOM 和 DOM 是独立的数据结构！结果证明，浏览器隐藏了一个重要步骤。接下来，让我们谈一谈将 DOM 与 CSSOM 关联在一起的渲染树。 P.S.了解浏览器构建页面的原理，是性能优化的基础。比如 BEM 对 CSS 性能优化的优势，DOM 节点操作的昂贵以及如何找出性能瓶颈。]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>DOM</tag>
        <tag>CSSDOM</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react新API——context上下文]]></title>
    <url>%2F2018%2F02%2F12%2Freacts-new-context-api.html</url>
    <content type="text"><![CDATA[React’s ⚛️ new Context API这是一种更人性化的方式，不再是“实验性功能”，并且现在它是一级API。并且使用了 render prop! 你之前听说过 react 的 context API 吗？如果你听说过，你是否和其他用户一样犹豫是否直接使用它，因为你会在官方文档看到如下内容： 搜索的第一个内容就是“为什么不要去使用 context”。这不能激发使用 context API 的信心。为了考虑风险，部分提到： 如果想让你的应用更稳定，那不要使用 context。这是一个实验性的 API，在未来发布的 react 版本中可能会被移除。 所以，为什么会想要使用 context 呢？你是否经历过将 state 从 react 树的根组件一直传递至叶节点的痛苦呢？这种痛苦被称为“prop drilling”，并且非常烦人。你必须让不关心该状态的组件传递 props 给关心该数据的子组件。特别是当你移动组件时，这种痛苦感更强烈了。 你当然可以使用标准 javascript 模块来避免这个问题。只需要将数据放到一个单例模块中，它可以在任何地方被访问或导入。但你可能在更新数据的时候遇到一些问题（你必须实现一个事件广播让订阅者知道何时更新了数据），并且服务端渲染也会对单例造成困扰。 所以，像 redux 这类的状态管理库就应运而生了。它允许你在 react 树的任何地方获取数据。你所要做的事只是使用一个叫 的东西，然后你的组件就可以通过 connected 神奇般地访问你的 store 数据。 如果我告诉你 使用了 context这个实验性功能会怎么样？😱 这是真的！provider 组件将数据放在 context ，然后 connect 高阶组件从 context 读取数据。所以实际上， redux 并没有实现在任何地方访问数据… 是 context 做了这件事！ 那么，现在知道为什么要使用 context 了吗？好吧。你可能已经知道并爱上它了！就算你没有直接使用 context, 你也可能通过 react-redux, MobX-react, react-router, glamorous 等间接地使用了它！ Context 重生尽管我们现在很喜欢 context, 但还记得那句“它很可能在将来的 react 版本中被移除”这句话吗？来吧，你会爱上它的！ 一个多月以前， react 团队受到 yarn, Rust, Ember 的启发创建了 RFCs 项目。这个项目的第一个 PR 来自 Andrew Clark（react 核心团队成员）并称之为“新版 context”。在这个提交中，Andrew 列出了新版 context 要实现的功能。这里面有一些有趣的讨论。几天后，Andrew 开了一个新 PR “新 context API”。 所以，它看起来像什么？它比旧的 context API 要直观一百万倍。这是我想到的最简单有用的例子： 这是最简单的版本： const ThemeContext = React.createContext('light') class ThemeProvider extends React.Component { state = {theme: 'light'} render() { return ( &lt;ThemeContext.Provider value={this.state.theme}> {this.props.children} &lt;/ThemeContext.Provider> ) } } class App extends React.Component { render() { &lt;ThemeProvider> &lt;ThemeContext.Consumer> {val => &lt;div>{val}&lt;/div>} &lt;/ThemeContext.Consumer> &lt;/ThemeProvider> } } 你可能注意到我在消费组件中使用了 render props（最佳实践！），但如果这不是你的菜，你也可以很容易地使用高阶组件或用了 context API 的其他方法去实现（这就是为什么它是最佳的）。 新的 context API 由以下几部分组件： React.createContext 传递初始值（可选的使用位掩码功能）。这返回了一个包含 Provider 和 Consumer 的对象。 Provider 在组件树中使用频率更高，并且接受一个 value 属性（可以是任何值）。 Consumer 组件可以在 Provider 组件树下的任何地方使用，并接受一个“children”属性， children 必须是一个接受 value 值并返回 react 元素（JSX）的函数。 看到这个API 我异常地兴奋。react 团队将会移除 context 是一个实验性功能的警告，因为它现在是这个框架的一等功能。这意味着开发者有希望使用 context 简单地解决 prop-drilling 问题，而不必借助 redux 这类工具来解决这个痛点，也能更好更自由地使用简单的 react 。（又或者， James Kyle未发布的的解决方案是我们所期待的） Context 实践关于这个新的 context API，我遇到的比较多的问题是（或者其他的 props render模式），如何组合 providers 和 consumers 组件。当你将一堆的 render prop 组件放在一起时，就会变成 嵌套: I mean come on (screen shot of actual code I’m playing with right now) pic.twitter.com/Ucc8gaxPMp— Andrew Clark (@acdlite) January 24, 2018 那我们如何避免这个问题？如果这让你很烦恼，那你可以像解决常规的 javascript 问题一样：使用实用函数/组件。这有个例子： const ThemeContext = React.createContext('light') class ThemeProvider extends React.Component {/* code */} const ThemeConsumer = ThemeContext.Consumer const LanguageContext = React.createContext('en') class LanguageProvider extends React.Component {/* code */} const LanguageConsumer = LanguageContext.Consumer function AppProviders({children}) { return ( &lt;LanguageProvider> &lt;ThemeProvider> {children} &lt;/ThemeProvider> &lt;/LanguageProvider> ) } function ThemeAndLanguageConsumer({children}) { return ( &lt;LanguageConsumer> {language => ( &lt;ThemeConsumer> {theme => children({language, theme})} &lt;/ThemeConsumer> )} &lt;/LanguageConsumer> ) } class App extends React.Component { render() { &lt;AppProviders> &lt;ThemeAndLanguageConsumer> {({theme, language}) => &lt;div>{theme} and {language}&lt;/div>} &lt;/ThemeAndLanguageConsumer> &lt;/AppProviders> } } 上面举例了一个常见的案例，并使用特殊的函数或组件去让这些案例更人性化。就像你平时处理问题一样，举对例子了吗？我希望有用 😅 总结就像我上面说的，我对这个 API 非常感兴趣。它现在还未发布，但将发布在下一个版本的 react。不要担心，旧的 context API 将支持到下一个主版本号发布。所以每个人都会有足够的时间迁移。不要忘了，react 团队有超过 50,000 react 组件，很可能会发布一个 codemod 来自动升级大家的代码。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>context</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 判断正负0]]></title>
    <url>%2F2018%2F01%2F14%2Fjudge-positive-and-negative-0.html</url>
    <content type="text"><![CDATA[javascript 判断正负0ES 2015/ ES 6 新增了一个方法用于 javascript 相等性判断 – Object.is()。它与之前的相等比较运算符有什么不同呢？ 三种不同的值比较操作 抽象相等比较 (==)：将执行类型转换再进行比较，特殊地：Null 与 undefined 返回 true, 任何类型与 NaN返回 false, +0与-0为true. 严格等于运算符（===）:不会执行类型转换，类型不一致返回false,特殊地：NaN与NaN为false,+0与-0为true. Object.is: 基本与全等（===）相同，特殊地：NaN与NaN为true,+0与-0为false. +0 与 -0 到底是否相同答案是不同。 一般地，使用全等运算符（===）是比较安全的操作，但是正负零是返回true，容易让人有一种存在一种0的错觉。 在高版本的Node中，正负0的符号是区别对待的，正0显示为0，负0显示为 -0。 在除法中，1/+0 为 +Infinity, 1/-0 为 -Infinity，而 +Infinity === -Infinity 返回 false. 同时根据 javascript 64位双精度浮点数，第 1 位是正负数符号位（sign），0代表正数，1代表负数，中间的 11 位存储指数（exponent），用来表示次方数，最后的 52 位是尾数（mantissa），超出的部分自动进一舍零。所以正负0的表示是不同的。 疑问：如果正负 0 确实是两个数，为什么全等判断中会相同？ 通过查看规范， 比较 x === y，x 和 y 为值，需要产出 true 或 false。比较过程如下： - 如果 Type(x) 与 Type(y) 的结果不一致，返回 false。 - 如果 Type(x) 结果为 Undefined，返回 true。 - 如果 Type(x) 结果为 Null，返回 true。 - 如果 Type(x) 结果为 Number，则 - 如果 x 为 NaN，返回 false。 - 如果 y 为 NaN，返回 false。 - 如果 x 与 y 为同一个数字，返回 true。 - 如果 x 为 +0，y 为 -0，返回 true。 - 如果 x 为 -0，y 为 +0，返回 true。 - 返回 false。 - 如果 Type(x) 结果为 String，如果 x 与 y 为完全相同的字符序列（相同的长度和相同的字符对应相同的位置），返回 true，否则，返回 false。 - 如果 Type(x) 结果为 Boolean，如果 x 与 y 都为 true 或 false，则返回 true，否则，返回 false。 - 如果 x 和 y 引用到同一个 Object 对象，返回 true，否则，返回 false。 全等运算符虽然没有作类型转换，但也是针对 NaN、+0、-0 作了特殊处理。 区分正负零的方法通过以上知识点，可以总结出： 1、通过除 0 法判断： const isNegativeZero = num => num === 0 &amp;&amp; 1/num === -Infinity; 2、通过 object.is const isNegativeZero = num => Object.is(num, -0); 总结Object.is 是ES2015 新特性，与 === 不一样的是：它可以正确分辨 正负零 及 NaN。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>基础</tag>
        <tag>isNegativeZero</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从微信跳一跳看加密算法选择]]></title>
    <url>%2F2018%2F01%2F03%2Fthrough-wechat-t1t-think-about-crypto.html</url>
    <content type="text"><![CDATA[通过微信小游戏跳一跳，看加密算法的选择近期微信更新，有跳一跳的游戏，并被网友找出源码并刷分，我也试了一下，成功刷了 1024。其中看到这个游戏使用了常用加密库 crypto-js（不支持RSA），它可以在浏览器端使用。而 nodejs 也有 crypto 模块，而且支持的加密算法更多。下面就来看看加密算法有哪些，并如何根据场景选择算法。 常用加密算法Hash 算法能计算出一个消息所对应到的，长度固定的字符串（又称消息摘要）的算法。 结果值长的 Hash 算法也能用于验证文件或数据的完整性。 Hash 算法通常有：md5,sha,sha1,sha256,sha512,RSA-SHA; 但 crypto-js 不支持 RSA。这里挑几个。 测试效率和结果： var CryptoJS = require('crypto-js'); function test(hashs, txt) { hashs.forEach(name => hashAlgorithm(name, txt);) } function hashAlgorithm(algorithm, txt) { algorithm = algorithm.toUpperCase(); console.time(algorithm); console.log(algorithm, CryptoJS[algorithm](txt).toString()); console.timeEnd(algorithm); } const algs = ['md5', 'sha1', 'sha256', 'sha512', 'sha3', 'sha384', 'ripemd160']; test(algs, 'robin'); // `crypto-js` // MD5 8ee60a2e00c90d7e00d5069188dc115b // MD5: 3.229ms // SHA1 474ee9ee179b0ecf0bc27408079a0b15eda4c99d // SHA1: 0.485ms // SHA256 287782ef42356ef3d6551590f1ef0117b71d876df0f9b3eb58d088864770c74c // SHA256: 0.505ms // SHA512 071b38098125700fe49e65ef0059bfda1fbd110472a8d7490e0b3af6a8260712f958b9c7f27be61a8ddfe4fecb71f9e8002360f894f06dd4b1f383963d71db41 // SHA512: 1.519ms // SHA3 a621609aa4b8be7efac720538c86e998ebfa1ea67e4d10fa94df74388bbf443e18d92ca5bf483b789f6b42ea4f98bb086f48664bd5c1f4df476629419fa9e8b8 // SHA3: 1.150ms // SHA384 2750a9f5dadea58259fb17a3259b00a94648d40481eea91dc0e585e151e751001dc86457aa765019b0ca9721841b59f9 // SHA384: 0.498ms // RIPEMD160 9ef3a5f5ede0a741e38740cc3cc3e1bfcdeaece5 // RIPEMD160: 0.661ms // &lt;!--node crypto --> // md5,8ee60a2e00c90d7e00d5069188dc115b // md5: 0.093ms // sha,0894ec72c817d851286dd9c7309db3408b1dd620 // sha: 0.056ms // sha1,474ee9ee179b0ecf0bc27408079a0b15eda4c99d // sha1: 0.023ms // sha256,287782ef42356ef3d6551590f1ef0117b71d876df0f9b3eb58d088864770c74c // sha256: 0.029ms // sha512,071b38098125700fe49e65ef0059bfda1fbd110472a8d7490e0b3af6a8260712f958b9c7f27be61a8ddfe4fecb71f9e8002360f894f06dd4b1f383963d71db41 // sha512: 0.033ms // RSA-SHA,0894ec72c817d851286dd9c7309db3408b1dd620 // RSA-SHA: 0.023ms 通常哈希算法用于登陆密码的加密。这里看到 SHA1 居然比 MD5要快，而且安全性更高，建议使用 SHA1 或 SHA256、SHA512, MD5 也由于字典库的出现和计算机性能的提升而变得相对不安全。 以下是维基百科的参考： salt 加盐由于被加密信息，很容易被使用彩虹表暴力破解，特别是 md5 这类已经出现案例的情况。另一种情况是大家的方法都是使用 md5 或 SHA1，那其实只是把明文密码变成更复杂密文，并不能很有效地防止撞库，攻击者可以直接用加密后的密文进行伪造请求进行登陆。 这时我们可以使用 salt, 把 salt 到密码的前、中、后部分，再加密，这样只要攻击者没有原始密码或你的 salt 与其他网站不同就能保证相对安全。还可以将 salt 分开、倒序、hash后插入。 例如： SHA3(SHA3(password) + salt); 另外还有 pbkdf2、 bcrypt 算法，它是一种适应性加密算法，可以根据需要设置迭代强度，以防止日益增长的电脑性能。 bcrypt(password, salt, cost) cost 是毫秒。攻击者就需要花更长的时间。 Hmac 密钥散列消息认证码(Keyed-hash message authentication code)类似加盐处理，HMAC 运算利用 Hash 算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。HMAC 也可以有效防止一些类似md5的彩虹表等攻击，比如一些常见的密码直接MD5存入数据库的，可能被反向破解。因为除了密码，还有一个可以是任意值的 key。相同密码，不同的 key 生成的值是不一样的。 看一下用法： var CryptoJS = require('crypto-js'); function run(hashs, txt, key) { hashs.forEach(name => hmacAlgorithm(name, txt, key);) } function hmacAlgorithm(algorithm, txt, key) { algorithm = algorithm.toUpperCase(); console.time(algorithm); console.log(algorithm, CryptoJS['Hmac'+algorithm](txt, key).toString()); console.timeEnd(algorithm); } var algs = ['md5', 'sha1', 'sha256', 'sha512', 'sha3', 'sha384', 'ripemd160']; run(algs, 'robin', 'abc'); run(algs, 'robin', 'adaslfjklsjdsafdasflsjfklasdhgkjashdfkasdklyreoiwqurenwmehrqoewnfknoineclwqnrewqmewqlrnewqfeqrbkwviwbqovbdpcsabveiwbqvibwvwibqvkbwibvkbwibvfldsalfjdklsaflkausld'); // short key // MD5 97ddf30a37c08700f6b8668b1b6cc4e5 // MD5: 4.226ms // SHA1 131e69c8d75cf3f5735c4320386f35dc93da2c89 // SHA1: 2.286ms // SHA256 4890c6579ce63619e31452ce80d1f917143987dfc131c0f61c195066b62753e3 // SHA256: 1.063ms // SHA512 64c34aff6f972dc8bef245c03198e8f3a7c9bda7bc208f01793fd03a93d89db0ca0d0235615c976d5ff331425adae7a5812c8d42b5bff30ab2e95683ad06eed8 // SHA512: 1.937ms // SHA3 27dc845b20795d64d25feabcac3d4f90297f32947780886bc16f4b18de850b7ac7d5bd021788d7b17fd4ad7da06cdadf650b7bfdb916394881902759b96dc8a6 // SHA3: 3.293ms // SHA384 cfe9ad71dc48deb9a778a68c8106370ead173e13fbcb77160a75ac190d2a4e201f962811d3c439f241892d4c69e604f1 // SHA384: 2.487ms // RIPEMD160 30de5538bfb0063ee42da27cdffe1c9f11f7acd0 // RIPEMD160: 1.327ms // ****long key // MD5 6c6d9995b33e4b7c992201bf54add3c4 // MD5: 0.244ms // SHA1 b71857c24215ab762033cf48a39b385eb5e299f6 // SHA1: 0.246ms // SHA256 7a9cbb46c0506bf52051c32f487142696316831af3d7af258389b9d83249660e // SHA256: 0.280ms // SHA512 05d1928b5a977cfe0a1e016e193f5f9c0e7ea7243e4b233d9a77508ec9ee18c4834485eb1a8a7803f8c8eb04a7b03df390e7bbf677c57d989c2c0101b10433f1 // SHA512: 0.750ms // SHA3 940fbf3853c76c70e0f50577bbc8b8252eee3d4404049e2bb2106c01419c1aa5b84a46ff0a6eedb699b3b1508e9d14915aceaaa3b037a04f6916c0c1f4e5f84c // SHA3: 1.589ms // SHA384 757946847447f8f52ade051b64cc1ad5c475c356a356cca7c81f36238ab4fce7c3af7fb69fc23eb4039aa7c7f20a077d // SHA384: 2.396ms // RIPEMD160 b92809af726d17aad164a128a19643a388213aa3 // RIPEMD160: 0.596ms 可以看到长短 key 算法不同，性能也不同，一般推荐 key 长度大于 哈希值长度。Node 原生模块就不测了，性能只能更好。 加密与解密上面的哈希算法严格意义上说不算加密算法，因为一般储存的也是密文，只是为了传输过程中或泄漏之后不被看到明文密码，或加大暴力破解的难度，从而降低风险。更高安全要求的就需要用到解密。可以分为对称加密和不对称加密。 对称加密：加密和解密密钥相同。代表是 AES， 速度快，安全性高，最流行的加密算法之一，中文也叫 高级加密标准（Advanced Encryption Standard）。另外还有DES、3DES、Blowfish、IDEA、RC5、RC6 非对称加密： 加密和解密密钥不同。代表是 RSA， 速度慢，安全性高；还有ECC（椭圆曲线加密算法）、ElGamal、背包算法、Rabin（RSA的特例） 加密与解密最重要的是密钥。 对称加密： （如何选择，就看性能和安全性的要求了） const CryptoJS = require('crypto-js'); function run(hashs, ...args) { hashs.forEach(name => encrypt(name, ...args)); } function encrypt(algorithm, txt, key) { const shasum = CryptoJS[algorithm]; console.time(algorithm); console.log(algorithm, shasum.encrypt(txt, key).ciphertext.toString()); console.timeEnd(algorithm); } var algs = ['AES', 'TripleDES', 'RC4', 'Rabbit', 'RabbitLegacy']; run(algs, 'robin', 'reiki'); // output // AES 4fe1199d6a3aee50fd285017ba841109 // AES: 5.589ms // TripleDES 90374ffa15857553 // TripleDES: 1.739ms // RC4 a9a8932b19 // RC4: 0.738ms // Rabbit 49fa9bd558 // Rabbit: 1.063ms // RabbitLegacy 6b8d025024 // RabbitLegacy: 1.022ms 客户端如何选择加密算法对于客户端，由于源码可泄露，也就相当于客户端的加密方法可暴露。以及 http 可被劫持等不安全因素。普通的加密根本没什么用。但并不是说客户端不用加密，而是要求服务端必须再次加密，或客户端采用安全系数更高的加密方式。另外也推荐升级 https。 我也并不了解所有算法，但是可以看需求，看场景，抛开场景谈技术就是耍流氓。 首先是否需要解密，安全性要求如何，一般的就使用 hash 算法，要求高一点就用 hmac。 如果需要解密，还要考虑性能及密钥的安全性。 微信跳一跳为什么选 AES？ // 跳一跳 game.js 里的加密算法 e.encrypt = function(t, e) { var e = e.slice(0, 16), // sessionID 前16位 i = n.default.enc.Utf8.parse(e), // base64 utf8 r = n.default.enc.Utf8.parse(e), // 同上 a = t; a = JSON.stringify(a); var o = n.default.AES.encrypt(a, i, { // AES 非对称加密，a为加密内容，i是密钥， iv: r, // iv参数 mode: n.default.mode.CBC, // 加密模式，AES包含ECB，CBC，CFB等加密模式，这些模式除了ECB由于没有使用IV而不太安全 padding: n.default.pad.Pkcs7 // 加密填充，块加密的一个要面临的问题就是如何填满最后一块 }); return o = o.toString() }; 其实这个方法是遵循小程序文档里的加密解密指导的： 用户数据的签名验证和加解密 首先分析上传游戏分数需要客户端加密，然后服务端解密提取分数记录。那就有对称加密和非对称加密两种。对于非对称加密，需要下发公钥，并且公钥和私钥必须配对，速度也慢，这对一个小游戏来说操作太麻烦。那就锁定对称加密。但如何传递密钥呢，所以它用了 sessionID 作为密钥，客户端和服务端都知道，并且可以每次登陆更新，安全性高。并且微信 API 使用了 https，防止一般抓包，安全性更高。 另外，对于源码，一般也会工程化构建，进行压缩，混淆。但对于源码会泄漏的情况下，又是用户本身主动抓包，还能看懂程序，游戏类型只是上传分数，这就出现了刷分的可能性。当然，分高有什么用呢，这本身只是娱乐。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>wechat</tag>
        <tag>crypto</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css counters 计数器]]></title>
    <url>%2F2017%2F12%2F21%2Fusing-css-counters.html</url>
    <content type="text"><![CDATA[让 css 像编程语言一样实现计数，IE 8 也支持的 css 计数器css counters 是一个我们可以利用特定属性增减计算的变量。通过它，我们可以做一些类似编程语言的通用的迭代。 这个方式可以用于一些创造性的解决方案，包括一些重复代码的计数器。 为了控制计数器，你需要使用 counter-reset 和 counter-increment 属性，同时与 counter() 和 counters() 函数配对。如果没有地方展示计数器，这个方法就没有任何存在的价值，对此，我们可以使用简化的 content 属性。 表现也很简单。假设你有一个无序列表，你想要计算列表项。在 ul 元素上指定一个计数器，并且在 li 元素上增加计数。 counter-reset 属性我们可以使用 counter-reset 属性定义我们的计数器变量。对于这一点，我们可以任意命名并且可选择一个计数初始值。默认起始值是 0。这个应设置在父元素。 counter-increment 属性通过使用 counter-increment 属性，我们可以增加或减少我们的计数器的值。这个属性也有第二个可选参数值，可以指定每次增减的幅度。 counter() 函数counter() 函数主要为了展现计数器。展示的地方就是 content 属性，因为这是一个你可以将数据通过 css 回填到 html 的属性；第一个参数是计数器变量名，第二个参数是计数器类型（可选）。 注意：在 css 中没有连接运算符，所以如果你想连接 content 属性里的两个值，只能值用空格。 counters() 函数这个函数和 counter() 函数一样。主要的不同是 counters() 你可以嵌套计数器到另一个，就像多级嵌套的 ul 列表。它有三个参数，第一个是计数器名，第二个是分隔符，第三个参数是计数器类型（可选）。 使用案例案例1 - 文档 issue 自动追踪当你有一些重复的元素，并且想去统计它们，这个方法可以方便你解决这个问题。 我们创建一个 counter-reset 在我们的 .container 父级元素。之后，我们给 issues 的类名设置 counter-increment 属性。最后，我们通过 content 属性在 .issues:before 元素上输出计数器的值。 See the Pen CSS Counter Example by Adam Laki (@adamlaki) on CodePen. 案例2 - 嵌套列表使用 counters() ，我们可以让嵌套列表实现文本编辑器里的效果。 See the Pen MrjmLX by robin-l (@robin-l) on CodePen. 案例3 - 复选框选择计数器使用 input 的 :checked 伪类，我们可以知道复选框是否选中，因此我们也能递增我们的计数器。 See the Pen OzRmGW by robin-l (@robin-l) on CodePen. 其他案例 Šime Vidas 发布的脚注例子 Sam Dutton 制作的有趣的行数例子]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css counters</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简洁代码与冗余代码]]></title>
    <url>%2F2017%2F11%2F29%2Fclean-code-dirty-code.html</url>
    <content type="text"><![CDATA[简洁代码与冗余代码这篇文章将重点介绍适用于现代 react 软件开发的简洁代码之道。我还会谈谈 ES6/ES2015 带来的一些“语法糖”。 什么是简洁代码之道，为什么我如此关心？简洁代码之道的一贯编码风格是让你的代码更易写、易读和易维护。经常，程序员在一个问题上花了许多时间，一旦问题被解决，就提交代码。我一直主张，你的工作并没有完成，因为你只是让你的代码“正常工作”而已。 这是一个机会来精简你的代码，通过删除死代码（僵尸代码）、重构、删除被注释的代码！努力提高可维护性。扪心自问，“6个月后其他人还能理解你的代码吗？” 简单来说，编写能让你自豪到带回家和母亲炫耀的代码。 为什么你要这么关心这个问题？因为如果你是一个好开发者，你会很懒。听我说完，我是赞扬的意思。一个好的开发者，面对同一件事要做很多遍的状况，通常会寻找一个自动解决（或更好的）方案来完成眼前的任务。所以，因为你很懒，关注简洁代码的技术将会减少你拉取代码一遍又一遍地 review 同一段代码的频率。 通过嗅觉测试精简代码精简代码应该通过嗅觉测试。不明白我是什么意思？我们都看着（自己的或别人的）代码说：“这里不太对劲。” 记住，如果感觉不太对劲，那可能真的不对劲。一起对代码深思熟虑是好的。但如果你发觉你正在把一个方形的钉子插进一个圆形的洞里，那就请停下来，退一步，并且休息一下。最多十次，你会找到更好的解决办法的。 精简代码就是 DRY （禁止重复）DRY 是 “Don’t repeat yourself!” 的缩写。如果一件事你做了很多遍，合并重复的代码。如果你在你代码里发现了设计模式，那是一个删除重复的迹象。有时候这意味着你站得离屏幕远远地，直到你看不清文字，也无法寻找模式。 // Dirty const MyComponent = () => ( &lt;div> &lt;OtherComponent type="a" className="colorful" foo={123} bar={456} /> &lt;OtherComponent type="b" className="colorful" foo={123} bar={456} /> &lt;/div> ); // Clean const MyOtherComponent = ({ type }) => ( &lt;OtherComponent type={type} className="colorful" foo={123} bar={456} /> ); const MyComponent = () => ( &lt;div> &lt;MyOtherComponent type="a" /> &lt;MyOtherComponent type="b" /> &lt;/div> ); 有时候，就像上面的例子那样 —— 删除重复代码并不会减少代码量。但是，删除重复代码一般会提高可维护性。 要注意，不要在删除重复代码这件事上做得太过分了，所以要知道什么时候该说什么。 简洁的代码是可预测和可测试的编写单元测试不仅仅是一个好主意，它已经几乎变成强制性的。毕竟，你怎样确保新特性没有在某些地方引起一些 bugs。 许多 react 开发者依靠零配置的 jest 测试库，并产出覆盖报告。如果你对前后视觉对照测试感兴趣，请尝试一下 美国运通开源的 Jest Image Snapshot。 简洁的代码能自我说明你之前有遇到过吗？你写了一些代码，并确保它拥有完整的注释。将会发生这样的情况，你发现一个 bug, 所以你回去修改代码。你还记得修改注释并对应新的逻辑吗？也许记得。也许不记得。下一个看你代码的人可能已经掉进兔子洞（被绕进去了）因为他还在看以前的注释。 只给复杂的思路添加注释。不要给显而易见的代码添加注释。更少量的注释也有利于减少视觉干扰。 // Dirty const fetchUser = (id) => ( fetch(buildUri`/users/${id}`) // Get User DTO record from REST API .then(convertFormat) // Convert to snakeCase .then(validateUser) // Make sure the the user is valid ); 而简洁版，我们重命名函数以便更好地描述他们是做什么的，因此消除了注释的必要并减少视觉干扰。这限制了代码与注释不匹配的潜在混乱。 // Clean const fetchUser = (id) => ( fetch(buildUri`/users/${id}`) .then(snakeToCamelCase) .then(validateUser) ); 命名的重要性在我前面的文章 子组件的函数是一种反模式, 我强调了命名的重要性。我们应该严肃思考变量名、函数名、甚至文件名。 下面是一些指南： 布尔值变量、或返回布尔值的函数，应该以 “is”, “has”, “should” 开头。 // Dirty const done = current >= goal; // Clean const isComplete = current >= goal; 函数名应该描述函数的功能是什么，而不是怎样实现这个功能。换句话说，不要在命名中暴露实现细节。为什么？因为不知道哪一天你就会换一种实现，而你不应该为重构实现方式而去更改业务代码。举个例子，今天你可能通过 REST API 加载你的配置，但可能明天你又改成用 javascipt 实现。 // Dirty const loadConfigFromServer = () => { ... }; // Clean const loadConfig = () => { ... }; 简洁代码遵循成熟的设计模式和最佳实践计算机普及很长时间了。多年来，程序员在解决某些问题的时候发现模式。被称为 设计模式。换句话说，它是随着时间推移被证明的有用的算法。你可以站在这些巨人的肩上，以便避免再犯这些错误。 然后有一些最佳实践，它们和设计模式很类似，但更广义，不具体指编码算法。它们可能涉及到类似“你应该在编码时使用 lint 工具” 或者 “当你写一个类库时，请包含 react 作为 peerDependency”。 将函数功能缩小，每一个都职责单一。这个叫做职责单一原则。确保每个函数做好并只做一件事。意思是你可以将一个复杂的组件拆分成许多小的部分。这也会让代码更易测试。 注意抽象接口。换句话说，不要强制让你的业务代码使用私有变量或私有方法。 遵循严格的 linting 规则，它会帮助你编写简洁、风格统一的代码。 简洁的代码不一定要花费更长时间我听到编写简洁的代码会降低工作效率。真是一派胡言。是的，为了冲刺，一开始你需要放慢脚步，但是写了几行代码后，你的步伐会越来越快。 并且不要考虑将来再“重构”它，并花时间修复来自 code review 的评论。如果你将代码拆分成小模块，每个都职责单一，很可能将来大部分模块都不会碰。这就是通过“写下它，忘了它”来了省时间。 冗余代码 VS. 简洁代码的实践例子看看下面的代码。继续看，并返回到前面我所讲的内容。你有看到什么模式吗？注意到 Thingie 组件和 ThingieWithTitle 组件除了 Title 组件之外都完全相同。这满足了 DRY 的条件。 // Dirty import Title from './Title'; export const Thingie = ({ description }) => ( &lt;div class="thingie"> &lt;div class="description-wrapper"> &lt;Description value={description} /> &lt;/div> &lt;/div> ); export const ThingieWithTitle = ({ title, description }) => ( &lt;div> &lt;Title value={title} /> &lt;div class="description-wrapper"> &lt;Description value={description} /> &lt;/div> &lt;/div> ); 这里允许我们传递 children 到 Thingie, 然后创建一个 ThingieWithTitle 包裹 Thingie，传递 Title 作为它的子节点。 // Clean import Title from './Title'; export const Thingie = ({ description, children }) => ( &lt;div class="thingie"> {children} &lt;div class="description-wrapper"> &lt;Description value={description} /> &lt;/div> &lt;/div> ); export const ThingieWithTitle = ({ title, ...others }) => ( &lt;Thingie {...others}> &lt;Title value={title} /> &lt;/Thingie> ); 默认值看下面的代码段。它默认使用 icon-large 作为 className 的声明值。 // Dirty const Icon = ({ className, onClick }) => { const additionalClasses = className || 'icon-large'; return ( &lt;span className={`icon-hover ${additionalClasses}`} onClick={onClick}> &lt;/span> ); }; 这里我们使用 ES6 默认语法，用字符串来替换未定义的值。这也允许我们使用箭头函数，并消除 return 的使用。 // Clean const Icon = ({ className = 'icon-large', onClick }) => ( &lt;span className={`icon-hover ${className}`} onClick={onClick} /> ); 下面是更简洁的版本，默认值通过 react 设置。 // Cleaner const Icon = ({ className, onClick }) => ( &lt;span className={`icon-hover ${className}`} onClick={onClick} /> ); Icon.defaultProps = { className: 'icon-large', }; 为什么这样更简洁？为什么这样更好？三个版本做的不是同样一件事吗？对于大部分情况来说，确实是的。但是，让 react 设置默认值的好处是会产生更高效的代码。默认 props 基于类的组件生命周期,同时允许你使用 propTypes 检查默认值。但还有一个好处：简化组件自身的默认逻辑。 举个例子，你可以这样做，在一个变量里存储所有默认的 props。我不建议你这样做，我只是说你可以有这种做法。 import defaultProps from './defaultProps'; ... Icon.defaultProps = defaultProps.Icon; 从 render 函数中分离状态在 render 函数中混合你的状态数据加载逻辑会让组件变得更复杂。相反，写一个职责单一的状态容器组件去加载数据。然后用另一个职责单一的组件去显示数据。这叫做 容器模式。 下面这个例子，用户数据在同一个组件中加载和显示。 // Dirty class User extends Component { state = { loading: true }; render() { const { loading, user } = this.state; return loading ? &lt;div>Loading...&lt;/div> : &lt;div> &lt;div> First name: {user.firstName} &lt;/div> &lt;div> First name: {user.lastName} &lt;/div> ... &lt;/div>; } componentDidMount() { fetchUser(this.props.id) .then((user) => { this.setState({ loading: false, user })}) } } 在简洁版本，关注点 —— 数据加载，显示加载动画，和显示数据被分离了。不仅让代码更容易理解。而且很容易独立地测试每个关注点。同时 RenderUser 是一个无状态组件。结果是可预测的。 // Clean import RenderUser from './RenderUser'; class User extends Component { state = { loading: true }; render() { const { loading, user } = this.state; return loading ? &lt;Loading /> : &lt;RenderUser user={user} />; } componentDidMount() { fetchUser(this.props.id) .then(user => { this.setState({ loading: false, user })}) } } 使用无状态组件 SFC无状态组件（SFC）在 React v0.14.0 的时候被推出。它们被用来大大简化一个仅用于渲染的组件。但很多开发者还没有放下过去。举个例子，下面这个组件具备转换成 SFC 的条件。 // Dirty class TableRowWrapper extends Component { render() { return ( &lt;tr> {this.props.children} &lt;/tr> ); } } 简洁版清理了很多冗余版本的干扰的东西。通过 react 的核心优化，有可能使用更少的内存，没有实例被创建。 // Clean const TableRowWrapper = ({ children }) => ( &lt;tr> {children} &lt;/tr> ); Rest/spread (…操作符)大约一年前，在我心中 Object.assign 将会变成每个人最好的新朋友。但是，时代变了，ES2016/ES7 的 rest/spread spec 来了。 看一个给组件传递 props 的案例。你想在组件内使用 className，但把剩余的 props 传递给子组件。你可能会这样做。 // Dirty const MyComponent = (props) => { const others = Object.assign({}, props); delete others.className; return ( &lt;div className={props.className}> {React.createElement(MyOtherComponent, others)} &lt;/div> ); }; 不够优雅，不是么？但使用 rest/spread, 就像看到一块蛋糕一样。 // Clean const MyComponent = ({ className, ...others }) => ( &lt;div className={className}> &lt;MyOtherComponent {...others} /> &lt;/div> ); 适时使用解构ES6 有一个概念叫 destructure解构赋值。它允许你取出 object 或 array 里的某个值。 object destructuring 对象解构比如，给 componentWillReceiveProps 传递了 newProps，我们给 state.active 设置一个新的 active 值。 // Dirty componentWillReceiveProps(newProps) { this.setState({ active: newProps.active }); } 在简洁版本中，我们将解构 newProps 里的 active， 不仅不再需要引用 newProps.active, 而且可以只使用对象中的属性名 setState: // Clean componentWillReceiveProps({ active }) { this.setState({ active }); } array destructuring 数组解构经常忽视 ES6 的数组解构特性。下面这个例子，它从 local 取出一个值,比如 “es-US”, 拆分并赋值给 language(en) 和 country(US) // Dirty const splitLocale = locale.split('-'); const language = splitLocale[0]; const country = splitLocale[1]; // Clean const [language, country] = locale.split('-'); 总结我希望我让你看到编写简洁代码的好处，并可以应用这里呈现的实际例子。一旦你拥抱简洁代码，它将成为你的第二天性。你和未来的你将会感激“写下它，忘了它”的生活方式。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>best practices</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dynamic import() 与 静态 import 相比较，有哪些不同]]></title>
    <url>%2F2017%2F11%2F27%2Fdynamic-import.html</url>
    <content type="text"><![CDATA[Dynamic import() 有哪些特点 Dynamic import() 已被 Chrome 63 和 Safari Technology Preview 24 支持。 Dynamic import() 采用 类函数 的方法来塑造 import，相比 static import 解锁了新功能。这篇文章对比了两者并概览新功能。 Static import（概括）九月份，Chrome 61 发布并支持在 modules 中使用 ES2015 import 声明。 仔细看下面这个模块，位于 ./utils.mjs: // Default export export default () => { console.log('Hi from the default export!'); }; // Named export `doStuff` export const doStuff = () => { console.log('Doing stuff…'); }; 下面是使用 静态 import 引入 ./utils.mjs 模块： import * as module from './utils.mjs'; module.default(); // → logs 'Hi from the default export!' module.doStuff(); // → logs 'Doing stuff…' 注意： 上面这个例子使用 .mjs 来标识这是一个模块文件而不是普通脚本。在网页端，文件扩展名并不是问题，只要服务端设置了正确的 MIME 类型（比如给 javascript 文件设置 Content-Type:text/javascript）在 HTTP header。.mjs 在其他一些平台上特别有用，如 Node.js 这类没有 MIME 类型或其他 Hooks 如 type=”module” 来确定模块或普通脚本。我们在这里使用相同的扩展名来保持跨平台的一致性，并清楚地区分模块和普通脚本。 这个导入模块的语法形式是 静态 声明：它只接受字符串作为模块标识符，并通过运行前的 “linking” 过程将模块绑定到本地作用域。静态 import 语法只能用于文件顶部。静态import 支持一些重要的用例，如：static analysis, bundling tools, 和 tree-shaking。 在一些案例中，下面这些特性会非常有用： 请求时导入模块（或有条件地） 运行时计算模块标识符 在普通脚本中导入模块（而不是在模块中导入） 但是这些用 静态 import 都无法做到。 Dynamic import() 🔥Dynamic import() 采用 类函数 的方法来塑造满足这些用例的 import。import(moduleSpecifier) 为请求模块的模块名称空间返回一个 promise。它是在获取，实例化和评估模块的所有依赖关系之后创建的，模块本身也是。 下面是如何使用 动态 import，并使用 ./utils.mjs 模块： const moduleSpecifier = './utils.mjs'; import(moduleSpecifier) .then((module) => { module.default(); // → logs 'Hi from the default export!' module.doStuff(); // → logs 'Doing stuff…' }); 注意： 尽管 import() 看起来像一个函数调用，但它只是恰好被规定为使用括号的一种 语法 （类似于 super()）。这意味着 import 不会继承 Function.prototype ，所以不能使用 call 和 apply。像 const importAlias = import 这样的代码也不能运行 —— import 甚至不是一个 object 对象！但是这在实践中并不重要。 下面是一个例子，展示了如何在一个小型单页应用的导航上使用 动态 import() 启用懒加载模块： &lt;!DOCTYPE html> &lt;meta charset="utf-8"> &lt;title>My library&lt;/title> &lt;nav> &lt;a href="books.html" data-entry-module="books">Books&lt;/a> &lt;a href="movies.html" data-entry-module="movies">Movies&lt;/a> &lt;a href="video-games.html" data-entry-module="video-games">Video Games&lt;/a> &lt;/nav> &lt;main>This is a placeholder for the content that will be loaded on-demand.&lt;/main> &lt;script> const main = document.querySelector('main'); const links = document.querySelectorAll('nav > a'); for (const link of links) { link.addEventListener('click', async (event) => { event.preventDefault(); try { const module = await import(`/${link.dataset.entryModule}.mjs`); // The module exports a function named `loadPageInto`. module.loadPageInto(main); } catch (error) { main.textContent = error.message; } }); } &lt;/script> 当正确使用 动态 import() 开启懒加载功能时将会非常强大。为了演示目的，Addy 修改了一个 Hacker News PWA 示例，在首次加载时静态地导入所有依赖，包括评论。升级版 使用 动态 import()延迟加载评论，避免加载，解析和编译成本，直到用户确实需要它们。 建议静态 import 和动态 import() 都很有用。它们都有各自的特点和使用场景。使用静态 import 来初始绘制依赖关系，尤其是首屏内容。另一种情况，考虑到按需加载则使用动态 import()。 译者注： static import 是没有括号的，dynamic import() 是带括号的。不注意的可能会混淆。用法的区别： static import: import $ from 'jquery' 有声明提升，一般只放在头部位置 dynamic import(): const $ = import('jquery') 可以放在任何位置]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>dynamic import</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 react 16 portal 做一些很酷的事情]]></title>
    <url>%2F2017%2F11%2F16%2Fusing-a-react-16-portal-to-do-something-cool.html</url>
    <content type="text"><![CDATA[React 16 已经发布了，其中一个很有趣的是添加了 “Portals”。 Portals 可以让你在父组件外渲染 react 受控 DOM 节点。react doc 也使用了一个模态框的例子很好地解释了它。用也做 tooltips 也很合适（这是我早前做的一个例子）。 但这些都并不是很有趣，让我们做一些更不可思议的事情… 因为所有 portal 做的，都是将一个元素放到其他元素上，你并没有被限制放在 当前 document 的任何地方。你可以添加到另一个 document 的 body 中，可能是完全不同浏览器窗口的一个 document。 下面我有一个基本的页面（左边），包含一个计数器及深红色按钮。另一个窗口（右边）同样是 react app 的一部分。 右边的窗口是属于 同一个 React app 这个事实应该让你感到惊讶。 上面图片中能看到的所有东西（除了树）都是在下面代码展示的同一个组件中： 你已经成功了， 有一点特殊，里面的所有东西都会被渲染到另一个 window 下。 尤其是， 做了两件事。 1、 当组件渲染时打开一个浏览器窗口。 2、 创建一个 portal 并将 props.children 添加到新窗口的 body。 这不是最酷的事情吗？ 我是多么兴奋，必须得冷静一下。 … I saw a duck! … 上面提到的 body中的组件就是下面这样。 React 16 新增的部分 ReactDOM.createPortal 在 11 行 —— 那就是黑魔法。 那有意义吗？组件并没有返回什么，只是做了一些其他事情。 换一个角度来想可能是这样的：按理来说，一个父组件对子组件说：“嘿，渲染 DOM， 然后把结果添加到我这里。”，然后子组件照做了。但是这次，任性的子组件说，“不！我要将东东渲染到另一个窗口，然后写一篇关于它的博客。” 现在，我知道你在想什么。 你有点渴，并且想知道你是否该喝点水了。是的，去吧。 另一件你可能在想的事情是：将一些 DOM 注入到无样式的空白窗口有什么好处？可能 Craigslist 或 Wikipedia 也不知道。但你的网站很美，任何时候都不能弹出小窗口。 好吧，好消息来了，大家注意了！ 起初，我还在想是否有一个简单的方式将样式复制到新窗口。然后我想起我的生活只是被一些毫无意义的事件填充，它们唯一的目的只是让我分心，阻止我内心的空虚寂寞冷。 所以亲自写这个函数就是乐趣！ 看下面： 事实上，我并不是很了解 styleSheet。我期待从评论中得知有什么奇技淫巧。 现在我可以在打开新窗口的时候很简单地复制样式，像这样： See the Pen React Portal Chat Window by David Gilbertson (@davidgilbertson) on CodePen. 我不认为这能在 Medium app 的 iOS/Android 平台上运行，所以请在浏览器打开。 好了，我认为这篇文章该结束了。 Bye!]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>portal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react 组件设计模式]]></title>
    <url>%2F2017%2F11%2F09%2Freact-component-patterns.html</url>
    <content type="text"><![CDATA[react component 模式 有状态组件（Stateful）和无状态组件（Stateless）、容器组件（Container）与展示组件（Presentational）、高阶组件（HOC）、渲染回调（Render Callbacks）等 我在工作中使用 React 有一段时间了——一个 facebook 使用 js 渲染用户界面的框架——刚开始的时候我想知道一些概念。这些文字是尝试总结我实践这么久以来学到的一些模式——可能对于刚开始进入组件世界的开发者有用。 有状态(Stateful) 与 无状态(Stateless) 组件就像有状态和无状态的 web 服务一样， React 组件也能在用户使用时保存和操作状态（有状态）。或只是一个简单的组件，按受 props 并返回需要显示的内容（无状态）。 一个简单的 无状态 按钮组件只接受 props: 而下面是一个 有状态 的计数组件（使用了 Button 组件）： 就像你所看到的，最后一个组件的 constructor 保持了一个组件的 state, 而第一个组件则是一个简单组件，只通过 props 渲染了文字。这个关注分离可能非常简单，但是让 Button 组件高度复用。 容器(Container) 与 展示(Presentational) 组件当使用外部数据运行时，我们可以把这个组件分成这两个新类别。容器组件 负责获取数据，存在在 react 作用域外部，就像连接 Redux 或 Relay ———— 而 展示组件 则不依赖 react 应用的其他部分，仅仅取决于它自身的 state 和接收的 props。让我们拿用户列表作为展示组件的例子： 这个列表可以使用我们的 容器组件 更新： 这种方法将数据获取与渲染分离，同时让 UserList 高度复用。如果你想进一步学习这种模式，这里有一篇文章解释地很好。 高阶组件高阶组件————或叫 HOC。当你想要重用逻辑的时候非常感兴趣。他们是 javascript 函数，将一个组件作为参数，并返回新组件。 假设你需要做一个可伸缩的的菜单组件，当用户点的时候，展示它里面的内容。所以，为了替代在父级组件上控制 state，你可以简单地创建一个通用的 高阶组件 来处理它： 这种方式允许我们将逻辑应用通过装饰模式（decorator）应用在 ToggleableMenu 组件上。 现在我们可以任意传递子级到 ToggleableMenu 组件了： 如果你熟悉使用 redux 的 connect 或 react router 的 withRouter 函数，那你已经在用 HOCs 了。 渲染回调（Render Callbacks）另一种让组件逻辑复用的很棒的方法是 将组件子级转换成函数。这也是为什么 渲染回调（Render Callbacks） 也叫作 Function as Child Components。我们可以拿可伸展的菜单高阶组件作为例子，并使用 渲染回调 重写它。 现在我们可以传递一个函数作为 Toggleable 的子组件： 上面的代码已经使用函数作为子级，但，如果我们想要像高阶组件的例子那样复用它（多个菜单），我们可以简单地使用 Toggleable 逻辑创建一个新组件： 我们的新产品 ToggleableMenu 组件已经准备好了： 这种方式真的非常有用，当我们需要更改渲染内容而不用管 state 操作时：就像你所看到的，我们可以将渲染逻辑移动到 ToggleableMenu 的子级函数中，但却保持我们 Toggleable 组件的 state 逻辑！ 进一步阅读上面的例子只是一些可以用在 react 编程中的基础模式，如果你真的想深入这个主题，我建议你看看这些了不起的文章： React Component Patterns by Michael Chan React Patterns Presentational and Container Components React Higher Order Components in depth Function as Child Components Recompose Downshift]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Components</tag>
        <tag>Higher Order ComponentsRender</tag>
        <tag>Callback</tag>
        <tag>patterns</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 事件循环是如何工作的以及使用async／await提升异步编程的5种方式]]></title>
    <url>%2F2017%2F11%2F06%2Fhow-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-async-and-await.html</url>
    <content type="text"><![CDATA[javascript 事件循环是如何工作的以及使用async／await提升异步编程的5种方式这次我们将通过回顾在单线程环境中编程的缺点来扩展先前的第一篇文章，以及如何克服它来建立一个令人惊叹的 javascript UIs。像以往一样，在文章的最后，我会分享使用 async/await 写简洁代码的 5 个小贴士。 为什么单线程是一个限制？在我们推出的第一篇文章, 我们仔细思考了这个问题，当我们调用了一个非常耗时的函数时发生了什么。 想象一下，例如浏览器中运行着一个复杂的图像变换算法。 当调用栈执行函数时，浏览器不能做任何其他事——它被阻塞了。这意味着浏览器不能渲染，不能执行其他代码，暂时卡住了。那问题也来了————你的UI界面也不再顺畅和高效。 你的应用被卡住了。 它很丑陋，完全毁了你的用户体验： javascript 程序的组成部分你可能会把你的 javascript 应用写在单个 .js 文件里，但你的程序肯定包含着好几块，只有其只一块正在执行，其他的会稍后执行。最常见的块就是函数。 问题是，大多数新开发者似乎都觉得，这个 稍后执行 并不是严格地在 当前执行 之后立即执行。换句话说，任务当前不能立即完成，通过定义，将会异步完成。意味着不会出现上面所说的阻塞行为，就像你所期望或希望发生的那样。 让我们看看下面的例子： 你可能已经意识到，标准的 Ajax 事件不会同步完成。意味着当执行代码 ajax(...) 的时候，并不会立即返回值并赋值给变量 response。 一个简单的方法就是使用一个叫 回调函数（callback）的函数去等待异步函数返回的结果。 提醒一下：你实际可以发起一个 同步 的 Ajax 请求。但永远不要这样做。如果你发送一个同步 Ajax 请求, 你 javascript 应用的 UI 就会被阻塞————用户将不能点击，输入数据，导航或滚动。这会阻碍用户交互，非常糟糕的体验。 就像下面这样，但请永远不要这样做，不要毁了网页： 我们只是用 Ajax 请求做一个例子，你可以异步执行任意一段代码。 可以通过 setTimeout(callback, milliseconds) 函数来做到。setTimeout 函数建立一个延后发生的事件。就像这样： 将会输出 first third second 剖析事件循环我们会从一个奇怪的要求开始————尽管允许异步编码（就像刚刚讨论的setTimeout），直到 ES6， javascript从未有过真正直接的异步的概念。javascript 引擎在执行单一代码块的时刻不会再做任何事情。 关于javascript 引擎（google专用的V8引擎）的更多细节，请查看我们之前的文章. 那么，谁让 javascript 引擎执行程序块呢？现实中，javascript 引擎并不是孤立运行的————它运行在一个 宿主 环境中，对于大多数开发者来说，典型的是网页浏览器或者 Node.js。事实上，javascript 被嵌入到各种设备中，从机器人到小灯泡。每个设备代表 javascript 引擎的不同的宿主环境类型。 在所有环境中，不变的是拥有共同的称为 事件循环 的内置机制，控制处理多个程序块的执行时机。 这意味着 JS 引擎只是在执行环境中按需调用任意代码。它（执行JS代码的）是一个事件调度的环境。 那，举个例子，当你的 JS 程序发起一个 Ajax 请求去从服务器中获取一些数据，你在一个函数里设置了“响应”的代码（称为“回调函数”），JS 引擎告诉宿主环境：“嘿，我现在会暂停执行，但当网络请求完成时，并返回一些数据，请回来调用这个函数。” 浏览器会监听网络响应，并在拿到数据时返回给你，它会通过插入到 事件循环 中来调度回调函数。 让我们看看下面的图表： 你可以在以前的文章阅读到更多关于堆内存和调用栈的讨论。 这些 web APIs 是什么？本质上来讲，它们是无法访问的线程，你只能利用它。它们只是浏览器的并发访问的一部分。如果你是 Node.js 开发者，它们是 C++ APIs。 那么，事件循环 到底是什么呢？ 事件循环有一个简单的工作————监视调用栈和回调队列。如果调用栈清空了，它会获取队列里的第一个事件放入调用栈，高效地运行。 在事件循环中，像这样的一个迭代被称为 tick。每个事件都只是一个回调函数。 让我们一起“执行”这段代码，然后看看发生了什么： 1、状态是清空的。浏览器控制台是清空的，调用栈也是空的。 2、console.log('Hi')被添加进调用栈。 3、console.log('Hi')被执行。 4、 console.log('Hi') 被移出调用栈。 5、setTimeout(function cb1() { ... })被添加进调用栈。 6、 setTimeout(function cb1() { ... })被执行。浏览器通过 web api 创建了一个定时器。它将为你处理倒计时。 7、setTimeout(function cb1() { ... })被执行完毕并移出调用栈。 8、console.log('Bye')被添加进调用栈。 9、console.log('Bye')被执行。 10、console.log('Bye')被移出调用栈。 11、在 至少 5000毫秒之后，定时器完成，并将 cb1 回调推入回调队列。 12、事件循环从回调队列里取出 cb1 并推入调用栈。 13、cb1 被执行，并添加 console.log('cb1') 到调用栈。 14、console.log('cb1') 被执行。 15、console.log('cb1') 被移出调用栈。 16、cb1 被移出调用栈。 快速回顾一下： 有趣的是 ES6 指定了 事件循环如何工作，意味着技术上来讲，事件循环是在 JS 引擎的职责范围内的，它将不再扮演宿主环境的角色。这一变化的一个主要原因是 ES6 Promise 的介绍说：因为后者需要直接访问和细粒度地控制事件队列循环的调度操作。（稍后我们会更详细地讨论它们） setTimeout(…) 如何工作值得注意地的， setTimeout(…) 并不会自动将回调函数添加进事件循环队列。它只是设定一个定时器。当定时器到期时，运行环境将回调事件推入事件循环。所以未来 tick 会取出回调并执行它。看一眼这个代码： 它并不意味着 myCallback 将会在1000毫秒的时候立即执行，而是在1000毫秒后，myCallback 被添加进事件循环队列。但是，队列里可能已经有其他事件被更早地添加进来————你的回调必须等待。 有相当多的文章和教程在开始使用异步js时建议使用 setTimeout(callback, 0)。现在你知道事件循环是怎么回事以及 setTimeout 如何工作：调用第二个参数为 0 的 setTimeout 只是推迟执行回调函数直至调用栈清空。 看一下下面的代码： 尽管定时器设置为 0ms, 但浏览器控制台的结果是： Hi Bye callback ES6 里的 Jobs 是什么？在 ES6 介绍中，出现了一个新概念 “Jobs Queue”。它是事件循环之上的一层。当你处理 Promise 异步操作的时候，你几乎经常碰到它（我们也会谈谈它）。 我们先来谈谈这个概念，以便稍后讨论异步 Promise 表现的时候，你能理解那些行为是如何被调度和处理的。 想像一下，Job Queue 是一个附属于事件队列中每一个 tick 结尾的队列。某些异步行为可能会发生在事件循环的某一刻，却不会引起一个全新的事件添加到事件循环队列中。但会添加一个项目（也叫Job）到当前 tick 的 Job Queue。 这意味着你可以添加一个功能，让它稍后执行。并且你可以放心，它刚好会在其他事件之前，在那之后执行。 一个 Job 也能引起其他的 Job 添加到相同的队列后面。理论上，Job “循环”也是有可能产生的（一个不断添加其他 Jobs的Job之类）。这样需要资源的程序就必须移动到事件循环的下一个 tick。概念上看，这就类似于需要长时候运行或死循环（就像 while (true) ..）。 Job 就像 setTimeout(callback, 0) 的 hack，但通过引入一个更加明确的概念来实现：稍后执行，但尽可能快。 回调函数正如你所知道的，回调函数是迄今为止 javascript 程序中最常见的表达和管理异步的方式。的确，回调是 javascript 语言中最基本的异步模式。无数的JS程序，甚至是即使是非常复杂的一个，也不会少了最基础的回调异步模式。 除了回调，其他的不会没有缺点。许多开发者尝试寻找更好的异步模式。但是，如果不能很好地理解引擎下的工作原理，就不可能有效地使用任何抽象概念。 在接下来的章节，我们将探索这些抽象概念，深入地展示为什么更复杂的异步模式（这将在随后的帖子中讨论）是必须的，甚至是推荐的。 嵌套回调看下面的代码： 我们有三个函数嵌套在一起，每一个就代表异步系列的一步。 这种代码经常被称为“回调地狱（callback hell）”。但“回调地狱”实际上与嵌套、缩进没什么关系。这是一个更深入的问题。 首先，我们等待“点击”事件，然后等待定时器被触发，然后等待 Ajax 请求响应数据，在这一点，它可能会再次重复。 粗略地看，这段代码似乎自然而然地将异步映射为连续的步骤： 然后我们有： 再然后有： 最后我们有： 这样用连续的方式表达异步看起来更自然，不是吗？这种方式一定行得通，对吧？ Promise看一下这个代码： 这非常简单：将 x 和 y 的值相加然后输出在控制台。但是，如果 x 和 y 的值在用于表达式之前丢失了，或还不确定怎么办呢？让我们想象一下，我们有两个函数 loadx 和 loady 分别从服务端加载 x 和 y 的值。然后，有一个函数 sum 会在 x 和 y 都获取到值的时候相加。 代码看起来可能是这样的（非常丑陋，不是吗）： 这里有一些非常值得注意的事情——在上面的代码段中，我们假设 x 和 y 都是未来值，并且我们表达了一个操作函数 sum 并不关心 x或y或两者是否都可用。 当然，这种基于回调的方式不尽人意。这只是首先的一小步，为了更好地理解为什么不需要关心 未来值 何时可用这方面。 Promise Value让我们粗略地看一下，如何使用 Promise 来表达 x + y: 这个代码段中有两层 Promise. fetchX() 和 fetchY() 被直接调用，并且他们的返回值被传递到 sum(...) 。潜在的值可能在现在或稍后准备好，但每个 Promise 规定了它们的表现是相同的。我们以独立的方式分析 x 和 y的值。它们是未来的值，有一段期限。 第二层是sum(...) 创建的 Promise(来源于 Promise.all([ ... ]))。我们等待着调用 then(...) .当 sum(...) 操作符完成时，我们相加的未来的值已经准备好，并且可以输出。我们为了等待 x 和y 值，在 sum(...)中隐藏了逻辑。 注意： 在sum(…)之中，调用 Promise.all([ … ]) 创建一个 Promise （等待 promiseX 和 promiseY 完成）。调用链 .then(...) 创建另一个 Promise，立即返回 values[0] + values[1] （相加的结果）。sum(...) 后面调用的 then(...) 实际上是第二个Promise 返回的，而不是第一个 Promise.all([ ... ]) 返回的。同样，我们没有链接第二个 then(...), 它也同样已经创建了另一个 Promise。这一 Promise 链的内容将在本章结尾详细解释。 使用 Promise, then(...) 实际上可以传入两个函数，第一个对应完成状态，第二个是对应失败状态。 如果在获取 x 或 y 的时候发生错误，或者在相加的时候出错，sum(...) 会返回失败，并且传入 then(...) 的第二个错误处理函数会收到 Promise 返回的值。 因为 Promise 封装了依赖时间的状态——等待底层值的完成或失败——从外部看，Promise 本身是依赖时间的，因此 Promise 可以以可预测的方式组合起来，而不用考虑时间和结果。 此外，一旦 Promise 解决了，它将永入停留在那个状态——它这时变成一个 不可变的 值——并且根据需要可以观察多次。 链式调用 Promise 真的非常有用： 调用 delay(2000) 创建一个 Promise 将会在 2000ms 后达到条件，然后从第一个 then(...) 成功回调返回，这会造成第二个 then(...) 会等待 2000ms 的 Promise. 注意： 因为 Promise 从外部看来如果被解决了是无法再改变的，现在把值传到任何一部分都是安全的，它不能被恶意或意外地修改。尤其是关系到多个 Promise 遵守协议。一方不可能影响另一方遵守协议的能力。不变性听起来关系到学术性的话题。但它实际上是 Promise 设计的最基本也是最重要的部分，不应该随便错过。 用还是不用 Promise关于 Promise 有一个很重要的细节就是要知道某个值是否是 Promise。换句话说，某个值表现得像 Promise 吗？ 我们知道，Promise 通过 new Promise(…) 语法构造，然后你认为 p instanceof Promise 足以检查它是否是一个 Promise。但，并不完全是。 主要是因为你可以有通过其他的浏览窗口接收一个 Promise 值（比如：iframe），它有它所属的 Promise， 不同于当前窗口的，并且检测是否是 Promise 实例会返回失败。 此外，一个类库或框架可能会选择自己使用的 Promise 实现版本，而不是使用 ES6 原生实现的 Promise。通过类库使用 Promise 可能在不支持 Promise 的浏览器上工作得很好。 被吞掉的异常如果任何时候创建一个 Promise ，或正在监听它决策的时候，发生了意外错误，比如 TypeError 或者 ReferenceError, 异常将会被捕获，并且这个 Promise 将会被强制变成失败状态。 举个例子： 但如果一个 Promise 还没有变成成功状态，却在观察期间发生了异常会怎样呢（在 then(...) 注册了回调）？尽管这个异常可以捕获，但它的处理方式可能让你有点吃惊。让我们挖得更深一点。 这看起来发生在 foo.bar() 的异常确实被吞掉了。虽然事实并没有。有一些更深的东西发生了错误，但是，我们并没有监听到。p.then(…) 返回另一个 Promise，而且这个 Promise 会因为 TypeError 变成失败状态。 处理未捕获的异常还有其他一些许多人认为 更好 的解决办法。 一个普遍的建议就是 Promise 应该添加一个 done(…)，意味着 Promise 链式调用已“完成”。done(…) 不会再创建并返回一个 Promise，所以传递回调函数到 done(..) 显然不能与不存在的 Promise 连接上报异常。 你可能期望发现任何未捕获的错误的情况：任何 done(..) 中的异常都会抛出全局的未捕获的错误（基本都会出现在控制台）： ES8 有什么变化？Async/awaitjavascript ES8 推出了 async/await 让 Promise 的工作更容易更简单。我们简要地看看 async/await 提供了什么并利用它们写一些异步代码。 那么，让我们来看看 async/await 是如何工作的。 你可以使用 async 声明定义一个异步函数。这样的函数返回一个异步函数对象。AsyncFunction 对象代表异步函数执行代码，并包含在那个宿主函数中。 当异步函数被调用时，它返回一个 Promise。当异步函数返回一个值时，那就不是一个 Promise。Promise 会被自动创建，并且会通过返回值来完成状态。当 async 抛出异常，Promise 将抛出值并变成失败状态。 一个 async 函数可以包含一个 await 表达式，它会暂停执行函数内的代码并等待 Promise 返回结果，然后继续执行异步函数并返回结果。 你可以认为 Promise 与 Java中的Future或者 C# 的任务。 使用 async/await 的目的是为了简化使用 Promise 的行为。 看下面的代码： 同样的，异步函数内抛出异常相当于普通函数抛出一个被拒绝的 Promise： await 语句只有用在 async 函数内，并允许你在 Promise 进行同步等待。如果我们要在 async 函数外使用 Promise, 我们仍要使用 then 来执行回调： 你也可以使用“异步函数表达式”来定义异步函数。一个异步函数表达式和一个异步函数声明很类似，几乎有相同的语法。他们之前主要的不同就是函数名。异步函数表达式可以省略函数名，创建一个匿名函数。异步函数表达式可以被当成 IIFE（自执行函数）来使用，一经定义就执行。 看下这个： 更重要的地，async/await 在主流浏览器中的支持情况： 最后，最重要的是不要盲目地选择“最新”的写法去实现异步函数。本质是要理解异步 javascript 的内部原理。了解它为什么如此关键，并深入理解你的选择的内部原理。每种方法都有优缺点，就像编程中的其他部分一样。 编写高可维护性，健壮的代码的5个提示1、 简洁的代码使用 async/await 允许你写很少的代码。每次你使用 async/await 跳过一些不必须要步骤：写 .then 时，创建一个匿名函数去处理回应，给返回值命名。例如： 与： 2、错误处理Async/await 让处理同步和异步错误使用相同的方法——广为人知的 try/catch。 与： 3、条件语句使用 async/await 写条件句更简单： 与： 4、堆栈帧与 async/await 不同，Promise 抛出的错误栈并没有包含错误发生在哪里。 与： 5、调试如果你使用过 Promise, 你一定知道调试它们是一个噩梦。例如，如果你在一个 .then 打了个断点，并且使用调试快捷键操作，像“stop-over”，调试器并不会移动到下一个 .then ，因为它只是同步代码的“一步”。使用 async/await 你可以精确地定位到每一步 await，就好像他们是正常的同步函数一样。 书写异步函数不仅对应用程序很重要，对类库也同样如此。 举个例子： Sessionstak 类记录了网页上发生的所有事情。所有 DOM 操作，用户交互，javascript 异常，堆栈跟踪，失败的网络请求，以及调试信息。 这一切都发生在生产环境下却不影响用户体验。我们必须高度优化我们的代码，让它们尽可能地异步，这样就可以增加事件循环处理事件的数量。 也不止是类库，当你在 SessionStack 重播用户的会话时，我们必须在发生问题时，将用户浏览器的状态重现出来，我们必须重建整个状态，允许你在时间轴上向后或向前跳跃。为了让这成为可能，我们大量使用了异步javascript提供的机会。 这里有一个免费的计划让你来体验一下。 参考： https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch2.md https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch3.md http://nikgrozev.com/2017/10/01/async-await/]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>tutorial</tag>
        <tag>web development</tag>
        <tag>programming</tag>
        <tag>asynchronous</tag>
        <tag>events loop</tag>
        <tag>promise</tag>
        <tag>async await</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你可能并不需要 redux]]></title>
    <url>%2F2017%2F10%2F25%2Fyou-might-not-need-redux.html</url>
    <content type="text"><![CDATA[你可能并不需要 redux人们常常在真正需要用到 redux 之前就选择了它。 “如果我们的应用没有使用 redux，变得不好扩展怎么办？” 后来，开发者们又都皱着眉头指头他们的代码间接地评论 redux.“为什么实现一个小功能需要更改三个文件？” 为什么一定要用 redux 呢! 大家痛苦地指责 redux, react, 函数式编程、 不变性等这些东西，我能理解他们。我们很自然地会拿 redux 和不需要‘按模板’来更新 state 的实现方式进行比较，并得出 redux 只会让事情变复杂的结论。某种程度上看，redux 是被设计成这样的。 redux 做了一个权衡，它要求你： 将应用的状态抽象成简单对象或数组。 将系统的变化抽象成简单对象。 将处理逻辑抽象成纯函数。 不管是不是应用在 react 应用程序上，这些限制都是必需的。事实上，这些都是很严格的约束。就算只是在你应用程序的一部分中使用，也应该认真考虑它。 有人会问，你有充分的理由解释为什么要做这些限制吗？ 这些限制对我很有吸引力，因为它们让我的应用拥有以下优点： 将 state 存储在本地，并用它启动，开箱即用 在服务端预渲染 state，并随 html 发送到客户端，从它启动，开箱即用 序列化用户交互并触发它，以及进行状态快照，自动 bugs 上报，以便让开发者重现 errors 通过网络传递 action 对象，而不会对写代码的方式产生大的影响 保持重做历史和实现可预测的变化，而不会对写法产生剧大的影响 开发环境中可以随意穿梭在历史的各个状态中，并在代码更改时根据交互历史重新计算当前状态，一种 TDD 驱动 为开发工具提供全面的检测和控制能力，以便产品开发者为他们的 app 构建自定义开发工具 当复用大部分业务逻辑的同时，也提供备用 UI 如果你正在开发可扩展的 terminal, javascript 调试器, 或某些类型的 webapp, redux 可能很值得一试，或者至少借鉴它的一些思想（顺便提一下，这些并不是 新事物）。 但是，如果你只是在学习 react, 那么不要把 redux 当成你的首选。 相反，学会 思考 react, 如果你发现你真的需要它，或者你想尝试一些新东西，那就重新考虑 redux 吧。但是一定要谨慎对待它，就像对待固执已见的工具一样。 如果你对 redux 的方式感到压力。这是一个信号，可能你的队友太认真了。 它只是你工具箱里的一个工具，一个疯狂 的实验。 最后，不要忘记，你可以不用 redux,而实现 redux 的思想。 举个例子，考虑一个带有 local state 的 react 组件: 看上去很好。严格地说，它没有达到高度复用。 但是，这样使用 Local state 就很好。 权衡之下，redux 提供解耦，将“发生了什么交互”与“数据如何改变”解耦。 举个例子，可以从我们的组件中提取出一个 reducer: 注意，我们没有运行 npm install 却应用了 redux ! 哇哦！ 你的状态组件是否也需要这样写呢？可能不需要。除非你有计划地从这种解耦方式中获益。有计划是我们的一种说法，这是关键。 redux 库本身只是“安装” reducer 和单个全局 store 对象的工具集。你可以只使用部分或者全部功能，这取决于你。 但，如果你付出了什么，一定要确保你有所收获。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解 ios11 webview 的 viewport]]></title>
    <url>%2F2017%2F09%2F21%2FUnderstanding-the-WebView-Viewport-in-iOS-11.html</url>
    <content type="text"><![CDATA[深入理解 ios11 webview 的 viewportios11 带来了一些新的东西，凭直觉，围绕状态栏区域的展现对于程序员使用的像 Apache Cordova 或 Ionic 这样的工具显得尤为重要。尤其是，这个改动影响到所有为 ios11 构建的、基于 web 的、使用了固定标题栏的 app 之中。这篇文章帮助你理解 ios11 webview 的 viewport。 注： 现有的 app 可以继续正常工作，因为原有的 viewport 表现并没有被改变。这个改变只影响那些使用 xcode9 来为 ios11 构建的应用。 为了理解这个改动，我们需要先了解一下背景知识。 状态栏和安全区域在 ios 的早期版本中，状态栏是屏幕顶部的不可触摸的黑色长条。它是系统 UI 的一部分，而 app 运行在它的下面。 随着 ios7 的发布，一切发生了改变。它变成了一个透明的状态栏，从而显示了 app 导航栏的颜色。对于像 Cordova 这样显示在 webview 的 app, 意味着通常需要检测是否 ios 并添加 padding-top: 20px 到固定的头部导航, 以便正确填充那部分空间。 后来发布的较新版本的 ios 添加了一些小修订。包含了一些新功能，比如当有电话呼入或在后台使用定位功能时顶部会展示额外的状态栏。 在原生应用方面，存在大量的导航栏和自动布局指南。会有一些布局指示在屏幕的顶部或底部以便自动调整高度，让状态栏不会遮住应用。如果在顶部设置了 UINavigationBar， ios 会自动在状态栏拓展它的颜色。对于 web，很不幸，没有等价的办法。 iOS11 的改变 ios11 和先前版本的不同之处在于， webview 内容现在重视安全区域了。这意味着，如果设置头部栏 top: 0, 它会渲染在屏幕顶部的20px之下，也就是状态栏下面。当向下浏览时，会移到状态栏后面。当向上浏览时，又会移动状态栏下面与状态栏部对齐。（留下尴尬的20像素空白） 可以看看下面剪辑的视频中了解到有多么糟糕： 为什么苹果公司会改成这个样子如果你看过 iPhone X 的设计，就知道它这样改动是有道理的： iPhone X 的屏幕顶部有个为摄像头和话筒留出的不规则区域。如果真的渲染到屏幕顶部，就会被麦克风挡住。 通过对齐状态栏底部，可以确保头部栏可以一直被访问。 酷！…除了现在 app 上面滑动内容时在状态栏底下留下的尴尬的空白。 iOS11 解决方案值得庆幸的是，Apple 给我们提供了一个通过设置 viewport meta 标签的解决方案。更幸运的是，它还向下兼容旧的，过期的 UIWebView。 我们正在找的 viewport 选项就是 viewport-fit,它有三个可选值： contain： 这意味着 iOS11 下，固定栏会被包含在安全区域内。 cover： 这意味着固定栏是相对 viewport 固定的，就算会被立大状态栏遮蔽。这就回到了 iOS10 的表现。 auto： 这和 contain 选项的表现是一样的。 所以为了恢复到固定在屏幕的最顶端，就像 iOS10 一样在状态栏下面。可以添加 viewport-fit=cover 到 viewport meta 标签。 iPhone X但 iPhone X 的小刘海怎么办？这个状态栏不再是 20px 高，并且因为里面有摄像头和扬声器，头部栏会完全无法访问。同样要注意固定在屏幕底部的页脚，它会被麦克风遮住。 注：如果有启动脚本，应用将只会运行在 iPhone X 的全屏幕上。现有的 app 会在顶部和底部有黑色区域。 幸运的是，Apple 给出了一个关于安全区域的 css 指南。他们添加一个类似 css 变量，叫做 css 常数。可以把它看做是系统的 css 变量并且不可覆盖。可以在 css 中通过constant() 函数来调用它们，并且已向 css 标准化工作小组提案。 这四个布局常量是： constant(safe-area-inset-top): viewport 顶部插入的安全区域（使用 css 像素） constant(safe-area-inset-bottom): viewport 底部插入的安全区域（使用 css 像素） constant(safe-area-inset-left): viewport 左边插入的安全区域（使用 css 像素） constant(safe-area-inset-right): viewport 右边插入的安全区域（使用 css 像素） 这是 Apple 给我们的最后一个礼物，也是向下兼容的。 css constants 的例子假设有一个头部固定栏，现在 iOS10 下的 css 如下： header { position: fixed; top: 0; left: 0; right: 0; height: 44px; padding-top: 20px; /* Status bar height */ } 为了调整自适应 iPhone X 和 iOS11 设备，会添加 viewport-fit=cover 选项到 viewport meta 标签上，并且更改 css， 引用 css constant。 header { /* ... */ /* Status bar height on iOS 10 */ padding-top: 20px; /* Status bar height on iOS 11+ */ padding-top: constant(safe-area-inset-top); } 重要的是，要保留回退值，因为旧设备不能解释 css constant() 语法。别外，也可以在 css calc() 表达式中使用 constants. 记住，你也会想要在屏幕底部做这件事的。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>ios11</tag>
        <tag>viewport</tag>
        <tag>css-constant</tag>
        <tag>viewport-fit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IphoneX 的缺口（小刘海）及其css样式解决方案]]></title>
    <url>%2F2017%2F09%2F21%2Fthe-notch-and-css.html</url>
    <content type="text"><![CDATA[IphoneX 的缺口（小刘海）及其css样式解决方案苹果公司的 IphoneX 拥有了全面屏，只保留了‘小刘海’给摄像头和一些传感设备。结果就是让屏幕设计陷入尴尬的境地，就像限制网页有一个“安全区域”和白色边缘条。虽然没有太多的黑魔法去消除它，但给 body 设置一个 background-color 属性也可以做到。或者扩展网页以覆盖整个屏幕（该死的缺口），可以给 viewport 的 meta 标签添加 viewport-fit=cover。 然后，由你自己决定如何处理安全区域的重叠。这里有一些新的 css 可以帮助适配它。Stephen Radford documents 为了适配缺口，可以引入 ios 11 版本包含的一些常量，这些常量需要使用了 viewport-fit=cover 才会生效。 safe-area-inset-top safe-area-inset-right safe-area-inset-left safe-area-inset-bottom 这些常量可以被用在 margin, padding, 或者绝对定位的 top, left 等属性上。 padding: constant(safe-area-inset-top) constant(safe-area-inset-right) constant(safe-area-inset-bottom) constant(safe-area-inset-left); 还有另外一个尴尬的局面关于缺口，安全区域和 fixed 定位。Darryl Pogue reports: ios 11与早期的版本不太一样，它现在遵守安全区域这一规则。这意味着，如果你有一个 header bar， 并且设置 position: fixed;top: 0;，它初始化时会渲染在顶部的 20px 下面：对齐顶部状态栏的底部。当你向下浏览网页，它会隐藏状态栏。如果向上滚动，状态栏又来跑出来（留下尴尬的20px间隙）。 幸运的是这也很容易解决。只需要添加 viewport-fit=cover 到 meta viewport 标签上。 如果覆盖了全屏幕，那可能需要耍点小聪明去避免挡住内容。 I think I’ve fixed the notch issue in landscape 🍾 #iphoneX pic.twitter.com/hGytyO3DRV— Vojta Stavik (@vojtastavik) September 13, 2017]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>viewport</tag>
        <tag>css</tag>
        <tag>iphoneX</tag>
        <tag>notch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何处理4种常见的内存泄露]]></title>
    <url>%2F2017%2F09%2F19%2Fhow-to-handle-4-common-memory-leaks.html</url>
    <content type="text"><![CDATA[如何处理4种常见的内存泄露什么是内存泄露本质上来说，内存泄露可以被定义为 当内存不再被应用使用，却因为某些原因没有被操作系统回收或释放到自由内存池 编程语言支持多种不同的内存管理。某些内存是否在使用实际上是不可判定的。换句话说，只要开发者才清楚哪些内存块是可以被操作系统回收。 某些编程语言提供一些特性帮助开发者进行内存回收。其他的期望开发者完全明白哪些内存是无用的。维基有一系列关于内存管理的好文章。 四种常见的内存泄露1. 全局变量javascript 通过一个有趣的方式处理未声明的变量：引用未声明的变量会在全局对象里创建一个变量。在浏览器中，全局对象是window, 换句话说： function foo(arg) { bar = "some text"; } 等价于： function foo(arg) { window.bar = "some text"; } 如果 bar 预想中是 foo 函数作用域内的局部变量，但又忘记使用 var 去声明，那么预料之外的全局变量就被创建了。 在这个例子中，一个简单的字符串泄露不会有多大害处，但这种写法当然会有更糟情况。 另一个意外创建全局变量的方式是通过 this： function foo() { this.var1 = "potential accidental global"; } // Foo called on its own, this points to the global object (window) // rather than being undefined. foo(); 为了防止这种情况发生，需要在 javascript 文件的开头添加 'use strict'.这会使用严格模式解析javascript以防止意外的全局变量。了解更多javascript严格模式的执行情况 尽管我们在谈论意外的全局变量，但仍然会有无数的明确的全局变量。这些被定义为不可回收的（除非指定为null或重新分配）。特别是应该关注用于临时存储和处理大量数据的全局变量。如果必须要用全局变量去存储大量数据，当你处理完之后，请勿必记得指定为null或重新全配 2. 被遗忘的定时器和回调在 javascript 中使用 setInterval 非常常见。 大部分类库提供观察者和其他调用回调的工具，小心地引用那些 拥有会变得不可访问的实例 的回调。setInterval 的例子，尽管这很常见： var serverData = loadData(); setInterval(function() { var renderer = document.getElementById('renderer'); if(renderer) { renderer.innerHTML = JSON.stringify(serverData); } }, 5000); //This will be executed every ~5 seconds. 这个例子说明了定时器会发生的事：定时器引用了不再需要的node节点和数据。 被 renderer 引用的对象在将来某个时刻可能会被删除，让整个内部块都变得不必要了。但是，因为定时器还在运行，所以处理程序不能被回收（定时器需要被停止才能回收）。如果定时处理程序不能被回收，那么相关的一切都不能被回收。这意味着可能存储着大量数据的 serverData 也不能被回收。 观察者的例子中，很重要的一点是当不在需要的时候，必须明确移除他们（或者让相关的对象变得不可访问）。 在过去，这对于某些不能很好地管理内存的浏览器（像IE6）是非常重要的。如今，大部分浏览器有能力并且会回收不可访问的观察者处理程序，就算有时监听器没有被明确地移除。这仍然是很好的做法，不管怎样，在对象被处理掉之前明确地移除观察者。举个实例： var element = document.getElementById('launch-button'); var counter = 0; function onClick(event) { counter++; element.innerHtml = 'text ' + counter; } element.addEventListener('click', onClick); // Do stuff element.removeEventListener('click', onClick); element.parentNode.removeChild(element); // Now when element goes out of scope, // both element and onClick will be collected even in old browsers // that don't handle cycles well. 框架或类库，比如 jQuery 在删除 node 节点的时候就移除了监听事件（当使用它的API的时候），这是类库内部处理的，为了防止内存泄露产生。就算在有问题的浏览器下运行，比如…对，IE6 ：） 闭包（closure）javascript 开发一个关键点是 闭包： 一个内部函数可以访问（封闭的）外部函数的变量。由于 javascript 运行环境的实现，以下方式很可能造成内存泄露： var theThing = null; var replaceThing = function () { var originalThing = theThing; var unused = function () { if (originalThing) // a reference to 'originalThing' console.log("hi"); }; theThing = { longStr: new Array(1000000).join('*'), someMethod: function () { console.log("message"); } }; }; setInterval(replaceThing, 1000); 这段代码做了一件事：每次调用 replaceThing 时，theThing 指向了一个包含大数据和闭包（someMethod）的新对象，同时， unused 也指向一个引用了 originalThing（theThing 指向前一次 replaceThing 调用） 的闭包，已经有点混乱了，啊哈？重点是，一旦为一个具有相同父级作用域的闭包创建作用域，作用域是共享的 这种情况下， 为闭包 someMethod 创建的作用域与 unused 共享。unused 有一个指向 originalThing 的引用。尽管 unused 从未被使用，但是 someMethod 可以通过 theThing 也就是 replaceThing 外围的作用域（例如：全局范围内）调用。与此同时 someMethod 与 unused 共享闭包作用域，unused 引用 originalThing 迫使它保持在内存中（在两个闭包共享的作用域范围）。这阻止了它被回收。 当这段代码反复地运行时，可以观察到内存使用率稳定地增长。GC 运行时也并未减少。本质上，一个闭包链被创建了（通过根作用域的 theThing 变量）。而每一个闭包作用域附带着引用了大数据，结果就是内存泄露。 这个问题被 Meteor 团队发现并发表了著名的文章描述这个问题。 4. 额外的 DOM 引用有时在数据结构中引用 DOM 节点很有用。假设你想迅速地更新一个表格中的几行内容。可能感觉在字典中或数据中引用 DOM row 是有意义的。在这种情况发生时，两个对相同 DOM 的引用被保持：一个在 DOM 树，另一个在字典中。如果将来某个时间点，你想删除这几行表格，你要确保这两个者失去引用。 var elements = { button: document.getElementById('button'), image: document.getElementById('image') }; function doStuff() { image.src = 'http://example.com/image_name.png'; } function removeImage() { // The image is a direct child of the body element. document.body.removeChild(document.getElementById('image')); // At this point, we still have a reference to #button in the //global elements object. In other words, the button element is //still in memory and cannot be collected by the GC. } 这里还有额外的点需要注意，当涉及到 DOM 树或子节点的引用。比如说在 javascript 代码中引用了表格的某个格子（一个标签）。某天你决定删除表格但还保持着单元格的引用。直观的假设就是 GC 会回收表格，但保留单元格。事实上，这是不可能的：单元格是表格的子节点，它保持着对父级表格的引用。javascript 代码保持单元格的引用导致 整个表格被保留在内存中。所以请谨慎考虑引用 DOM 元素。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>memory leaks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[避免大型，复杂的布局和布局颠覆]]></title>
    <url>%2F2017%2F08%2F30%2Favoid-large-complex-layouts-and-layout-thrashing.html</url>
    <content type="text"><![CDATA[避免大型，复杂的布局和布局颠覆布局是浏览器查找元素的几何信息：其大小和页面中的位置。每个元素将基于所使用的CSS，元素的内容或父元素显示或隐式的大小调整信息。该过程在 Chrome，Opera，Safari 和 Internet Explorer中称为“布局”。在 Firefox 中，它被称为 Reflow （回流），但是这个过程的作用是相同的。 类似于 style 计算，布局成本的直接相关是： 需要布局的元素数量。 这些布局的复杂性。 TL; DR 布局通常作用于整个文档。 DOM 元素的数量将影响性能; 您应尽可能避免触发布局。 评估布局模型性能; 新的Flexbox通常比旧版Flexbox或基于浮动的布局模型更快。 避免强制同步布局和布局颠覆; 先读取样式值，然后再进行样式更改。 尽可能避免布局当您更改样式时，浏览器将检查以查看是否有任何更改需要计算布局，并为该渲染树进行更新。对“几何属性”的更改，如宽度，高度，左侧或顶部都需要布局。 .box { width: 20px; height: 20px; } /** * 改变宽高 * 触发 layout. */ .box--expanded { width: 200px; height: 350px; } 布局几乎总是作用于整个文档。如果你有很多元素，那么需要很长时间来确定它们的位置和尺寸。 如果不可能避免布局，那么关键是再次使用 Chrome DevTools 来查看花费多长时间，并确定布局是否是瓶颈的原因。首先，打开 DevTools，转到“时间轴”选项卡，点击记录并与您的网站进行交互。当您停止录制时，您会看到您的网站执行的细目： 当在上面的例子中挖掘每一帧时，我们看到在布局中花费了超过20毫秒，当我们的屏幕在动画中有16ms时，这太高了。您还可以看到，DevTools 会告诉您 DOM 树的大小（在这种情况下为1,618个元素），以及需要多少个节点进行布局。 注意：想要明确列出哪些 CSS 属性触发布局(layout)，绘画(paint)或复合(composite)？查看CSS触发器。 在旧的布局模型上使用 flexbox网络上有一系列的布局模式，其中一些比其他模型更受广泛支持。最旧的 CSS 布局模型允许我们在屏幕上进行相对，绝对地定位元素和浮动元素。 下面的截图显示了在1,300个盒子上使用浮点数时的布局成本。诚然，这是一个例证，因为大多数应用程序将使用各种方法来定位元素。 如果我们更新样本以使用 Flexbox，这是Web平台上最近的一个补充，我们得到了一个不同的图片： 现在，在相同数量的元素和相同的视觉外观的布局中，我们花费更少的时间（在这种情况下，3.5ms对14ms）。重要的是要记住，对于某些浏览器环境，您可能无法选择 Flexbox，因为它比浮动布局更不受支持，但您应该至少应该调查布局模型对您的性能的影响，并将其最小化执行成本 无论您是否选择Flexbox，您仍然应该 尝试避免 在应用程序的高压点 完全触发布局！ 避免强制同步布局运送一个框架到屏幕有这样的顺序： 首先 JavaScript 运行，然后进行风格计算，然后进行布局。然而，可以强制浏览器使用 JavaScript 更早地执行布局。它被称为 强制同步布局。 要记住的第一件事是，由于 JavaScript 运行，所有旧的布局值都是已知的，可供您查询。所以如果你想在下一帧之前写出一个元素的高度（我们称之为“box”），你可以编写一些这样的代码： // Schedule our function to run at the start of the frame. requestAnimationFrame(logBoxHeight); function logBoxHeight() { // Gets the height of the box in pixels and logs it out. console.log(box.offsetHeight); } 如果您在要求其高度之前更改了 box 的样式，那么事情会变得有问题： function logBoxHeight() { box.classList.add('super-big'); // Gets the height of the box in pixels // and logs it out. console.log(box.offsetHeight); } 现在，为了回答高度问题，浏览器必须首先应用样式更改（因为添加了 super-big 类），然后运行布局。只有这样才能恢复正确的高度。这是不必要的和潜在的昂贵的工作。 因此，您应该始终批评这类的样式读取，并首先执行（浏览器可以使用上一帧的布局值），然后执行任何写操作： 完成上述功能将是： function logBoxHeight() { // Gets the height of the box in pixels // and logs it out. console.log(box.offsetHeight); box.classList.add('super-big'); } 在大多数情况下，您不应该需要应用样式，然后查询值; 使用最后一帧的值应该是足够的。过早地运行 style 计算和布局是浏览器同步和布局潜在的瓶颈，这不是您通常想要做的事情。 避免布局颠覆有一种方法可以使强制同步布局更加糟糕：快速连续地做很多事情。看看这段代码： function resizeAllParagraphsToMatchBlockWidth() { // Puts the browser into a read-write-read-write cycle. for (var i = 0; i &lt; paragraphs.length; i++) { paragraphs[i].style.width = box.offsetWidth + 'px'; } } 此代码循环遍历一组段落，并设置每个段落的宽度以匹配名为“box”的元素的宽度。它看起来很无害，但问题是循环的每次迭代读取一个样式值（box.offsetWidth），然后立即使用它来更新一个paragraph（paragraphs[i].style.width）的宽度。在循环的下一个迭代中，浏览器必须考虑到 offsetWidth 上一次请求（在上一次迭代中）样式已经改变的事实，因此它必须应用样式更改并运行布局。这将在每一次迭代中发生！ 此示例的解决方法是缓存读取值，然后写值： // Read. var width = box.offsetWidth; function resizeAllParagraphsToMatchBlockWidth() { for (var i = 0; i &lt; paragraphs.length; i++) { // Now write. paragraphs[i].style.width = width + 'px'; } } 如果您想保证安全性，您应该检查FastDOM，这将自动为您分配读取和写入数据，并且应防止您意外触发强制同步布局或布局颠覆。 【翻译原文】:Avoid Large, Complex Layouts and Layout Thrashing]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>layout</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 requestIdleCallback]]></title>
    <url>%2F2017%2F08%2F25%2Fusing-requestIdleCallback.html</url>
    <content type="text"><![CDATA[使用 requestIdleCallback许多网站和应用程序都有很多脚本来执行。您的 JavaScript 通常需要尽快运行，但同时您不希望它阻碍用户那条路。如果您在用户滚动页面时发送分析数据，或者在轻触按钮时将元素附加到 DOM，则您的 Web 应用程序将无法响应，从而导致用户体验不佳。 好消息是，现在有一个 API 可以帮助：requestIdleCallback。以同样的方式，requestAnimationFrame 我们可以正确地安排动画，并最大限度地提高 60fps 的机会，requestIdleCallback 当一个框架结束时，或当用户处于非活动状态时，可以安排工作。这意味着有机会在用户不使用的情况下进行工作。它可用于 Chrome 47！这是一个实验性的功能，规格还在不断变化，所以将来会发生变化。 检查 requestIdleCallback 支持这是早期的 requestIdleCallback，所以在使用它之前，您应该检查它是否可用： if ('requestIdleCallback' in window) { // Use requestIdleCallback to schedule work. } else { // Do what you’d do today. } 你也可以 polyfill 它的行为，这需要回到 setTimeout： window.requestIdleCallback = window.requestIdleCallback || function (cb) { var start = Date.now(); return setTimeout(function () { cb({ didTimeout: false, timeRemaining: function () { return Math.max(0, 50 - (Date.now() - start)); } }); }, 1); } window.cancelIdleCallback = window.cancelIdleCallback || function (id) { clearTimeout(id); } 使用 setTimeout 不是很好，因为它不知道 requestIdleCallback 的空闲时间是如何工作的，但是如果 requestIdleCallback 不可用的话，你可以直接调用你的回调，你没有比这更差的方式。有了垫片，requestIdleCallback 就可以使用，你将被默认重定向到直接调用，这是很棒的。 现在，我们假设它存在。 使用requestIdleCallback调用 requestIdleCallback 非常类似于 requestAnimationFrame, 它需要回调函数作为其第一个参数： requestIdleCallback(myNonEssentialWork); 当 myNonEssentialWork 被调用时，它将被赋予一个 deadline, 它是一个包含函数的对象，该函数返回一个数字，指示您的工作剩余多少时间： function myNonEssentialWork (deadline) { while (deadline.timeRemaining() > 0) doWorkIfNeeded(); } timeRemaining 可以调用该函数来获取最新值。当 timeRemaining() 返回零时，您可以安排另一个 requestIdleCallback, 如果您还有更多的工作要做： function myNonEssentialWork (deadline) { while (deadline.timeRemaining() > 0 &amp;&amp; tasks.length > 0) doWorkIfNeeded(); if (tasks.length > 0) requestIdleCallback(myNonEssentialWork); } 调用你的任务如果浏览器真的很忙，你该怎么办？您可能会担心您的回调可能永远不会被调用。嗯，虽然 requestIdleCallback 类似 requestAnimationFrame，但它也有所不同，它需要一个可选的第二个参数：具有 timeout 属性的 options 对象。此超时（如果设置）为浏览器提供了必须执行回调的时间（以毫秒为单位）： // Wait at most two seconds before processing events. requestIdleCallback(processPendingAnalyticsEvents, { timeout: 2000 }); 如果您的回调由于超时触发而执行，您会注意到两件事情： timeRemaining() 将返回零。 对象的 didTimeout 属性 deadline 将为 true。 如果你看到这 didTimeout 是真的，你很可能只想运行这个工作并完成它： function myNonEssentialWork (deadline) { // Use any remaining time, or, if timed out, just run through the tasks. while ((deadline.timeRemaining() > 0 || deadline.didTimeout) &amp;&amp; tasks.length > 0) doWorkIfNeeded(); if (tasks.length > 0) requestIdleCallback(myNonEssentialWork); } 由于潜在的中断，这种超时可能会导致您的用户（工作可能会导致您的应用程序变得无响应或janky）设置此参数时要谨慎。在哪里可以让浏览器决定何时调用回调。 使用 requestIdleCallback 发送分析数据让我们来看看 requestIdleCallback 发送分析数据。在这种情况下，我们可能会想跟踪一个事件，比如说 - 点击导航菜单。不过，由于通常在萤幕上设定动画，我们希望避免立即将此事件发送到 Google Analytics（分析）。我们将创建一系列事件来发送和请求在将来的某个时间发送它们： var eventsToSend = []; function onNavOpenClick () { // Animate the menu. menu.classList.add('open'); // Store the event for later. eventsToSend.push( { category: 'button', action: 'click', label: 'nav', value: 'open' }); schedulePendingEvents(); } 现在我们需要使用 requestIdleCallback 来处理任何待处理的事件： function schedulePendingEvents() { // Only schedule the rIC if one has not already been set. if (isRequestIdleCallbackScheduled) return; isRequestIdleCallbackScheduled = true; if ('requestIdleCallback' in window) { // Wait at most two seconds before processing events. requestIdleCallback(processPendingAnalyticsEvents, { timeout: 2000 }); } else { processPendingAnalyticsEvents(); } } 在这里，您可以看到我设置了2秒的超时时间，但这个值取决于你的应用程序。对于分析数据，有意义的是，将使用超时时间来确保数据在合理的时间内报告，而不仅仅是在将来的某个时间点。 最后我们需要编写 requestIdleCallback 将执行的函数。 function processPendingAnalyticsEvents (deadline) { // Reset the boolean so future rICs can be set. isRequestIdleCallbackScheduled = false; // If there is no deadline, just run as long as necessary. // This will be the case if requestIdleCallback doesn’t exist. if (typeof deadline === 'undefined') deadline = { timeRemaining: function () { return Number.MAX_VALUE } }; // Go for as long as there is time remaining and work to do. while (deadline.timeRemaining() > 0 &amp;&amp; eventsToSend.length > 0) { var evt = eventsToSend.pop(); ga('send', 'event', evt.category, evt.action, evt.label, evt.value); } // Check if there are more events still to send. if (eventsToSend.length > 0) schedulePendingEvents(); } 对于这个例子，我假设如果 requestIdleCallback 不存在分析数据应该立即发送。然而，在生产应用程序中，延迟发送超时可能会更好，以确保它不会与任何交互冲突，并导致 jank。 使用 requestIdleCallback 进行 DOM 更改另一种 requestIdleCallback 真正有助于表现的情况是当您进行非必要的 DOM 更改时，例如将项目添加到不断增长的惰性列表的末尾。我们来看一下如何将 requestIdleCallback 实际应用在一个典型的框架。 浏览器可能太忙，无法在给定的框架中运行任何回调，所以您不应该期望在框架结尾处有任何空闲时间来执行任何更多的工作。这使得它不同于 setImmediate 这类每帧都运行的东西。 如果回调在框架结束时被触发，它将被调度到当前帧已经提交之后，这意味着将应用样式更改，并且重要的是布局计算。如果我们在空闲回调内部进行 DOM 更改，这些布局计算将无效。如果有任何读取下一帧布局的事件，例如 getBoundingClientRect，clientWidth等等，浏览器将不得不进行强制同步布局，这是一个潜在的性能瓶颈。 不要在空闲回调中 DOM 更改的另一个原因是更改 DOM 的时间影响是不可预测的，因此我们可以很容易地超过浏览器提供的期限。 最好的做法是只能在 requestAnimationFrame 回调内部进行 DOM 更改，因为它是由浏览器安排的那种类型的工作。这意味着我们的代码将需要使用一个文档片段，然后可以将其附加在下一个 requestAnimationFrame 回调中。如果您正在使用 VDOM 库，则可以使用 requestIdleCallback 进行更改，但是您可以在下一个回调中应用 DOM 修补程序 requestAnimationFrame，而不是空闲回调。 所以考虑到这一点，让我们来看看代码： function processPendingElements (deadline) { // If there is no deadline, just run as long as necessary. if (typeof deadline === 'undefined') deadline = { timeRemaining: function () { return Number.MAX_VALUE } }; if (!documentFragment) documentFragment = document.createDocumentFragment(); // Go for as long as there is time remaining and work to do. while (deadline.timeRemaining() > 0 &amp;&amp; elementsToAdd.length > 0) { // Create the element. var elToAdd = elementsToAdd.pop(); var el = document.createElement(elToAdd.tag); el.textContent = elToAdd.content; // Add it to the fragment. documentFragment.appendChild(el); // Don't append to the document immediately, wait for the next // requestAnimationFrame callback. scheduleVisualUpdateIfNeeded(); } // Check if there are more events still to send. if (elementsToAdd.length > 0) scheduleElementCreation(); } 在这里我创建元素并使用该 textContent 属性来填充它，但是您的元素创建代码可能会更多的操作！在创建元素后 scheduleVisualUpdateIfNeeded，调用该元素将会建立一个单独的 requestAnimationFrame 回调，然后依次将文档片段附加到正文中： function scheduleVisualUpdateIfNeeded() { if (isVisualUpdateScheduled) return; isVisualUpdateScheduled = true; requestAnimationFrame(appendDocumentFragment); } function appendDocumentFragment() { // Append the fragment and reset. document.body.appendChild(documentFragment); documentFragment = null; } 一切顺利，我们现在将把项目附加到 DOM 时看起来更少 jank。优秀！ 常问问题 是否有 polyfill？ 可悲的是，没有。如果你想要透明的重定向到 setTimeout，那就有一个 shim 。该API存在的原因是因为它在Web平台中插入了非常真实的差距。但是没有JavaScript API来确定框架结束时的空闲时间，所以最多只能做出猜测。像 setTimeout，setInterval 或者 setImmediate 这样的 API 可以用于调度工作，但是并不是按照 requestIdleCallback 这样的方式避开用户交互。 如果我设置 timeout，会发生什么？ 如果 timeRemaining() 返回零，但是您选择运行更长时间，您可以这样做，而不用担心浏览器停止工作。但是，浏览器为您提供了最终期限，以确保您的用户顺利体验，因此除非有非常好的理由，否则您应始终遵守最终期限。 timeRemaining() 会返回有最大值吗？ 是的，现在是 50ms 。在尝试维护响应式应用程序时，所有对用户交互的响应应保持在 100ms 以下。如果用户在 50ms 窗口中进行交互，在大多数情况下应允许空闲回调完成，并且浏览器可以响应用户的交互。您可能会得到多个空闲的回调（如果浏览器确定有足够的时间来运行它们），那么它们将被一个个安排。 有没有什么工作我不应该在 requestIdleCallback 里执行？ 理想情况下，您所做的工作应该是具有相对可预测特征的小块（微任务）。例如，特别是更改 DOM 将具有不可预测的执行时间，因为它将触发样式计算，布局，绘画和合成。因此，您应该仅在上述 requestAnimationFrame 回调中进行 DOM 更改。要注意的另一件事是解决（或拒绝）Promises，因为在空闲回调完成后回调将立即执行，即使没有更多的时间剩余。 我会总是在一帧结束时被执行 requestIdleCallback ？不，不总是。浏览器将在帧结束时的空闲时间或用户处于非活动状态的时段内调度回调。您不应该期望每帧调用回调，并且如果要求它在给定的时间范围内运行，则应该使用超时。 我可以有多个 requestIdleCallback 回调吗？ 是的，你可以拥有非常多个 requestAnimationFrame 回调。值得记住的是，如果你的第一个回调使用了它在回调期间的剩余时间，那么任何其他回调都不会有更多的时间。然后，其他回调将不得不等待浏览器下一个空闲，才能运行。根据您要完成的工作，可能会有一个空闲的回调，并将工作分配到那里。或者，您可以使用超时时间来确保回调都有机会执行。 如果我在另一个内部设置一个新的空闲回调，会发生什么？ 新的空闲回调将被安排尽快运行，从下一个帧开始（而不是当前的）。 利用空闲requestIdleCallback 是一个非常棒的方法，以确保您可以运行您的代码，但没有阻碍用户的交互。使用起来很简单，非常灵活。但仍然属于早期，而且规范还没有完全解决，所以你所提供的任何反馈都是值得欢迎的。 【翻译原文】:useing requestIdleCallback]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>performance</tag>
        <tag>optimization</tag>
        <tag>requestIdleCallback</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntersectionObserver API]]></title>
    <url>%2F2017%2F08%2F24%2Fintersectionobserver.html</url>
    <content type="text"><![CDATA[IntersectionObserver假设你想追踪 DOM 里的一个元素是否进入 viewport 的可视区。你做这件事可能是因为你想在这个时机 lazyload 图片或者你需要知道用户是否真的在看一个某个广告横幅。你可以通过添加 scroll 事件钩子或使用定时器去调用元素的 getBoundingClientRect() 方法。然而，这种方法真的很慢，因为每次调用 getBoundingClientRect() 会造成浏览器 re-layout 当前页面 并会在你的页面造成很大的卡顿和闪烁。 iframe 里的元素是否可见这样的事情几乎很难做到。 基于单一源模型，浏览器不会让你访问包含 iframe 的页面的任何数据。这是频繁使用 iframe 加载广告的常见问题。 为了让可见度测试更有效率， IntersectionObserver 被设计出来了。IntersectionObserver 让你知道观察的元素何时进入或退出浏览器 viewport。 如何创建一个 IntersectionObserverAPI 相当简单，例子一看就懂： var io = new IntersectionObserver( entries => { console.log(entries); }, { /* 使用默认选项，详细在下面会介绍 */ } ); // 开始观察一个元素 io.observe(element); // 停止观察一个元素 // io.unobserve(element); // 禁用整个 IntersectionObserver // io.disconnect(); 使用默认选项，回调会在元素进入和完全退出 viewport 的时候触发。 如果你需要观察多个元素，建议在同一个 IntersectionObserver 实例上多次调用 observe() 来观察多个元素，这也是允许的调用方式。 回调函数回传的参数是一个数组对象 IntersectionObserverEntry 。每个这样的对象都包含了每个观察元素的最新数据。 🔽[IntersectionObserverEntry] 🔽 0: IntersectionObserverEntry time: 3893.92 🔽 rootBounds: ClientRect bottom: 920 height: 1024 left: 0 right: 1024 top: 0 width: 920 🔽 boundingClientRect: ClientRect // ... 🔽 intersectionRect: ClientRect // ... intersectionRatio: 0.54 🔽 target: div#observee // ... rootBounds 是对 root 元素调用 getBoundingClientRect 的结果，默认 root 元素是 viewport 。 boundingClientRect 是被观察元素调用 getBoundingClientRect 的结果。 intersectionRect 是两个矩形的交叉部分，可能有效地告诉你被观察的元素的哪一部分是可见的。 intersectionRatio 是最相关的，告诉你元素有百分之几是可见的。 有了这些信息，你现在可以实现元素进入 viewport 前及时加载的特性。非常有用。 IntersectionObservers 是异步推送他们的数据，而回调是运行在主线程的。另外，规范提到 IntersectionObserver 应该使用 requestIdleCallback()。 这意味着调用回调函数的优先级是非常低的，只会在浏览器有空闲的时候调用。这是有意设计的。 Scrolling divs我并不喜欢在 div 中滚动元素, 但我不会用 scroll 判定, 而是用 IntersectionObserver。 option 对象有一个 root 选项让你定义一个代替 viewport 的 root 元素。需要记住的是，要保证 root 元素是所有被观察元素的祖先。 重叠所有元素不！那是糟糕的开发者！请注意使用用户的 CPU 周期。让我们考虑一下无限滚动的例子： 在脚本中，添加一个哨兵来观察和回收是明智的选择。你应该在无限滚动的最后一个元素添加哨兵。当哨兵快要进入 viewport 的时候，在回调函数中加载数据，创建接下来的元素，并添加到哨兵之前的 DOM 结构中。如果重复利用哨兵，不需要再调用 observe()， IntersectionObserver 仍然会继续工作。 更多地更新与回调调用就像前面提到的，当被监听元素进入或离开 viewport 的时候，回调函数会分别单次触发。 这让IntersectionObserver 可以给你这个问题的答案，“元素 X 是否在视图中？”。但在某些场景中，这还不够。 theshold 选项登场。它允许你定义一个 intersectionRatio 阈值数组。当达到每一个 intersectionRatio 值时，回调函数都会被调用。theshold 默认值是 [0]，就是我们解释的默认表现。当设定 theshold 为 [0, 0.25, 0.5, 0.75, 1], 我们会在元素每四分之一的部分进入 viewport 时得到通知。 还有其他问题吗？到现在为止，还有一个选项没有被提到。rootMargin 允许你指定 root 元素的 margin，有效地允许你增加或缩减实际的交叉区域。margin 使用 css-style 的规则， 10px 20px 30px 40px 分别表示上、右、下、左。总的来说，IntersectionObserver 的选项总结如下： new IntersectionObserver(entries => {/* … */}, { // The root to use for intersection. // If not provided, use the top-level document’s viewport. root: null, // Same as margin, can be 1, 2, 3 or 4 components, possibly negative lengths. // If an explicit root element is specified, components may be percentages of the // root element size. If no explicit root element is specified, using a percentage // is an error. rootMargin: "0px", // Threshold(s) at which to trigger callback, specified as a ratio, or list of // ratios, of (visible area / total area) of the observed element (hence all // entries must be in the range [0, 1]). Callback will be invoked when the visible // ratio of the observed element crosses a threshold in the list. threshold: [0], }); iframe 魔法IntersectionObserver 被设计时明确考虑广告服务和网络社交服务，可能经常会用到 iframe 和有益于知道他们是否在看。如果观察 iframe 中的元素，那么滚动 iframe 和滚动父页面都可以在适当的时候触发回调函数。对于后者， rootBounds 将被设置为 null 以避免数据源泄漏。 IntersectionObserver 不是什么？需要知道的是， IntersectionObserver 是被故意设置成不完美和低延迟的。使用它们努力实现像滚动动画之类是注定会失败的。因为严格地说，当你获得数据时，数据已经过时了。这里有更多的关于 IntersectionObserver 原始用例。 可以在 callback 中做多少事情在回调中花太多时候会让你的应用滞后，和常见的实践一样。 使用 IntersectionObserver对于 IntersectionObserver，浏览器的支持仍然很弱，所以它不会马上被普遍应用。同时，WICG 的 polyfill 也被建立起来。显然，使用 polyfill 不如原生实现的效率好。 Except as otherwise noted, the content of this page is licensed under the Creative Commons Attribution 3.0 License, and code samples are licensed under the Apache 2.0 License. For details, see our Site Policies. Java is a registered trademark of Oracle and/or its affiliates. 上次更新日期：六月 5, 2017 【翻译原文】： intersectionobserver]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>lazyload</tag>
        <tag>performance</tag>
        <tag>optimization</tag>
        <tag>IntersectionObserver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 intersection observer 延迟加载图片]]></title>
    <url>%2F2017%2F08%2F18%2Flazy-loading-images-using-intersection-observer.html</url>
    <content type="text"><![CDATA[使用 intersection observer 延迟加载图片如果您还没有看过，Paul Lewis 组织了一个令人敬畏的视频系列，演示如何构建媒体播放器以及拥有非常棒的特性的 Progressive Web Apps。他在YouTube上建立了一系列视频，这些视频是在他建立网站的每一部分的过程中发生的。观看开发者展示他们工作的视频绝对是我最喜欢学习新事物的方法之一！ 当他在演示他的代码时，我注意到他创建了一个出色的 helper 库来延迟加载图像。我一直在寻找改善我网站性能的方法，这无疑引起了我的兴趣。 与懒惰加载有什么关系？延迟加载图像背后的想法是，您等到用户向下滚动页面，并图像进入视图之前，再为这个图片发起网络请求。如果您的网页包含多个图像，但是只有在图像滚动到视图时才加载每个图像，您将最终节省带宽，并确保您的网页加载更快。 为了给你一个这样的想法，我们来想象下面有三个图像的页面。 如果用户登陆页面并且仅查看第一张图像，我们不想加载页面底部比萨的图像，直到用户向下滚动，并且等到图像真正在视图中。如果我们懒惰加载图像，这意味着用户只需要下载他们需要的东西，这使您的网页更精简。 对于更有经验的开发人员，您可能会熟悉延迟加载图像，毕竟这个概念已经有一段时间了。那么有什么新概念吗？！有很多懒加载库做得很好。我甚至以前在这个博客上写了一篇（很多年前）。问题在于，几乎所有这些库都会绑定滚动事件，或者使用定时器来检查元素的边界，然后再确定是否在视图中。这种方法的问题是它强制浏览器重新布局（re-layout）整个页面，并且在某些情况下，您的网站会引起相当大的性能损失。我们可以做得更好！ INTERSECTION OBSERVER 来抢救！这是就是 Intersection Observer 的用处。Intersection Observer 内置于大多数现代浏览器中，让您知道被观察的元素何时进入或退出浏览器的视口。这使得它非常理想，因为它能够异步传输数据，并且不会影响主线程，使其成为提供反馈的有效手段。 在 Paul 的例子中，他演示了如何使用 Intersection Observer 来延迟加载进入视口图像。我已经获取了他的初始代码，并稍微调整了一点，使我更容易理解。在本文中，我将通过了解 Intersection Observer 的基础知识，并向您展示如何以超级高效的方式做到延迟加载图像。 入门想象一下一个基本的HTML页面，其中包含三个与上述相似的图像。在网页上，您将具有与以下熟悉的图像元素代码： 您可能会注意到，在上面的代码中，图像文件没有 src 属性。这是因为它正在使用一个名为 data-src 的数据属性来指向图像源。当进入视口时，我们将使用它来加载图像。您还可能会注意到，图像元素还具有一个名为 “js-lazy-image” 的类 - 我们将在 JavaScript 代码中尽快使用这个类，以确定要延迟加载的元素。 接下来，我们需要创建将在页面上加载图像的代码。在我们的 JavaScript 文件中，我们需要创建一个新的 Intersection Observer 。 上面的例子看起来像很多代码，但是让我们一步一步地分解它。首先，我正在选择页面上具有类“js-lazy-image”的所有图像。接下来，我正在创建一个新的 IntersectionObserver，并使用它来观察我们选择的具有类“js-lazy-image”的所有图像。使用 IntersectionObserver 的默认选项，当元素部分进入视图或完全离开视口时，您的回调都将被调用。在这种情况下，我将几个额外的配置选项传递给 IntersectionObserver。使用 rootMargin 允许您指定根的边距，有效地允许您增加或缩小用于观察交点的区域。我们想确保如果图像在Y轴上的50像素内，我们将开始下载。 现在我们已经创建了一个 Intersection Observer，并且正在观察页面上的图像，我们可以进入到该元素进入视图时被触发的 intersection 事件。 在上面的代码中，只要我们观察到的元素进入用户视口，onIntersection 功能将被触发。此时，我们可以循环查看我们观察到的图像，并确定哪个图像在视口中。如果当前元素处于交叉比例中，我们知道图像在用户视口中，我们可以加载它。加载图像后，我们不需要再观察图像，并且使用 unobserve() 将其从 Intersection Observer 中的条目列表中删除。 就是这样！一旦用户滚动并且图像进入视图，则将加载适当的图像。这个代码最好的办法是 Intersection Observer 比巴里·怀特（Barry White）更平滑。我尽量保持尽可能简洁的代码，但如果您想看到完整版本，我已经创建了一个Github repo，其中包含了一个有效的例子。 浏览器支持在这一点上，您可能会想知道浏览器对此功能的支持。Edge，Firefox，Chrome和Opera目前支持 Intersection Observer，这是一个好消息。 但是，为了确保不支持此功能的浏览器的代码不会报错，我们可以使用功能检测来确定我们如何加载图像。我们来看看下面的代码。 在上面的代码中，我们正在检查 IntersectionObserver 是否在当前浏览器中可用，如果不支持我们只是简单地立即加载图像，否则我们使用我们的默认行为。 如果您真的喜欢 IntersectionObserver API 的简便性，并且想要使用 polyfill，则 WICG 已创建一个可在 Github repository 中使用的功能。唯一的缺点是您不会获得原生实现给您的性能优势。 您甚至可以采取进一步措施，并为 Robin Osborne 建议的未启用 JavaScript 的用户添加支持。 总结在本文中，我们已经使用 IntersectionObserver 来延迟加载图像，但是您可以使用它来进行更多操作。它可以用于确定某人是否正在查看广告，或者即使是在iFrame中的元素。易于理解的API使其可以打开许多选项。 如果您想了解有关交叉点观察者的更多信息，我建议您在Google Developers网站上阅读这篇有关信息的文章。我还强烈建议在 Youtube 上观看保罗·刘易斯的视频系列，它包含了很棒的提示，你一定会学到一些东西。 【翻译原文】: LAZY LOADING IMAGES USING INTERSECTION OBSERVER]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>lazyload</tag>
        <tag>performance</tag>
        <tag>optimization</tag>
        <tag>IntersectionObserver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你可能不知道的JSON用法及误区]]></title>
    <url>%2F2017%2F07%2F28%2Fyou-may-dont-know-JSON.html</url>
    <content type="text"><![CDATA[再谈 JSON, 你可能不知道的一些 JSON 用法及误区最近也是看到很多人在讨论 JSON, 但有些点说得不太准确，翻翻犀牛书，再次复习一下。 JSON.stringify(value [, replacer [, space]])第一个参数一般是对象（Object）或数组（Array），或 javascript 基本值。 误区：不支持的值都会被忽略首先 JSON 只能序列化可枚举的值，其次 undefined，NaN，Infinity，function, Date, RegExp, Error 这些值或对象都是不支持的，但并不是这些值都会被忽略。 var o = { a: Symbol(), // 新增的 ES6 基本值 b: [1,2,3], c: undefined, d: NaN, e: Infinity, f: function (){ return 1;}, g: new Date(), h: /^\d$/gi, i: new Error('err'), j: {} } JSON.stringify(o); // output: '{"b":[1,2,3],"d":null,"e":null,"g":"2017-07-28T02:56:37.102Z","h":{},"i":{},"j":{}}' 由上可以看出： Symbol, undefined, function 会直接被忽略 NaN, Infinity 被转换成了 null RegExp, Error 则被转成了空对象 {} replacer因为 JSON.stringify() 序列化不支持部分值，所以不能简单地使用 JSON 的两个方法进行深拷贝。但可以利用 JSON.stringify() 的第二个参数进行正确序列化。 但这并不推荐，因为 JSON.parse() 仍然无法还原不被支持的值。只有对象字面量 Object 和 数组 Array 可以被正确还原，其他都变成字符串 // 沿用上一例子的代码 var replacer = function(k ,v) { var type = typeof v; if(type === 'function') { return Function.prototype.toString.call(v) } if (type === 'undefined'){ return 'undefined' } if (type === 'number'){ if (v !== v){ return 'NaN' } if (v === Infinity){ return 'Infinity' } } if (type === 'symbol'){ return Symbol.prototype.toString.call(v) } if (v instanceof RegExp){ return RegExp.prototype.toString.call(v) } if (v instanceof Error &amp;&amp; v.name !== '' &amp;&amp; v.message !== ''){ return 'new ' + v.name + '('+ v.message +')' } return v } JSON.stringify(o, replacer); // output: '{"a":"Symbol()","b":[1,2,3],"c":"undefined","d":"NaN","e":"Infinity","f":"function (){ return 1;}","g":"2017-07-28T02:56:37.102Z","h":"/^\\d$/gi","i":"new Error(err)","j":{}}' 另外一个用法就是传入数组，指定需要序列化的key.这个在提取部分属性的时候也是很有用。 // 沿用上面的代码 JSON.stringify(o, ["b", "c", "d"]); // output: '{"b":[1,2,3],"d":null}' space是一个可选的美化属性，序列化时是没有换行和空格的，此参数可指定一个数值（大于10则限制为10）或一组字符（长度最长为10个字符), 此参数不为空会自动插入换行。 但是设置为字符时，无法使用 parse 复原 JSON.stringify(o, null, '-'); // '{ // -"b": [ // --1, // --2, // --3 // -], // -"d": null, // -"e": null, // -"g": "2017-07-28T02:56:37.102Z", // -"h": {}, // -"i": {}, // -"j": {} // }' JSON.parse(value[, reviver])JSON.parse 与 JSON.stringify 操作正好相反，但 value 必须严格符合 JSON 格式，否则报错。 第二个参数可传入一个函数，用以转换解析出来的值。 比如 Date 对象在序列化之后无法逆转成一个 Date 对象，此时可写一个函数去转换： var reviver = function (name, value){ console.log(/^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\d.\d\d\dZ$/.test(value)); if (typeof value === 'string' &amp;&amp; /^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\d.\d\d\dZ$/.test(value)){ return new Date(value) } return value } // 沿用前个例子的代码 JSON.parse(JSON.stringify(o.g), reviver) // output: Fri Jul 28 2017 10:56:37 GMT+0800 (+08) toJSON()有些文章会说 Object.toJSON() ，这是不对的，Object 原型上并没有定义 toJSON 方法，该方法只被定义在 Date 对象上。JSON.stringify() 在序列化的时候会首先查找该方法，如果有则直接返回 toJSON 的调用结果。这个一开始是让 Date 正确序列化成 JSON 时设计的。但我们也可以利用 toJSON 的屏蔽功能。 Function.prototype.toJSON = function (){ return Function.prototype.toString.call(this) } // 沿用上面的例子 JSON.stringify(o); // {"b":[1,2,3],"d":null,"e":null,"f":"function (){ return 1;}","g":"2017-07-28T02:56:37.102Z","h":{},"i":{},"j":{}} 会发现，function 没有被忽略，但此方法要慎用，在原型上添加方法可能产生副作用。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[像 google 一样通过缩短 css 类名和作用域隔离来压缩优化 css 包的大小]]></title>
    <url>%2F2017%2F07%2F24%2Freducing-css-bundle-size-by-cutting-the-class-names-and-using-scope-isolation.html</url>
    <content type="text"><![CDATA[像 google 一样通过缩短 css 类名和作用域隔离来压缩优化 css 包的大小 就像 google 的做法一样 今年年初，我已经退出咨询公司并开始构建 GO2CINEMA - 一个 快速，简单和安全 的方式来预订英国的电影票的网站。我做了一个辉煌的工作，使其快速，简单和安全。在其中某个阶段，我一直痴迷于关键渲染路径的优化。⚡️ 我已经使用 ūsus 解决了 HTML 的预渲染。ūsus 渲染单页应用程序（SPA）的 HTML，并内嵌了用于呈现页面的 CSS。但是，我并不喜欢在每个 HTML 文档内嵌 70 KB 的 css，特别是其中大部分是 CSS 类名。 就像Google一样你有没有看过 https://www.google.com/ 的源代码？如果看过，您注意到的第一件事是会是，CSS 类名称没有超过几个字符。 但是怎么样做到的呢？ CSS minifiers 的缺点有一件事，minifier 不能做 - 改变选择器名称。这是因为 CSS minifier 不能控制 HTML 输出。同时，CSS 名称可以很长。 如果您使用 CSS modules，您的 CSS modules 可能会包含样式表文件名，本地标识名和随机哈希。使用 css-loader localIdentName 配置描述类名模板，例如[name]___[local]___[hash:base64:5]。因此，生成的类名称将如下所示 .MovieView___movie-title___yvKVV ; 如果你喜欢描述性的名字，它可能更长，例如 .MovieView___movie-description-with-summary-paragraph___yvKVV 。 在编译时重命名 CSS 类名但是，如果您使用的是 webpack 和 babel-plugin-react-css-modules，那么您很幸运 🍀 - 您可以使用 css-loader 的 getLocalIdent 配置项或者等效的 babel-plugin-react-css-modules 中的 generateScopedName 配置项来达到在编译时重命名类名的目的。 generateScopedName 中很酷的是，同样的功能实例可以用于 Babel 和 webpack 的构建过程： 让名字变短感谢 babel-plugin-react-css-modules 和 css-loader 共享相同的逻辑来生成 CSS 类名称，我们可以将类名改为任何我们喜欢的，甚至是随机哈希。然而，我想要最短的类名，而不是随机哈希。 为了生成最短的类名，我创建了类名索引，并使用该 incstr 模块为索引中的每个条目生成增量ID。 这保证了类名简短并且唯一。现在，.MovieView___movie-title___yvKVV 和 .MovieView___movie-description-with-summary-paragraph___yvKVV 的类名都成了 .a_a, .b_a等。 这将 GO2CINEMA CSS 压缩包的大小从 140 KB 降低到 53KB。 使用作用域隔离来进一步减少包的大小分离组件名称和本地标识符名称是一个很好的理由让我添加 _ 到 CSS 类名 - 对于缩小文件大小特别有用。 csso（CSS minifier）具有作用域配置。作用域定义了在某些标记上专门使用的类名列表，即来自不同作用域的选择器不会匹配同一个元素。这一条让优化规则更进一步。 要利用此功能，请使用 csso-webpack-plugin 来后处理 CSS 包： 这使 GO2CINEMA CSS 捆绑包的大小从 53 KB 降至 47 KB。 这值得么？这种压缩的第一个争议是觉得压缩算法本来就可以做到。使用 Brotli 算法压缩的 GO2CINEMA CSS 包与长类名的原始包相比只压缩了 1 KB。 另一方面，设置这个缩小是一次性投入，它减少了需要解析的文档的大小。它还具有其他好处，例如阻止依赖 CSS类名称的扫描仪导航或意外匹配广告拦截器黑名单的 CSS选择器。 同时，您可以看到在 GO2CINEMA 和 venue 页面上使用的这种压缩的演示，例如 https://go2cinema.com/movies/wonder-woman-2017-1305237 https://go2cinema.com/venues/odeon-oxford-magdalen-st-1001053 【翻译原文】：https://medium.freecodecamp.org/reducing-css-bundle-size-70-by-cutting-the-class-names-and-using-scope-isolation-625440de600b]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>webpack</tag>
        <tag>css</tag>
        <tag>minifier</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[桂林山水最强徒步攻略-大圩古镇-奇峰镇-会仙镇-葡萄镇至兴坪古镇20公里经典徒步路线]]></title>
    <url>%2F2017%2F07%2F23%2FDaxu-village-Huixian-wetland-Putao-Xingping-of-Guilin.html</url>
    <content type="text"><![CDATA[我可不是一个酒店享受者，我的玩法是 don’t stop, keep your step. 桂林山水最强徒步攻略-大圩古镇-奇峰镇-会仙镇-葡萄镇至兴坪古镇20公里经典徒步路线对于每个地方并不打算去两次的人来说（除了一些体验特别好的地方），一次性打包看完一个地方所有感兴趣的地点是最合适的。所以，每次去完，总是把一个市，甚至一个省的攻略都做完了。或许也是一种强迫症吧。 其实国内很多景点都是坑，网上照片基本都不是原片。写攻略是为了方便别人，也是为坑了别人一起，哈哈，顺便记录。 路线规划下面先简要看看总体路线规划： Day 1: 火车 ——> 桂林市 ——> 大圩古镇（+熊村） Day 2: 大圩古镇 ——> 奇峰镇（遇到不可抗因素）——> 会仙镇 Day 3: 会仙湿地 ——> 玻璃田 ——> 葡萄镇 Day 4: 葡萄镇 至 兴坪古镇 经典徒步路线 20 公里 ——> 相公山（日落） Day 5: 相公山（日出）——> 相公山至兴坪古镇 ——> 老寨山（日落）——> 阳朔高铁最后一班回（8pm） 补充几张线路图： 葡萄镇至兴坪古镇 徒步路线图 会仙玻璃田路线图 大圩古镇（大墟）“明清时期繁华一时的大圩古镇”。 在桂林火车站旁边的桂林长途汽车总站坐开往冠岩的专线车，40分钟左右即可到达大圩，票价5元左右。 古镇不大，1小时足以游完，距大圩镇8公里（在大圩路口能看到指路牌）的熊村（大圩县城搭公交过去3元）。 村上保留着完整的旧时村落格局，有上百栋明清建筑，现存有湖南会馆、江西会馆、财神殿等，村子的老建筑上保留了许多文革标语。 小吃：姜汁桂花凉粉 “大圩江上芦田寺，百尺深潭万竹围。柳店积薪晨爨后，僮人荷叶裹盐归” 奇峰镇（李家村）在桂林火车站对面搭乘4路车，开往奇峰镇方向，在 东山村 下车。每趟运行单程时间大约是40分钟。（我是大圩直接坐摩的30元抄小路到奇峰镇） 奇峰镇外看奇峰，万点尖峰锁碧空。 事实上，里面是军事管制区，只有本村村民才能进。公交车到村口就被强制下车。请不要来这里，没有开放 会仙镇桂林汽车站，乘坐桂林—会仙的班车，每隔15分钟一趟，票价8元（直达），也可在雁中路口，师大侧门坐车。 秋天去看一片金黄，或田地放水时，一片天镜。 会仙湿地： 正在开发中，酒店食宿全没有，一年后应该会有。到睦洞村委路口，然后乘坐前往毛家村的三轮车每人2元钱（实际上有时会坑你10元）。也可从路口步行至毛家村，大概40分钟左右，路边一大片农田，湿地公园有一大片荷花。一般摄影人会去龙山，售票口的人会建议你坐船过去上龙山。票价不菲。觉得值可以坐。如果是穷学生，那就买门票，走过去，船是走近路直接到山脚，走路就要十八弯，40分钟左右。再不济，往回走有条岔路，是通向刚刚入口方向，人少时没人守，免票进入，这是我出来的时候发现的。 玻璃田： 湿地是后开发的，最开始出名的是玻璃田这一块。山也不难找，就是下图的 D 点，上山点在村口医院前。 葡萄镇这是个中转休息点，是经典徒步路线的起点。从会仙过来的话，先坐车到 雁中路口，师大侧门，然后在南下的大路上拦去阳朔的车，在葡萄镇下车。 《石头城到兴坪徒步 - 居高临下欣赏山水画卷》（总长度22.5公里）: 这条徒步线路清幽古朴，游人罕至，途中每一次登高俯视，都将为您展开一幅不同的阳朔山水画卷。阳朔的经典摄影主题，葡萄田园风光(地处阳朔葡萄镇乌龙村，拍摄葡萄田园风光多为逆光拍摄，应选择有太阳的天气下午4-5时到达山顶等候拍摄)、相公山日出以及老寨山日落，都在这条线路上。途径古朴的石头城以及兴坪老街，又给这条线路增加了人文风情。线路最好分两天完成，这样可以夜宿相公山以便第二天观看日出。全程难度不大，两三人轻装便可出发，沿途村庄可以补给，也可带少量食物和水以防万一 当然，这条路线可以反着来走，但我是从会仙过来的，这样走更顺路，最后阳朔高铁回。 【徒步线路A：小耀门村–石头寨–大岩头村–小冲崴村–大坪村–水岩门村–相公山–黄泥田村–镰刀湾村–大河背村–渔村村–兴坪镇。（全程约19公里） 徒步线路B：小耀门村—石头寨—大岩头村—小冲崴村—大坪村–水岩门村–相公山–荷苞山村–冷水村–画山村–兴坪镇。（全程约18公里）】 (PS: 其实应该有25公里，我在石头城迷路，走得太累，后来还搭了一段顺风车到相公山) 兴坪古镇相公山到冷水村路不太好走，比想象中远，但其实应该有近路，因为在路上有岔路，但地图上没有标。去冷水村需要渡河，10元。本地人免费。冷水村到兴坪古镇一路是风景，也可坐三轮车过去。下车点就是20元人民币上的图。之后在老寨山看日落。下山在汽车站坐小面包 5元到阳朔高铁站回。 详细影摄上面都是交通简要，下面是影摄： （待更。。）]]></content>
      <categories>
        <category>travel</category>
      </categories>
      <tags>
        <tag>travel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[马萨萨海滩(masasa beach) 旅行预算指南]]></title>
    <url>%2F2017%2F07%2F22%2Fmasasa-beach-travel-guide.html</url>
    <content type="text"><![CDATA[假期旅行之菲律宾系列之二 —— 马萨萨海滩(masasa beach)马萨沙滩可以说是 Tingloy 最好的海滩，这是 Batangas 唯一不在大陆吕宋岛上。它的主要岛屿是鱼形马里卡班（Maricaban），位于 Calumpang 半岛的一角，将巴拉扬湾（Balayan Bay）与八打雁湾（Batangas Bay）分开。 事实是，这里的沙滩不像你在长滩岛或巴拉望岛所期望的那样像白色珍珠，但是马萨沙滩在缺乏亮度的沙滩中展现出波浪的气息。它的水晶般清澈，浅水散发出美丽的绿松石闪光，即使远距离也能吸引您的注意。 来这里主要是玩水，如果你喜欢游泳，来这里吧。我是在这学会狗爬式的。哈哈。。 先来看看一些照片。 小岛是一个小鱼形状，很可爱 在 Anilao Port 坐公共船只 到达 小鱼岛 ，准备浮潜，小哥很卖力！ 没错，螃蟹船很好看，他们喜欢涂成各种颜色，艺术细胞不错。以及。。真正蓝色的大海，而不是灰色的。 浮潜只需100p !!超便宜，一定要尝试一下，虽然只是带着你转一圈，但是可以看到各种海龟，珊瑚，长带鱼等。怪不得很多本地大学生来！经济漂亮！但是我没有拍到好的海底照片。。 沙子确实不怎么样，但是水还是不错 水清见底 全貌 家庭出行非常多 香蕉船 附近村庄的小卖部的老人 这是什么，谁能告诉我 其实来到这里再找住宿也可以，因为很多，到处都是 菲菲 交通 bus,在八打雁市区 Batangas Grand Terminal下车（3-4 小时）（同样的，半夜出发，早上到达，不然会塞车） 在LRT- Gil Puyat 车站旁边有公共汽车站（DLTB liner 或 JAM liner）。（注意，越早越好。如果您选择一辆带有 CALABARZON 标志的公共汽车，旅行时间将会更短）P120-P180。 转吉普尼（1小时） 40 minutes. Fare: PhP 37. 终点站是 Mabini Multi-purpose port.（又名 Anilao Port）(在habagat season季节，终点站是 Talaga Port ) a. 在 Anilao Port 坐船(推荐)（45min） 如果要在岛上住一晚，就选择公共船只，最便宜，P80。旅行时间：45分钟 - 1小时。 直接坐船到 masasa beach。但是直达的船更少，不可预测，P100 （注意，最后一艘返回 Anilao的船是上午九点，所以不得不住一晚,有些船在较小的码头在中午12点可以接乘客回,具体可以咨询当地人上船地点） b. 如果是一日游，租船P4500，可坐10人，可以讲价。如果租船，可以要求中途登陆 Sombrero岛，上岛费 P200，有些要P500.（算是跳岛游，比较贵） 住宿我当时是在 facebook 上搜索 masasa 然后联系的住宿，P300 每人！没有酒店。其实那里旁边有村子，有很多过夜的地方。以前可以在沙滩露营过夜，但后来不允许了。 其他项目 环岛游： 标准费率：P1500，岛上可以联系当地船只。 浮潜：P100 !!我是当时住宿的人帮我安排联系的，30min,时间不长 费用清单 到八打雁的票价车票：票价：P157 从LRT-Buendia 出发，P127 从阿拉邦出发。 吉隆尼到阿尼洛的吉普尼票价：P37 从Anilao出发的小船出租（岛屿游览）：每船P4500（最大10人）Masasa 海滩的小船出租（岛屿游览）：每船P1500（3pax最大） 公共小船到 Tingloy：P80（推荐） 三轮车到马萨沙滩：P120/辆 环境费：P30 马萨沙滩：免费 Sombrero Island 上岛费：P200 租帐篷 P200 注意事项 masasa beach只有一个洗手间，收费，P10 每次； 过夜可能没有电，带好充电宝； 看好天气，晴天比阴天更漂亮，水更清；]]></content>
      <categories>
        <category>travel</category>
      </categories>
      <tags>
        <tag>travel</tag>
        <tag>philippine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Borawan island、Pagbilao Beach 和 Dampalitan island旅行预算指南——一个周末三个沙滩]]></title>
    <url>%2F2017%2F07%2F22%2Fborawan-island-Pagbilao-beach-and-Dampalitan-island.html</url>
    <content type="text"><![CDATA[一个孩子的冒险故事 ————讲故事的人 假期旅行之菲律宾系列之一 ———— Borawan岛、Pagbilao岛、Dampalitan岛坐落在奎松南部的边缘，布尔戈斯（Padre Burgos）和帕格比洛（Pagbilao）的城镇面向泰巴巴斯湾（Tayabas Bay），这是分离大陆吕宋岛和马林杜克岛（Marinduque）的通道。马尼拉市区的这一边只有四到五个小时的路程，甚至远远近于 Pangasinan和碧瑶（Baguio）。 这是Puting Buhangin，Pagbilao（也叫Kuwebang Lampas）最推荐，请在这里规划最长的时间 Borawan，背靠山，是另一种风景，和岩石拍照特别好看。这是 Borawan 的日落。 水面很平静，没有浪，很适合游泳 Dampalitan， 水很清！ 天气很好！ 公共交通如何到达 公共汽车站：JAM liner, DLTB liner, JAC liner. 位于 Taft Ave. 乘公共汽车到卢塞纳市（Lucena）。马尼拉大都会有许多终点站到卢塞纳。票价介于P250-260之间。旅行时间：3-4小时。 在卢塞纳站下车（Lucena Grand Terminal）。 a. 从终点站乘坐另一辆巴士到 Unisan。公共汽车没有空调，票价在P35-40左右。旅行时间：1个半小时。 b. 也有小面包车 （Vans），有招客牌写着 Unisan，说去 QCRB Bank 下车，大概 60p 每人 在QCRB银行（Padre Burgos）下车，或者 提前告诉司机让你这里下车。 乘坐三轮车到 Aplaya。告诉司机你打算去Borawan， 只需 20p。 在 Aplaya 有小船出租。这些船只可以带您前往 Puting Buhangin（Pagbilao），Dampalitan岛和Borawan岛的一个岛屿游览。P1500 - P2000，适合10人以下。 行程参考时间表半夜出发是最合适的，早上就到。如果早上出发，你会在路上塞车并浪费一整天。不要把白天玩的时间浪费在车上。 2:00 - Buendia Bus Terminal(DLTB liner or JAM liner)坐车 (P227-P250, 4h)【凌晨两点出发，早上六点到】 目的地：Lucena Grand Terminal 6:00 - Lucena Grand Terminal换乘去 Unisan 的公交bus（P35 - P40）【1.5h, 预计七点半到】 7:00 - 在 QCRB BANK下车。换tricycle三轮车（10min），去Aplaya (和司机说要去 Borawan) 在Aplaya租船 8:00 出发。 注意事项该地区有水母（jerryfish），请一定注意，Borawan沙滩尤其多，所以建了水网区域游泳，不要在非安全区域游泳。被水母蛰了也不要惊慌，提前了解处理方法，使用碱性溶液（如肥皂水等）清洗。Pagbilao岛、Dampalitan岛比较安全，下水前可以询问岛上工作人员能否下水，或与其他人一同下水，勿单独游泳。 露营或酒店或租船Borawan 和 Dampalitan Islands 没有度假村或酒店，但允许露营过夜。如果你不是野营的类型，那么大陆有几个度假村，你可以选择留下来。以下是我收集的简短列表： Silangang Nayon餐厅和度假村。位于Pagbilao，它是Bicol绑定的路途跋涉者之间的共同点，他们渴望品尝到他们美味的Pinoy海鲜菜肴。他们只有少量的房间，所以如果你要在旺季，提前预订。联系电话：（042）7160077，0922 8867677 但，如果你认为你是一个野营旅行，为什么不露营呢？露营不仅降低了成本，还使您更好地欣赏岛屿，从而使您更接近自然。所有你需要的是一个帐篷和一些易于准备的食品。如果有冲泡食品，沙滩小卖部有热水出售，20p。 租船（完全可以去到再租，如果不放心，可以提前询问）： 09501928546，09094819703 大部分人会在 Borawan 沙滩 和 Pagbilao 沙滩过夜，这两个地方有冲凉房和公厕，免费使用。我建议在 Puthang Buhangin, Pagbilao 过夜，那里水最清。 备用物品提示 化妆品和防晒霜 - 通常。在岛上有商店，但预计价格有点过高，所以更好地带上洗发水，肥皂，牙膏，卫生纸和湿巾。Dampalitan 岛上有公厕，但水有点稀少。 防蚊洗剂 - 很多人会忘记带来。岛上有蚊子。 手电筒 - 那里偶尔会停电 打火机和很多故事 - 你会被诱惑开始篝火，你将需要打火机点火和对话，以保持燃烧。 急救包 - 你永远不会知道意外什么时候发生。 浮潜装置 - 我们没有看到活珊瑚，但有很多鱼。特别是在 Dampalitan和Pagbilao，这两个沙滩水更清。 防水相机 - Kuwebang Lampas（在Puthang Buhangin, Pagbilao）是非常棒的，但去那里的水很深。如果您想要在洞穴内的图片，防水相机非常有用。 预算详细条目以下是您期望的费用和其他费用清单。 乘船游览费（8人乘车）： P800 - Borawan海滩（往返） P1800 - Borawan + Dampalitan + Puting Buhangin（三岛两天一夜，这是总船费，不是每次） Borawan海滩 上岛费：P80 帐篷租金：P500(买一个帐篷去最好，便宜的才1000p左右，还能带回去) 小屋出租：P700-P850 过夜费： P220每人 帐篷占地费用：P200-P250(分占地大小) Puting Buhangin，Pagbilao 上岛费：P80 帐篷出租：P300-400 Dampalitan 岛 上岛费：P80 帐篷占地费：P100 小屋出租：P850-P1000 水：P40/5L，P400/大桶 以上费用可能会涨价，但不会偏离太多。最重要是带好食物和饮用水。过夜请拿好票据，以免其他员工再次来收钱。 一般顺序： 推荐：Borawan（9：00-午餐） ==> Puting buhangin（14：00-过夜） ===> Dampalitan (10：00 - 14:00回程) Puting buhangin（9：00） ==> Dampalitan（11：30-午餐） ===> Borawan (14：00 - 过夜) Puting buhangin（9：00-午餐）===> Borawan（14：00-过夜）===> Dampalitan(10:00- 14:00回程)]]></content>
      <categories>
        <category>travel</category>
      </categories>
      <tags>
        <tag>travel</tag>
        <tag>philippine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高性能 react：3种加快应用程序的新工具]]></title>
    <url>%2F2017%2F07%2F18%2Fmake-react-fast-again-tools-and-techniques-for-speeding-up-your-react-app.html</url>
    <content type="text"><![CDATA[高性能 react：3种加快应用程序的新工具react 通常很快，但很容易造成导致性能问题的小错误。缓慢的组件安装，深层组件树和不必要的渲染循环可以快速添加到一个感觉缓慢的应用程序。 幸运的是，有很多工具，有些甚至内置于 React，这有助于诊断性能问题。在这篇文章中，我将强调使 React 应用程序更快速的工具和技术。每个部分还有一个互动，（希望）有趣的演示！ 工具＃1：性能时间表React 15.4.0引入了一个新的性能时间轴功能，可让您准确了解组件的挂载，更新和卸载。它还可以让您可视化相关的组件生命周期。 注意：现在，此功能仅适用于Chrome，Edge和IE，因为它利用了尚未在所有浏览器中实现的用户时间轴API（User Timing API）。 怎么运行的 打开你的应用程序并附加查询参数：react_perf。例如，http://localhost:3000?react_perf 打开Chrome DevTools 性能选项卡，然后按 记录（Record）。 执行您要分析的操作。 停止记录 在 User Timing 下检查可视化。 了解输出每个彩色条显示组件正在做“工作”的时间。由于JavaScript是单线程的，每当组件正在加载或呈现时，它会阻止主线程，并阻止其他代码运行。 方括号中的文字[update]描述了组件生命周期的哪个部分正在发生。时间轴会分解每个步骤，因此您可以在[componentDidMount] [componentWillReceiveProps] [ctor]（构造函数）和 [render] 方法上看到细粒度的时序. 堆叠的条表示组件树。虽然在React中具有相当深的组件树是典型的，但如果要优化经常安装的组件，则可以帮助减少封装组件的数量，因为每个组件都会增加小的性能和内存损失。 这里有一点值得注意的是，时间表中的时间序列是用于开发构建React的，它比生产环境更慢。事实上，甚至性能时间表本身会减慢您的应用程序。虽然这些数字不应该被认为是真实表现的性能，但是不同组件之间的相对定时是准确的。此外，组件是否更新完全不依赖于生产环境上的构建。 演示＃1为了乐趣，我操纵了TodoMVC应用程序，出现一些严重的性能问题。你可以在这里试试看。 要查看时间轴，请打开Chrome开发工具，转到“性能”选项卡，然后单击记录。然后在应用程序中添加一些TODO，停止录制并检查时间轴。看看是否可以发现哪些组件导致性能问题:) 工具＃2：为什么更新影响 React 中性能的最常见问题之一是不必要的渲染循环。默认情况下，即使他们的 props 没有改变，React 组件将在父级 render 时重新 render。 例如，如果我有一个这样的简单组件： class DumbComponent extends Component { render() { return &lt;div> {this.props.value} &lt;/div>; } } 加上父组件: class Parent extends Component { render() { return &lt;div> &lt;DumbComponent value={3} /> &lt;/div>; } } 无论何时父组件 render，DumbComponent 都会重新 render，尽管其 props 没有改变。 通常，如果 render 运行，并且没有对虚拟DOM进行任何更改，则这是一个浪费的渲染循环，因为该 render 方法应该是纯的，并且没有任何副作用。在大规模的 React 应用程序中，检测发生这种情况的地方可能很棘手，但幸运的是，有一个可以帮助的工具！ 使用 why-did-you-update why-did-you-update 是一个挂接到 React 的库，并检测潜在的不必要的组件渲染。它检测组件的render方法何时被调用，尽管它的 props 没有改变。 建立安装 npm： npm i --save-dev why-did-you-update 在您的应用程序的任何地方添加此代码段： import React from 'react' if (process.env.NODE_ENV !== 'production') { const {whyDidYouUpdate} = require('why-did-you-update') whyDidYouUpdate(React) } 请注意，此工具在本地开发中非常出色，但确保在生产中已被禁用，因为它会减慢您的应用程序。 了解输出why-did-you-update 监视您的应用程序运行并记录可能会不必要地更改的组件。它允许您在渲染循环之前和之后看到 props，确定它可能是不必要的。 演示＃2为了演示why-did-you-update，我将库安装在 TodoMVC 应用程序的 Code Sandbox 上，这是一个在线 React 游戏场。打开浏览器控制台并添加一些 TODO 以查看输出。 这是演示 请注意，应用程序中的几个组件不必要地 render。尝试实现上述技术来防止不必要的渲染。如果正确完成，则why-did-you-update控制台中不应有输出。 工具＃3：反应开发工具 React 开发者工具 Chrome 扩展程序具有可视化组件更新的内置功能。这有助于检测不必要的渲染循环。要使用它，首先请确保在此处安装扩展。 然后，点击Chrome DevTools中的“React”标签打开扩展程序，然后选中“Highlight Updates”。 然后，只需使用你的应用程序。与各种组件交互，并观看 DevTools 工作的魔力。 了解输出“react 开发人员工具”突出显示在给定时间点重新呈现的组件。根据更新的频率，使用不同的颜色。对于频繁更新的组件，蓝色显示不频繁更新，按更新频率依次为绿色，黄色和红色。 看到黄色或红色不一定是坏事。当调整滑块或触发频繁更新的其他UI元素时，可以预期。但是，如果您点击一个简单的按钮并看到红色，这可能意味着某些东西是错误的。该工具的目的是发现不必要的更新的组件。作为应用程序开发人员，您应该有一个一般的想法，哪些组件应该在给定的时间更新。 演示＃3为了演示组件突出显示，我安装了 TodoMVC 应用程序来不必要地更新某些组件。 这是演示 打开上面的链接，然后打开 React Developer Tools 并启用更新突出显示。当您输入顶部文本输入时，您将看到所有 TODO 都不必要地突出显示。当您输入更快时，您将看到颜色更改以指示更频繁的更新。 修复不必要的渲染一旦识别出应用程序中不必要的重新渲染的组件，就会有一些简单的修复。 使用PureComponent在上面的例子中，DumbComponent 是它 props 的纯函数。也就是说，该组件只有在其 props 更改时才需要重新 render。React 有一种内置的特殊类型的组件，PureComponent 这个类型是为这个用例准备的。 而不是继承自 React.Component，请使用 React.PureComponent，如下所示： class DumbComponent extends PureComponent { render() { return &lt;div> {this.props.value} &lt;/div>; } } 然后，该组件只有在其 props 实际更改时才会重新 render。而已！ 请注意，PureComponent做一个 props 的浅比较，所以如果你使用复杂的数据结构，它可能会错过一些 props 更改，而不是更新您的组件。 实现 shouldComponentUpdateshouldComponentUpdate 是 render 任何一个 props 或 state 更改之前调用的组件方法。如果 shouldComponentUpdate 返回 true，render 将被调用，如果它返回 false，没有任何反应。 通过实现此方法，您可以指示 React 避免重新渲染给定的组件，当其 props 不更改的时候。 例如，我们可以像下面这样，在一个组件中实现一个 shouldComponentUpdate ： class DumbComponent extends Component { shouldComponentUpdate(nextProps) { if (this.props.value !== nextProps.value) { return true; } else { return false; } } render() { return &lt;div>foo&lt;/div>; } } 调试生产中的性能问题如果您在自己的机器上运行应用程序，“React Developer Tools”才能起作用。如果您有兴趣了解用户在生产中看到的性能问题，请尝试使用LogRocket。 LogRocket 就像是网络应用程序，记录 DVR 字面上 的一切，您网站上发生的。您可以使用错误或性能问题重播会话，而不是猜测为什么会出现问题，以快速了解根本原因。 LogRocket 为您的应用程序记录性能数据，Redux actions/state，日志，错误，网络请求/响应与标题+主体和浏览器元数据。它还在页面上记录HTML和CSS，重新创建即使是最复杂的单页应用程序的像素视频。 【翻译原文链接】：https://medium.freecodecamp.org/make-react-fast-again-tools-and-techniques-for-speeding-up-your-react-app-7ad39d3c1b82]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux 并不慢，只是你使用姿势不对 —— 一份优化指南]]></title>
    <url>%2F2017%2F07%2F17%2Freact-redux-optimization.html</url>
    <content type="text"><![CDATA[Redux 并不慢，只是你使用姿势不对 —— 一份优化指南如何优化使用了 Redux 的 react 应用程序并不是显而易见的。但实际上相当简单。这是一个简短的指南，以及一些例子。 当优化使用 Redux 的 react 应用程序时，我经常听到有人说 Redux 缓慢。在99％的情况下，性能不佳的原因（适用于任何其他框架）与不必要的渲染相关联，因为 DOM 更新是昂贵的！在本文中，您将学习如何在使用 Redux 绑定 react 时避免不必要的 render。 通常，我们使用官方 react 绑定的 Redux 的 connect 高阶组件， 当您的 Redux store 更新时，react 组件就会更新。这是一个将组件包装在另一个组件中的函数，该组件订阅了 Redux store 中的更改，并渲染 store，这就是它的子节点更新的原因。 快速入坑 react-redux，官方 react 绑定 Redux该 connect 高阶组件实际上是已经过优化。要了解如何最好地使用它，最好了解先它是如何工作的！ Redux 以及 react-redux 实际上是相当小的库，所以源代码并不费解。我鼓励大家阅读源代码，或至少其中的一些。如果你想进一步，编写自己的实现，它将让你深入了解为什么库的设计方式是这样的。 不用多说，我们来看看 react 绑定的工作原理。正如我们公认的那样，react 绑定的核心部分就是 connect 高阶组件，这是它的写法： return function connect( mapStateToProps, mapDispatchToProps, mergeProps, { pure = true, areStatesEqual = strictEqual, areOwnPropsEqual = shallowEqual, areStatePropsEqual = shallowEqual, areMergedPropsEqual = shallowEqual, ...extraOptions } = {} ) { ... } 作为附注 - 唯一的强制性参数是 mapStateToProps，在大多数情况下，您只需要前两个参数。但是，我在这里使用完整的写法来说明 react bindings 是如何工作的。 传递给 connect 函数的所有参数都用于生成一个对象，该对象作为 props 传递到封装的组件上。mapStateToProps 用于将状态从 Redux store 映射到一个对象，mapDispatchToProps 用于生成包含函数的对象 - 通常这些函数是 actions 创建者。最后，mergeProps 有三个参数 stateProps，dispatchProps 和 ownProps。第一个是 mapStateToProps 的结果，第二个参数是 mapDispatchToProps 的结果，第三个参数是从组件本身继承的 props 对象。默认情况下，mergeProps 将这些参数简单地组合到一个对象中，但是如果您传递一个函数作为 mergeProps 参数，connect 则将使用该函数生成封装组件的 props。 connect 函数的第四个参数是一个 options 对象。这包含5个选项：pure 可以是 true 或 false，以及确定是否重新渲染组件的4个函数（应该返回一个布尔值）。pure 默认设置为true。如果设置为false，则connect 将跳过任何优化，并且options对象中的4个函数将不生效。我个人不能想到一个用例，但是如果您希望关闭优化，则将其设置为false。 我们的 mergeProps 函数产生的对象与最后一个 props 对象进行比较。如果我们的 connect 认为 props 对象已经改变了，那么这个组件就会重新渲染。要了解库如何决定是否有变更，我们可以查看该 shallowEqual 功能。如果函数返回 true，组件将不会重新渲染，如果返回 false，它将重新渲染。shallowEqual 执行此比较。下面你会看到 shallowEqual 方法的一部分，它告诉你所有你需要知道的： for (let i = 0; i &lt; keysA.length; i++) { if (!hasOwn.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) { return false } } 总而言之，这是上面的代码： 它在 object a 中的 key 上循环，并检查 object B 是否拥有相同的属性。然后它检查 object A中的属性（具有相同名称）是否等于对象B的属性。如果只有一个比较返回false，那么对象将被视为不相等，并且会发生重新渲染。 这导致我们一个黄金法则： 只给您的组件它需要呈现的数据这说得很含糊，所以让我们用一些实际的例子来阐述。 拆分连接的组件我看到人们这样做 订阅容器组件一系列状态，并通过 props 传递所有东西。 const BigComponent = ({ a, b, c, d }) => ( &lt;div> &lt;CompA a={a} /> &lt;CompB b={b} /> &lt;CompC c={c} /> &lt;/div> ); const ConnectedBigComponent = connect( ({ a, b, c }) => ({ a, b, c }) ); 现在，每次要么a，b或c变化，BigComponent包括CompA，CompB并且CompC将重新呈现。 相反，拆分您的组件，不要害怕更多地使用 connect： const ConnectedA = connect(CompA, ({ a }) => ({ a })); const ConnectedB = connect(CompB, ({ b }) => ({ b })); const ConnectedC = connect(CompC, ({ c }) => ({ c })); const BigComponent = () => ( &lt;div> &lt;ConnectedA a={a} /> &lt;ConnectedB b={b} /> &lt;ConnectedC c={c} /> &lt;/div> ); 通过此次更新，CompA 将只有当a已经改变才会重新渲染，CompB当b改变等。考虑这样一个场景，每一个值a，b并c分别经常更新。对于每次更新，我们现在重新渲染一个，而不是所有组件。这几乎没有什么明显的三个组件，但如果你有更多！ 改变你的状态，使其尽可能的最小这是一个假设（稍微设计过）的例子： 你有一个大的项目列表，我们假设有300或更多。 &lt;List> {this.props.items.map(({ content, itemId }) => ( &lt;ListItem onClick={selectItem} content={content} itemId={itemId} key={itemId} /> ))} &lt;/List> 当我们点击一​​个列表项时，一个动作被触发，更新一个存储值 - selectedItem。每个列表项连接到 Redux 并获取selectedItem： const ListItem = connect( ({ selectedItem }) => ({ selectedItem }) )(SimpleListItem); 我们正在做正确的事情，我们仅将组件连接到所需的状态。但是，当selectedItem更新时，所有ListItem组件都将重新渲染，因为我们返回的对象selectedItem已经更改。在此之前 { selectedItem: 123 }，现在是 { selectedItem: 120 }。 请记住，我们正在使用该 selectedItem 值来检查当前项目是否被选中。所以我们的组件真正需要知道的是它是否被选择 - 实质上是一个Boolean。Boolean 是伟大的，因为只有两个可能的值，true 或者 false。所以如果我们返回一个布尔值，而不是 selectedItem ，仅 Boolean 更改的两个项目将会重新渲染，这就是我们需要的。mapStateToProps 实际上 props 它是组件的第二个参数，我们可以用它来检查这是否实际上是选定的项目。以下是这样的： const ListItem = connect( ({ selectedItem }, { itemId }) => ({ isSelected: selectedItem === itemId }) )(SimpleListItem); 现在，只要我们的 selectedItem 值发生变化，只有两个组件重新呈现 - ListItem 现在已经被选择了，而且原来那个已经被取消选择了。 保持数据扁平化在 Redux文档提到 这是一种最佳实践。保持您的store 扁平化是有益的一些原因。但是对于本文的主旨，嵌套会造成问题，因为为了让我们的应用程序尽可能的快，我们希望我们的更新尽可能的细微。假设我们有一个这样的嵌套形状： { articles: [{ comments: [{ users: [{ }] }] }], ... } 为了优化我们的 Article，Comment 和 User 组件，我们现在需要所有的人订阅 articles，然后深深伸入这种结构只返回他们所需要的状态。相反地​​，如此设计你的形状更有意义： { articles: [{ ... }], comments: [{ articleId: .., userId: ..., ... }], users: [{ ... }] } 然后使用映射函数选择注释和用户信息。关于这一点的更多信息可以在 Redux文档中阅读关于规范化状态的信息。 彩蛋：用于选择 Redux state 的库这是完全可选的，取决于您。通常所有以上的建议都足够深入地让你写出快速的 react 和 Redux 应用程序。但是有两个优秀的库使得选择状态更容易一些： Reselect 是 selectors 为您的 Redux 应用程序编写的引人注目的工具。从重新选择文档： 选择器可以计算派生数据，允许 Redux 存储尽可能小的状态。 选择器效率高。除非其中一个参数发生变化，否则不会重新计算选择器。 选择器是可组合的。它们可以用作其他选择器的输入。 对于具有复杂接口，复杂状态 和/或 频繁更新的应用程序，重新选择可以帮助您轻松使您的应用程序更快！ Ramda 是一个功能强大的库，具有更高阶的函数。换句话说 - 用函数创建函数。由于我们的映射函数只是这个函数，所以我们可以很方便地使用 Ramda 创建我们的选择器。Ramda 可以有选择器的所有功能并做的更多。查看 Ramda 食谱的一些例子，您可以使用 Ramda 做什么。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优化 react 让它快如闪电——你是电，你是光，你是唯一的神话]]></title>
    <url>%2F2017%2F07%2F17%2Freact-at-light-speed.html</url>
    <content type="text"><![CDATA[光速 ReactVixlet 团队优化性能的经验教训在过去一年多，我们 Vixlet 的 web 团队已经着手于一个激动人心的项目：将我们的整个 web 应用迁移到 React + Redux 架构。对于整个团队来说，这是不断成长中的机会，在整个过程中，我们在这方面面临一些挑战。 因为我们的 web-app 可能有非常大的 feed 视图，包括成百上千的媒体、文本、视频、链接元素，我们花了相当多的时间寻找能充分利用 React 性能的方法。在这里，我们将分享我们这一路学到的一些经验教训。 声明：下面讲的做法和方法更适用于我们具体应用的性能需求。然而，像所有的开发者建议的那样，最重要的是要考虑到你的应用程序和团队的实际需求。React 是一个开箱即用的框架，所以你可能不需要像我们一样细致地优化性能。话虽如此，我们还是希望你能在这篇文章里找到一些有用的信息。 基本优化 向更大的世界迈出第一步。 render() 函数一般来说，要尽可能少地在 render 函数中做操作。如果非要做一些复杂操作或者计算，也许你可以考虑使用一个 memoized 函数以便于缓存那些重复的结果。可以看看 Lodash.memoize，这是一个开箱即用的记忆函数。 反过来讲，避免在组件的 state 上存储一些容易计算的值也很重要。举个例子，如果 props 同时包含 firstName 和 lastName，没必要在 state 上存一个 fullName，因为它可以很容易通过提供的 props 来获取。如果一个值可以通过简单的字符串拼接或基本的算数运算从 props 派生出来，那么没理由将这些值包含在组件的 state 上。 Prop 和 Reconciliation重要的是要记住，只要 props（或 state）的值不等于之前的值，React 就会触发重新渲染。如果 props 或者 state 包含一个对象或者数组，嵌套值中的任何改变也会触发重新渲染。考虑到这一点，你需要注意在每次渲染的生命周期中，创建一个新的 props 或者 state 都可能无意中导致了性能下降。 例子: 函数绑定的问题 例子: 对象或数组字面量 例子 : 注意字面量的回退值 尽可能的保持 Props（和 State）简单和精简理想情况下，传递给组件的 props 应该是它直接需要的。为了将值传给子组件而将一个大的、复杂的对象或者很多独立的 props 传递给一个组件会导致很多不必要的组件渲染（并且会增加开发复杂性）。 在 Vixlet，我们使用 Redux 作为状态容器，所以在我们看来，最理想的是方案在组件层次结构的每一个层级中使用 react-redux 的 connect() 函数直接从 store 上获取数据。connect 函数的性能很好，并且使用它的开销也非常小。 组件方法由于组件方法是为组件的每个实例创建的，如果可能的话，使用 helper/util 模块的纯函数或者静态类方法。尤其在渲染大量组件的应用中会有明显的区别。 进阶 在我看来视图的变化是邪恶的！ shouldComponentUpdate()React 有一个生命周期函数 shouldComponentUpdate()。这个方法可以根据当前的和下一次的 props 和 state 来通知这个 React 组件是否应该被重新渲染。 然而使用这个方法有一个问题，开发者必须考虑到需要触发重新渲染的每一种情况。这会导致逻辑复杂，一般来说，会非常痛苦。如果非常需要，你可以使用一个自定义的 shouldComponentUpdate() 方法，但是很多情况下有更好的选择。 React.PureComponentReact 从 v15 开始会包含一个 PureComponent 类，它可以被用来构建组件。React.PureComponent 声明了它自己的 shouldComponentUpdate() 方法，它自动对当前的和下一次的 props 和 state 做一次浅对比。有关浅对比的更多信息，请参考这个 Stack Overflow： http://stackoverflow.com/questions/36084515/how-does-shallow-compare-work-in-react 在大多数情况下，React.PureComponent 是比 React.Component 更好的选择。在创建新组件时，首先尝试将其构建为纯组件，只有组件需要更多功能时才使用 React.Component。 更多信息，请查阅相关文档 React.PureComponent。 组件性能分析（在 Chrome 里）在新版本的 Chrome 里，timeline 工具里有一个额外的内置功能可以显示哪些 React 组件正在渲染以及他们花费的时间。要启用此功能，将 ?react_perf 作为要测试的 URL 的查询字符串。React 渲染时间轴数据将位于 User Timing 部分。 更多相关信息，请查阅官方文档：Profiling Components with Chrome Timeline 。 有用的工具: why-did-you-update这是一个很棒的 NPM 包，他们给 React 添加补丁，当一个组件触发了不必要的重新渲染时，它会在控制台输出一个 console 提示。 注意: 这个模块在初始化时可以通过一个过滤器匹配特定的想要优化的组件，否则你的命令行可能会被垃圾信息填满，并且可能你的浏览器会因此而挂起或者崩溃，查阅 why-did-you-update 文档 获取更多详细信息。 常见性能陷阱 setTimeout() 和 setInterval()在 React 组件中使用 setTimeout() 或者 setInterval() 要十分小心。几乎总是有更好的选择，例如 ‘resize’ 和 ‘scroll’ 事件（注意：有关注意事项请参阅下一节）。 如果你需要使用 setTimeout() 和 setInterval()，你必须 遵守下面两条建议 不要设置过短的时间间隔。 当心那些小于 100 ms 的定时器，他们很可能是没意义的。如果确实需要一个更短的时间，可以使用 window.requestAnimationFrame() 替代。 保留对这些函数的引用，并且在 unmount 时取消或者销毁他们。 setTimeout() 和 setInterval() 都返回一个延迟函数的引用，并且需要的时候可以取消它们。由于这些函数是在全局作用域执行的，他们不在乎你的组件是否存在，这会导致报错甚至程序卡死。 注意: 对 window.requestAnimationFrame() 来说也是如此 解决这个问题最简答的方法是使用 react-timeout 这个 NPM 包，它提供了一个可以自动处理上述内容的高阶组件。它将 setTimeout/setInterval 等功能添加到包装组建的 props 上。(特别感谢 Vixlet 的开发人员 Carl Pillot 提供这个方法) 如果你不想引入这个依赖，并且希望自行解决此问题，你可以使用以下的方法： 如果你使用 requestAnimationFrame() 执行的一个动画循环，可以使用一个非常相似的解决方案，当前代码要有一点小的修改： 未 去抖 频繁触发的事件某些常见的事件可能会非常频繁的触发，例如 scroll，resize。去抖这些事件是明智的，特别是如果事件处理程序执行的不仅仅是基本功能。 Lodash 有 _.debounce 方法。在 NPM 上还有一个独立的 debounce 包. “但是我真的需要立即反馈 scroll/resize 或者别的事件” 我发现一种可以处理这些事件并且以高性能的方式进行响应的方法，那就是在第一次事件触发时启动 requestAnimationFrame() 循环。然后可以使用 [debounce()](https://lodash.com/docs#debounce) 方法并且将 trailing 这个配置项设为 true（这意味着该功能只在频繁触发的事件流结束后触发）来取消对值的监听，看看下面这个例子。 密集CPU任务线程阻塞某些任务一直是 CPU 密集型的，因此可能会导致主渲染线程的阻塞。举几个例子，比如非常复杂的数学计算，迭代非常大的数组，使用 File api 进行文件读写，利用 对图片进行编码解码。 在这些情况下，如果有可能最好使用 Web Worker 将这些功能移到另一个线程上，这样我们的主渲染线程可以保持顺滑。 相关阅读 MDN 文章: Using Web Workers MDN 文档: Worker API 结语我们希望上述建议对您能有所帮助。如果没有 Vixlet 团队的伟大工作和研究，上述的提示和编程技巧是不可能产出的。他们真的是我曾经合作过的最棒的团队之一。 在你的 React 的征途中保持学习和练习，愿原力与你同在！ 原文地址：React at Light Speed @Jacob Beltran]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npx是什么，为什么需要npx?]]></title>
    <url>%2F2017%2F07%2F14%2Fintroducing-npx-an-npm-package-runner.html</url>
    <content type="text"><![CDATA[介绍npx：一个npm包运行NPM升级到最新版本，npm@5.2.0，你可能会发现，它会安装一个新的二进制包跟着 npm：npx。 npx 是一个工具，旨在帮助整理从npm注册软件包的体验 - 和 使得npm非常容易地安装和管理托管在注册表上的依赖关系是 同样的方式，npx使 npm 很方便使用CLI工具和其他被托管的可执行文件。它大大简化了一些事情，到目前为止，需要一些与普通的npm有关的步骤： 使用本地化的安装工具而不用 npm run-script 将cowsay作为本地devDependency进行安装，并以“$ npx cowsay”运行 在过去几年中，npm生态系统越来越多地将安装工具作为项目本地化devDependencies，而不是要求用户在全局安装。这意味着，像工具mocha，grunt和bower，曾经被要求安装在系统的全局目录上，现在可以在每个项目的基础上管理自己的版本。这也意味着，所有你需要做的就是基于NPM的项目运行起来，以确保您有node + NPM您的系统上，克隆github项目，并运行npm it去运行install和test。由于npm run-script添加本地二进制文件到路径，这个工作很好！ 不利之处在于，它不会快速/方便地以交互方式调用本地二进制文件。有几种方法可以做到这一点，他们都对他们有一些烦恼：你可以添加这些工具到你scripts，但是你需要记住通过使用传递参数--，你可以通过shell技巧alias npmx=PATH=$(npm bin):$PATH 做到，或者你可以手动路径他们，使用 ./node_modules/.bin/mocha。这些都是工作，但没有一个是非常理想的。 npx给你我认为是最好的解决方案：您需要做的是使用$ npx mocha进行本地安装。如果你再进行一个额外的步骤并配置shell自动回退（更多内容在下面会提到），那么在一个项目目录中运行$ mocha将会成为你的技巧！ 作为彩蛋，如果调用已经安装的二进制文件，npx基本上没有开销 - 这足以将该工具的代码直接加载到当前运行的node进程中！这种事情就像读取文件一样快，并且使它成为一个完全可以接受的脚本编写工具。 执行一次性命令 $ npx create-react-app my-cool-new-app安装一个临时的创建应答程序并调用它，而不会污染全局安装或需要多个步骤！ 你有没有遇到过 想要尝试一些CLI工具的情况，但是要安装一个全局只是为了运行一次，这很烦人？npx对这种情况也是很有用。调用的npx 当不在你的$PATH意愿列表中，会自动从你的npm注册表中安装一个包含该名称的包，然后调用它。完成后，安装的软件包将不会储存在全球范围内任何地方，所以您不用担心长期的污染。 此功能也适用于generators等。像yeoman或create-react-app这样的工具只被调用一次。当你再次运行它们时，他们已经过时了，所以你最终不得不在每次想要使用它们时再次安装更新。 作为一种工具的维护者，我很喜欢这个功能，因为这意味着我可以把$ npx my-tool写进README.md的指令，而不是试图让人们在实际安装它的障碍。坦白说，说“哦，只需复制粘贴这一个命令，这是零成本的”更贴切，对于不确定是否使用这个工具的用户来说。 这里，你可能想用尝试一些其他有趣的包npx：happy-birthday，benny-hill，workin-hard，cowsay，yo，create-react-app，npm-check。甚至有一个完整的awesome-npx入门项目！来吧！获取一个足够小的完整的本地REST服务器运行的命令以适应一个推文。 使用不同Node.js版本运行命令 npx -p node-bin @ node -v可用于执行节点版本的一次性运行。 事实证明，在npm注册表中有一个很酷的包叫 node-bin。这意味着你可以使用不同的node版本，而不必使用node版本管理器,像nvm，nave或n。所有你需要的只是安装`npm@5.2.0`！ -pnpx 选项允许您指定要安装并添加到正在运行的软件包$PATH，这意味着您可以进行有趣的操作，例如：$ npx -p node-bin@6 npm it安装并测试当前的npm软件包，就像在node@6全局运行一样。我一直使用这个 - 我甚至最近不得不在一个项目中经常使用它，由于我的一个测试库在node@8环境下无法运行。这是一个真正的救世主，我发现使用这种类型的用例比版本管理器更容易，我总是以某种方式找到break或错误配置的方法。 注意：node-bin仅适用于* nix平台。这是Aria Stewart的出色工作。在将来，同样的软件包将可以简单地使用node，所以您可以$ npx node@6 ...直接执行，包括在Windows上。 与 npm run-script 互动发展 $ npx -p cowsay -p lolcatjs -c'echo“$ npm_package_name @ $ npm_package_version”| cowsay | lolcatjs's将安装cowsay和lolcatjs，并使脚本从运行脚本访问一堆“$ npm_”变量。 很多npm的用户现在可以利用这个非常酷的run-script功能。他们不仅让您的$PATH本地二进制文件可访问，而且还添加了一大堆环境变量，您可以在这些脚本中访问。你可以看到这些额外的变量是什么$ npm run env | grep npm_。 这可以使开发和测试运行脚本变得棘手 - 这意味着即使使用诸如此类的技巧$(npm bin)/some-bin，在交互式工作的同时仍然无法访问这些神奇的env var。 可是等等！npx还有一个技巧：当你使用这个-c选项时，写入string参数内的脚本将能够像普通的运行脚本一样完全访问相同的env变量！您甚至可以使用管道和多个命令进行单次npx调用！ 与朋友以及你想要的任何人分享基于gist的脚本！ 使用gist.github.com分享各种实用程序脚本变得很常见，而不是设置整个git repos，发布新工具等。 使用npx，您可以进一步：因为npx接受npm本身所做的任何说明符，您可以创建一个人们可以直接使用单个命令调用的要点！ 尝试使用https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32！ 注意：保持安全！在执行这些时，始终确保通过 gists 网站读取和执行代码，就像运行 .sh 脚本时一样谨慎！ 彩蛋：shell自动回退 将.zshrc中的npx自动回退意味着你可以在没有引用npx的情况下执行$ ember-cli @ latest ... FélixSaparelli补充说，这个令人敬畏的功能意味着对于许多这些用例，您甚至不需要直接调用npx！常规的npx使用和回退之间的主要区别是，回退不会安装新软件包，除非您使用pkg@version语法：安全网来防止潜在的危险排序。 设置自动回退是很简单的：在npx文档中查看用于当前shell的命令，将其添加到 .bashrc / .zshrc / .fishrc，然后重新启动shell（或使用source或其他机制来刷新shell）。 现在，您可以做一些$ standard@8 --version尝试不同版本的东西，如果您在一个npm项目中，$ mocha则会自动回到本地安装的mocha版本，前提是它尚未在全局安装。 现在就试试吧你现在可以通过安装`npm@5.2.0或更新来获得npx，或者如果你不想使用npm，你可以安装独立版本的npx！它与其他软件包管理器完全兼容，因为任何npm使用仅适用于内部操作。哦，它有10种不同的语言，感谢来自世界各地的一大批早期采用者的贡献，–help以及所有的系统消息翻译，并可以根据系统区域设置自动提供！还有一个awesome-npx[repo](https://github.com/js-n/awesome-npx)与npx`工作地很好的例子！ 你有最喜欢的功能吗？你有没有使用过？如果你有一些很酷炫的事，我没有在这里列出，请在评论中分享！我很想听听别人的意见！ PS人们不断地问这个，所以我只是会弹出它在这里：在这些GIF文件，我使用monokai主题的Hyper运行 oh-my-zsh中的spaceship主题，再加上FiraCode字体。 【翻译原文】: https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>npx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么我停止使用多个显示器]]></title>
    <url>%2F2017%2F07%2F11%2Fwhy-should-stopped-using-multiple-monitors.html</url>
    <content type="text"><![CDATA[许多开发人员认为多个显示器可以提高生产力。研究证明是这样，对吧？那么，请记住，许多这些研究是由戴尔和NEC等监控制造商委托进行的。🤔 尽管多个显示器使您看起来像一个重度的计算机使用者，但我在几年前卖了我的多显示器，并切换到一个监视器。而且我并不是一个人。 下面就是为什么。 专注人类一次只能关注一件事情。那么为什么我们花钱来同时显示多个东西呢？如果我的电子邮件或社交媒体资讯提供一目了然，我会经常检查。这不仅不是不必要的，反而是有效的。在一个无休止的分心的世界中，能够长期专注于单一任务是一项非常有价值的技能。 深刻的工作在我们分心充实的经济中变得越来越困难，但也变得越来越重要和罕见。少数能够在深度工作上度过的日子将变得非常市场化和成功。 Cal Newport在“ 深加工 ” 一个监视器意味着我的工作 - 只有我的工作 - 显示在前面和中央。分心停留在视线之外，所以眼不见，心不烦。 这看起来像是专注一项任务吗 我们每天做的最有价值的工作之一就是要长期专注于一个单一的应用程序：阅读和写作。阅读和写作都受益于来自于屏幕上唯一的重点。一本带有移动微博的小本本在旁边将是一场灾难。但是很多人都愿意做这个。额外的显示经常导致潜在的持续分心。如果您的电子邮件，社交媒体等不可见，您更有可能继续工作。 作为开发人员，我每天都在编写代码。所以我经常阅读文档。但是我很少需要在读文档的 同时 编写代码。我读完相关的文档，然后再编码。我的工作流是模态的。 减少窗口管理我使用一个月的 34“LG超宽屏显示器，起初，我喜欢它。 不过，过了几天，我很惊讶地发现我出了个馊主意。我的桌面最大化，太宽了，所以我发现自己花了太多的时间摆弄桌面。“今天应该放在左边呢？”“现在有什么重要的事情呢？” 当然，屏幕足够宽，可以并排显示多个窗口，但是它非常宽，边缘感到不舒服。所以，我发现自己不断把我的工作转移到屏幕的中心，从而违背了买一个巨大的显示器的整个目的！Jeff Atwood很久以前在“大型显示悖论”中讨论了这个问题。他的解决方案，使用软件移动和调整大小的窗口更容易。我的解决方案，只需使用一个合理尺寸的显示器。 即使使用方便的窗口管理软件，多个显示器也会出现问题：如果我有两个显示器，内容不会直接在我的前面。我必须向右或向左转动我的头（特别烦在跑步机上行走的人，就像我经常看到的那样）。我可以把一个监视器直接放在我面前，但是第二个监视器甚至更远一些，这使得它显然是一个二等公民。这再次导致我从正在工作的中间屏幕移动。 正如巴里·施瓦茨（Barry Schwartz）在“选择的悖论”中所探讨的那样，决策疲劳是一个真正的问题。有时候，少即是多。 “选择使我们不是更自由，更瘫痪，不快乐，但更不满意。” 只通过一个屏幕，我决定。我不会浪费时间决定在哪里拖曳窗口或摆放在给定窗口的位置。我最大化我正在使用的应用程序，以阻止所有其他分心…在上班的时候。 虚拟桌面为赢Mac和Windows现在都支持虚拟桌面。在我的Mac上，我可以通过3个手指快速切换多个虚拟桌面。这需要不到一秒钟的时间，它不需要我转过头来重新聚焦我的眼睛在不同的地方的内容。我也不用浪费时间安排。最左边的虚拟桌面总是我的浏览器，右边是我的编辑器。所以我将虚拟桌面视为可靠呈现相同内容的物理屏幕。 顶部的三个框架表示三个虚拟桌面。三手指滑动可立即在它们之间切换 - 无需再花时间旋转我的头，看一个单独的显示器。 我用于完成工作的首选监视器我更喜欢使用一个24“4K，为什么24”？因为如果你想完成实际的工作，更大的不一定更好。24“足够大，可以全屏显示单个应用程序，它足够大，可以在罕见的情况下并排显示两个应用程序，我真的需要同时看到两件事情（我在Mac上使用BetterTouchTool，只需击中Win +箭头在Windows），但是24“足够小，您可以最大限度地利用所有应用程序，而无需移动您的头部或眼睛很多看到屏幕边缘。记住，最大化所有的事情。最大化=集中。 为什么是4K？高DPI降低疲劳。文字更加清晰。价格也慢慢合理了，所以如果你还没有高DPI显示器，买一个。而24“4K每4K英寸的点数要大于4K屏幕，所以它更加清晰。过去几年内建成的任何MacBook Pro都可以在DisplayPort上以60hz的速度推出4K显示器，许多最近的Windows笔记本电脑也可以这样做。 那么为什么这么多工作者需要多台显示器呢？我相信这是极端不合逻辑的诱惑。 太多的东西变得相反。 - 蒂姆·弗里斯 显示器太多会变得分心。所以说到监视器，我拥抱这些想法： 少即是多 质量而不是数量 定力，定力，定力（Location, Location, Location） 【翻译原文】:（有删减） https://hackernoon.com/why-i-stopped-using-multiple-monitors-bfd87efa2e5b]]></content>
      <categories>
        <category>workflow</category>
      </categories>
      <tags>
        <tag>performance</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不要混用 import 和 require]]></title>
    <url>%2F2017%2F07%2F10%2Fdont-mixin-import-and-require.html</url>
    <content type="text"><![CDATA[import 是 ES6 规范语法之一。而 require 属于CommonJS规范的一部分。 目前来说，使用现代浏览器还无法支持 import，一般都会搭配 babel 使用，而 babel 会把 import 转换成 CommonJS 的 require. 但是，我们不能混用 import 和 require。有时候会看下如下代码： 但实际执行顺序并不是你想象或看到的那样。import 具有声明提升效果，会首先执行。所以最好 不要混用。 import 是 ES6 标准，如果可能，首先使用 import, 如果不行，就用 require。 ES6 import 具有声明提升效果 您可以使用命名导入来选择性地加载所需的部分。这样可以节省内存， 如：import { render } from react 导入可以是异步的 ES6 标准 require 您可以在加载的模块名称不是预定义/静态的情况下进行动态加载，或者只有在真正需要的情况下才有条件地加载模块（取决于某些代码流） CommonJS 规范加载是同步的。这意味着如果你有多个require，它们将逐个加载和处理（AMD规范是可以异步的） 只是约定的规范 参考：https://twitter.com/dan_abramov/status/883375646357041152]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>import</tag>
        <tag>require</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react性能优化：提取子组件中额外的事件绑定]]></title>
    <url>%2F2017%2F07%2F06%2Freact-pattern-extract-child-components-to-avoid-binding.html</url>
    <content type="text"><![CDATA[react性能优化：提取子组件中额外的事件绑定我们经常在快要完成一个react中型应用时，发现页面并没有想象中那么流畅。 react 理论性能是不错的，但是对开发者要求也很高，一些不易注意的点很容易造成性能问题。正所谓“烂泥扶不上墙”。 下面看看子组件的事件绑定写法对性能的影响。 这是React中的常见情况：您正在映射数组，您需要每个项目调用点击处理程序和一些相关数据。 这是一个例子。我正在迭代一个用户列表，并将userId传递给第29行的deleteUser函数。 这是Codeandbox上的一个工作示例。（真棒） 所以, 有什么问题？我在点击处理程序中使用箭头函数。这意味着每次渲染运行时，都会分配一个新函数。在许多情况下，这不是一件多大的事。但是，如果您有子组件，即使数据没有更改，它们也将重新渲染，因为每个渲染分配一个新的函数。 底线：避免在渲染中声明箭头函数或绑定以获得最佳性能。我的团队使用这个ESLint规则帮助提醒我们这个问题。 解决方案是什么？那么你如何在渲染中避免绑定和箭头函数呢？一个选项是提取一个子组件。在这里，我将列表项提取到UserListItem.js： 然后，父组件的渲染变得更简单，不再需要包含箭头函数。它只是通过props传递每个列表项的相关上下文： 这是一个重构的工作实例。 Yay or Yuck?此模式通过消除冗余的函数分配来提高性能。所以当这种情况适用于您的组件时，它是最有用的： 渲染频繁被调用 渲染子组件非常耗时 诚然，我提取子组件也是我提到的一个额外的工作。它需要更多的移动部件和更多的代码。所以如果你没有出现性能问题，可以说这是一个过早的优化。 所以你有两个选择：允许箭头和绑定到任何地方（如果有性能问题再处理），或禁止他们获得最佳性能和一致性。 底线：我建议禁止箭头函数并在render中绑定。下面就是为什么： 你必须禁用我上面建议的有用的ESLint规则来允许它。 禁用linting规则后，人们可能会复制此模式，并开始禁用其他linting规则。一个处例外可以很快成为规范… General rule for code reviews:Each line of code should be worthy of copying. Because people will.#cleancode— Cory House 🏠 (@housecor) March 8, 2017 所以我发现提取子组件是一个有用的模式，以避免在渲染中绑定。 其他的反例还有些人会想要这样写： deleteUser = id=() => { this.setState(prevState => { return { users: prevState.users.filter( user => user.id !== id)} }) } // … onClick={this.deleteUser(user.id)} 他们认为传递参数会比其他方式更加方便。但这和第一个糟糕的例子并无太大区别，子组件同样会再次渲染。 如果有相当多类似的输入框，像这样： &lt;form> Render = () => Input1 value=this.state.input1 onChange= update state for field1 Input2…. Input3…. 官方给出的方法是给每个 input 添加 name 属性，进而获取参数。 当然也有人会想要在 html 上动文章，比如添加自定义属性 data-id=${userId}。这当然也能实现，但是 html不应该是数据源，这应该避免。 【翻译原文】:(有改动)https://medium.freecodecamp.org/react-pattern-extract-child-components-to-avoid-binding-e3ad8310725e]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用Memoize来缓存JavaScript函数结果并加快代码的速度]]></title>
    <url>%2F2017%2F07%2F04%2Funderstanding-memoize-in-javascript.html</url>
    <content type="text"><![CDATA[Function 是编程的组成部分。它们有助于为我们的代码增加模块化和可重用性。 将程序划分为大块是很常见的功能，我们稍后可以使用这些功能来执行一些有用的操作。 有时，多次调用功能可能会变得昂贵（比如，计算一个数字的阶乘的函数）。但是有一种方法可以优化这些功能，使它们执行得更快：缓存。 例如，假设我们function要返回一个数字的阶乘： function factorial(n) { // Calculations: n * (n-1) * (n-2) * ... (2) * (1) return factorial } 非常好，现在我们来看看factorial(50)。计算机会执行计算，并返回给我们最后的答案，不错！ 完成后，让我们来看看factorial(51)。计算机再次执行一些计算并获得结果，但是您可能已经注意到我们已经重复了可以避免的一些步骤。优化的方式是： factorial(51) = factorial(50) * 51; 但是我们function每次调用时都会从头开始执行计算： factorial(51) = 51 * 50 * 49 * ... * 2 * 1 如果我们的函数factorial能记住它之前运算的结果并用它来提交运行效率，那不是很酷吗？ 谈到Memoization，一种让我们的function记住（缓存）结果的方式。既然您对我们要实现的目标有一个基本的了解，这里是一个正式的定义： Memoization是一种优化技术，主要用于通过 存储昂贵的函数调用的结果 来加速计算机程序，并在相同的输入再次发生时返回缓存的结果. 记住简单的东西意味着记忆或存储在内存中。记忆函数通常更快，因为如果随后使用先前的值调用该函数，我们将从缓存中获取结果来代替执行该函数，。 这看起来像一个简单的记忆函数（如果你想进行测试它，这里是一个CodePen）： // a simple function to add something const add = (n) => (n + 10); add(9); // a simple memoized function to add something const memoizedAdd = () => { let cache = {}; return (n) => { if (n in cache) { console.log('Fetching from cache'); return cache[n]; } else { console.log('Calculating result'); let result = n + 10; cache[n] = result; return result; } } } // returned function from memoizedAdd const newAdd = memoizedAdd(); console.log(newAdd(9)); // calculated console.log(newAdd(9)); // cached Memoization 要点以上代码的一些要点是： memoizedAdd返回一个function以便稍后调用的。这是可能的，因为在JavaScript中，函数是一等公民，它们可以将它们用作高阶的函数并返回另一个函数。 cache可以记住它的值，因为返回的函数被闭包封装了。 memoized功能纯粹(Pure)是至关重要的。纯函数将为特定输入返回相同的输出，而不需要调用多少次，这使得cache按预期的工作。 编写自己的 memoize 功能以前的代码工作正常，但如果我们想将任何函数转换为记忆函数呢？ 以下是如何编写自己的memoize函数（codepen）： // a simple pure function to get a value adding 10 const add = (n) => (n + 10); console.log('Simple call', add(3)); // a simple memoize function that takes in a function // and returns a memoized function const memoize = (fn) => { let cache = {}; return (...args) => { let n = args[0]; // just taking one argument here if (n in cache) { console.log('Fetching from cache'); return cache[n]; } else { console.log('Calculating result'); let result = fn(n); cache[n] = result; return result; } } } // creating a memoized function for the 'add' pure function const memoizedAdd = memoize(add); console.log(memoizedAdd(3)); // calculated console.log(memoizedAdd(3)); // cached console.log(memoizedAdd(4)); // calculated console.log(memoizedAdd(4)); // cached 这很棒！这个简单的memoize功能将任何简单的function封装成一个有记忆性的等价物。该代码适用于简单的功能，可以根据您的需要轻松调整处理任意数量的arguments代码。另一个选择是利用一些的类库，如： Lodash的_.memoize(func, [resolver]) 来自decko的 ES7 @memoize 装饰器 记忆递归函数如果您尝试将递归函数传递到memoize上面的函数或Lodash的_.memoize函数，结果将不会如预期的那样，因为其后续调用的递归函数将最终调用自身而不是记忆函数，从而不再使用cache。 只需确保递归函数调用记忆函数。这里是你如何调整教科书阶乘例子（codepen）： // same memoize function from before const memoize = (fn) => { let cache = {}; return (...args) => { let n = args[0]; if (n in cache) { console.log('Fetching from cache', n); return cache[n]; } else { console.log('Calculating result', n); let result = fn(n); cache[n] = result; return result; } } } const factorial = memoize( (x) => { if (x === 0) { return 1; } else { return x * factorial(x - 1); } } ); console.log(factorial(5)); // calculated console.log(factorial(6)); // calculated for 6 and cached for 5 从这段代码注意几点： 该factorial函数递归地调用自己的记忆版本。 记忆功能是缓存先前阶乘的值，从而可以重复使用，从而显着改善了计算 factorial(6) = 6 * factorial(5) memoization 是否与 caching 相同？是的，有点。Memoization实际上是一种特定类型的缓存。虽然缓存通常可以引用任何存储技术（如HTTP缓存）以供将来使用，但是memoizing特指调用缓存的function返回值。 什么时候记录你的 functions虽然可能看起来 memoize 可以与所有函数一起使用，但它实际上有限制的用例： 为了记忆一个函数，它应该是纯粹的（pure），所以每次返回值对于相同的输入是相同的 记忆是增加的空间和增加的速度之间的权衡，因此对于具有有限的输入范围的功能而言是重要的，以便可以更频繁地使用缓存的值 它可能看起来像您记住您的API调用，但这并不是必需的，因为浏览器会为您自动缓存它们。有关详细信息，请参阅HTTP缓存 我发现用于记忆功能的最佳用例是 重度计算功能，可以显着提高性能（阶乘和斐波那契不是真正现实世界的例子） 如果您进入React / Redux，您可以检查重新选择哪个使用记忆选择器，以确保仅在状态树的相关部分发生更改时进行计算。 进一步阅读如果您想更详细地了解本文中的一些主题，以下链接可能很有用： JavaScript中的高阶函数 JavaScript闭包 纯函数 Lodash的_.memoize 文档和源代码 更多的memoization例子在这里和这里 reactjs/reSelect 【翻译原文】: https://medium.freecodecamp.org/understanding-memoize-in-javascript-51d07d19430e]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>Memoize</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3中background-position 的四值语法]]></title>
    <url>%2F2017%2F07%2F04%2Fbackground-position-of-css3-about-four-value-syntax.html</url>
    <content type="text"><![CDATA[css3中background-position的四值语法刨根问底，每个css属性都要知道它的所有值实在不容易。今天看看 background-position. background-positionCSS中的属性允许您在其容器内移动背景图像（或渐变）。 简介html { background-position: 100px 5px; } 它有三种不同的取值： 长度值（例如100px 5px） 百分比（例如100% 5%） 关键字（例如top right） 默认值为0 0。这会将您的背景图像放在容器的左上角。 长度值很简单：第一个值是水平位置，第二个值是垂直位置。因此，100px 5px将图像向右移动100像素，向下移动五个像素。您可以设定长度值单位为px，em或任何其他的CSS长度值。 百分比有所不同。戴上你的数学帽子：用x％移动背景图像意味着 将图像中的X％点 与 容器中的X％点 对齐(PS：很多人解释的时候只会说向左向下移动了x%,这就无法解释50%)。例如，50%意味着它会将图像的中间与容器的中间对齐。100%意味着它会将图像的最后一个像素与容器的最后一个像素对齐，依此类推。 关键字只是百分比的捷径。这top right比记住和写作要容易得多0 100%，这就是关键字的意义。以下是所有五个关键字及其等价取值的列表： top：垂直0％ right：水平100％ bottom：垂直100％ left：水平0％ center：如果水平尚未定义，则水平为50％。如果定义了则应用到垂直。 有趣的是，您关键字使用的顺序并不重要：与之top center相同center top。只有当您使用单一关键字时，您才能做到这一点。center 10%是不一样的10% center。 演示此演示演示了background-position具有长度单位，百分比和关键字取值的集合示例。 See the Pen background-position values by CSS-Tricks (@css-tricks) on CodePen. 声明值(Declaring Values)background-position现代浏览器中最多可以放置四个值（有关详细信息，请参阅浏览器支持列表）。 如果您只声明 一个值，则该值是水平偏移量。浏览器将垂直偏移设置为center。 当您声明 两个值 时，第一个值是水平偏移量，第二个值是垂直偏移量。 当您开始使用三个或四个值时，事情会变得更加棘手，但您也可以更好地控制您的背景位置。 三或四值语法在关键字和长度或百分比单位之间进行交替。您可以在background-position的三值或四值中使用任何关键字值， _除_ center之外。 当您指定 三个值 时，浏览器将“丢失”第四个值插入为0.以下是三值的示例background-position： #threevalues { background-position: right 45px bottom; } 这样就可以将背景图像定位在右侧的45px和容器底部的0px。 这是一个background-position 四值 的例子： #fourvalues { background-position: right 45px bottom 20px; } 这将背景图片定位在右侧的45px和容器底部的20px。 注意上面示例中值的顺序：关键字后跟长度单位。三或四个值background-position必须遵循该格式，关键字在长度或百分比单位之前。 演示此演示包括一个值，两个值，三个值和四个值的示例background-position。 See the Pen background-position 1, 2, 3, and 4 value syntax by CSS-Tricks (@css-tricks) on CodePen. 更多参考 background-position 在CSS3规范 background-position 在MDN 偏移背景图像 browser-support基本价值得到支持。四值语法具有此支持： Chrome Safari Firefox Opera IE Android iOS 25+ 7+ 13+ 10.5+ 9+ 4+ 7.1+ 【翻译原文：】https://css-tricks.com/almanac/properties/b/background-position/]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>background</tag>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array数组的indexOf、includes vs for-loop性能比较]]></title>
    <url>%2F2017%2F07%2F03%2Farr-of-indexOf-vs-includes-and-for-loop.html</url>
    <content type="text"><![CDATA[Array数组的indexOf、includes vs for-loop性能比较最近遇到一道算法题，然后有些人会使用 includes、indexOf 去判断是否存在另一个数。这让我不禁思考，这和 for loop有什么区别，能减少时间复杂度吗？我一开始也不是很清楚，但我可以找文档，找标准。我的第一判断是 includes 完全和 for loop没有区别的，只是es6 标准规范提供的语法糖，而 indexOf 还是有一定效率的。带着疑惑，查看 MDN 和 ecma-262 includesincludes 是 ES6 新增语法，返回 布尔值。最容易拿 indexOf 来比较， indexOf 不能判断 NaN, 而且不够语义，返回的是 匹配值的位置 或 -1。 includes 内部实现是这样的： Let O be ? ToObject(this value). Let len be ? ToLength(? Get(O, “length”)). If len is 0, return false. Let n be ? ToInteger(fromIndex). (If fromIndex is undefined, this step produces the value 0.) If n ≥ 0, then Let k be n. Else n < 0, Let k be len + n. If k < 0, let k be 0. Repeat, while k < len Let elementK be the result of ? Get(O, ! ToString(k)). If SameValueZero(searchElement, elementK) is true, return true. Increase k by 1. Return false. 其中的 SameValueZero 内部实现是这样的： If Type(x) is different from Type(y), return false. If Type(x) is Number, then If x is NaN and y is NaN, return true. If x is +0 and y is -0, return true. If x is -0 and y is +0, return true. If x is the same Number value as y, return true. Return false. Return SameValueNonNumber(x, y). 从上面可以看出 includes 内部是使用 while 循环，并不能够降低时间复杂度。它能判断出 NaN 以及 +0等于-0。 所以，返回值的语义化和 NaN的判断就是 includes 的场景。 indexOf好，includes 用来提升效率的幻想破灭了，那 indexOf 呢，规范是这么写的： Let O be ? ToObject(this value). Let len be ? ToLength(? Get(O, “length”)). If len is 0, return -1. Let n be ? ToInteger(fromIndex). (If fromIndex is undefined, this step produces the value 0.) If n ≥ len, return -1. If n ≥ 0, then If n is -0, let k be +0; else let k be n. Else n < 0, Let k be len + n. If k < 0, let k be 0. Repeat, while k < len Let kPresent be ? HasProperty(O, ! ToString(k)). If kPresent is true, then Let elementK be ? Get(O, ! ToString(k)). Let same be the result of performing Strict Equality Comparison searchElement === elementK. If same is true, return k. Increase k by 1. Return -1. Array的 indexOf 也使用了 while 循环，并使用 === 全等比较。（注： 与 String.prototype.indexOf 并不同） indexOf 使用场景是需要知道 匹配值的位置。 结论这是一个性能测试比较 so? 如果单纯只是想比较，简单的才是最快的。 includes与indexOf效率相当，而for Loop最快，因为没有其他的前置判断和浏览器对它的优化。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>indexOf</tag>
        <tag>includes</tag>
        <tag>loop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web Animations API 入门教程总结回顾]]></title>
    <url>%2F2017%2F06%2F28%2FWeb-Animations-API-Tutorial-Conclusion.html</url>
    <content type="text"><![CDATA[Web Animations API 入门教程总结回顾这是 Web Animations API 入门教程系列的总结部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与@dancwilson联系。 我们已经涵盖了相当多的知识面，希望能够解决有关Web Animations API是什么（而不是什么）的问题。要总结这个系列，我们将回顾一下我们已经讨论过的内容，并看看尚未实现的内容。 为什么要用API？在介绍中，我们讨论了API是如何将CSS，JS和SVG中的各种方法结合起来进行动画处理，旨在充分利用它们。这意味着，例如，JavaScript可以锁定CSS多年来的硬件加速，并不限于CSS的声明性。API并不意味着替换像GSAP这样的库，而只是为了在浏览器级别提供更多的选项。 Firefox和Chrome都已经开始实施，而Edge已经积压了很多事没有做。随着团队完成规范，polyfill可以让我们开始玩转它。 动画基础要创建一个基本的动画，我们通过提供关键帧和时序属性来跟踪类似于CSS的结构。 var player = document.getElementById('toAnimate').animate([ { transform: 'scale(1)', opacity: 1, offset: 0 }, { transform: 'scale(.6)', opacity: .6, offset: 1 } ], { duration: 700, }); 时间轴控制是当前CSS中明显不存在的部分。通过playState属性读取动画的状态，并改变状态，例如play()，pause()，和finish()。我们也可以通过读/写playbackRate属性将播放速度更改或更快。currentTime可读写，我们可以设置当动画与完成回调onfinish。 多个动画和分组Web Animations API允许对元素设置多个动画，创建单独的动画对象。document上默认的timeline可以使用getAnimations()方法让我们访问创建的所有动画。可以通过使用GroupEffects 和 SequenceEffects（在polyfill中提供但不在Level 1规范中）将动画组合在一起或一个接一个地进行播放。 运动路径与未来在这个系列中，沿着一条路径运动让我们看到了它在CSS中的第一个实现，但还有很多其他模块尚未实现。 间距(Spacing)如果在关键帧中没有设置offset，则当前的实现使用默认的间隔，这意味着它们是均匀分布的（例如，三个帧将具有0,1,5和1的偏移量）。该规范还定义了一种基于属性来调整动画的方法，以使其具有恒定的变化率。当讨论Spacing keyframes时，该规范描述了这一点。 Promises该规范已经演变成–包括ready在内的，每次动画取消或进入挂起状态（通常在更改为“运行”或“已暂停”）之前将会被新的Promise替换。除了onfinish, 我们在本系列中讨论的使用回调之外，我们还可使用finished返回的Promise在动画完成后运行其他功能。 让我们继续谈论Web动画API人们开始更多地谈论这个API，我希望这个讨论继续下去。规格，浏览器实现和polyfill已经持续了一段时间，他们准备好仔细检查。 有时CSS会有更多场景，有时候是requestAnimationFrame，有时使用类库会是最好的解决方案。知道什么时候使用什么是好的，这个API提供了不少以前我们以前没有的可用的东西，所以很有趣。 查看本系列的其余部分： 介绍 第1部分：创建基本动画 第2部分：动画和时间线控制 第3部分：多个动画 第4部分：GroupEffects和SequenceEffects 第5部分：运动路径 总结与回顾 【翻译原文】： http://danielcwilson.com/blog/2015/09/animations-conclusion/]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>Web Animations</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web Animations API 入门教程第5部分: 可爱的运动路径]]></title>
    <url>%2F2017%2F06%2F28%2FWeb-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path.html</url>
    <content type="text"><![CDATA[Web Animations API 入门教程第5部分: 可爱的运动路径这是 Web Animations API 入门教程系列的第5部分。 重要信息：自撰写本文以来，运动路径的规范（和Chromium实现）已经发生了重大变化。以下在概念上仍然有效，但是属性名称和更多内容已经改变。截至2016年10月，请查看CSS运动路径。 最后，沿着路径动画…不再仅仅是SVG的领域。 运动路径：当前方向（Spec）See the Pen Motion Path Infinity by Dan Wilson (@danwilson) on CodePen. 随着API规范的运用，运动路径出现了不同的形式。最初有可能的一个方向是一个形式的特效（如前面所讨论的GroupEffect），但随后借助CSS模块的运动路径的气势一点点上升（拥有它自己的规范）。 因此，沿着路径动画将只是另一组CSS属性，可以动画化，正如opacity和tranform也可以。这样，CSS过渡和关键帧可以使用它,Web Animations API也是…这是伟大的，因为我们想要尽可能多的这些方法之间共享给我们更多的灵活性。Chrome和Opera已经发布了一个初步的实现，所以我们可以在今天开始玩它，尽管还没有在polyfill找到它的任何使用方式。 让我们分解这些属性，我们如何使用它们，现在还有什么事情可以阻碍我们。 运动路径属性我们将讨论motion的三个属性。现在，要查看示例，您将需要运行Chrome 46或Opera 33。 motion-path起始点是motion-path定义元素可以移动的路径，遵循SVG 1.1中的路径工作方式： #motioner { motion-path: path("M200 200 S 200.5 200.1 348.7 184.4z"); } 这也可以fill-rule在路径调用中作为可选的第一个参数。我建议您阅读Joni Trythall的“优秀口袋指南”，就SVG进行讨论。 根据规范，您还可以使用基本形状，例如circle，polygon，ellipse，和inset。如果您尝试过使用CSS shape，这些应该看起来很熟悉。 根据Blink的初始实现，我只看过这个path()方法可以工作，所以我一直没有正确使用形状或者还没到时候。 motion-offset驱动运动，并将元素放在我们使用的路径上的某个位置motion-offset。这可以是双倍长度值或百分比。因此，从路径的起点到最后，我们设置一个从0到100％的动画。使用我们拥有的Web Animations API var m = document.getElementById('motioner'); m.animate([ { motionOffset: 0 }, { motionOffset: '100%' } ], 1000); 以及CSS的写法 #motioner { animation: path-animation 1s; } @keyframes path-animation { 0% { motion-offset: 0; } 100% { motion-offset: '100%'; } } See the Pen CSS Motion Path Spiral by Dan Wilson (@danwilson) on CodePen. 该CodePen演示显示了从外部到内部沿着螺旋路径移动的几个点。随着每个点接近中心，它变得越来越快，变得越来越透明。 .animate()在每个点被称为两次无限迭代和一个延迟，其中一个调用集中在运动偏移，另一个焦点在缩放和不透明度上。我分解了他们，指出了不同的解决方案，当然，他们也可以结合在一起。 这种方法还使用功能检测，您将会注意到，如果您在Safari，Firefox，Edge或旧版Chrome / Opera中查看，因为您将看到一条消息而不是动画。有几种方法可以做到这一点，比如 var m = document.getElementById('motioner'); if (m.style.motionOffset !== undefined) { ... } 当然，我们不想在真正的网页中完全阻止用户，所以如果支持，我们可以有另一个动画（或者没有动画）切换到Motion Path动画。像往常一样，渐进增强(Progressive Enhancement)是我们的朋友。 motion-rotation最后的属性是motion-rotation，它处理元素沿着路径移动时面向哪个方向。有四种主要方法可以指定这一点。 auto 表示元素将随路径旋转。 reverse 元素也将随着路径旋转，但会增加180度，因此将向后。 auto Xdeg / reverse Xdeg 除了添加X度也会一样 Xdeg 将不再与路径一起旋转，元素将保持固定朝向相同的方向。 See the Pen CSS MotionPath by Dan Wilson (@danwilson) on CodePen. 少了点什么东西？这是第一个版本，当然，浏览器制造商和规范作者仍在讨论这一切。在尝试这一过程中，我注意到的最大的一件事就是缺少适应不同屏幕/容器尺寸的路径。 路径只是按照它们的定义出现。当使用SVG时，我们获得灵活性，因为我们在容器上具有不同的坐标系和属性，如 viewBox。使用CSS中定义的运动路径，路径的大小不能被其他属性另外修改或约束。元素上定义的宽度和高度仅适用于元素，而不是其运动路径。您可以使用媒体查询或JavaScript来定义不同条件的不同路径，但是想通过motion属性灵活地设置它们是不可能的事。 回顾和下一节我们将看到规范的方向，但现在尝试这样做是很有趣的，看看它可能提供什么（和不提供什么）。我正在收集我在CodePen上找到的CSS Motion Path演示文稿，而Eric Willigers（Chrome开发团队的相关实现任务的所有者）拥有一个Google Doc的例子。 我们将在下次再次介绍我们所讨论的内容，并且再看几个目前唯一的规范主题。 查看本系列的其余部分： 介绍 第1部分：创建基本动画 第2部分：动画和时间线控制 第3部分：多个动画 第4部分：GroupEffects和SequenceEffects 第5部分：运动路径 总结与回顾 【翻译原文】： http://danielcwilson.com/blog/2015/09/animations-part-5/]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>Web Animations</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web Animations API 入门教程第4部分: GroupEffects & SequenceEffects]]></title>
    <url>%2F2017%2F06%2F27%2FWeb-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects.html</url>
    <content type="text"><![CDATA[Web Animations API 入门教程第4部分: GroupEffects & SequenceEffects这是 Web Animations API 入门教程系列的第4部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与@dancwilson联系。 让我们继续讨论Web动画API中的多个动画，通过讨论今天在polyfill中提供的几个部分来提供分组和排序。 KeyframeEffectsA KeyframeEffect需要三个参数：动画元素(element)，关键帧数组(keyframes)和时间选项(timing options)。这些都是我们以前使用过的参数element.animate()。这个新对象本质上是单个动画的蓝图，当我们讨论分组(group)和队列(sequence)动画的方法时，我们会看到它。它不启动动画，它只是定义动画。 var elem = document.getElementById('toAnimate'); var timings = { duration: 1000, fill: 'both' } var keyframes = [ { opacity: 1 }. { opacity: 0 } ]; var effect = new KeyframeEffect(elem, keyframes, timings); GroupEffects虽然在任何浏览器中都没有实现此功能，甚至在Level 2规范中找不到，但是polyfill提供了一种组合动画并将其一起播放的方法。 GroupEffect（是的，它是未来将集成在Level 2规范）组合一个或多个KeyframeEffects同时播放。 See the Pen Group Effects with WAAPI by Dan Wilson (@danwilson) on CodePen. 一个GroupEffect任务需要一个Effects参数，我们可以传递代表我们多个动画的KeyframeEffect数组。一旦定义，我们可以在准备好的时候在默认时间轴上播放动画组。 var elem = document.getElementById('toAnimate'); var elem2 = document.getElementById('toAnimate2'); var timings = { duration: 1000 } var keyframes = [ { opacity: 1 }. { opacity: 0 } ]; var kEffects = [ new KeyframeEffect(elem, keyframes, timings), new KeyframeEffect(elem2, keyframes, timings) ]; var group = new GroupEffect(kEffects); document.timeline.play(group); SequenceEffects类似于GroupEffect，SequenceEffect允许我们将多个动画（由KeyframeEffects 指定）组合在一起…不是并行播放它们，而是一个接一个地播放它们。您也可以按照polyfill中的定义将GroupEffect和SequenceEffect一起使用（例如具有多个序列的分组）。 See the Pen SequenceEffect with WAAPI by Dan Wilson (@danwilson) on CodePen. 队列提供给你一些我们必须用CSS或者我们在 animations API中看到的东西。我们必须根据早期动画的持续时间或使用 finish 回调来维持延迟。这些方法可能难以维护，或者不会如此精确。 使用先前在GroupEffect代码段中的变量： var sequence = new SequenceEffect(kEffects); document.timeline.play(sequence); 创建动画的备用方法我们以前看过element.animate()创建动画的方式。这是创建动画的快捷方式，立即播放，并获取Animation对象的引用。我们专注于这一点，因为Chrome支持了一段时间了，polyfill也是。Firefox是第一个支持替代方式的：·构造函数。它向我们展示了另一种使用方法KeyframeEffect，而且它在Level 1规范中，所以我们应该很快会看到它的更多应用。 首先提醒一下如何element.animate()工作： var elem = document.getElementById('toAnimate'); var timings = { duration: 1000, fill: 'both' } var keyframes = [ { opacity: 1 }. { opacity: 0 } ]; elem.animate(keyframes, timings); 使用与上述相同的变量，以下是使用Animation构造函数的等价写法： var kEffect = new KeyframeEffect(elem, keyframes, timings); var player = new Animation(kEffect, elem.ownerDocument.timeline); player.play(); 这里的主要区别在于，动画不会立即开始播放，所以在提前创建动画以便稍后播放时，这将非常有用。 回顾和下一节当Level 2规范通过工作草案时，我们应该看到更多关于这些不同效果的定义。本系列中还有两个计划的章节。下一次我们将再次看看未来，还有什么我们可以期待看到。 查看本系列的其余部分： 介绍 第1部分：创建基本动画 第2部分：动画和时间线控制 第3部分：多个动画 第4部分：GroupEffects和SequenceEffects 第5部分：运动路径 总结与回顾 【翻译原文】：http://danielcwilson.com/blog/2015/09/animations-part-4/]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>Web Animations</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web Animations API 入门教程第3部分: 多个Animations对象]]></title>
    <url>%2F2017%2F06%2F27%2FWeb-Animations-API-Tutorial-Part-3-Multiple-Animations.html</url>
    <content type="text"><![CDATA[Web Animations API 入门教程第3部分: 多个Animations对象这是 Web Animations API 入门教程系列的第3部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与@dancwilson联系。 在我们讨论动画和时间线控制之后，让我们来讨论多个动画。 每个元素的多个动画See the Pen Multiple animate calls by Dan Wilson (@danwilson) on CodePen. 在这个例子中，每个矩形都有三个动画应用（涉及到transform，opacity和color）。您可以多次调用元素的animate()方法，类似于允许多个动画的CSS。 使用CSS： #toAnimate { animation: pulse 1s, activate 3000ms, have-fun-with-it 2.5s; } @keyframes pulse { /* ... */ } @keyframes activate { /* ... */ } @keyframes have-fun-with-it { /* ... */ } 使用Web Animations API： var animated = document.getElementById('toAnimate'); var pulseKeyframes, //在这里定义 keyframes. activateKeyframes, haveFunKeyframes; var pulse = animated.animate(pulseKeyframes, 1000); // 第二个数值参数作为持续时间的缩写 var activate = animated.animate(activateKeyframes, 3000); var haveFunWithIt = animated.animate(haveFunKeyframes, 2500); 使用Web Animations API，这将创建三个Animation对象，每个对象可以通过时间轴(timeline)或播放速率(playback rate)进行暂停，播放，完成，取消的操作。 获取 Animations，全部动画对象所以你可以知道一个动画开始播放了，但是当你想在元素上调用animate()时你却还没有捕获到Animation的引用。那要怎么做？ See the Pen Pause All those Random Dots! by Dan Wilson (@danwilson) on CodePen. 该规范允许getAnimations()在文档上的方法。在最新版本的规范中，它直接在document（document.getAnimations()）上，在Firefox 48+上它是这样实现的。然而，对于Chrome 52 和polyfill（如V2.2.0的），则根据该旧规范将其置于新的timeline对象上。 // 如果引用了 polyfill ，你可以这样写 var animations = document.getAnimations ? document.getAnimations() : document.timeline.getAnimations(); // 返回一个数组，包含所有正在进行的（除了已完成的和被取消的）动画 在CodePen示例中，您将看到随机的持续时间，延迟和无限持续时间的变换移动的几个点。“暂停全部”按钮调用getAnimations()并遍历所有, 返回的玩家（每个动画对象）并暂停每一个。 下一节…在下一部分中，我们将看看WAAPI动画可以创建的不同方式（因为它不仅仅是element.animate）。提示：document.timeline会出现更多的体现。 查看本系列的其余部分： 介绍 第1部分：创建基本动画 第2部分：动画和时间线控制 第3部分：多个动画 第4部分：GroupEffects和SequenceEffects 第5部分：运动路径 总结与回顾 【翻译原文】: http://danielcwilson.com/blog/2015/08/animations-part-3/]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>Web Animations</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web Animations API入门教程第2部分：动画和时间线控制]]></title>
    <url>%2F2017%2F06%2F26%2FWeb-Animations-API-Tutorial-Part-2-The-Animation.html</url>
    <content type="text"><![CDATA[Web Animations API入门教程第2部分：动画和时间线控制这是 Web Animations API 入门教程系列的第2部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与@dancwilson联系。 现在我们了解如何使用Web Animations API 创建基本动画，让我们来谈谈状态（states），控制(controls)，回调(callback)和时间轴(timelines)。 Animations 播放状态和控制当你调用时element.animate()，返回一个Animation对象（以前称为AnimationPlayerspec），动画开始播放。要查看动画的当前状态，您可以检查readonly属性playState，该属性将返回五个字符串之一。我们也可以通过调用四种方法之一修改动画的当前状态： var player = element.animate(/* ... */); console.log(player.playState); //"running" player.pause(); //"paused" player.play(); //"running" player.cancel(); //"idle"... 跳到原始状态 player.finish(); //"finished"...跳到结束状态 此外running，paused，idle，和finished播放状态有一个pending状态定义当播放或暂停任务正在等待批准即将发生。 这个“步行圆圈”示例显示六个圆缩放。您可以暂停或播放每个圈子，以查看上述播放状态的一部分。 See the Pen Blob That Walks by Dan Wilson (@danwilson) on CodePen. 播放速率在之前的CodePen示例中，还有一个“2x”按钮，您可以按更改动画的播放速度，将其切换到双倍速度。这是通过读/写playbackRate属性。 var player = element.animate(/* ... */); console.log(player.playbackRate); //1 player.playbackRate = 2; //双倍速度, 也可以使用十进制数字控制它降低速度. 动画完成后的回调使用CSS transitions，当转换结束时，通常会触发一个事件。类似地，Animation允许您指定一个onfinish函数，在动画完成或调用之前讨论过的finish()方法时调用它。请注意，根据规范，无法完成无限次迭代的动画集，也不能完成一个具有playbackRate = 0 的动画集。还有一个oncancel处理程序，以及在Animation完成时使用Promises的写法。 以下示例用于onfinish在动画完成后显示一些统计信息（并且它也很好地切换到下一次关于时间轴的讨论）。 See the Pen Timer Countdown by Dan Wilson (@danwilson) on CodePen. 时间轴每个Animation都公开两个读/写时间相关属性 - currentTime和startTime。现在，我们将重点关注前者。 currentTime返回动画当前的毫秒数。最大值将为延迟时间 +（持续时间迭代次数）（`delay + (duration iterations)`），因此无限次迭代将不具有最大值。 var player = element.animate([ {opacity: 1}, {opacity: 0} ], { duration: 1000, delay: 500, iterations: 3 }); player.onfinish = function() { console.log(player.currentTime); // 3500 }; 播放速率将影响时间轴的持续时间。如果您将播放速度设置为10，则您的最大时间保持不变，但您的时间轴会快10倍。这个概念也在之前的“计时器倒计时”示例中显示。 由于currentTime是可 读/写，我们也可以使用它来跳转到时间轴中的某一点。它也可以让我们同步两个动画，如下例所示。 See the Pen Syncing Timelines - WAAPI by Dan Wilson (@danwilson) on CodePen. 还有一个选项： reverse()你也可以使用reverse()反转一个与之非常相似的动画play()（比如它会有相同的playState），除了它将以相反的方式遍历时间轴。当动画完成时，currentTime将为0。 See the Pen waRKOm by Dan Wilson (@danwilson) on CodePen. 下一节…这包含了很多的信息，但仍然只是熟悉一下WAAPI有哪些可用的。下面我们来看一些更高级的用法。 查看本系列的其余部分： 介绍 第1部分：创建基本动画 第2部分：动画和时间线控制 第3部分：多个动画 第4部分：GroupEffects和SequenceEffects 第5部分：运动路径 总结与回顾 【翻译原文】: http://danielcwilson.com/blog/2015/07/animations-part-2/]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>Web Animations</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web Animations API 入门教程第1部分:创建一个基本的动画]]></title>
    <url>%2F2017%2F06%2F26%2FWeb-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation.html</url>
    <content type="text"><![CDATA[Web Animations API 入门教程第1部分:创建一个基本的动画这是 Web Animations API 入门教程系列的第1部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与@dancwilson联系。 我们之前初步看了下 Web Animations API，但是我们没有得到任何真正的细节，所以现在我们来看看。 WAAPI（Web Animations API, 以下均简称WAAPI）为您提供更多的控制比您可能已经习惯使用的CSS动画，但在我们进入这些演示之前，我们需要设置基本目标：如何通过此API创建基本动画？ 创建关键帧动画如果您熟悉CSS Transitions/ Animations，这将非常熟悉。 var player = document.getElementById('toAnimate').animate([ { transform: 'scale(1)', opacity: 1, offset: 0 }, { transform: 'scale(.5)', opacity: .5, offset: .3 }, { transform: 'scale(.667)', opacity: .667, offset: .7875 }, { transform: 'scale(.6)', opacity: .6, offset: 1 } ], { duration: 700, //毫秒 easing: 'ease-in-out', //'linear', a bezier curve等. delay: 10, //毫秒 iterations: Infinity, //或其他数值 direction: 'alternate', //'normal', 'reverse', 等. fill: 'forwards' //'backwards', 'both', 'none', 'auto' }); 为了对照，这里是一个等效的CSS关键帧动画 @keyframes emphasis { 0% { transform: scale(1); opacity: 1; } 30% { transform: scale(.5); opacity: .5; } 78.75% { transform: scale(.667); opacity: .667; } 100% { transform: scale(.6); opacity: .6; } } #toAnimate { animation: emphasis 700ms ease-in-out 10ms infinite alternate forwards; } 我们将分解这一切，解释每一部会。 var player = document.getElementById('toAnimate').animate() 动画将返回一个 Animation（以前在规范中称为 AnimationPlayer）对象，这将给我们做些有趣的事情，所以你可能想要设置一个变量来捕获这个引用。我们找到我们想要的动画元素（这里简单地使用document.getElementById）并调用该animate函数。此功能是新添加的特性，所以如果您必须要测试它的支持性/存在性，在使用它之前或者引用 polyfill。 该animate函数有两个参数，一个KeyframeEffects和一个AnimationEffectTimingProperties选项的数组。本质上，第一个参数映射到CSS中的内容@keyframes，第二个参数是您在CSS规则中使用的animation-*属性（或animation简写，如我之前的示例）所指定的那样。这里的主要优点是我们可以使用变量或重用以前定义的KeyframeEffects，而使用CSS我们仅限于我们在前面声明的值。 var player = document.getElementById('toAnimate').animate([ { transform: 'scale(1)', opacity: 1 }, { transform: 'scale(.5)', opacity: .5 }, { transform: 'scale(.667)', opacity: .667 }, { transform: 'scale(.6)', opacity: .6 } ]); 对于每一个KeyframeEffect，我们将CSS中的百分比偏移量改为offset从0到1 的十进制值。它是可选的，如果没有指定，它们将均匀分布（因此，如果您有三个，则第一个具有偏移为0，第二个偏移量为.5，第三个偏移量为1）。您还可以指定easing与animation-timing-functionCSS中相同的属性。每个的其他属性KeyframeEffect都是动画的属性。每个属性的值应该符合在JavaScript的element.style中的用法，因此opacity将是一个数字，但transform会期望一个字符串。 var player = document.getElementById('toAnimate').animate([], { duration: 700, //milliseconds easing: 'ease-in-out', //'linear', a bezier curve, etc. delay: 10, //milliseconds iterations: Infinity, //or a number direction: 'alternate', //'normal', 'reverse', etc. fill: 'forwards' //'backwards', 'both', 'none', 'auto' }); 时间属性将映射到CSS动画属性，尽管有时会使用不同的名称。较早的代码示例讨论了主要选项。 以下是使用polyfill的示例（但如果您正在Chrome 36+，Opera 23+或Firefox 48+中查看，则应使用实际的浏览器实现）。第一列灰色块使用WAAPI动画，第二列红色块使用CSS关键帧进行动画。 See the Pen CSS Keyframes v. WAAPI by Dan Wilson (@danwilson) on CodePen. 下一节…现在我们知道如何创建在CSS中熟知的等效动画，我们将开始查看Animation 的 animate 函数返回的对象。这是我们看到真正的功能和改进的地方。 查看本系列的其余部分： 介绍 第1部分：创建基本动画 第2部分：动画和时间线控制 第3部分：多个动画 第4部分：GroupEffects和SequenceEffects 第5部分：运动路径 总结与回顾 【翻译原文】： http://danielcwilson.com/blog/2015/07/animations-part-1/]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>Web Animations</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让我们谈谈 Web Animations API]]></title>
    <url>%2F2017%2F06%2F25%2Fanimations-intro.html</url>
    <content type="text"><![CDATA[这是 Web Animations API 入门教程系列的总结部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与@dancwilson联系。 2014年夏天，Google宣布通过Polymer在网页中展示Material设计…使用polyfill技术支持即将推出的标准Web Animations API。 我没有听说过这个API，但是我很感兴趣，特别是因为它谈到了MotionPath(运动路径)效果。这还没有实现（你会在第5部分发现这是什么），但是它的目标是提供一种组合CSS，JS和SVG的动画方式，让我感兴趣。一年以后，Chrome和Firefox开始实施，polyfill的进步是稳定的，现在是认真看待它的时候了。 但是很少有人在谈论WAAPI！我希望开始一系列突出浏览器（和polyfill）功能的帖子，探索为什么我们想要这个API，并找出细微差别。希望我们也能让更多的人讨论和使用这个API。 什么是Web动画API？我们将通过弄清楚它是什么，以及它正在努力完成的事情来开始这个探索。 动画在过去的十年中已经取得了很好的进展，并提供了很好的CSS支持和新增功能来改进JavaScript。但是，每种动画方法仍然对他们所提供的所有优点都有一些缺陷。 CSS具有用于平滑过渡的硬件加速，并且浏览器内置了支持，但规则在CSS中声明，并且需要跳过JavaScript环节以获得动态更改的值。 requestAnimationFrame有很好的支持，让浏览器在动画时进行优化，但如果还有很多其他JavaScript运行，它仍然可以挂起。它也经常需要更多的数学知识来获得定时。 setInterval被很多开发人员用来做动画，但它是不精确的，可以导致动画卡顿。 jQuery.animate() 被其他一些开发人员推荐制作动画，但往往有性能问题。 诸如Velocity和GreenSock（GSAP）这样的类库可以提高JavaScript的性能，并且在许多情况下已经被测试成为最好的。然而，他们仍然需要维护和加载额外的库。 一般来说，我们喜欢浏览器的支持尽可能多，直接被优化过的方式。现在浏览器有document.querySelector，因为我们看到jQuery提供选择DOM元素的值。理想情况下，我们可以在浏览器级别包装尽可能多的动画控件。这些库可以专注于提供更新的功能，并且可以持续迭代。 Web Animations API尝试这样做。它旨在带来CSS性能的强大，增加了JavaScript的好处和灵活性（以及SVG动画，我们将在以后的一篇文章中讨论），并将其留给浏览器使其运行良好。 让我们通过添加新的东西来解决这个问题！在以前的工作中，我们收到一封电子邮件，表示他们知道我们有太多的地方可以查看公司公告 - 电子邮件，办公室的监视器，Yammer，Google Chat和Intranet / wiki。所以要解决他们宣布的问题，他们正在添加一个博客。 我第一次听到有关Web Animations API 和我听到我公司新增博客的想法一样 - 这只会使事情变得更糟。果然，博客没有集中任何东西，它只是添加了一个地方，我们必须查看新闻，然后不了了之了。 这感觉不一样。 审查规范（第一次我在这个程度上真的做到这一点）显示了对此的关注。这并不意味着取代现有的行为（尽管有些浏览器似乎已经不赞成某些行为），而是将各种方式联合起来，并允许他们进行交互。语法类似于CSS，但添加了变量，控制和完成回调的选项。 下一节…因此，Web Animations API是新的，并且开始实现（目前在Chrome和Firefox中），除了拥有一个polyfill。下次我们实际上会开始看看它为开发者提供了什么…有例子！ 查看本系列的其余部分： 介绍 第1部分：创建基本动画 第2部分：动画和时间线控制 第3部分：多个动画 第4部分：GroupEffects和SequenceEffects 第5部分：运动路径 总结与回顾 【翻译原文】：http://danielcwilson.com/blog/2015/07/animations-intro/]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>Web Animations</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css 动画和 Web Animation API(WAAPI)对比]]></title>
    <url>%2F2017%2F06%2F22%2Fcss-animations-vs-web-animations-api.html</url>
    <content type="text"><![CDATA[css 动画和 Web Animation API(WAAPI)对比有一个JavaScript的动画原生API，称为Web Animation API。我们在这篇文章中称之为WAAPI。MDN有很好的文档，Dan Wilson 有一个伟大的系列文章。 在本文中，我们将比较WAAPI和CSS中完成的动画。 关于浏览器支持的提示尽管现在浏览器的支持很有限，但WAAPI有一个全面而强大的polyfill工具，让它可以在当前的生产环境中使用。 一如既往，您可以检查Can I Use 的浏览器支持数据。然而，这并没有提供非常好的信息来支持WAAPI的所有子功能。这是一个检查器： See the Pen WAAPI Browser Support Test by Dan Wilson (@danwilson) on CodePen. 想要不使用polyfill而体验所有功能，请使用Firefox Nightly。 WAAPI的基础知识如果您曾经使用jQuery.animate()，WAAPI的基本语法应该看起来很熟悉。 var element = document.querySelector('.animate-me'); element.animate(keyframes, 1000); 该animate方法接受两个参数：关键帧和持续时间。与jQuery不同的是，它不仅具有内置在浏览器中的优点，而且性能也更高。 第一个参数，关键帧应该是一个对象数组。每个对象都是我们动画中的一个关键帧。这是一个简单的例子： var keyframes = [ { opacity: 0 }, { opacity: 1 } ]; 第二个参数，持续时间，是我们想要动画持续多久。在上面的例子中是1000毫秒。我们来看一个更令人兴奋的例子。 用WAAPI重新创建animista CSS动画这里有一些CSS代码，从非常棒的animista中吸取了一些称为“幻灯片模糊的”入场动画的东西。看起来很可爱。 以下是CSS中的关键帧： 0% { transform: translateY(-1000px) scaleY(2.5) scaleX(.2); transform-origin: 50% 0; filter: blur(40px); opacity: 0; } 100% { transform: translateY(0) scaleY(1) scaleX(1); transform-origin: 50% 50%; filter: blur(0); opacity: 1; } WAAPI中的代码相同： var keyframes = [ { transform: 'translateY(-1000px) scaleY(2.5) scaleX(.2)', transformOrigin: '50% 0', filter: 'blur(40px)', opacity: 0 }, { transform: 'translateY(0) scaleY(1) scaleX(1)', transformOrigin: '50% 50%', filter: 'blur(0)', opacity: 1 } ]; 我们已经看到，将关键帧应用到要运动的任何元素是多么容易的事： element.animate(keyframes, 700); 为了简单起见，我只指定了持续时间。但是，我们可以使用这个第二个参数来传递更多的选项。至少我们也应该指定一个缓动函数。以下是可用选项的完整列表，其中包含一些示例值： var options = { iterations: Infinity, iterationStart: 0, delay: 0, endDelay: 0, direction: 'alternate', duration: 700, fill: 'forwards', easing: 'ease-out', } element.animate(keyframes, options); 有了这些选项，我们的动画将从头开始，没有任何延迟，永远循环在向前和向后播放。 See the Pen motion blur waapi circle by CSS GRID (@cssgrid) on CodePen. 令人烦恼的是，对于我们熟悉CSS动画的人来说，一些术语与我们习惯的不同。虽然在积极的一面看，有些事情写起来更快一点！ 这里用easing而不是animation-timing-function 使用iterations而不是animation-iteration-count。如果我们希望动画永远重复，用Infinity而不是infinite。有点混乱，Infinity不是引用。Infinity是一个JavaScript关键字，而其他值是字符串。 我们使用毫秒而不是秒，对于之前编写过许多JavaScript的人来说，这应该是熟悉的。（您可以在CSS动画中使用毫秒数，但很少有人使用。） 我们来仔细看看一个选项：iterationStart。 当我第一次碰到iterationStart, 我被难住了。你为什么要指定迭代的开始，而不仅仅是减少迭代次数？当您使用十进制数时，此选项非常有用。例如，您可以将其设置为 .5，动画将开始一半。要做一整个动画需要两半，所以如果你的迭代次数设置为1，并且你的iterationStart设置为 .5，动画将从一半到动画结束播放，然后从动画开头开始，结束于中间！ 值得注意的是，您也可以将迭代次数设置为小于1。例如： var option = { iterations: .5, iterationStart: .5 } 这将从中间到最后播放动画。 endDelay：endDelay如果要将多个动画串在一起，但是希望在一个动画的结尾和任何后续动画的开始之间存在差距。这是一个有用的视频，Patrick Brosset 的解释。 缓动缓动是任何动画中最重要的元素之一。WAAPI为我们提供了两种不同的方式设置缓动函数 - 在我们的关键帧阵列或我们的选项对象内。 在CSS中，如果你应用了，animation-timing-function: ease-in-out你可能会假设你的动画的开始会ease in，动画的结束将会ease out。实际上，这些缓动函数应用在关键帧之间，而不是整个动画。这可以对动画的感觉进行细粒度的控制。WAAPI还提供这种能力。 var keyframes = [ { opacity: 0, easing: 'ease-in' }, { opacity: 0.5, easing: 'ease-out' }, { opacity: 1 } ] 值得注意的是，在CSS和WAAPI中，您不应该传入最后一帧的缓动值，因为这将不起作用。这是很多人犯的错误。 有时候，在整个动画中添加缓动效果更为直观。这在CSS是不可能的，但现在可以实现与WAAPI。 var options = { duration: 1000, easing: 'ease-in-out', } 你可以看到这两种缓动在CodePen上的区别： See the Pen Same animation, different easing by CSS GRID (@cssgrid) on CodePen. ease vs linear值得注意的是CSS动画和WAAPI之间的另一个区别：CSS ease的默认值是ease,WAAPI的默认值linear。 Ease实际上是一个版本，ease-in-out是一个非常好的选择，如果你感到懒惰。同时，linear 是沉闷的和无生机的 - 一致的速度看起来机械和不自然。它被选为默认值，可能因为它是最中立的选项。然而，在WAAPI中使用时，使用缓动比在CSS更重要，以免您的动画看起来很乏味和机械地。 性能WAAPI提供与CSS动画相同的性能改进，尽管这并不意味着平滑的动画是不可避免的。 我希望这个API的性能优化意味着我们可以避免使用will-change和完全hack translateZ - 最终可能。但是，至少在目前的浏览器实现中，这些属性在处理闪烁问题（jank issue）方面仍然是有帮助和必要的。 但是，至少如果您的动画有延迟，则无需担心使用will-change。网络动画规范的主要作者对“Animation for Work Slack community”提出了一些有趣的建议，希望他不介意我在这里重复： 如果您有一个积极的延迟，您不需要will-change因为浏览器将在延迟开始时进行分层，当动画启动时，它将准备就绪。 WAAPI对战CSS动画？WAAPI为我们提供了一个在JavaScript中实现css中的语法。然而，他们不应该被视为对手。如果我们决定坚持使用CSS进行animations和transitions，那么我们可以与WAAPI进行动画交互。 Animation 对象该.animate()方法不仅仅是动画我们的元素，它也返回一些东西。 如果我们看看控制台中的返回值，我们将看到它的一个动画对象。这为我们提供了各种各样的功能，其中一些是非常不言自明的myAnimation.pause()。通过更改animation-play-state属性，我们可以通过CSS动画实现类似的结果，但WAAPI语法比稍微简单element.style.animationPlayState = "paused"。我们也有权力轻松地扭转我们的动画myAnimation.reverse()，再次，animation-direction与使用我们的脚本更改CSS属性相比，稍微有点改进。 然而，到目前为止，@keyframe用JavaScript进行操作并不是世界上最简单的事情。即使像重新启动动画一样简单，就像Chris Coyier 先前写过的那样，这个技巧也有一些技巧。使用WAAPI，我们可以简单地使用myAnimation.play()，它从一开始就重播动画，如果它已经完成，或者如果我们暂停播放，则从中间迭代继续播放动画。 我们甚至可以轻松地改变动画的速度。 myAnimation.playbackRate = 2; // speed it up myAnimation.playbackRate = .4; // use a number less than one to slow it down getAnimations（）此方法将返回任何动画对象的数组，以便我们使用WAAPI定义的任何动画以及 任何CSS transitions或animations。 element.getAnimations() // returns any animations or transitions applied to our element using CSS or WAAPI 如果您感觉使用CSS来定义和应用您的动画比较顺手，getAnimations()可以使用API​​与@keyframes 结合使用。您可以继续使用CSS进行大部分动画工作，并在需要API时获得API的优势。让我们看看这是多么简单。 即使一个DOM元素只有一个动画应用到它，getAnimations()也将始终返回一个数组。我们来抓住那个单一的动画对象来处理。 var h2 = document.querySelector("h2"); var myCSSAnimation = h2.getAnimations()[0]; 现在我们可以在我们的CSS动画中使用web animation API :) myCSSAnimation.playbackRate = 4; myCSSAnimation.reverse(); Promise和事件我们已经有多种通过CSS触发的事件，我们可以在我们的JavaScript代码利用的有：animationstart，animationend，animationiteration和transitionend。我经常需要收听animations或transitions的结束，以便从DOM中删除应用于它的元素。 在WAAPI 中使用animationend或transitionend为此目的相当于再次使用动画对象： myAnimation.onfinish = function() { element.remove(); } WAAPI为我们提供了事件和Promise的选择。我们的动画的.finished属性对象将在动画结束时返回一个resolve 的 Promise。以下是上面的例子，就像使用Promise一样： myAnimation.finished.then(() => element.remove()) 我们来看看Mozilla开发人员网络中的一个稍微有点省略的例子。Promise.all接收一个Promise数组，一旦所有这些Promise得到解决，才会运行我们的回调函数。我们已经看到，element.getAnimations()返回一个动画对象数组。我们可以将数组中的所有动画对象映射到每个动画对象.finished上，为我们提供所需的Promise数组。 在这个例子中，只有在页面上的所有动画完成后，我们的函数才能运行。 Promise.all(document.getAnimations().map(animation => animation.finished)).then(function() { // do something cool }); 未来本文中提到的功能只是开始。目前的规范和实践看起来是一件伟大的事情的开始。 「翻譯原文」：https://css-tricks.com/css-animations-vs-web-animations-api/?utm_source=frontendfocus]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>Web Animations</tag>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack3官方正式发布,亮点:作用域提升，“魔法注释”，以及更多新特性！]]></title>
    <url>%2F2017%2F06%2F21%2Fwebpack3-publish-scope-hoisting-magic-comments-and-more.html</url>
    <content type="text"><![CDATA[作用域提升，“魔法注释”，以及更多新特性！原文 在我们发布了 webpack v2 之后，我们曾向社区做了一些承诺。 我们承诺，我们将提供用户投票的功能。 此外，我们承诺我们的发布周期会 更快，更稳定。 这次没有 beta 版本，完全向下兼容。我们承诺让你们、让 webpack 成长的社区更轻松的使用。webpack 团队自豪地宣布，今天我们已经发布了 webpack 3.0.0！ 现在就可以下载或升级！ npm install webpack@3.0.0 --save-dev 或者使用 yarn add webpack@3.0.0 --dev 从 webpack 2 迁移到 3，只需要执行升级命令，在使用上没有任何差别。我们将这次升级标记为版本的重大升级，是因为内部的突破性变化可能会影响某些插件的使用。 到目前为止，98%的升级的用户都没有遇到任何不兼容！ 有哪些新特性?像上文提到的一样，我们发布了一些由用户投票选出的功能，感谢 Github，赞助商和我们的支持者，有了他们我们才能做出每一个改进。😍 🔬作用域提升（Scope Hoisting）🔬作用域提升是 webpack 3 的重点功能。之前 webpack 在打包时，您的 bundle 中的每个模块都将被包装在单独的函数闭包中。这些闭包会使您的 JavaScript 在浏览器中执行速度更慢。相比之下，像 Closure Compiler 和 RollupJS 这样的工具可以将所有模块包装在一个大的闭包内，从而使您的代码在浏览器中具有更快的执行速度。 70K => 37K (gzip!) savings on our main bundle using #webpack 3 RC.2 + ModuleConcatenationPlugin 😲 🔥 Awesome work @TheLarkInn @wSokra et al! pic.twitter.com/zVfQoivT9d— Jeremy Gayed 🤓 (@tizmagik) June 17, 2017 而现在，使用 webpack 3，您现在可以 在配置中添加下面的插件以启用作用域提升： module.exports = { plugins: [ new webpack.optimize.ModuleConcatenationPlugin() ] }; 作用域提升是基于 ECMAScript Module 语法实现的一个特征。通过这个，webpack 可以根据你正在使用什么样的模块和一些其他条件来回退到正常的捆绑。 为了了解什么触发了这些回退，我们添加了一个 --display-optimization-bailoutcli 标志，它将告诉你是什么导致的回退。 Total evaluation script time went from 2.52s to 2.06s, first meaningful paint from 3.43s to 2.70s and all initial event fired 20% earlier— Jeremias Menichelli (@jeremenichelli) June 18, 2017 同时，由于作用域提升会移除模块外的函数包装，你可能会看到一些小的体积改进。然而，更显着的改进是JavaScript在浏览器中加载的速度。 如果您在比较使用之前和之后时发现加载速度取得了非常棒的改进，请随时回复一些数据，我们将很荣幸分享！ 🔮 魔法注释 ”Magic Comments” 🔮当我们在webpack 2中引入使用动态导入语法（import()）时，用户表示，他们不能像使用 require.ensure 一样创建命名 chunk。我们现在介绍由社区创建的“魔法注释”，它可以传递 chunk 名称，还有更多功能，例如可以添加更多的内联注释到 import() 语句中。 import(/* webpackChunkName: "my-chunk-name" */ 'module'); 通过使用注释，我们能够在使用动态导入语法的同时，对代码块进行命名。 尽管这是我们在 v2.4 和 v2.6 中发布的技术特性，但在 v3 中，我们修复了这些功能的一些错误，使其变得更稳定。 同时，现在允许动态导入语法具有与 require.ensure 相同的灵活性。 TIL webpack /chunkName/ comments aren't just for nicer filenames—also great for organizing your chunks. Even interops w/ commonsChunk! pic.twitter.com/wjdT9y6oTE— Adam Rackis (@AdamRackis) June 7, 2017 要了解更多信息，请参阅我们最新文档的代码分割部分，文档高亮了这些新功能！ 😍 接下来是什么？😍我们有很多功能和增强功能想要推出！但我们需要了解用户需求的优先级。所以访问我们的投票页面，并提出你想看到的功能！ 这些是我们希望带给您的一些功能： 更好地构建缓存 更快的初始构建和增量构建 更好的TypeScript体验 改进长期缓存 WASM模块支持 改善用户体验 🙇 致谢 🙇感谢我们所有的用户，贡献者，文档作者，博客，赞助商，支持者和维护者。是他们都帮助我们确保 webpack 在未来几年成功。 为此，我们感谢所有人。webpack 发展到现在与你的支持密不可分，我们迫不及待地想要与你分享未来 webpack 的新进展！]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>前端构建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flow和TypeScript之间的区别和优劣]]></title>
    <url>%2F2017%2F06%2F14%2Fcompare-with-Flow-and-TypeScript.html</url>
    <content type="text"><![CDATA[Flow和TypeScript之间的区别和优劣采用Flow＆TypeScript, 两者上手流程之间的比较。 让我们想象一下我们想要采用一种类型检查器的场景… 最近我们已经注意到了我们的应用程序中的很多NaN的出现。我们搜索源代码并找到以下代码： // math.js function square(n) { return n * n; } square("oops"); 我们对自己叹了口气，也许决定添加一个类型检查器。我们退后一步，查看我们的选项： Flow 或 TypeScript。 这两个工具都有相当简单的方法给逐个文件应用： Flow: // @flow 向文件顶部添加注释 TypeScript：将扩展名更改为.js扩展.ts 名 但是让我们比较一下这里面发生了什么。 采用TypeScript要采用TypeScript，我们首先重命名math.js为 math.ts： // math.ts function square(n) { return n * n; } square("oops"); 现在我们将运行typescript： (no errors) 没有错误，是因为TypeScript要求我们给函数键入注释，然后才会根据注释检查类型。如下所示： function square(n: number): number { return n * n; } square("oops"); 如果没有这些类型，TypeScript将根据您的配置执行下面两件事情之一： 隐含地将每个未知类型转换为any。这种任何类型将让您退出所有类型检查。 或者如果您使用了--noImplicitAny选项，它会为任何未知类型抛出错误，指明需要添加类型注释。 这意味着TypeScript 覆盖的代码量与您所写的类型相关。写入类型时，类型coverage将线性上升。 类型覆盖（type coverage）在我们进一步讲解之前，我应该解释一下什么是类型覆盖。 未有类型覆盖的代码用红色显示 如果你看到你的代码中的值和表达式，并问类型检查器“你知道这是什么类型吗”。 如果类型检查器知道它类型，则覆盖该值或表达式。如果类型检查器不知道类型，那么它没有被覆盖。 您希望您的程序尽可能多地提供类型覆盖，因为这样可以在更多地方抛出错误时提前告诉您。 没有类型覆盖，类型检查器什么都不是。 采用Flow// @flow function square(n) { return n * n; } square("oops"); 然后我们将运行Flow并查看结果： function square(n) { return n * n; ^ ^ Error (x2) } square("oops"); Error (x2) string. The operand of an arithmetic operation must be a number. 紧接着就抛出了类型错误，告诉我们代码出了问题。 Flow 只需要我们键入文件和外部模块的导出。可以推测出其他一切。 这使得类型覆盖率快得多。只需几种类型，您可以快速获取具有非常高类型覆盖率的文件。 根据我的经验，我可以在短短几分钟内将文件覆盖约70-90％。 这是一个非常科学的差异图： 这不是我一家之言，你可以自己尝试一下，看看几种类型的区别。 要查看Flow中文件的类型覆盖，可以运行： flow coverage path/to/file.js --color 您还可以使用 流量报告 来帮助您。 注意：我没有注意到TypeScript 有任何的类型报告工具（如果您知道一个，请给我发送一个链接）。但是，您可以测试代码是否覆盖，以确定当您出现错误时是否会报告错误。 这个的工作原理是什么这两种工具具有不同行为的原因归结于其架构之间的区别。 TypeScript体系结构：AST导向TypeScript将遍历您的程序并构建已知类型的表。当它发现值和表达式时，它会立即为其分配类型。当TypeScript发现一个未知的类型时，它必须立即作出决定，这意味着将其分配给any或抛出错误。 Flow 架构：图形导向Flow 将建立一个你所有的值和表达式及其彼此之间的关系的图表。然后，它将开始为每个值和表达式分配类型。如果它找到一个未知的类型，它将使它成为一个“开放”类型，稍后再回来判断。 一旦Flow具有您的程序的完整蓝图，它将开始连接所有点，从一个值连接到另一个值地跟踪类型。打开类型接受流入它们的所有值的类型 - 生成的类型称为 “推断类型”。 你可以看这个是怎么回事。来看看我们在之前的类型错误： function square(n) { return n * n; ^ ^ Error (x2) } square("oops"); Error (x2) string. The operand of an arithmetic operation must be a number. 注意错误是指向n * n而不是 square("oops")。因为我们没有写入一个类型为n的 “oops”字符串流入它，并且Flow开始检查n，就好像它是一个字符串。 添加类型注释我们可以看到错误点移动了： function square(n: number) { return n * n; } square("oops"); ^ Error Error: string. This type is incompatible with the expected param type of number. 这提出了一个重要的一点：Flow可以在任何地方自动推断类型并不意味着你不应该添加类型注释你的代码。 结论TypeScript和Flow都有非常好的上手过程。一个个文件地尝试是一个很好的经历。 但是，如果使用Flow，你就会有更高以及更快的覆盖类型，你就可以安心睡觉。 使用Flow，您可以添加类型以使错误更友好，而不仅只是发现它们。 本文译自： adopting flow and typescript]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>Flow</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用RXJS组合、过滤和映射数据流的值]]></title>
    <url>%2F2017%2F06%2F05%2Fuse-RXJS-compose-filter-and-map-stream.html</url>
    <content type="text"><![CDATA[使用RXJS组合、过滤和映射数据流的值查询可观测序列在事件桥接 一文中，我们将现有的DOM和Node.js事件转换成可观察的序列以订阅它们。在本主题中，我们将把可观察序列的父级class视为IObservable对象，其中Rx组件提供通用LINQ操作符来操作这些对象。大多数操作符获取可观察的序列并对其执行一些逻辑并输出另一个可观测序列。另外，从代码示例可以看出，甚至可以在源序列上使用多个运算符，最终将结果序列调整到您的确切需求。 本文翻译在： RXJS中文文档 使用不同的运算符我们已经在以前的主题中使用create和range运算符来创建和返回简单的序列。我们还使用fromEvent和fromEventPattern运算符将现有事件转换成可观察的序列。在本主题中，我们将使用其他Observable类型的运算符，以便可以过滤，分组和转换数据。这些运算符将可观察到的序列作为输入，并生成输出另一个可观察序列。 组合不同序列在本节中，我们会研究将各种可观察序列组合成单个可观察序列的操作符。请注意，当我们组合序列时，数据不会被转换。在以下示例中，我们使用Concat运算符将两个序列组合成一个序列并订阅它。为了说明的目的，我们将使用非常简单的range(x, y)运算符创建一个从x开始的整数序列，然后产生y个序列数字。 var source1 = Rx.Observable.range(1, 3); var source2 = Rx.Observable.range(1, 3); source1.concat(source2) .subscribe(console.log.bind(console)); // => 1 // => 2 // => 3 // => 1 // => 2 // => 3 注意，结果序列是1,2,3,1,2,3。这是因为当您使用concat运算符时，第二个序列（source2）将在第一个序列（source1）完成推送其所有值之后才会激活。只有在source1完成之后，source2才会将值推送到最后的序列。然后，订阅者将从得到的序列中获取所有值。 与merge 操作符进行比较。如果运行以下示例代码，您将获得1,1,2,2,3,3。这是因为两个序列同时处于活动状态，并且值在数据源中发生时被推出。结果序列仅在最后一个数据源完成推送值时完成。 var source1 = Rx.Observable.range(1, 3); var source2 = Rx.Observable.range(1, 3); source1.merge(source2) .subscribe(console.log.bind(console)); // => 1 // => 1 // => 2 // => 2 // => 3 // => 3 catch 操作符可以进行另一个比较。在这种情况下，如果source1完成没有任何错误，那么source2将不会启动。因此，如果运行以下示例代码，则获得1,2,3因为source2（产生4,5,6））被忽略。 var source1 = Rx.Observable.range(1, 3); var source2 = Rx.Observable.range(4, 3); source1.catch(source2) .subscribe(console.log.bind(console)); // => 1 // => 2 // => 3 最后，我们来看看onErrorResumeNext。即使由于错误导致source1无法完成，该操作符也将移动到source2。在以下示例中，即使source1表示通过使用throw运算符终止异常的序列，用户将接收source2发布的值（1,2,3）。因此，如果您预期到任何一个源序列产生任何错误，那么使用它onErrorResumeNext来保证用户仍然会收到一些值是更安全的。 var source1 = Rx.Observable.throw(new Error('An error has occurred.')); var source2 = Rx.Observable.range(1, 3); source1.onErrorResumeNext(source2) .subscribe(console.log.bind(console)); // => 1 // => 2 // => 3 映射select或 map 操作符将可观察到的一个序列的每个元素转换成另一种形式。 在下面的示例中，我们将一系列字符串映射到一系列表示长度的整数中。 var array = ['Reactive', 'Extensions', 'RxJS']; var seqString = Rx.Observable.from(array); var seqNum = seqString.map(x => x.length); seqNum .subscribe(console.log.bind(console)); // => 8 // => 10 // => 4 在以下示例中，我们在“桥接现有事件”主题中看到的事件转换示例的扩展，我们使用select或map运算符将事件参数投影到x和y点。这样，我们将鼠标移动事件序列转换为可以进一步解析和操作的数据类型，如下一个“过滤”部分所示。 var move = Rx.Observable.fromEvent(document, 'mousemove'); var points = move.map(e => ({x: e.clientX, y: e.clientY })); points.subscribe( pos => console.log('Mouse at point ' + pos.x + ', ' + pos.y)); 最后，我们来看看selectMany or flatMap运算符。selectMany或flatMap操作符具有许多重载，其中一个就是需要选择器函数作为参数。这个选择器函数是由数据源推出的每个值去调用的。对于每一个值，选择器将其映射成一个迷你的可观察序列。最后，selectMany或者flatMap操作符将所有这些迷你序列扁平化成单个结果序列，然后将其推送到用户。 在数据源和由选择器函数产生的所有迷你可观察序列都已经完成之后，源序列返回selectMany或flatMap发布的onCompleted。当发生源数据流中的错误时触发onError，当一个异常被选择函数抛出，或者当在任何迷你观察序列的发生了错误。 在下面的例子中，我们首先创建一个数据源序列，每5秒产生一个整数，并决定使用生成的前两个值（使用take运算符）。然后，我们使用selectMany或者flatMap对另一个序列{100,101,102}这些整数进行映射。通过这样做，产生两个迷你观察序列{100,101,102}和{100,101,102}。它们最终平坦化成{100,101,102,100,101,102}的单个整数流，并被推送到观察者。 var source1 = Rx.Observable.interval(5000).take(2); var proj = Rx.Observable.range(100, 3); var resultSeq = source1.flatMap(proj); var subscription = resultSeq.subscribe( x => console.log('onNext: %s', x), e => console.log('onError: %s', e.message), () => console.log('onCompleted')); // => onNext: 100 // => onNext: 101 // => onNext: 102 // => onNext: 100 // => onNext: 101 // => onNext: 102 // => onCompleted 过滤在下面的例子中，我们使用generate 运算符创建一个简单的可观察数字序列。该generate操作符有几个版本，包括有相对和绝对时间调度。在我们的示例中，它需要初始状态（在我们的示例中为0），一个条件函数终止（少于10次），迭代器（+1），结果选择器（当前值的平方函数））和打印只使用小于5的那些使用filter或where运算符。 var seq = Rx.Observable.generate( 0, i => i &lt; 10, i => i + 1, i => i * i); var source = seq.filter(n => n &lt; 5); var subscription = source.subscribe( x => console.log('onNext: %s', x), e => console.log('onError: %s', e.message), () => console.log('onCompleted')); // => onNext: 0 // => onNext: 1 // => onNext: 4 // => onCompleted 以下示例是本主题前面已经看到的映射示例的扩展。在该示例中，我们使用select或map运算符将事件参数投影到具有x和y的点。在下面的例子中，我们使用filter或where和select或map操作符只挑选那些鼠标移动，我们感兴趣的是，在这种情况下，我们鼠标移动过滤，以找出在第一平分线（其中x和y坐标是相等的）。 var move = Rx.Observable.fromEvent(document, 'mousemove'); var points = move.map(e => ({ x: e.clientX, y: e.clientY })); var overfirstbisector = points.filter(pos => pos.x === pos.y); var movesub = overfirstbisector.subscribe(pos => console.log('mouse at ' + pos.x + ', ' pos.y)); 基于时间的操作您可以使用缓冲区运算符执行基于时间的操作。 缓冲可观察序列意味着可观测序列的值基于指定的时间段或计数阈值被放入缓冲区。这在您预期有大量数据被序列推出的情况下特别有用，并且订阅者没有资源来处理这些值。通过基于时间或计数缓冲结果，并且只有在超过条件时才返回值序列（或者源序列完成时），用户可以按照自己的速度处理OnNext调用。 在下面的例子中，我们首先创建一个以每秒为时间单位的简单的整数序列。然后我们使用bufferWithCount运算符，并指定每个缓冲区将保存序列中的5个项目。在onNext当缓冲区已满被调用。然后我们使用缓冲区的总和Array.reduce。缓冲区自动刷新，另一个循环开始。打印输出将为10,35,60 …，其中10 = 0 + 1 + 2 + 3 + 4,35 = 5 + 6 + 7 + 8 + 9等。 var seq = Rx.Observable.interval(1000); var bufSeq = seq.bufferWithCount(5); bufSeq .map(arr => arr.reduce((acc, x) => acc + x, 0)) .subscribe(console.log.bind(console)); // => 10 // => 35 // => 60 ... 我们还可以创建一个指定时间跨度（以毫秒为单位）的缓冲区。在以下示例中，缓冲区将保存累积3秒钟的项目。打印输出将为3,12,21 …其中3 = 0 + 1 + 2,12 = 3 + 4 + 5，依此类推。 var seq = Rx.Observable.interval(1000); var bufSeq = seq.bufferWithTime(3000); bufSeq .map(arr => arr.reduce((acc, x) => acc + x, 0)) .subscribe(console.log.bind(console)); 请注意，如果您使用任何一个buffer*或window*运算符，则必须确保序列不为空，然后再过滤。 按类别操作按类别划分的操作符主题列出了按类别实施的Observable的所有主要操作符; 具体来说：创建，转换，合并，功能，数学，时间，异常，杂项，选择和原值。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>RxJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何调试Node.js|使用谷歌chrome浏览器调试Node.js]]></title>
    <url>%2F2017%2F06%2F02%2Fdebugging-Node-js-with-google-chrome.html</url>
    <content type="text"><![CDATA[如何调试Node.js|使用谷歌chrome浏览器调试Node.js如何调试 Node.js, 还在使用 console.log 来调试 Node.js 吗，可以像调试前端页面一样调试 Node.js! 调试是从软件应用程序中识别和删除错误的任务，而不仅仅是打印代码中的值。本文介绍如何使用最新的Google Chrome DevTools高效地调试Node.js程序。 为什么console.log不是最好的选择？使用console.log来调试你的代码，通常你会无限重复地做 “停止你的应用程序，添加一个console.log，并再次启动你的应用程序” 这样的操作。除了减缓您的应用程序的开发外，它还使您的书写变得脏乱并创建不必要的代码。最后，尝试注销变量以及其他可能的日志记录操作的噪点时，可能会在尝试找到正在调试的值时使调试变得困难。 调试工具调试工具为用户提供的是几个重要的功能console.log无法提供。特别是，它们允许您在代码中的特定点暂停执行应用程序，并在程序仍在运行时检查和修改变量的值。 设置Chrome for Node.js调试使用Chrome 57+，Node.js调试功能是默认启用的，不需要像以前的版本那样从“实验功能”面板手动启用它。 如果您还没有完成，请将Google Chrome更新到最新版本，并确保使用Node.js 6.4+。 要开始调试，请使用 - inspect标志运行Node.js应用程序。 $ node --inspect &lt;your_file> .js 接下来，忽略从终端中显示的“chrome-devtools://”开头的URL ，而是在Google Chrome中打开“ about:inspect ”。 最后点击“ Open dedicated DevTools for Node” 开始调试应用程序的代码。 此外，关于调试Node.js App的官方文档还提供了所有其他检查器工具和客户端选项的详细列表。 Chrome DevTools的应用要结束本文，我想说明一下Chrome DevTools在以下Express应用程序中的应用。 'use strict' const express = require('express') const app = express() const PORT = process.env.PORT || 3000 function capitalize (str) { const firstLetter = str.charAt(0) // we can check what's inside here return `${firstLetter.toUpperCase()}${str.slice(1)}` } app.get('/:name?', (req, res) => { const name = req.params.name ? capitalize(req.params.name) : 'World' res.send(`Hello ${name}!`) }) app.listen(PORT, () => console.log(`App listening on *:${PORT}`)) 让我们从运行- inspect标志，并打开专用DevTools for Node如前所述。 此时，您将可以访问您可能已经熟悉的所有功能：断点(breakpoints)，压缩代码的源映射(source map for transpiled code)，堆快照检查(heap snapshot inspection)，分配分析(allocation profiling)，JavaScript值热插拔(JavaScript values hot-swapping)等。 具体来说，如下图所示，您可以插入断点来停止执行程序，检查和“热交换”变量的值。 使用Chrome作为调试工具的另外一件好事是您可以使用相同的界面🚀调试前端和后端JavaScript代码。 译文：Debugging Node.js with Google Chrome]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>debug</tag>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RXJS我该选用哪个操作符之-创建篇]]></title>
    <url>%2F2017%2F06%2F01%2FRXJS-should-i-choose-operator-of-creating.html</url>
    <content type="text"><![CDATA[RXJS该怎么上手？这么多操作符该用哪个？RXJS比较强大，操作符众多，想熟悉需要比较长时间的运用，所以大部分新手都比较疑惑应该使用哪些操作符去实现自己的数据流的操作。 更多详情请翻阅 RXJS中文翻译文档 我该选用哪个操作符? - 创建操作符使用此页面查找Observable符合您需求的类型创建操作： 静态方法 我想创建一个新的序列 使用自定义逻辑 Observable.create 像一个for循环 Observable.generate 并随时间发射值 Observable.generateWithRelativeTime Observable.generateWithAbsoluteTime 它返回一个值 Observable.return/just 多次 Observable.repeat 这会抛出错误 Observable.throw 完成了 Observable.empty 从来没有做任何事情 Observable.never 从事件 Observable.fromEvent 它使用自定义函数来添加和删除事件处理程序 Observable.fromEventPattern 来自一个ES6 Promise Observable.fromPromise 它可迭代 覆盖到数组中的值 Observable.fromArray 对象键/值对 Observable.pairs 异步元素 Observable.for 数值范围内的值 Observable.range 来自一个可迭代的数组或类似数组的对象的值 Observable.from 来自参数 Observable.of 根据定时器发出值 Observable.interval 具有可选的初始延迟 Observable.timer 不传参调用函数 在特定的调度程序 Observable.start 异步 Observable.startAsync 取决于订阅时 基于布尔条件 Observable.if f从一组预先设定的序列 Observable.case 使用自定义逻辑 Observable.defer 它取决于资源 Observable.using 我想包装一个函数 并产生一个序列的结果 Observable.toAsync 它接受回调 Observable.fromCallback 它接受Node.js回调 Observable.fromNodeCallback 我想结合多个序列 并且仅从产生值的序列中接收值 Observable.amb 所有人都已经完成通知 Observable.forkJoin 并输出所有这些值 Observable.merge 为了 不改变时重复使用最新值 Observable.combineLatest 每个值只使用一次 Observable.zip 通过订阅每个序列为了 当前一个序列完成时 Observable.concat 当另一个序列抛出错误时 Observable.catch 不管先前的序列是完成还是抛出错误 Observable.onErrorResumeNext 通过响应不同的值组合（连接微积分） Observable.when]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>RxJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RXJS我该选用哪个操作符之-实例操作符篇]]></title>
    <url>%2F2017%2F06%2F01%2FRXJS-should-i-choose-operator-of-instance.html</url>
    <content type="text"><![CDATA[RXJS比较强大，操作符众多，想熟悉需要比较长时间的运用，所以大部分新手都比较疑惑应该使用哪些操作符去实现自己的数据流的操作。 更多详情请翻阅 RXJS中文翻译文档 我该选用哪个操作符? - 实例操作符使用此页面通过类型查找Observable 适合您需要的实例运算符： 实例操作符 使用现有的序列 我想改变每个值 map/select 我想从每个值拉一个属性 pluck 我想在不影响值的情况下被通知值 do/tap doOnNext/tapOnNext doOnError/tapOnError doOnCompleted/tapOnCompleted 我想包含值 基于自定义逻辑 filter/where 从序列开头 take 基于自定义逻辑 takeWhile 从序列的末尾 takeLast 直到另一个序列发射一个值或完成 takeUntil 我想忽略值 全部 ignoreElements 从序列的开头 skip 基于自定义逻辑 skipWhile 从序列的末尾 skipLast 直到另一个序列发出一个值 skipUntil 与以前的值相同 distinctUntilChanged 这（触发）太频繁 throttle 我想计算 总和 这些值的 sum 平均值 average 使用自定义逻辑 并且只输出最终值 aggregate reduce 并在计算出值时输出（每一步的）值 scan 我想用元数据包装它的消息 描述每个消息 materialize 包括从最后一个价值以来的时间 timeInterval 包括时间戳 timestamp 经过一段时间的不活动 我想抛出一个错误 timeout 我想切换到另一个序列 timeout 我想确保只有一个值 并且如果存在多于或少于一个值则抛出错误 single 并且如果没有值，则使用默认值 singleOrDefault 我只想取第一个值 并且如果没有值，则抛出错误 first 并且如果没有值，则使用默认值 firstOrDefault 在一段时间内 sample 我只想取最后的值 如果没有值，则报错 last 并且如果没有值，则使用默认值 lastOrDefault 我想知道它包含多少值 count 我想知道它是否包含一个指定的值 contains 我想知道条件是否满足 只需要任一值满足 any/some 需要所有值都满足 all/every 我想把消息延迟一段特定的时间 delay 基于自定义逻辑 delayWithSelector 我想给值分组 直到序列完成 toArray toMap toSet 使用自定义逻辑 作为数组 buffer 作为序列 window 根据特定大小分批 作为数组 bufferWithCount 作为序列 windowWithCount 基于时间 作为数组 bufferWithTime 作为序列 windowWithTime 基于时间或计数，以先发生者为准 作为数组 bufferWithTimeOrCount 作为序列 windowWithTimeOrCount 基于一个指定的key 直到序列完成 groupBy 并控制每组的生命周期 groupByUntil 我想为每个值开始一个新的序列 并且并行地从所有序列中发出值 flatMap/selectMany 并按顺序从每个序列中输出值 concatMap/selectConcat 并在新值到达时取消先前的序列 flatMapLatest/selectSwitch 并递归地为每个新值启动一个新的序列 expand 并根据onNext，onError和onCompleted并行地从所有序列发出值 flatMapObserver/selectManyObserver 并根据onNext，onError和onCompleted顺序地从所有序列发出值 concatMapObserver/selectConcatObserver 我想把它与另一个结合起来 两者都完成时发出通知 forkJoin 我想执行复杂的操作，而不会打破流畅的调用 let 我想在多个订阅者之间共享订阅 使用特定的subject实现 multicast publish share 并向未来订阅者提供最后的值 publishLast shareLast 并向未来订阅者重播默认值或最新值 publishValue shareValue 并向未来的订阅者重播n个值 replay shareReplay 发生错误时 我想重新订阅 retry 我想开始一个新序列 catch 取决于错误 catch 当完成时 我想重新订阅 repeat 我想开始一个新序列 concat 当完成或抛出错误时 我想开始一个新序列 onErrorResumeNext 当完成，抛出错误或退订时 我想执行一个函数 finally 我想改变路由的调度程序 调用subscribe（订阅） subscribeOn 消息 observeOn 使用两个序列 我想决定从哪个接收值 取决于哪个序列先发出值 amb 我想确定它们的值是否相等 sequenceEqual 我想合并它们的值 只有当第一个序列发射时，使用每个序列的最新值 withLatestFrom 为了 不改变时重复使用最新值 combineLatest 每个值只使用一次 zip 重复分享我选择的“生命周期” 并通知每个组合 join 并给每个“左”的序列的值给“右”的序列 groupJoin 我想包含两者的值 merge]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>RxJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Marko和react,preact,vue相比快在哪里]]></title>
    <url>%2F2017%2F06%2F01%2Fwhy-Marko-faster-than-react-preact-vue.html</url>
    <content type="text"><![CDATA[Marko和react,preact,vue相比快在哪里在eBay，我们正在使用[Marko](http://markojs.com/)每天处理超过十亿的请求，这就要求我们精简我们的开源UI库Marko。我们大大优化了Marko ，以实现快速渲染，高级性能技术，并实现了最小的页面重量（〜10kb gzipped）。性能只是一个方面，因为我们还必须扩展Marko以支持数百个团队的开发，从而允许开发人员有效地创建可维护和强大的Web应用程序。 我们已经创建了我们自己的benchMarks进行比较，也已经将Marko添加到其他基准测试中，但是基准测试并不总是值得信赖的。尽管我们尽可能公平地对待我们的基准，但最重要的是在现实世界的应用中的表现，而不是专注于微观基准。这就是V8团队转而采用新的方法来衡量和理解现实JavaScript性能的一个原因。 同样，我们已经观察过我们的开发人员实际开发中如何编写他们的Marko组件，并且发现了可以进一步优化的模式。而不是关注本文中的基准测试，我想关注我们应用于Marko的优化细节。 多个编译输出Marko是一个在服务器和浏览器中运行的同构UI库。正如Michael Rawlings在“ 服务器端渲染染 ”中提到的，当在服务器上呈现时，Marko直接呈现可以作为HTTP响应发送的文档（HTML）的字符串表示形式。 在浏览器中呈现时，必须解析HTML字符串才能更新DOM。因此，Marko通过程序将视图编译为直接呈现到虚拟文档（VDOM）树，这可以针对浏览器有效地更新真实的DOM。 给出以下模板： &lt;div>Hello ${input.name}!&lt;/div> 编译为服务器编译输出针对服务器上的HTML输出进行了优化： var marko_template = require("marko/html").t(__filename), marko_helpers = require("marko/runtime/html/helpers"), marko_escapeXml = marko_helpers.x; function render(input, out) { out.w("&lt;div>Hello " + marko_escapeXml(input.name) + "!&lt;/div>"); } 编译为浏览器编译输出针对浏览器中的虚拟DOM渲染进行了优化： var marko_template = require("marko/vdom").t(__filename); function render(input, out) { out.e("DIV", null, 3) .t("Hello ") .t(input.name) .t("!"); } 模块化运行时Marko运行时并不作为单个JavaScript文件分发。相反，Marko编译器会生成一个JavaScript模块，该模块仅导入实际需要的运行时部分。这允许我们向Marko添加新功能，而不会使现有应用程序膨胀。例如，给出以下模板： $ var color = 'red'; &lt;div style={backgroundColor: color}>&lt;/div> 在上面的示例中，需要额外的运行时代码来根据所提供style的JavaScript对象呈现属性。导入styleAttr助手的编译代码如下所示： var marko_styleAttr = require("marko/runtime/vdom/helper-styleAttr"); function render(input, out) { var color = 'red'; out.e("DIV", { style: marko_styleAttr({ backgroundColor: color }) }, 0, 4); } 高性能的服务器端渲染与基于专门进行虚拟DOM渲染的JSX的解决方案相比，Marko在服务器端渲染方面具有巨大的优势。当渲染到服务器上的虚拟DOM树时，它是一个两步的过程来呈现HTML： 首先在内存中生成一个完整的虚拟DOM树 第二遍将虚拟DOM树序列化为可以通过线路发送的HTML字符串（这需要遍历整个树结构） 相比之下，Marko直接一次性渲染一整个HTML流。没有中间树数据结构。 静态子树的编译时优化给出以下模板： &lt;div>This is a &lt;strong>static&lt;/strong> node&lt;/div> Marko将会认识到，模板片段每次都会产生相同的输出，因此会像以下编译输出一样创建一个虚拟DOM节点： var marko_node0 = marko_createElement("DIV", null, 3, ...) .t("This is a ") .e("STRONG", null, 1) .t("static") .t(" node"); function render(input, out) { out.n(marko_node0); } 渲染静态子树几乎是零成本。此外，Marko将跳过对比/修补静态子树。 同样，在服务器上，Marko会将模板的静态部分合并成一个字符串： function render(input, out) { out.w("&lt;div>This is a &lt;strong>static&lt;/strong> node&lt;/div>"); } 静态属性的编译时优化Marko还将优化动态元素的静态属性。 给出以下模板： &lt;div.hello>Hello ${input.name}!&lt;/div> Marko将产生以下编译输出： var marko_attrs0 = { "class": "hello" }; function render(input, out) { out.e("DIV", marko_attrs0, 3) .t("Hello ") .t(input.name) .t("!"); } 请注意，属性对象只创建一次，它用于每个渲染。另外，静态属性不会发生 diffing/patching。 智能编译器使用Marko，我们倾向于在编译时尽可能多地执行。这使我们的编译器更加复杂，但它在运行时给我们带来了很大的收获。我们有〜90％的代码覆盖率和超过2000个测试，以确保编译器正常工作。此外，在许多情况下，Marko编译器为给定的模板提供运行时提示，以便运行时可以针对特定模式进行优化。例如，识别的Marko如果HTML元素仅具有class/id/style定义和做版本比较时/修补运行时优化了这些虚拟DOM节点（Marko编译器生成的代码，标记简单的虚拟DOM节点用于针对 diffing/patching 逻辑）。 事件委托如果你正在建立一个UI组件，您将很可能需要编写代码来处理不同的DOM事件（click，submit，等）。开发人员常常编写使用el.addEventListener(...)或使用诸如jQuery的库来添加DOM事件监听器的代码。当您使用Marko构建UI组件时，您仍然可以执行此操作，但是在初始化大量组件时，在附加侦听器时会出现开销。相反，Marko建议使用声明式事件绑定，如下所示： &lt;button type="button" on-click("handleClick")> Click Me &lt;/button> 当使用声明性事件绑定时，事实上没有附加任何DOM事件侦听器。相反，Marko会为每个DOM事件（在启动时完成）为页面的根DOM元素附加一个监听器。当Marko在根节点处收到事件时，它将把事件委托给该事件的相应组件。这是通过查看event.target属性来查看事件发生的位置，然后向上遍历树来查找需要通知的组件。因此，当根目录捕获DOM事件时，会做更多的工作，但这种方法使用的内存少得多，并减少了初始化时需要完成的。将事件委派给组件的额外开销并不明显，因此这是一个非常有益的优化。 译文：why-is-marko-fast]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>Marko</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm@5发布有哪些改进]]></title>
    <url>%2F2017%2F06%2F01%2Fnpm-5-published.html</url>
    <content type="text"><![CDATA[npm@5发布有哪些改进从今天开始，如果您输入“npm install npm@latest -g”，那么您将被更新为npm版本5。另外，在所有Node.js 8的新安装中都捆绑了npm@5 ，它已经替代了Node.js 7在Node Project的当前版本中。 在过去一年半的时间里，我们一直在努力解决大量的痛点，其中有些是创建npm以来就已经存在的。今天的发布是对npm速度，一致性和用户体验的最大改进。 发布说明中有什么新内容和更改内容的明确列表，但这里有一些亮点： 速度很快重新编排了包元数据，软件包下载和软件包缓存，这大大加快了工作。一般来说，期望性能提升20-100％; 我们还看到一些安装和版本冲突的运行速度提高了5倍。 由于npm最初的设计，开发人员已经改变了他们如何使用npm。npm生态系统不仅呈指数级增长，而且从2014年起，平均npm软件包中的依赖关系数量增加了250％。现在，更多的开发人员现在可以在本地安装Babel，webpack和Tap等有用工具，而不是全局。这是一个最佳实践，但这意味着“npm install”可以做更多的工作。 鉴于我们社区的规模，任何速度上升都会为数百万用户带来巨大的节省，更不用说我们的所有组织和npm企业客户。使npm @ 5变快成为一个很显然的目标。 目标一致默认锁文件Shrinkwrap很早就已经是npm的一部分，但npm@5使lockfiles成为默认，所以所有的npm安装现在都是可重现的。在安装给定版本的软件包时，每次安装它您获得的文件将是相同的。 我们发现无数常见且耗时的问题可能与不同开发人员环境利用不同软件包版本时发生的“漂移”相关。使用默认锁文件，这不再是问题。你不会浪费时间，试图找出一个错误，只是为了了解它来自运行不同版本的图书馆的人。 SHA-512哈希npm@5增加了对Node.js支持的任何tarball Hash功能的支持，并以SHA-512 hash发布。通过检查所有下载的软件包，您可以防止数据损坏和恶意攻击，并且您可以相信您从npm下载的代码是一致和安全的。 自愈缓存我们的新缓存很容易损坏，但也更具弹性。多个npm进程不会破坏共享缓存，npm@5将检查插入和提取的数据，以防止安装损坏的数据。如果缓存项失败完整性检查，npm@5将自动删除它并重新获取。 更易使用根据您的反馈，我们通过npm @ 5中的优化改进了用户体验。其中很大一部分是输出更多的有用的提示信息。最好的例子是，npm不再显示package上的整个树; 相反，您将看到有关安装内容的摘要报告。由于平均每个package中的依赖关系较大，因此我们进行了此更改。逐个文件读出结果是超过一定数量就会显得非常笨重。 比较有一个项目使用 benchmark 比较了 yarn, pnpm, npm 的效率, 传送门 下面是比较结果： Installer Average over 5 runs yarn –offline 5.88 pnpm –offline 6.72 pnpm (cached) 6.86 npm 5.x (shrinkpacked, compressed) 8.35 npm 5.x (shrinkpacked) 8.94 npm 5.x (cached) 11.36 npm 4.x (cached) 13.47 yarn 13.71 npm 5.x 14.93 pnpm 17.57 npm 4.x (shrinkpacked, compressed) 18.73 npm 4.x (shrinkpacked) 18.78 npm 4.x 29.73]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSX是什么鬼(WTF-is-JSX)]]></title>
    <url>%2F2017%2F05%2F30%2FWTF-JSX.html</url>
    <content type="text"><![CDATA[JSX是什么鬼(WTF-is-JSX)JSX实际上很简单：只需要花1分钟阅读这个，你会明白有关这个有趣的替代模板的一切。 替换标题：“融入JSX” Pragma您可以声明每个文件或每个函数来告诉您的transpiler（例如：Babel）每个节点在运行时应调用的函数的名称（请参阅“Transpilation”）。 在下面的例子中，我们说的是“ h()为每个节点注入一个函数”： /** @jsx h */ Transpilation如果你还没有使用解析器，你应该是尝试一下。使用ES6 / ES2015 编写，调试，测试和运行JavaScript时更为高效。Babel是最受欢迎和推荐的透析器，所以我会假设你正在使用它。 除了将ES6 / ES7 +语法转换为 ES5 以外，Babel还包括对JSX 开箱即用的转换支持。您不需要添加或更改任何内容以使用此功能。 通过查看一个非常简单的例子来了解它的工作原理是最简单的： 转换前 :( 你写的代码） /** @jsx h */ let foo = &lt;div id="foo">Hello!&lt;/div>; 转换后 :(你运行的代码） var foo = h('div', {id:"foo"}, 'Hello!'); 你可能看第二个代码片段的时候，认为使用函数构建UI不会那么糟糕 这就是为什么我坐上了 JSX 的车：如果它从地球上消失了，用手写的输出依然会很舒服。 JSX只是一种已经相当不错的语法的糖。 人们甚至把它用于整个项目：hyperscript 我们来构建一个JSX渲染器首先，我们需要定义转换代码后调用的 h() 函数。 你调用任何你想要的，我使用h()，因为这种类型的“构建器”功能的原始想法被称为hyperscript (“hypertext“ + “javascript”).。 function h(nodeName, attributes, ...args) { let children = args.length ? [].concat(...args) : null; return { nodeName, attributes, children }; } 好的，这看起来很简单（ps: 只处理了 children） 不熟悉ES6 / ES2015？ 这…在参数列表是一个rest param。它将“其余”的参数收集到数组中。 该concat(…args)位是一个扩展运算符：它需要该数组并将其扩展为参数concat()。这里使用的concat()是将子节点推入数组。 现在我们有这些嵌套的JSON对象我们的h()函数吐出来，所以我们最终得到一个这样的“树”： { nodeName: "div", attributes: { "id": "foo" }, children: ["Hello!"] } 所以我们只需要一个接受该格式并抛出实际DOM节点的函数：(即沉染vdom) function render(vnode) { // 字符串只转换成 文本节点： if (vnode.split) return document.createTextNode(vnode); // 使用 VDOM 的 nodeName 创建一个DOM 标签 let n = document.createElement(vnode.nodeName); // 拷贝所有属性到新节点上 let a = vnode.attributes || {}; Object.keys(a).forEach( k => n.setAttribute(k, a[k]) ); // 渲染并添加子节点 (vnode.children || []).forEach( c => n.appendChild(render(c)) ); return n; } ：） 不难理解这是如何工作的。 如果有帮助，您可以将“虚拟DOM”视为一个非常简单的配置，用于构建给定的DOM结构。 虚拟DOM的好处是它非常轻巧。小对象引用其他小对象，一个由易于优化的应用程序逻辑构成的结构。 这也意味着它不受任何渲染逻辑或缓慢的DOM方法的束缚。 使用JSX我们知道JSX被转换成h()函数调用。 那些函数调用创建一个简单的“虚拟”DOM树。 我们可以使用该render()函数来制作一个匹配的“真实”DOM树。 这就是这样的： // JSX -> VDOM: let vdom = &lt;div id="foo">Hello!&lt;/div>; // VDOM -> DOM: let dom = render(vdom); // add the tree to &lt;body>: document.body.appendChild(dom); Partials，迭代与逻辑：没有新的语法 我们拥有所有的JavaScript语法，而不是模板语言引入的有限概念。（PS:这是JSX胜过模板语言的地方） “Partials”是由无逻辑/有限逻辑模板引擎引入的概念，用于在不同的上下文中重复使用视图块。 迭代似乎是每个新的模板语言都重新发明的东西（我和任何人一样有罪）。使用JSX，没有新的语法来学习：迭代您在JavaScript程序中的其他任何地方。您选择最适合给定任务迭代式的：[].forEach()，[].map()，for和while循环等 逻辑，像迭代，是模板语言喜欢重新发明的东西。一方面，无逻辑模板在将逻辑嵌入到视图方法非常弱：有限的结构，如\{\{ \#if value}}将逻辑推入控制器层，鼓励膨胀。这规避了构建语言来描述更复杂的逻辑，避免可预见性和安全隐患。 在另一方面，使用代码生成（一种从粗略到不可原谅的技术）的引擎通常具有执行逻辑或甚至迭代任意JavaScript表达式的能力。这是一个很好的理由，不惜一切代价避免这种情况：您的代码被从原始位置（也许是一个模块，闭包或标记内）中剥离出来，并对“别的地方”评估。这对我来说是不可预测的或足够安全的。 JSX允许所有 JavaScript的语言功能，而不依赖于在构建步骤中生成奇怪的代码，没有eval()和扩展。 // 将数组中的字符串以列表的形式展示 let items = ['foo', 'bar', 'baz']; // 创建列表li function item(text) { return &lt;li>{text}&lt;/li>; } // 一个使用迭代和复用的视图 let list = render( &lt;ul> { items.map(item) } &lt;/ul> ); render()返回一个DOM节点（在上述情况下是返回列表），所以我们只需要把它放到DOM中： document.body.appendChild(list); 把它放在一起以下是小型虚拟DOM渲染器和使用它的视图的完整源码。 具有一些样式的CodePen可在下面获得。 同样，我也写了一个例子：在任何地方使用JSX渲染DOM const ITEMS = 'hello there people'.split(' '); // turn an Array into list items: let list = items => items.map( p => &lt;li> {p} &lt;/li> ); // view with a call out ("partial") to generate a list from an Array: let vdom = ( &lt;div id="foo"> &lt;p>Look, a simple JSX DOM renderer!&lt;/p> &lt;ul>{ list(ITEMS) }&lt;/ul> &lt;/div> ); // render() converts our "virtual DOM" (see below) to a real DOM tree: let dom = render(vdom); // append the new nodes somewhere: document.body.appendChild(dom); // Remember that "virtual DOM"? It's just JSON - each "VNode" is an object with 3 properties. let json = JSON.stringify(vdom, null, ' '); // The whole process (JSX -> VDOM -> DOM) in one step: document.body.appendChild( render( &lt;pre id="vdom">{ json }&lt;/pre> ) ); Codepen演示]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>JSX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJS事件桥接]]></title>
    <url>%2F2017%2F05%2F05%2FRxJS-events-binding.html</url>
    <content type="text"><![CDATA[事件桥接RxJS 提供工厂方法来桥接 DOM 或 Node.js 中已存在的异步数据源，所以，你可以使用丰富的创作、过滤和资源管理功能对RxJS提供的任何类型的数据流进行操作。这篇文章探讨 fromEvent 和 fromEventPattern操作符，它允许导入一个 DOM 或者普通事件到 RxJS 的数据流。每次引发事件时，一个 OnNext 消息将传递到数据流。然后，可以像其他任何数据流一样操作事件数据流。 RxJS 不打算取代现有的异步编程模型如 Promises 或 callbacks。但是，当你尝试组合事件， RxJS的工厂方法会提供简便的方法给你，你完全感受不到当前使用了何种编程模式。这真的很方便维护（比如取消订阅）和筛选（比如选择合适的数据）数据源。在本节和下节中，你可以尝试 RxJS 的这些特性如何协助你完成异步编程。 自然，RxJS 支持一批库和他们的勾子函数去使用他们的事件系统，比如 jQuery, Zepto.js, AngularJS, Ember.js 和 Backbone.js。这种行为，不管怎样只能重写本地绑定。默认情况下， RxJS 也支持 Node.js EventEmitter 的事件勾子。 将一个 DOM 事件转换成 RxJS 数据流接下来这个例子为鼠标移动事件创建了一个 DOM 事件操作，并且在页面上打印出鼠标的坐标。 var result = document.getElementById('result'); document.addEventListener('mousemove', e => result.innerHTML = e.clientX + ', ' + e.clientY, false); 导入一个事件到 RxJS, 你可以使用 fromEvent 操作符，并且传入被桥接的事件参数。然后它会将事件转换成数据流。 下面这个例子，我们将 DOM 的 mousemove 事件流转换成事件流（可观察对象）。每次鼠标移动事件被触发时，订阅都会接收到一个 onNext 事件。然后我们可以检查这种通知的事件参数并获得鼠标的坐标。 var result = document.getElementById('result'); var source = Rx.Observable.fromEvent(document, 'mousemove'); var subscription = source.subscribe(e => result.innerHTML = e.clientX + ', ' + e.clientY); 在这个例子中要注意，（鼠标）移动变成一个数据流以便我们进一步操作。 Querying Observable Sequences 这篇文章将会展示如何将该序列投射到点类型集合中并筛选其内容，以便应用程序只接收满足一定条件的值。 事件处理程序的销毁由 subscribe 方法返回的 Disposable 对象处理。调用 dispose 将会释放由该序列所使用的所有资源，包括底层事件处理程序。这本质上是取消订阅事件。 fromEvent 方法还支持向多个项目添加事件处理程序，比如一整个 DOM 节点列表。下面这个例子将会给列表中的每个元素添加 ‘click’ 事件。 var result = document.getElementById('result'); var sources = document.querySelectorAll('div'); var source = Rx.Observable.fromEvent(sources, 'click'); var subscription = source.subscribe(e => result.innerHTML = e.clientX + ', ' + e.clientY); 另外，fromEvent 也支持类库，像 jQuery, Zepto.js, AngularJS, Ember.js and Backbone.js： var $result = $('#result'); var $sources = $('div'); var source = Rx.Observable.fromEvent($sources, 'click'); var subscription = source.subscribe(e => $result.html(e.clientX + ', ' + e.clientY)); 如果表现不如预期，你可以通过设置 Rx.config.useNativeEvents 为 true 去重写它，这会无视任何类库。 // 只使用原生事件，尽管引用了 jQuery Rx.config.useNativeEvents = true; // 只使用原生事件 var result = document.getElementById('result'); var source = Rx.Observable.fromEvent(document, 'mousemove'); var subscription = source.subscribe(e => result.innerHTML = e.clientX + ', ' + e.clientY); 另外，您可以轻松地给事件系统的事件添加许多快捷方式，比如 mousemove， 甚至是 Pointer and Touch 事件。 Rx.dom = {}; var events = "blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu"; if (root.PointerEvent) { events += " pointerdown pointerup pointermove pointerover pointerout pointerenter pointerleave"; } if (root.TouchEvent) { events += " touchstart touchend touchmove touchcancel"; } events.split(' ').forEach(e => { Rx.dom[e] = (element, selector) => Rx.Observable.fromEvent(element, e, selector) }); 现在我们可以重写单个鼠标拖拽事件： var draggable = document.getElementById('draggable'); var mousedrag = Rx.dom.mousedown(draggable).flatMap(md => { md.preventDefault(); var start = getLocation(md); return Rx.dom.mousemove(document) .map(mm => getDelta(start, mm)) .takeUntil(Rx.dom.mouseup(draggable)); }); 注意这在 RxJS-DOM 项目中已经可用，但你自己实现也只需要很少量的代码。 将 Node.js 事件转换成 RxJS 数据流Node.js 也支持类似 EventEmitter: var Rx = require('rx'), EventEmitter = require('events').EventEmitter; var eventEmitter = new EventEmitter(); var source = Rx.Observable.fromEvent(eventEmitter, 'data') var subscription = source.subscribe(data => console.log('data: ' + data)); eventEmitter.emit('data', 'foo'); // => data: foo 使用 FromEventPattern 桥接自定义事件下面有一个使用类库实现事件订阅和退订的实例。fromEventPattern 方法就是为了这个目的而创建的，用来桥接这些自定义事件。 举个例子，你可以想使用 jQuery on 方法去桥接。我们可以将下列代码转换为基于表格行单击的 alert。 $( "#dataTable tbody" ).on('click', 'tr', e => alert($( e.target ).text())); 使用 fromEventPattern 方法转换后的代码看起来像下面这样。每个函数在处理函数中传递，允许您调用 on 和 off 方法来正确处理事件的处理。 var $tbody = $('#dataTable tbody'); var source = Rx.Observable.fromEventPattern( function addHandler (h) { $tbody.on('click', 'tr', h); }, function delHandler (h) { $tbody.off('click', 'tr', h); }); var subscription = source.subscribe(e => alert($( e.target ).text())); 除了这种常用的支持外，我们也支持 addHandler 返回一个对象，它可以通过 removeHandler 去完全退订。在这个例子中，我们将使用 Dojo Toolkit 和 on 模块。 require(['dojo/on', 'dojo/dom', 'rx', 'rx.async', 'rx.binding'], (on, dom, rx) => { var input = dom.byId('input'); var source = Rx.Observable.fromEventPattern( function addHandler (h) { return on(input, 'click', h); }, function delHandler (_, signal) { signal.remove(); } ); var subscription = source.subscribe( x => console.log('Next: Clicked!'), err => console.log('Error: ' + err), () => console.log('Completed')); on.emit(input, 'click'); // => Next: Clicked! }); 相关内容概念 Querying Observable Sequences 本文翻译在: RxJS中文文档]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>RxJS</tag>
        <tag>bridging</tag>
        <tag>event</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用RxJS创建和订阅单一数据流]]></title>
    <url>%2F2017%2F05%2F04%2Fcreating_and_subscribing_to_simple_observable_sequences.html</url>
    <content type="text"><![CDATA[来自 创建和订阅单一可观察序列你不需要去实现 Observable 类去创建一个可观察序列。 同样的，你也不需要去实现 Observer 去订阅数据流。通过安装 Rx 库，你可以利用 Observable类型，它提供了许多操作符来根据零个，一个或多个元素去创建一个数据流。另外， RxJS 还提供 subscribe 方法允许你使用 onNext, onError 和 onCompleted 函数。 从零创建一个数据流在使用操作符之前，让我们看一看怎样使用 Rx.Observable.create 方法从零创建 Observable 。 首先， 我们需要确认引用了 rx.js 核心文件。 如果我们使用 Node.js， 我们可以这样引入: var Rx = require('rx'); 在这个例子中， 我们将只产生一个单一值42，然后标记为完成。 如果不需要清除，返回值是完全可选的。 var source = Rx.Observable.create(observer => { // 产生一个单一值然后完成。 observer.onNext(42); observer.onCompleted(); // 任何清除的逻辑写在这里 return () => console.log('disposed') }); var subscription = source.subscribe( x => console.log('onNext: %s', x), e => console.log('onError: %s', e), () => console.log('onCompleted')); // => onNext: 42 // => onCompleted subscription.dispose(); // => disposed 对于大多数操作， 这完全是多余的，但这展示了非常基础的大部分 RxJS 操作符是如何工作的。 创建及订阅单一数据流接下来的例子使用 Observable 类的 range 操作符来创建一个包含一些数字的单一数据流。观察者使用 Observable 类的 Subscribe 订阅这个数据流集合， 并且处理回调 onNext, onError and onCompleted。在我们的例子中，创建了一个从 x 开始的整数序列，然后接下来产生 y 个。 只要订阅了数据流，数据就会发送给观察者。onNext函数会打印出这个值。 // 创建一个从 1 开始，包含 5 个整数的数据流 var source = Rx.Observable.range(1, 5); // 打印每个值 var subscription = source.subscribe( x => console.log('onNext: %s', x), e => console.log('onError: %s', e), () => console.log('onCompleted')); // => onNext: 1 // => onNext: 2 // => onNext: 3 // => onNext: 4 // => onNext: 5 // => onCompleted 当一个观察者订阅了一个数据流， subscribe 方法背后使用的异步操作取决于操作符。因些， subscribe 的调用是异步的，因为调用者在完成序列观察之前不会被阻塞。这篇文章 Using Schedulers 提供了更多信息。 注意 subscribe 方法返回一个 Disposable，所以你可以很容易地退订和销毁它。当你在可观察对象上调用 dispose 方法时，观察者将会停止监听数据流。正常来说，你不需要精确地调用 dispose 除非你需要提前退订，或者当数据流的生命周期比观察者的还长。 Rx 的订阅被设计成 触发-丢弃 的场景，并不需要终结者。注意到，可观察对象的操作符的默认表现是 只要有可能（比如，onCompleted 或 onError 消息被发送时），订阅就会被销毁。举个例子，下面的代码将会订阅 a 和 b 两个数据流。如果 a 抛出一个错误， x 会立即退订 b 。 var x = Rx.Observable.zip(a, b, (a1, b1) => a1 + b1).subscribe(); 还可以调整代码示例以使用观察者的 Create 运算符，创建并从指定的 OnNext, OnError, 和 OnCompleted 回调返回一个观察者。然后你可以传递 observer 给 observable 的 subscribe 方法。下面的例子展示了这种写法。 // 创建包含 5个整数的数据流，从 1 开始 var source = Rx.Observable.range(1, 5); // 创建观察者 var observer = Rx.Observer.create( x => console.log('onNext: %s', x), e => console.log('onError: %s', e), () => console.log('onCompleted')); // 打印每个结果 var subscription = source.subscribe(observer); // => onNext: 1 // => onNext: 2 // => onNext: 3 // => onNext: 4 // => onNext: 5 // => onCompleted 另外，从零创建一个数据流，你也可以将已存在的 数据， 事件，回调以及 promise 转换成数据流。下一节的主题将会教你怎么做。 注意，这一节只展示了可以从零创建数据流的很少一部分操作符。学习更多其他的 LINQ 操作符， 可以查看 Querying Observable Sequences. 使用定时器接下来的例子使用 timer 操作符去创建一个数据流。 这个数据流将在5秒后输出第一个值，接着每1秒输出后面的值。为了说明， 我们配合 timestamp 操作符去查询，使每一个被推出来的值将在发布时追加时间戳。这样，当我们订阅这个数据源时，我们可以接收到值和时间戳。 首先，我们需要确认我们是否在浏览器引入了相关的文件。注意 RxJS NPM 包已经默认包含了所有操作符。 下面是我们的例子： console.log('Current time: ' + Date.now()); var source = Rx.Observable.timer( 5000, /* 5 秒 */ 1000 /* 1 秒 */) .timestamp(); var subscription = source.subscribe( x => console.log(x.value + ': ' + x.timestamp)); /* 输出可能像这样子 */ // Current time: 1382560697820 // 0: 1382560702820 // 1: 1382560703820 // 2: 1382560704820 通过使用 timestamp 操作符，我们可以证实，第一个值确实是开始5秒后输出，然后每1秒输出一个值。 将数组和可迭代对象转换为数据流使用 Rx.Observable.from 操作符，你可以将一个数组转换为数据流。 var array = [1,2,3,4,5]; // 将数组转换为数据流 var source = Rx.Observable.from(array); // 输出每个值 var subscription = source.subscribe( x => console.log('onNext: %s', x), e => console.log('onError: %s', e), () => console.log('onCompleted')); // => onNext: 1 // => onNext: 2 // => onNext: 3 // => onNext: 4 // => onNext: 5 // => onCompleted 你也可以转换类数组结构，比如包含 length 属性和数字索引的对象。这种情况下，我们只简单有一个包含长度为5的对象。 var arrayLike = { length: 5 }; // 转换数组为数据流 var source = Rx.Observable.from(arrayLike, (v, k) => k); // 输出每个值 var subscription = source.subscribe( x => console.log('onNext: %s', x), e => console.log('onError: %s', e), () => console.log('onCompleted')); // => onNext: 1 // => onNext: 2 // => onNext: 3 // => onNext: 4 // => onNext: 5 // => onCompleted 另外，我们也可以使用 ES6 可迭代对象，如 Map 和 Set 使用 from 转换成数据流。下面这个例子，我们将获取一个 Set 对象，并且将它转换成数据流。 var set = new Set([1,2,3,4,5]); // 转换 Set 为数据流 var source = Rx.Observable.from(set); // 转出每个值 var subscription = source.subscribe( x => console.log('onNext: %s', x), e => console.log('onError: %s', e), () => console.log('onCompleted')); // => onNext: 1 // => onNext: 2 // => onNext: 3 // => onNext: 4 // => onNext: 5 // => onCompleted 我们也可以将它应用在 Map 对象上面。 var map = new Map([['key1', 1], ['key2', 2]]); // 将 Map 转换成数据流 var source = Rx.Observable.from(map); // 打印每个值 var subscription = source.subscribe( x => console.log('onNext: %s', x), e => console.log('onError: %s', e), () => console.log('onCompleted')); // => onNext: key1, 1 // => onNext: key2, 2 // => onCompleted from 方法也支持 ES6 generators，可以你的浏览器已经支持，或将要支持。这允许我们实现一些像 斐波那契序列 等，并将它们转换成数据流。 function* fibonacci () { var fn1 = 1; var fn2 = 1; while (1){ var current = fn2; fn2 = fn1; fn1 = fn1 + current; yield current; } } // 将 generator 转换成数据流 var source = Rx.Observable.from(fibonacci()).take(5); // 打印每个值 var subscription = source.subscribe( x => console.log('onNext: %s', x), e => console.log('onError: %s', e), () => console.log('onCompleted')); // => onNext: 1 // => onNext: 1 // => onNext: 2 // => onNext: 3 // => onNext: 5 // => onCompleted 冷（惰性） vs. 热（非惰性） 数据流冷数据流的开始运行取决于订阅，比如，数据流只有当 subscribe 调用的时候才开始输出值。用户之间也没有共享值。这些是与热数据流的不同之处，热数据像流鼠标移动事件或股票代码这样的订阅时就已经不断输出值。当观察者订阅热数据流时，它将会获取流的实时值。热数据流是与所有订阅者共享的，每个订阅者按顺序推送下一个值。举个例子，就算没有人订阅一个特定的股票，股票市场也将继续根据市场动向更新其价值。当有注册者对这支股票感兴趣时，它会自动获得股票的最新值。 下面的示例演示了一个冷数据流。这个例子中，我们使用了 Interval 操作符去创建一个单一数据流并在特定的时间间隔输出值，这个例子中是间隔1秒。 两个观察者订阅这个数据流并打印输出值。你会注意到数据流会为每个订阅者重置，第二个订阅者也是从第1个值开始的。 首先，我们需要确保在浏览器中引入了相关文件。注意 RxJS NPM 包已经默认包含了所有操作符。 然后是例子： var source = Rx.Observable.interval(1000); var subscription1 = source.subscribe( x => console.log('Observer 1: onNext: ' + x), e => console.log('Observer 1: onError: ' + e.message), () => console.log('Observer 1: onCompleted')); var subscription2 = source.subscribe( x => console.log('Observer 2: onNext: ' + x), e => console.log('Observer 2: onError: ' + e.message), () => console.log('Observer 2: onCompleted')); setTimeout(() => { subscription1.dispose(); subscription2.dispose(); }, 5000); // => Observer 1: onNext: 0 // => Observer 2: onNext: 0 // => Observer 1: onNext: 1 // => Observer 2: onNext: 1 // => Observer 1: onNext: 2 // => Observer 2: onNext: 2 // => Observer 1: onNext: 3 // => Observer 2: onNext: 3 接下来的例子中，我们使用 publish 操作符将前面的冷数据源转换成热数据源，返回一个 ConnectableObservable 实例，我们称为 hot。publish 操作符通过向多个订阅服务器广播单个订阅来提供共享订阅的机制。hot变量作为代理订阅 source，因为它从 source 接收值，推到自己的用户. 我们使用 ConnectableObservable.prototype.connect 建立订阅的备份源，并开始接收值。因为 ConnectableObservable 继承自 Observable， 我们可以在它运行之前使用 subscribe 去订阅这个热数据流。 在这个例子中要注意，当 subscription1订阅它的时候热数据流还没有开始。因些，没有值输出给订阅者。只有调用 Connect 之后，输出值才会推送给 subscription1。3秒的延迟之后，subscription2 订阅了热数据流，并且立即开始接收当前输出值（当前值是3），一直到最后。输出结果看起来像这样： // => Current time: 1382562433256 // => Current Time after 1st subscription: 1382562433260 // => Current Time after connect: 1382562436261 // => Observer 1: onNext: 0 // => Observer 1: onNext: 1 // => Current Time after 2nd subscription: 1382562439262 // => Observer 1: onNext: 2 // => Observer 2: onNext: 2 // => Observer 1: onNext: 3 // => Observer 2: onNext: 3 // => Observer 1: onNext: 4 // => Observer 2: onNext: 4 首先，我们需要确认我们引入了相关文件。注意 RxJS NPM包已经默认包含了所有操作符。 接下来是例子！ console.log('Current time: ' + Date.now()); // 创建一个数据流 var source = Rx.Observable.interval(1000); // 将数据流转换成热数据流 var hot = source.publish(); // 第一个订阅时没有值输出 var subscription1 = hot.subscribe( x => console.log('Observer 1: onNext: %s', x), e => console.log('Observer 1: onError: %s', e), () => console.log('Observer 1: onCompleted')); console.log('Current Time after 1st subscription: ' + Date.now()); // 空闲 3 秒 setTimeout(() => { // 热数据源连接并开始输出值给订阅者 hot.connect(); console.log('Current Time after connect: ' + Date.now()); // 又空闲 3 秒 setTimeout(() => { console.log('Current Time after 2nd subscription: ' + Date.now()); var subscription2 = hot.subscribe( x => console.log('Observer 2: onNext: %s', x), e => console.log('Observer 2: onError: %s', e), () => console.log('Observer 2: onCompleted')); }, 3000); }, 3000); // => Current Time after connect: 1431197578426 // => Observer 1: onNext: 0 // => Observer 1: onNext: 1 // => Observer 1: onNext: 2 // => Current Time after 2nd subscription: 1431197581434 // => Observer 1: onNext: 3 // => Observer 2: onNext: 3 // => Observer 1: onNext: 4 // => Observer 2: onNext: 4 // => Observer 1: onNext: 5 // => Observer 2: onNext: 5 // => ... 类推 这有助于思考冷热数据源的关系，就像一个人看（subscribe）电影和表演。 冷数据流：电影。 热数据流：现场演出 重播热数据流：录播现场演出 你管你何时观看电影，你看电影和别人看都是独立的，尽管所有观看者看的都是相同的内容。另一方面，一个表演是与多个观看都一起分享的。如果你迟到了，你将会错过一部分。不管怎样，如果记录下来了（在 RxJS中可以使用 BehaviorSubject 或 ReplaySubject），你也可像看电影一样看现场演出。.publish().refCount() 现场表演是艺术家在没有人观看的情况下退出比赛，当观众中至少有一人出现时，他会重新开始演奏。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>RxJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coverage针对js和css的代码覆盖检测-Chrome_devtools的新功能]]></title>
    <url>%2F2017%2F04%2F06%2Fcheck-coverage-of-js-and-css-used-in-Chrome-devtools.html</url>
    <content type="text"><![CDATA[Coverage针对js和css的代码覆盖检测-Chrome_devtools的新功能也许你之前用过一些像 css usage、css used 这样的浏览器插件去检测代码覆盖率。但现在，Chrome的实验版本Canary终于实现了代码覆盖率检测，这意味着它将很快普及到正式版本。这是一个令人兴奋的功能，在使用JavaScript和CSS时非常有用，所以我会做一个快速的演示，并探索它如何使用。 它做了些什么事情代码覆盖可以在您运行您的Web应用程序的时候，遍历每个JS / CSS文件，看看哪些代码行运行，哪些代码没有运行。 在这里，我做了一个简单的静态网页，Chrome生成了页面上存在的CSS和JS文件的问题汇总。右侧的栏显示每个文件的相对大小，红色表示未使用的代码，绿色显示运行的代码。 记录代码覆盖范围与devtools时间轴类似，您点击开始记录，然后在您的站点进行正常的交互。完成后，Chrome会进行一些计算并生成读数。在这里，我很好奇网站上有多少未使用的CSS，所以我导航到各个子页面，以确保我触及到每个css。果然，这里有很多改进的空间，因为我的网站上的css的97％没有使用！ Chrome还可让您深入研究单个文件的代码范围。在这里，左边的红色/绿色条显示哪一行执行了，哪一行没有。请注意，当检查最小化的文件时，可以按文件左下角的按钮来“prettify”代码。 这有什么用在一个复杂的或长期的项目上工作时，很容易积累冗余代码。如果你使用 webpack 或另一个JS构建系统，可以防止大多数无用的JS代码。但是对于CSS来说，这样做可能会有点棘手。有了这个覆盖工具，在Chrome是一个伟大的方式来快速了解多少冗余的代码在运行，哪些文件需要优化。 如何才能使用它下载Chrome的实验版本Canary或等待此功能更新到正式版本。 【译文参考】：https://blog.logrocket.com/using-the-chrome-devtools-new-code-coverage-feature-ca96c3dddcaf]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>coverage</tag>
        <tag>Chrome_devtools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习RxJS需要知道的奇淫技巧]]></title>
    <url>%2F2017%2F04%2F05%2Fwhat-you-need-to-know-about-RxJS.html</url>
    <content type="text"><![CDATA[学习RxJS需要知道的奇淫技巧尝试画珠宝图为你想创建的流画一个珠宝图。 通过画珠宝图，你将会很清楚你应该使用哪些操作符。 珠宝图就是每个珠宝表示当前的一个事件或状态。珠宝图需要包含输入和输出流。 通过画珠宝图，我们可以看到，我们在异步调用事件回调之前，需要延迟检测用户的输入。在这个例图里展示的是throttle操作符的延迟。从一个流创建另一个流，我们会使用 flatMap 或 selectMany 操作符。然后就有了下面的代码： var dictionarySuggest = userInput.throttle(250).flatMap(input => serverCall(input)); 何时忽略这条指南如果你感觉你已经可以很熟练地编写出你想要的流，你可以省去画珠宝图这一步。不管怎样，就算是 Rx 团队的成员在写代码的时候也仍然会先画一画珠宝图。 调用 subscribe 时传递多个参数为了方便， Rx 提供一个subscribe方法来加载观察者的回调函数。 观察者只需要实现这三个方法（onNext, onError & onCompleted）。 subscribe方法的扩展允许开发人员使用这些方法的默认选项。 比如： 当调用subscribe方法时只有一个onNext参数，onError将捕获来自事件流的异常。onCompleted在这里什么也不会做。 大部分情况下，处理异常是很重要的（不管是对于恢复还是中断应用程序）。 知道事件流是否完成也经常是很重要的。举个例子，告诉用户他的操作是否完成了。 所以，最好提供完整的三个参数给 subscribe 操作符。 RxJS还提供了三种方便的方法，其仅订阅所期望的序列的一部分。其他的处理程序会默认为原来的行为。有三个这样的功能： subscribeOnNext: 只对应 onNext 消息 subscribeOnError: 只对应 onError 消息 subscribeOnCompleted: 只对应 onCompleted 消息. 何时忽略这条指南 当流确定不会有完成状态，比如 keyup事件。 当流确定不会抛出异常，比如一个事件，一个完全确定的流。 当默认行为是符合预期的时候。 考虑通过特定的调度程序并发引入操作符相比使用observeon操作符来改变可观察序列产生消息的执行上下文，更好的做法是在正确的地方开始创建并发。 通过正确的调度器将会减少 ObserveOn操作符的使用。 例Rx.Observable.range(0, 90000, Rx.Scheduler.requestAnimationFrame).subscribe(draw); 在这个例子中，来自range操作符的回调将会通过window.requestAnimationFrame传递。在这个例子中， range操作符的回调将被调用。默认情况下，当递归调用立即执行时，range过载将会代替 onNext在Rx.Scheduler.currentThread上的调用。 通过提供Rx.Scheduler.requestAnimationFrame调度程序， 所有来自observable的消息都将会在 window.requestAnimationFrame回调中产生。 何时忽略这条指南当结合来自不同执行上下文的几个事件时，使用指南4.4将所有消息尽可能晚地放在特定的执行上下文。 尽可能少且尽可能迟地调用observeOn 操作符通过使用 observeOn 操作符， 一个预定的功能是通过原始的消息流来获取信息。这可能会改变时序信息以及对系统施加额外的压力。在查询中延迟使用这个操作符可以改善这两个问题。 Samplevar result = xs.throttle(1000) .flatMap(x => ys.takeUntil(zs).sample(250).map(y => x + y)) .merge(ws) .filter(x => x &lt; 10) .observeOn(Rx.Scheduler.requestAnimationFrame); 这个例子合并了多个 运行在不同上下文的 observable 。这个查询筛选掉了大部分信息。将observeOn操作符放在查询中的前面会对筛选出来的消息做额外的工作。最后才调用 observeOn 将会最大限度地提高性能。 何时忽略这条指南如果你使用的 observable 并没有指定不同的上下文环境。这种情况下可以不必使用 observeOn 操作符。 关注内存限制RxJS 有很多操作符和类可以在内存中创建 observable, 比如：replay 操作符。当这些内存存储着 observable 时，这些缓存的大小将取决于 observable 的操作。如果缓存过大，将会造成内存溢出。有许多缓冲操作符提供策略来限制缓冲区，不管是从时间方面还是大小。提供这个限制将解决内存压力问题。 例子var result = xs.replay(null, 10000, 1000 * 60 /* 1 hr */).refCount(); 这个例子中，replay 操作符创建了一个 buffer. 我们有限制这个 buffer 最多包含 10,000 条信息以及最多保留这些信息1小时。 何时忽略这条指南当 observable 创建了大量的信息只填充了一小块 buffer， 或者当 buffer本身有大小限制。 使用 do/tap 操作符的副作用很明显有很多 Rx 操作符使用函数作为参数，这可以在这些参数中传递任何有效的用户代码。这些代码可以改变全局状态（比如改变全局变量，读写硬盘等等）。 Rx 是通过每个操作符组合起来运行的（除了共享操作符，例如“publish”）。这将使副作用发生在每个订阅。 如果这种表现是期望的行为，最好弄清楚在 do/tap 操作符中有副作用的这部分代码。这些方法会过载，只能调用指定的方法，比如 doOnNext/tapOnNext，doOnError/tapOnError,doOnCompleted/tapOnCompleted 例var result = xs.filter(x => x.failed).tap(x => log(x)); 这个例子中，过滤失败的消息。将它们分发到订阅observable的代码之前记录该消息。此记录有一个副作用（比如：将消息放置在计算机的事件日志中）并明确地通过调用do/tap操作符。 假设消息可以传达，直到退订完成由于RxJS 使用推模式，消息可以通过不同的上下文环境发送。 当退订的时候，消息可能还在路上。当退订还没有完成的时候，这些消息仍然可以被传达。当控制权被返回时，消息将不能再传达。退订过程可以是在一个不同的上下文环境中进行。 何时忽略这条指南一旦 onCompleted 或 onError 方法被调用，RxJS语法可以保证订阅已结束。 使用 publish 操作符分享副作用因为许多 observable是冷门的(see cold vs. hot on Channel 9), 每个订阅都有单独的副作用。 某些情况下，这些副作用只发生一次。publish 操作符通过向多个用户广播单个订阅来提供共享订阅的机制。 有几个过载publish运算符。最方便的过载是那些提供了一个函数封装 observable 共享的副作用的参数。 例var xs = Rx.Observable.create(observer => { console.log('Side effect'); observer.onNext('hi!'); observer.onCompleted(); }); xs.publish(sharedXs => { sharedXs.subscribe(console.log); sharedXs.subscribe(console.log); return sharedXs; }).subscribe(); 这个例子中，xs 是一个有副作用的（写入console） observable。正常情况下，每个单独的订阅都会触发这些副作用。 publish 操作符使用xs单独给所有订阅者 sharedXs 变量去订阅。 何时忽略这条指南只有当 publish 操作符需要共享副作用时才使用这条指南。在大多数情况下，您可以创建单独的订阅，没有任何问题：不管是订阅没有副作用的或是副作用可以执行多次没有任何问题的。 参考 同步翻译至RxJS中文文档]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>RxJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么选择 RxJS?]]></title>
    <url>%2F2017%2F04%2F04%2Fwhy-rxjs.html</url>
    <content type="text"><![CDATA[Why RxJS?你可能会问，为什么选择 RxJS? 为什么不是 Promises? Promises 可以很好地解决异步操作，像使用 XMLHttpRequest 去查询服务器, 它预期会返回值并且最终完成请求。 The Reactive Extensions 统一了 JavaScript 中的 Promises, callbacks 以及事件数据，比如 DOM输入, Web Workers, Web Sockets. 一旦我们统一了这些概念，就可以进行各种各样的组合. 为了让您了解丰富的组合，我们可以创建一个自动完成功能，它从文本输入中接收用户输入，然后查询服务，确保不会对每个键盘输入的进行泛滥地调用，而是以一种更自然的方式调用。 首先，我们将引用JavaScript文件，包括jQuery，尽管RxJS没有依赖于jQuery … 接下来，我们将从输入框获取用户输入，使用Rx.Observable.fromEvent 方法监听 keyup 事件. 如果 jQuery, Zepto, AngularJS and Ember.js 可用，将会使用它们来绑定事件, 否则将使用原生事件绑定. 这跟您的框架思考事件的一致方式，因此没有任何惊喜。 var $input = $('#input'), $results = $('#results'); /* 只从 keyup 事件获得输入值 */ var keyups = Rx.Observable.fromEvent($input, 'keyup') .map(e => e.target.value) .filter(text => text.length > 2); /* 函数节流输出设置为 500ms */ var throttled = keyups.throttle(500 /* ms */); /* 现在判断值是否有改变，只获取不同的值 */ var distinct = throttled.distinctUntilChanged(); 现在，让我们来查询维基百科！在RxJS中，我们可以立即通过Rx.Observable.fromPromise方法绑定到任何Promises A+的实现上，或者直接返回它，并将其封装。 function searchWikipedia (term) { return $.ajax({ url: 'http://en.wikipedia.org/w/api.php', dataType: 'jsonp', data: { action: 'opensearch', format: 'json', search: term } }).promise(); } 一旦创建，现在我们可以将不同的节流输入绑定在一起，然后查询服务。在这种情况下，我们将调用flatMapLatest获取该值，并确保我们不会有任何混乱的调用。 var suggestions = distinct.flatMapLatest(searchWikipedia); 最后，我们将在可观察对象上调用subscribe方法开始拉数据。 suggestions.subscribe(data => { var res = data[1]; /* Do something 像数据绑定 */ $results.empty(); $.each(res, (_, value) => $('&lt;li>' + value + '&lt;/li>').appendTo($results)); }, error => { /* handle any errors */ $results.empty(); $('&lt;li>Error: ' + error + '&lt;/li>').appendTo($results); }); 翻译参考 同步发布RxJS中文文档]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>RxJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lerp的应用-利用简单线性插值来平滑动画效果]]></title>
    <url>%2F2017%2F03%2F20%2Flerp-application-uses-simple-linear-interpolation-to-smooth-animation-effects.html</url>
    <content type="text"><![CDATA[Lerp的应用-利用简单线性插值来平滑动画效果上一篇的 RxJS的动画简介 里提到一个动画平滑的小技巧, 这里展示几个例子，它真的很简单却很有用。 Lerp是两点之间的线性插值的别称。这是一个实现起来相当简单的效果，但可以真正改善你的动画的外观，如果你将一个对象从点A移动到点B. 它是如何工作的？如果您有一个对象的当前位置和目标的位置，您可以线性内插这些点之间的距离的百分比，并在每个动画帧上更新该位置。 function lerp(position, targetPosition) { // 计算当前位置与目标位置差值的 20% position.x += (targetPosition.x - position.x)*0.2; position.y += (targetPosition.y - position.y)*0.2; } 通过这样做，对象移动的量随着位置和目标之间的距离减小而变小。这意味着对象将越来越接近它的目标，速度将减慢，这创造一个很好的缓和效果。 一些例子这里有一个球跟随用户的鼠标或触摸运动的例子。如果我们使球移动到鼠标移动的地方，球的移动可以非常快但看起来有点脱节。如果我们快速移动鼠标，我们也可以看到单独的“球影”。 这里是同样的演示，除了这次我们使用lerp。不是将球立即向右移动到鼠标位置，我们每次将它移动10％的距离。 注意球的运动很平滑，整体更令人愉快的效果。 这里是使用lerp的另一个例子。这次我们有一个滚动指示器，当您向下滚动“页面”时更新。 所以，lerp“把戏”是一个伟大的工具，我们的网络动画套路，以对抗线性或锯齿状的运动。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>animate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJS的动画简介]]></title>
    <url>%2F2017%2F03%2F19%2Fanimated-intro-rxjs.html</url>
    <content type="text"><![CDATA[本文译自 An Animated Intro to RxJS 你可能听说过RxJS，ReactiveX，或反应式编程，或者甚至只听过函数式编程。这些术语在谈论最新和最前沿的前端技术时变得越来越突出。如果你像我一样，当你第一次尝试学习它时，你感到很困惑。 根据ReactiveX.io： ReactiveX是一个库，用于通过使用可观察序列来组成异步和基于事件的程序。 这句话包含了很多要消化的内容。在本文中，我们将采用一种不同的方法来学习RxJS（ReactiveX的JavaScript实现）和Observables，通过创建反应式动画。 理解Observable数组是元素的集合，例如[1, 2, 3, 4, 5]。你可以立即得到所有的元素，你可以做的事情像map，filter和映射他们。这允许你以任何你想要的方式转换元素的集合。 现在假设阵列中的每个元素随时间发生; 也就是说，你不是立即得到所有的元素，而是一次一个。你可能得到第一个元素在第1秒，下一个在第3秒，依此类推。以下是如何表示： 这可以被描述为值的流，或事件序列，或更确切地，称为observable。 observable是随时间的值的集合。 就像使用数组一样，您可以对这些值进行映射，过滤等操作，以创建和组合新的observable。最后，你可以订阅这些observable，并在steam的值之后执行你想要做的事。这是RxJS的源。 RxJS起步开始使用RxJS的最简单的方法是使用CDN，虽然有很多方法可以安装，这取决于项目的需要。 &lt;!-- the latest, minified version of RxJS --> &lt;script src="https://unpkg.com/@reactivex/rxjs@latest/dist/global/Rx.min.js">&lt;/script> 一旦你的项目中有RxJS，你可以从任何东西中创建一个observable ： const aboutAnything = 42; // 从变量创建 // The observable emits that value, then completes. const meaningOfLife$ = Rx.Observable.just(aboutAnything); // 从数组或可遍历的结构中创建 // The observable emits each item from the array, then completes. const myNumber$ = Rx.Observable.from([1, 2, 3, 4, 5]); // From a promise. // The observable emits the result eventually, then completes (or errors). const myData$ = Rx.Observable.fromPromise(fetch('http://example.com/users')); // 从事件中创建 // The observable continuously emits events from the event listener. const mouseMove$ = Rx.Observable .fromEvent(document.documentElement, 'mousemove'); 注意：变量末尾的美元符号$是一个约定，表示该变量是一个可观察者。Observable可以用来对任何可以表示为随时间变化的值的流进行建模，例如事件，Promises，计时器，间隔和动画。 因为，这些可观察的东西不做任何事情，至少直到你实际观察他们。一个简单的订阅将做到这一点，使用创建.subscribe()： myNumber$.subscribe(number => console.log(number)); // Result: // > 1 // > 2 // > 3 // > 4 // > 5 让我们实践看看： const docElm = document.documentElement; const cardElm = document.querySelector('#card'); const titleElm = document.querySelector('#title'); const mouseMove$ = Rx.Observable .fromEvent(docElm, 'mousemove'); mouseMove$.subscribe(event => { titleElm.innerHTML = `${event.clientX}, ${event.clientY}` }); 从mouseMove$观察到的，每次mousemove事件发生时，订阅改变titleElm的.innerHTML的鼠标的位置。该.map操作（据工作原理类似Array.prototype.map方法）可帮助简化事情： // Produces e.g., {x: 42, y: 100} instead of the entire event const mouseMove$ = Rx.Observable .fromEvent(docElm, 'mousemove') .map(event => ({ x: event.clientX, y: event.clientY })); 使用一些数学和内联样式，您可以使卡片朝向鼠标旋转。pos.y / clientHeight和pos.x / clientWidth计算为0和1之间的值，所以乘以由50减去一半（25）产生的值从-25到25，这正是我们需要为我们的旋转值： const docElm = document.documentElement; const cardElm = document.querySelector('#card'); const titleElm = document.querySelector('#title'); const { clientWidth, clientHeight } = docElm; const mouseMove$ = Rx.Observable .fromEvent(docElm, 'mousemove') .map(event => ({ x: event.clientX, y: event.clientY })) mouseMove$.subscribe(pos => { const rotX = (pos.y / clientHeight * -50) - 25; const rotY = (pos.x / clientWidth * 50) - 25; cardElm.style = ` transform: rotateX(${rotX}deg) rotateY(${rotY}deg); `; }); 使用 .merge 合并现在让我们假设你想让这个适应触摸设备，不管是鼠标事件或是触摸动作。没有任何混乱的回调，你可以通过RxJS使用很多方法来结合Observable。在这个例子中，可以使用.merge实现。就像交通多条车道合并成一个单一的车道，这将返回一个包含所有数据的Observable通过合并多个Observable. const touchMove$ = Rx.Observable .fromEvent(docElm, 'touchmove') .map(event => ({ x: event.touches[0].clientX, y: event.touches[0].clientY })); const move$ = Rx.Observable.merge(mouseMove$, touchMove$); move$.subscribe(pos => { // ... }); 继续，尝试在触摸屏设备上平移左右： 还有很多其他有用的Observable合并方法，如.switch()，.combineLatest()和.withLatestFrom()，我们继续关注下一个点。 添加平滑的运动旋转卡动作有点太死板。只要鼠标（或手指）停止，旋转即刻停止。为了解决这个问题，线性内插（线性插值）都可以使用。一般技术中描述这个伟大的教程由雷切尔·史密斯。本质上，而不是从A点跳到B，线性插值会在每一个动画运行一小部分。这将产生一个平滑的过渡，甚至当鼠标/触摸移动已停止。 让我们创建一个函数实现这个功能：计算给定初始值和终值下一个值，采用线性插值： function lerp(start, end) { const dx = end.x - start.x; const dy = end.y - start.y; return { x: start.x + dx * 0.1, y: start.y + dy * 0.1, }; } 非常简约。我们有一个纯函数每次返回一个新的，线性内插的位置值，通过移动当前的（开始）接近每个动画帧上的下一个（完）位置10％的位置。 调度和.interval问题是，我们如何在RxJS中表示动画帧？原来，RxJS有一个叫做Schedulers的东西，它控制什么时候从一个observable发出数据，当订阅都开始接收值。 使用Rx.Observable.interval()，您可以创建一个observable，它在固定的时间间隔发出值，例如每隔一秒（Rx.Observable.interval(1000)）。如果创建一个非常微小的时间间隔，例如Rx.Observable.interval(0)，并希望它只在每个动画帧上发出值，那么在动画帧内Rx.Scheduler.animationFrame每隔16到17ms就会发出一个值，如下所示： const animationFrame$ = Rx.Observable.interval(0, Rx.Scheduler.animationFrame); 结合.withLatestFrom要创建平滑线性插值，您只需要关心每个动画帧的最新鼠标或触摸位置。要做到这一点，有一个操作符叫.withLatestFrom()： const smoothMove$ = animationFrame$ .withLatestFrom(move$, (frame, move) => move); 现在，smoothMove$是一个新的observable，move$ 只有当animationFrame$发出一个值时，才会发出最新的值。这是必须的 - 你并不想要的动画帧外发出的值（除非你真的喜欢jank）。第二个参数是描述当组合来自每个可观察的最新值时要做什么的函数。在这种情况下，唯一重要的值是move值，这是所有返回的值。 与过渡.scan现在你有一个observable从move$每个动画帧发出最新的值，是时候添加线性插值了。.scan()运算符“积累”从可观察到的当前值和下一个值，提供给需要这些值的函数。 这对于我们的线性插值用例是完美的。记住，我们的lerp(start, end)函数有两个参数：start（current）值和end（next）值。 const smoothMove$ = animationFrame$ .withLatestFrom(move$, (frame, move) => move) .scan((current, next) => lerp(current, next)); // or simplified: .scan(lerp) 现在，您可以订阅smoothMove$代替move$在操作中查看线性插值： 结论RxJS 不是一个动画库，当然，但对于处理随时间变化的值，它的可组合以及声明性的方式是ReactiveX演示动画的核心概念。反应式编程是考虑编程的另类方式，具有许多优点： 它是声明性的，可组合的和不可变的，避免回调地狱，并使你的代码更简洁，可重用和模块化。 它在处理所有类型的异步数据时非常有用，无论是获取数据，通过WebSockets进行通信，监听来自多个源的外部事件，甚至是动画。 “关注的分离” - 您使用Observable和运算符声明性地表示您期望的数据，然后在一个单独的上下文环境中处理.subscribe()，而不会在您的原代码上产生副作用。 有这么多语言的实现了它 - Java，PHP，Python，Ruby，C＃，Swift和其他你可能没有听说过的。 它不是一个框架，它与许多流行的框架（如React，Angular和Vue）可以非常好地融合在一起。 你可以得到行家指点，如果你想要，但ReactiveX从被提出到现在实施了近十年前（2009年），由创意所产生的Conal Elliott和保罗·胡达克 2年前（1997年），在描述功能性反应的动画（惊喜惊喜）。不用说，它经过了足够的测试。 本文探讨了一些有用的部分和RxJS的概念-创建与订阅.fromEvent()和.interval()，对订阅操作.map()和.scan()，多个订阅相结合.merge()和.withLatestFrom()，并与引入调度Rx.Scheduler.animationFrame。有很多其他有用的资源学习RxJS： ReactiveX：RxJS - 官方文档 RxMarbles - 用于可视化观察 Reactive编程的介绍 如果你想进一步深入RxJS动画（和使用更多的CSS变量），请查看我的幻灯片从CSS Dev Conf 2016和我2016年的演讲从JSConf冰岛关于反应式动画与CSS变量。这里有一些使用RxJS创建的动画可能对触发灵感有帮助： 3D数字时钟 心脏app概念 透视使用RxJS拖动]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>RxJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过动图简单通俗地了解Flexbox的工作原理（二）]]></title>
    <url>%2F2017%2F03%2F13%2Fan-animated-guide-to-flexbox-2.html</url>
    <content type="text"><![CDATA[本文译自 Scott Domes Flex属性是一个复合属性，而大部分教程中都只设置一个值，但其实它包含了 flex-basis、flex-grow、flex-shrink. 让我们深入了解Flexbox - 以及如何利用它来构建适应性强和漂亮的布局. 属性一： Flex-Basis在上一篇文章中，我们主要把它用于外部容器中。这一次，我们试着把它用在容器内的子元素中。 这是一个很不起眼的属性，但也很直接。 Flex-basis 控制着一个元素的默认大小，在其他 flex 属性应用之前。 在下面的 GIF 看来，它的作用和 width 的作用一样： 是什么让 flex-basis 表现得和 width 一样？事实上，它对应着 flex 的坐标轴。 flex-basis 影响无素在主轴上的大小 让我们看看保持 flex-basis 的值不变，但是改变主轴方向会有什么变化： 注意到，我从手动设置高度变成手动设置宽度。 Flex-basis 影响宽度还是高度取决于 flex-direction 的值。 属性二：Flex Grow现在，我们来点更复杂的。 首先，让我们设置给所有方块设置相同的宽度，120px: 现在，当它加上属性 flex-grow（默认值为0）.这意味着，不允许方块自动充满容器。 没理解？现在给每个方块的 flex-grow 属性设置为 1： 所有方块共同充满了容器的整个宽度，并且是平均分。 flex-grow 属性覆盖了 width 属性。 让人困惑的是 flex-grow 的值到底是什么意思？ flex-grow: 1 意味着什么？ 好吧，下图是给每个方块设置 flex-grow 值为 999 的表现： 这真是。。完全一样。 那是因为 flex-grow 不是一个绝对的值，而是一个相对的值。 重要的不是一个方块 flex-grow 值的本身，而是这个值和其他方块的值的关系。 如果给每个方块设置 flex-grow: 1， 然后调整第3个方块的 flex-grow 属性，可以看到如下变化： 想要真正明白这里发生了什么，让我们快速略过一个简单的数学计算。 每个正方形都以flex-grow为1开始。如果我们将每个正方形的flex-grow相加，则总和为6。因此，容器被分成6个单独的部分。每个正方形增长到可用空间的1/6以填满容器。 当设置第3个方块的flex-grow 为 2， 现在容器被分成7份，因为 flex-grow 属性的值的总和为 1+1+2+1+1+1. 方块3获得 2/7 的宽度，剩下的获得 1/7。 当设置第3个方块为 flex-grow: 3， 容器被分成8份（1+1+3+1+1+1）, 方块3占 3/8, 剩下的占 1/8. 以此类推。 flex-grow是占所有值总和的比例。如果给所有方块设置flex-grow: 4, 方块3设置 flex-grow: 12, 效果和给它们分别设置 1 和 3 是一样的。 最后一点，flex-grow 和 flex-basis 都和主轴对应。我们的方块只会增长宽度，除非设置 flex-direction 为 column. 属性三： Flex Shrinkflex-shrink 和 flex-grow正好相反，决定每个方块可以收缩多少。 它只有在元素必须收缩以适应其容器时才起作用 - 即当容器太小时。 它的主要用途是指定哪些元素要缩小，哪些元素不用缩小。默认情况下，每个方块的 flex-shrink 值为1 - 这意味着它会随着容器的收缩而收缩。 让我们看看它的表现。在下面的GIFS中，正方形的flex-grow为1，因此它们填充了容器，并且flex-shrink为1，因此它们被允许收缩. 现在让我们将方块3的flex-shrink设置为0.它禁止收缩，所以它会增长以适应容器，但它拒绝收缩到其设置的120px宽度以下。 flex-shrink的默认值是1 - 这意味着你的元素会收缩，除非设置为0去禁止它。 同样，flex-shrink 是按比例的。如果一个盒子的flex-shrink为6，其余的flex-shrink为2，一个盒子将以3倍的速度缩减，当空间被压缩。 注意这里说的是：具有3x弹性收缩的方块将比其他方块缩短3倍。这并不意味着它将收缩1/3的宽度。 稍后，我们会深入了解这到底会收缩或增长多少，在此之前，先来看一下最后一个属性，并把所有混在一起。 属性四： Flexflex 是 grow, shrink 以及 basis 的缩写，复合属性。 它的默认值是 0(grow) 1（shrink）auto(basis). 最后一个例子，让我们简化到两个 boxs 这是它们的属性： .square#one { flex: 2 1 300px; } .square#two { flex: 1 2 300px; } 两者都有相同的 flex-basis属性。这意味着如果它们都有足够的空间（容器是600px加上边距和填充空间），它们都将是300px宽度。 但随着容器的增长，Square 1（具有更高的flex-grow）将增长两倍。随着盒子的收缩，Square 2（具有更高的flex-shrink）将缩短两倍。 它是如何增长和收缩的这里有可能会混淆：当Square 1增长时，它不会增长到Square 2的两倍。同样，当Square 2缩小时，它不会缩小到Square 1的一半大小 - 即使比率的收缩率为2比1。 这不是他们的大小 2比1或1比2.这是他们的收缩和增长的速度的比例。 一点数学计算容器的起始大小为640像素。在容器的每一边占用20px的填充后，这留下了足够的空间，两个方块恢复到它们的flex-basis的300px. 当容器设置为430px时，我们丢失了210px的空间。正方形1，flex-shrink:1，失去70px。方形2，flex-shrink: 2，失去140px。 当容器缩小到340px时，我们现在已经失去了300像素的空间。方块1损失100像素，方块2损失200像素. 损失的空间根据它们各自的收缩率（2:1）的比率来分割。 flex-grow同样。当容器增长到940px，我们获得了300px的空间，Square 1获得了额外的200px，Square 2获得了额外的100px。 在上面的GIF中，您可以看到宽度如何根据比率进行调整，增量（Δ）显示与基于flex-basis的差异。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>Flexbox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过动图简单通俗地了解Flexbox的工作原理（一）]]></title>
    <url>%2F2017%2F03%2F13%2Fan-animated-guide-to-flexbox-1.html</url>
    <content type="text"><![CDATA[Flexbox 的工作原理是怎样的，让我们通过彩色的动态图来了解。Flexbox 承诺将我们从平庸的 css 中解救出来（比如垂直对齐）。 好吧，Flexbox 确实实现了这一目标。但是掌握它这种新模式是一个挑战。 所以，让我们做一些动图来看看 Flexbox 是如何工作的，以便我们可以用它来构建更好的布局。 Flexbox 的基本原理就是让布局灵活直观。 为了做到这一点，让容器自己决定如何平均分配子节点，包括子节点的大小和它们之间的间隔。 这些原理听起来不错。不过还是让我们来看看实践中是怎样的。 这篇文章中，我们将深入介绍 Flexbox 的 5 个最常见的基本属性。我们将探索它们做了什么，我们可以怎样使用，以及它们的真实表现。 属性#1: Display: Flex 有四个不同大小的 div 放在一个灰色容器中。现在，每个 div 都设置为 display: block。每个 div 块都占据了整行行宽。 为了应用 Flexbox, 你需要先将你的 容器 变成 Flex 容器， 就像下面这样简单： #container { display: flex; } 并没有很大的改变——看起来只是 div 块排列成一行。但是在幕后，你做了一些很强大的事。你给这些方块一个 flex 上下文 现在你可以在这个上下文中去定位 div， 这比传统 css 要简单多了。 属性#2: Flex Direction一个 Flexbox 容器有两个坐标轴：一个主坐标轴 和 一个交叉坐标轴。默认看起来像这样: 默认地，元素按主轴方向排列，从左到右。 这是就为什么你应用 display: flex 时，元素会横向排列显示。 然而 Flex-direction 可以旋转你的主轴。 #container { display: flex; flex-direction: column; } 这里有个很重要的区别： flex-direction: column 并没有让方块按垂直坐标轴排列。它使垂直坐标轴变成主轴。 flex-direction 还有其他几个选项： row-reverse 和 column-reverse 属性#3: Justify ContentJustify-content 控制元素在主轴方向上的对齐方式。 这里，我们将深入主轴和交叉轴的区别。首先，让我们回到 flex-direction: row: #container { display: flex; flex-direction: row; justify-content: flex-start; } justify-content 有五个可取值： Flex-start Flex-end Center Space-between Space-around Space-around 和 space-between 是最不直观的。space-between 只在元素之间插入间隙，而元素与容器之间则没有。 Space-around 在方块的每一边都插入相等的间隙。这意味着，最边上方块与容器之间的空隙只有方块之间的空隙的一半（每个方块都贡献不重叠的相等间隙，所以加倍了） 最后要注意的是 justify-content 只作用在主轴，而 flex-direction 则切换主轴方向。这对接下来十分重要… 属性 #4: Align Items如果你理解了 justify-content, align-items 理解起来是轻而易举的。 就像 justify-content 只对主轴起作用， align-items 则只对垂直坐标轴起作用。 让我们看一下 align-items 的取值： flex-start flex-end center stretch baseline 前三个就和 justify-content 一样，没有悬念。 接下来两个有点难理解。 stretch 意味着占满整个垂直坐标轴的大小。 baseline 表示元素对齐段落标签的底部。 （注意： align-items: stretch，必须将高度属性设置为 auto ， 否则将会覆盖 stretch 属性） 对于 baseline ，如果删除所有段落标签，将会对齐所有元素底部。就像这样： 为了更好地演示主轴和交叉轴的区别，让我们合并应用 justify-content 和 align-items，然后看看 flex-direction 不同取值的区别： 即使在这两种情况下，正方形都垂直和水平居中，但两者不可互换。 属性#5: Align SelfAlign-self 允许你手动控制指定元素的排列方式。 这基本上是覆盖一个元素的 align-items 的属性。所有属性值都是一样的，虽然默认是 auto，但是继承容器的 align-items 属性。 #container { align-items: flex-start; } .square#one { align-self: center; } /*只有这个方块是居中的*/ 看看是怎样的表现。设置两个方块的 align-self 属性，其余的设置成 align-items: center 和 flex-direction: row。 结论即使我们刚刚了解了 Flexbox 的皮毛，这些命令应该足以让您处理最基本的对齐方式，并让内容在容器中垂直对齐。 【翻译原文】： How Flexbox works — explained with big, colorful, animated gifs]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>Flexbox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js遍历Object对象可枚举属性、不可枚举属性、原型链属性和自身属性]]></title>
    <url>%2F2017%2F01%2F13%2Fhow-to-enumerate-object-properties.html</url>
    <content type="text"><![CDATA[js遍历Object对象可枚举属性、不可枚举属性、原型链属性和自身属性利用hasOwnProperty、getOwnPropertyNames、Object.keys、for…in遍历对象的可枚举属性、不可枚举属性、原型链上的属性和自身属性。 首先来看看各种方法的用法及兼容性。 hasOwnPropertyObject.prototype.hasOwnProperty(name) 方法用来判断某个对象是否含有指定的自身属性，它本身是对象原型链上的默认方法。 hasOwnProperty 方法是 ES3 就标准化了，所以不用担心兼容性问题。 但由于 hasOwnProperty 是原型链上的方法，所以有可能被对象的自身方法所屏蔽。如： var foo = { hasOwnProperty: function() { return false; }, bar: 'Here be dragons' }; foo.hasOwnProperty('bar'); // 始终返回 false // 如果担心这种情况，可以直接使用原型链上真正的 hasOwnProperty 方法 ({}).hasOwnProperty.call(foo, 'bar'); // true Object.prototype.hasOwnProperty.call(foo, 'bar'); // true getOwnPropertyNamesObject.getOwnPropertyNames(obj)方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组, 该方法不会获取到原型链上的属性。如： // 父类构造函数 function ParentClass() {} ParentClass.prototype.inheritedMethod = function() {}; // 继承 var ChildClass = Object.create(ParentClass.prototype, { // 不可枚举属性 getFoo: { value: function() { return this.foo; }, enumerable: false } }); // 自身可枚举属性 ChildClass.foo = 1; // 再定义一个原型链属性 ChildClass.prototype.prototypeMethod = function() {}; console.log(Object.getOwnPropertyNames(my_obj).sort()); // ["foo", "getFoo"] 兼容性到 IE9, es 5标准。 Object.keys()返回该对象的所有可枚举自身属性的属性名。 //具有随机键排序的数组类对象 var an_obj = { 100: 'a', 2: 'b', 7: 'c' }; console.log(Object.keys(an_obj)); // console: ['2', '7', '100'] 这些属性的顺序与手动遍历（如for..in）该对象属性时的一致。 注意：Object.keys 和 getOwnPropertyNames ，在ES5，如果此方法的参数不是一个对象（原始的），那么它会造成 TypeError。在ES6，非对象的参数将被强制转换为一个对象。 Object.keys("foo"); Object.getOwnPropertyNames("foo"); // TypeError: "foo" is not an object (ES5 code) Object.keys("foo"); // ["0", "1", "2"] (ES6 code) Object.getOwnPropertyNames("foo"); // ["0", "1", "2", "length"] (ES6 code) 兼容性到 IE9, es 5标准。 for..in手动遍历，可以遍历到自身和原型链上所有可枚举的属性。 只获取自身可枚举属性 直接用 Object.keys() IE9 以下可以通过hasOwnProperty实现： if (!Object.keys) Object.keys = function(o) { if (o !== Object(o)) throw new TypeError('Object.keys called on a non-object'); var k=[],p; for (p in o) if (Object.prototype.hasOwnProperty.call(o,p)) k.push(p); return k; } 只获取自身不可枚举属性 通过 Object.keys() 排除可枚举属性 var target = myObject; var enum_and_nonenum = Object.getOwnPropertyNames(target); // 排除可枚举属性 var enum_only = Object.keys(target); var nonenum_only = enum_and_nonenum.filter(function(key) { var indexInEnum = enum_only.indexOf(key); if (indexInEnum == -1) { // not found in enum_only keys mean the key is non-enumerable, // so return true so we keep this in the filter return true; } else { return false; } }); console.log(nonenum_only); 通过propertyIsEnumerable判断，该方法返回Boolean值，不可枚举返回false。 var target = myObject; var enum_and_nonenum = Object.getOwnPropertyNames(target); var enum_only = Object.keys(target); var nonenum_only = enum_and_nonenum.filter(function(key) { // 筛选不可枚举属性 return !target.propertyIsEnumerable(key) }); console.log(nonenum_only); 只获取原型链上的可枚举属性 直接用 for..in var o = Object.getPrototypeOf(targetObj); // 跳过遍历自身属性，直接从原型上开始 var k=[],p; for (p in o) if (Object.prototype.hasOwnProperty.call(o,p)) k.push(p); return k; 注意，这样遍历出来的属性也不一定能访问， 因为自身属性可能会屏蔽掉原型上的属性。 只获取原型链上的不可枚举属性比较麻烦，如果使用 getOwnPropertyNames，只能单独获取一层原型链，必须一级一级遍历往上找，而且这也不一定有场景，因为原型链上的方法重名是会被屏蔽的。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>getOwnPropertyNames</tag>
        <tag>hasOwnProperty</tag>
        <tag>Object.keys</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[比较instanceof与isPrototypeOf]]></title>
    <url>%2F2017%2F01%2F12%2Fcompare-instanceof-with-isPrototypeof.html</url>
    <content type="text"><![CDATA[比较instanceof与isPrototypeOf在javascript中，instanceof 和 isPrototypeOf 都可以判断一个原型是否在另一个实例的原型链中，那他们有什么区别呢，为什么说 isPrototypeOf 可以替代 instanceof 。 instanceof 用法function Super() { // init code } function Sub() { Super.call(this); // other init code } Sub.prototype = new Super(); var sub = new Sub(); 对于上面的代码，用 instanceof 可以像这样确定他们的关系： sub instanceof Super; // true isPrototypeOf 用法复用上面的代码，用 isPrototypeOf 可以这样写： Super.prototype.isPrototypeOf(sub); // true 区别乍一看，都可以用，但某种情况下是有区别的，例如： var super = { // some super properties } var sub = Object.create(super); sub.someProp = 5; var sub = Object.create(sub); console.log(super.isPrototypeOf(sub)); // true console.log(sub instanceof super); // TypeError 这时候 super 并不是构造函数，无法使用 instanceof, 只能使用 isPrototypeOf. 结论结论就是 isPrototypeOf 能使用的场景更广，完全可以替代 instanceof， 只是写起来没那么简洁。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>instanceof</tag>
        <tag>isPrototypeOf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript通过Vibration API实现手机振动反馈提高用户体验]]></title>
    <url>%2F2017%2F01%2F10%2Fuse-javascript-vibration-feedback-to-improve-user-experience.html</url>
    <content type="text"><![CDATA[javascript通过Vibration API实现手机振动反馈提高用户体验目前大多数的移动设备均具备硬件能力支持振动，让软件代码通过使设备摇晃来向用户提供物理反馈。Vibration API 为 Web应用程序提供访问此硬件的能力。如果设备不支持，则不会产生任何效果。 振动描述振动被抽象成【开-关】脉冲的模式，且可以具有变化的长度。参数可以是单个整数，表示持续振动的毫秒数 (ms)；或可由多个整数组成的数组，达到振动和暂停循环的效果。只要单一 window.navigator.vibrate() 函式即可控制振动。 单次振动你可指定单一数值，或用只有一个数值成员的数组，让设备振动 1 次： window.navigator.vibrate(200); window.navigator.vibrate([200]); 以上两个例子都可以使设备振动 200 ms. 多次振动一个数组的值描述了装置振动与不振动的交替时间段。数组中的每个值都转换为整数，然后交替解释为设备应该振动的毫秒数和不振动的毫秒数。例如: window.navigator.vibrate([200, 100, 200]); 这会使设备振动200 ms，然后暂停100 ms，然后再次振动设备200 ms。 您可以根据需要设定多个振动/暂停对，数组的值可以是偶数或奇数个； 值得注意的是，由于振动在每个振动周期结束时自动停止，因此您不必提供最后一个值去暂停，换句话说，数组长度只需要设置奇数个。 停止振动当调用 window.navigator.vibrate() 的参数为「0」、空白数组，或数组全为「0」时，即可取消目前进行中的振动。 持续振动一些基于setInterval和clearInterval操作将允许您创建持续的振动： var vibrateInterval; // Starts vibration at passed in level function startVibrate(duration) { navigator.vibrate(duration); } // Stops vibration function stopVibrate() { // Clear interval and stop persistent vibrating if(vibrateInterval) clearInterval(vibrateInterval); navigator.vibrate(0); } // Start persistent vibration at given duration and interval // Assumes a number value is given function startPeristentVibrate(duration, interval) { vibrateInterval = setInterval(function() { startVibrate(duration); }, interval); } 当然上面的代码片段没有考虑到振动参数为数组情况; 基于阵列的持久性振动将需要计算数组项的和，并基于该数量创建周期（可能具有额外的延迟）。 生成振动节奏可以通过vibe.js tool这个工具来生成你需要的振动频率，然后复制它到你的代码里。 lib我写了一个小lib，方便使用vibrate.js demo: DEMO 译自： MDN Vibration API]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>html5</tag>
        <tag>Vibration</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由lodash引出数组Array的slice方法性能探究]]></title>
    <url>%2F2016%2F11%2F25%2Fexplore-lodash-and-slice-of-Array-slice-peformance.html</url>
    <content type="text"><![CDATA[由lodash引出数组Array的slice方法性能探究lodash 源码中，发现数组截取操作并没有直接使用array的slice方法，而是写了个 baseSlice 方法，更重要的是 baseSlice 方法里，也并没有使用 slice 方法，而是使用循环索引的方式去实现。这让我陷入思考，难道原生Array的slice方法还不如循环快？ lodash 源码如下： function baseSlice(array, start, end) { var index = -1, length = array.length; if (start &lt; 0) { start = -start > length ? 0 : (length + start); } end = end > length ? length : end; if (end &lt; 0) { end += length; } length = start > end ? 0 : ((end - start) >>> 0); start >>>= 0; var result = Array(length); while (++index &lt; length) { result[index] = array[index + start]; } return result; } 于是就开始写代码比较： 操作长度为100的数组，执行10000次： var baseArray = []; var i = -1; while (++ i &lt; 100) { // 定义一个10000长度的数组以供使用 baseArray[i] = i; } console.time('slice with no args'); for (var i = 0; i &lt; 10000; i++){ baseArray.slice(); } console.timeEnd('slice with no args'); console.time('slice with args'); for (var i = 0; i &lt; 10000; i++){ baseArray.slice(20, 40); } console.timeEnd('slice with args'); console.time('index'); for (var i = 0; i &lt; 10000; i++){ var result = Array(100); var index = -1; var length = baseArray.length; while (++index &lt; length) { result[index] = baseArray[index]; } } console.timeEnd('index'); console.time('index with no init array'); for (var i = 0; i &lt; 10000; i++){ var result = []; var index = -1; var length = baseArray.length; while (++index &lt; 20) { result[index] = baseArray[index]; } } console.timeEnd('index with no init array'); 对比结果： // chrome 版本 54.0.2840.98 (64-bit) slice with no args: 93.3ms slice with args: 175ms index: 365ms index with no init array: 546ms // safari 版本 9.0.2 (11601.3.9) slice with no args: 122.152ms slice with args: 117.181ms index: 60076.301ms index with no init array: 62055.406ms //firefox 50.0 slice with no args: 462.07ms slice with args: 442.25ms index: 194206.08ms index with no init array: 184714.59ms 由于mac ox无法测试IE, 可以看出，chrome总体要比safafi、firefox快很多； slice方法上，safari和chrome差不多， chrome下slice有参数比无参数慢； 新建数组Array()和 []性能差不多； 这么看来，那用原生 slice 明显会更好，为什么 lodash 要用循环索引呢？难道是因为一般应用数组都不会这么大，那改成长度为100的数组进行操作； // chrome slice with no args: 6ms slice with args: 4.12ms index: 5.82ms index with no init array: 7.96ms // safari slice with no args: 9.158ms slice with args: 8.432ms index: 640.311ms index with no init array: 643.174ms //firefox slice with no args: 17.56ms slice with args: 17.53ms index: 2174.15ms index with no init array: 2198.15ms 发现结论并没有改变。 然后就向lodash提了question, 回复是： The perf wins of Array#slice vs. baseSlice depends on the size of the array. That is a minor point though as the perf of that method is not likely to be an issue. The reason we use baseSlice is because we treat arrays as dense while Array#slice will respect sparse arrays. 大概意思是，他觉得性能没有太大的差别，Array#slice和baseSlice性能强弱取决于数组的大小。这里采用baseSlice是因为他们要视所有为密集数据，而Array#slice会处理稀疏数组。 然后就有下面的测试： 使用 Array#slice和baseSlice 分别截取数组其中一段，循环1000000次： var baseArray = []; var i = -1; while (++ i &lt; 100000) { // 定义一个10000长度的数组以供使用,这里数组长度并不影响性能，性能影响主要在于截取的长度。 baseArray[i] = i; } console.time('slice with args'); for (var i = 0; i &lt; 1000000; i++){ baseArray.slice(0, 20); } console.timeEnd('slice with args'); console.time('index'); for (var i = 0; i &lt; 1000000; i++){ var result = Array(20); var index = -1; while (++index &lt; 20) { result[index] = baseArray[index]; } } console.timeEnd('index'); 不同截取长度在chrome下的效果： // 截取长度 20 slice with args: 110ms index: 78.9ms // 截取长度 30 slice with args: 114ms index: 112ms // 截取长度 30 slice with args: 132ms index: 146ms 由此看出，截取长度为30左右时，Array#slice和loop方式性能基本一样，而 Array#slice 基本不受截取长度的影响。 所以结论是，当长度为30以下时，lodash的方法是比较高效的，当然，这影响微乎其微。像_.chunk方法，一般场景分组都不会太长。 疑惑是，对我的回复的后半句我没怎么看懂，密集数据和稀疏数据对这有什么影响呢？]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>lodash</tag>
        <tag>array</tag>
        <tag>slice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Debounce and Throttle 的可视化解释]]></title>
    <url>%2F2016%2F11%2F17%2FDebounce-and-Throttle-explain-visualizatly.html</url>
    <content type="text"><![CDATA[Debounce and Throttle 的可視化解釋Debounce 和 Throttle是两个概念，我们可以在 JavaScript 中使用，以提高我们对执行功能的控制，在事件处理的时候特别有用。 比喻这两种技术都回答同样的问题“一个功能可以随着时间被推移多久？” Debounce：把它看成是“多个分组事件之一”。试想一下，你回家，再进入电梯，门正在关闭……，突然你的邻居出现在大厅，并试图跳上电梯。要有礼貌！并打开大门，他说：你等等，让我一起上。相同的情况下，可以与第三人再次发生，等等…这可能会延缓出发几分钟。 Throttle：把它看成是一个阀，它规定了执行的流程。我们可以判断函数可以在一定时间内被调用的最大次数。因此，再用电梯比喻..你有足够的礼貌，持续10秒等人，但一旦时间到了，你一定要走！ 无 Debounce 或 Throttle 事件处理程序就像一次只能一个人用的电梯：没有那么高效。 我希望这个坏比喻对你有所帮助，但有时言语并不会对掌握这些概念有多大的帮助，所以我创建了一个演示去理解 Debounce 和 Throttle 概念，并把它们应用到mousemove事件。 function elevator_departure(name){ alert(name + " was the last one. Nobody else? Let's go then"); }; var debounced_elevator_departure = $.debounce(200, false, elevator_departure); debounced_elevator_departure('John'); debounced_elevator_departure('Mike'); debounced_elevator_departure('Peter'); // You will see *only* one message, "Peter was the last one. Nobody else? Let's go then"; 我发现这3个人在JavaScript中都通过debounce和throttle执行了。我真的建议你先读一下 Ben Alman's 的文章，以便更好地理解 debounce 和 throttle. underscore 和 lodash 有不同的实现方式，但参数都是一样的（除了 throttle没有 trailing）. Underscore.js by Jeremy Ashkenas * Lodash.js by John-David Dalton * jQuery Plugin by Ben Alman. 演示这里是视觉演示: 这是截图： 注意： 这个的源代码演示在GitHub上托管。 如果你看到动画在浏览器中并不流畅，请在一个单独的页面打开演示，或者尝试在Chrome中。 我通过在鼠标区域 tapping来去在Android环境下演示它 每个单元代表约30毫秒，但JS是单线程的，所以浏览器是不是准确。这个演示并不是想成为一个最佳实践，只是为了更好地去理解概念。 当你做了setTimeout，时间间隔可能不同，在每个浏览器在4ms和15ms的之间（尼古拉斯Zakas的文章），甚至是setTimeout(fn,0)至少需要4毫秒。在另一方面，时间为1毫秒为最小单位的。 在mousemove第一行中的事件也有做节流（80毫秒）。这对理解演示有所帮助。 要获得 trailing选项$.throttle，你需要传递false。 不要忘了，这一切都是builder，他们返回一个函数，所以你只需要执行一次。 应用场景debounce 案例用它减少执行频繁的事件。例子： 当将要处理的textarea的快速打字：你不想执行处理函数，直到用户停止输入再来处理文本。 当数据保存到通过AJAX服务器：你不想每秒调用非常缓慢的邮件服务器 throttle 案例和debounce 一样，但如果想每隔一段时间必须执行事件，可以使用它： 假设用户不停地快速输入30秒，可能你会想每5秒执行一次函数； 一些对性能有影响的事件但又必须处理：scroll, mouseweel, mousemove。一个简单的鼠标滚轮运动可以在一秒钟内触发几十个事件。 本文翻译自 Debounce and Throttle: a visual explanation ========= update on 11-21 ========= exampledebouncevar validation = _.debounce(function () { ... // 校验输入，逻辑可能还会有点复杂 }, 250) jQuery('input').keyup(validation) // 输入完成或停顿250ms后才去执行校验，如果不停输入10s，则10s内都不会触发 /** * debounce第三个参数为可选参数， * leading为true时，则在事件开始时首先执行一次， 默认值为 false； * trailing为true时，则在结束时触发, 默认值为 true； * maxWait设置每隔多长时间必须触发； */ function foo () { ... } jQuery('input').on('keyup', _.debounce(foo, 300, { 'leading': true, // 注意： 执行的前提是定时器为undefined 'trailing': false, 'maxWait': 1000 })); // debounce还可以被取消 jQuery('button').on('click', function() { validation.cancel(); }); throttlefunction mousemove () { ... } jQuery('#div').on('mousemove', _.throttle(mousemove, 100)) // 每100ms必须触发一次 // mousemove会在定时器开始时触发, 但5分钟内不会有第二次 jQuery('#div').on('mousemove', _.throttle(mousemove, 300000, { 'leading': true, // 定时器前沿触发，默认值为true 'trailing': false // 定时器后沿触发，默认值为true })); // throttle 同样可以被取消 jQuery(window).on('popstate', throttled.cancel);]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>debounce</tag>
        <tag>throttle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 npm shrinkwrap 来管理项目依赖]]></title>
    <url>%2F2016%2F10%2F20%2Fuse-npm-shrinkwrap-to-manage-reference-projects.html</url>
    <content type="text"><![CDATA[使用 npm shrinkwrap 来管理项目依赖管理依赖是一个复杂软件开发过程中必定会遇到的问题。 在Node.js项目开发的时候，我们也经常需要安装和升级对应的依赖。虽然 npm 以及语意化的版本号 (semantic versioning, semver) 让开发过程中依赖的获取和升级变得非常容易， 但不严格的版本号限制，也带来了版本号的不确定性。主要的问题可能有三个： npm 建议使用 semver 的应用程序版本，但这也完全依赖第三方包遵守这一规则。如果你依赖于的包不遵循 semver ，或者依赖的包的新版本有重大更改（而你使用了 ^ 的宽泛版本安装），这潜在可能是会导致问题的。 另一个问题的出现是由于 npm 安装依赖的机制。npm 的安装包是有层次结构的，手动控制要安装的软件包的版本号可以实现，但是你只能在 package.json 使用精确的版本号控制你的直接依赖包，但那些多层以上的依赖就没办法控制了；一个第三方包不严谨的版本依赖生命可能破坏你的依赖管理。 在开发阶段执行得到的版本，和后续部署时得到的可能是不一致的，更不可控的是，你依赖的第三方包也有这样的情况会导致潜在的上线风险。 如果要控制上线的风险，我们就必需要解决这个问题，这时候，就需要使用 npm shrinkwrap 这个命令来解决问题。 npm shrinkwrapnpm shrinkwrap 可以按照当前项目 node_modules 目录内的安装包情况生成稳定的版本号描述。 比方说，有一个包 A { "name": "A", "version": "0.1.0", "dependencies": { "B": "]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>shrinkwrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Git-Hooks进行自动部署,让提交发布自动化]]></title>
    <url>%2F2016%2F08%2F11%2FGit-Hooks.html</url>
    <content type="text"><![CDATA[之前了解的自动化部署都是jekins这样集成化的成熟的工具。最近因为有朋友提交代码时，不想登陆服务器拉取代码，才了解到 git hooks。看来还是git使用不到位。之前一直都是本地开发并提交代码，测试时，人工登陆测试服务器去拉取最新代码。 网上资料还是比较多的，最后在本机测试是成功了的。 主要选要明白几个关键点： git init –bare post-receive 文件 SSH 认证 这几个都比较容易找到资料。 git init –bare和 git init 不一样的是，git init --bare并不存储实际代码，仓库文件夹不会看到任何项目代码，反而生成了一些 .git之外的文件夹，其中 hooks文件夹就是存放git命令操作后需要执行的脚本。 需要新建两个文件夹，一个执行git init --bare作为远端仓库，一个执行git init作为服务器项目目录。 本地开发目录和服务器项目目录的remote都要指向 服务器的远端仓库。 post-receive 文件post-receive 文件是git push 之后，执行的脚本文件，自动部署的脚本代码就写在这里。 如： #!/bin/sh unset GIT_DIR echo "远程开始更新" NowPath=`pwd` echo $NowPath DeployPath="../deploy" cd $DeployPath git pull origin master echo "远程更新完毕" cd $NowPath exit 0 这里有一点比较容易出问题的就是路径，最好还是使用绝对路径。 脚本里还可以加入任何想执行的脚本，比如打包编译。 不过要注意使用 chmod +x post-receive 改变一下权限，服务器端的配置就基本完成了。 SSH认证这个在 mac os x 和 linux都没有问题，我用别人的windows配置的时候经常都会出现认证失败，就算认证成功了，也无法执行脚本，对这个还是不太熟悉。我猜可能是 cmd 的问题，ssh 登陆后还遇到过乱码。 这些都配置好之后，本地开发只需要提交代码，服务器就可以预览最新代码了。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack-sourcemap选项应该选哪个]]></title>
    <url>%2F2016%2F08%2F08%2Fwebpack-sourcemap-options.html</url>
    <content type="text"><![CDATA[webpack-sourcemap选项应该选哪个使用 webpack 也有一段时间了，但是每次看到别的项目配置，还是会去浏览一遍。这次刚好看到一个 devtool: '#eval-source-map'，就有些好奇，之前都是默认使用 #source-map 并没有过多去注意它。google一下，发现这个 devtool 选项还不少，那我们到底选哪个呢，它们有哪些区别。 先来看看官方文档的相关描述： 有构建速度，重新构建速度，打包速度，来源 这几项的展示。 然后可以看看这一篇文章，对这几个选项描述得比较详细： https://chemzqm.me/webpack-sourcemap 摘出主要部分： eval 文档上解释的很明白，每个模块都封装到 eval 包裹起来，并在后面添加 //# sourceURL source-map 这是最原始的 source-map 实现方式，其实现是打包代码同时创建一个新的 sourcemap 文件， 并在打包文件的末尾添加 //# sourceURL 注释行告诉 JS 引擎文件在哪儿 hidden-source-map 文档上也说了，就是 soucremap 但没注释，没注释怎么找文件呢？貌似只能靠后缀，譬如 xxx/bundle.js 文件，某些引擎会尝试去找 xxx/bundle.js.map inline-source-map 为每一个文件添加 sourcemap 的 DataUrl，注意这里的文件是打包前的每一个文件而不是最后打包出来的，同时这个 DataUrl 是包含一个文件完整 souremap 信息的 Base64 格式化后的字符串，而不是一个 url。 eval-source-map 这个就是把 eval 的 sourceURL 换成了完整 souremap 信息的 DataUrl cheap-source-map 不包含列信息，不包含 loader 的 sourcemap，（譬如 babel 的 sourcemap） cheap-module-source-map 不包含列信息，同时 loader 的 sourcemap 也被简化为只包含对应行的。最终的 sourcemap 只有一份，它是 webpack 对 loader 生成的 sourcemap 进行简化，然后再次生成的。 webpack 不仅支持这 7 种，而且它们还是可以任意组合的，就如文档所说，你可以设置 souremap 选项为 cheap-module-inline-source-map。 结合官方的列表比较和引用的这篇文章的介绍，就比较容易选择合适的选项了。建议开发时使用 #cheap-module-eval-source-map，测试环境或线上有需要的话使用 #cheap-module-source-map]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>前端构建</tag>
        <tag>sourcemap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用ApplicationCache离线缓存做一个h5离线应用]]></title>
    <url>%2F2016%2F06%2F30%2Fuse-ApplicationCache-to-build-html5-offline-web-app.html</url>
    <content type="text"><![CDATA[使用ApplicationCache离线缓存做一个h5离线应用原生app可以离线操作，在以前是相对web app的优势，web必须联网才能刷新使用。虽然所有浏览器都有缓存机制，但它们并不一定总能起到预期的作用。HTML5 使用 ApplicationCache 接口解决了由离线带来的部分难题。即使用户在离线状态下按了刷新按钮，您的应用也会正常加载和运行。 使用缓存接口可为您的应用带来以下三个优势： 离线浏览 - 用户可在离线时浏览您的完整网站 速度 - 缓存资源为本地资源，因此加载速度较快。 服务器负载更少 - 浏览器只会从发生了更改的服务器下载资源。 引用清单文件manifest属性要启用某个应用的应用缓存，请在文档的 html 标记中添加 manifest 属性： &lt;!DOCTYPE html> &lt;html manifest="app.manifest"> ... &lt;/html> 您应在要缓存的网络应用的每个页面上都添加 manifest 属性。如果网页不包含 manifest 属性，浏览器就不会缓存该网页（除非清单文件中明确列出了该属性）。这就意味着用户浏览的每个包含 manifest 的网页都会隐式添加到应用缓存。因此，您无需在清单中列出每个网页。 manifest 属性可指向绝对网址或相对路径，但绝对网址必须与相应的网络应用同源。 清单文件格式与 MIME 类型设置清单文件可使用任何文件扩展名，但必须以正确的 text/cache-manifest MIME 类型提供。 下面是几件网络服务的配置例子： Apache: 新建或者编辑现有的 .htaccess 文件，在里面加上一行 AddType text/cache-manifest .manifest Nginx: 修改 mime.types 文件，在里面增加 manifest 文件的映射 text/cache-manifest manifest Tomcat： 修改 web.xml 文件，在里面增加 manifest text/cache-manifest 清单文件结构基本的清单格式： CACHE MANIFEST index.html stylesheet.css images/logo.png scripts/main.js 您需要注意以下几点： CACHE MANIFEST 字符串应在第一行，且必不可少。 网站的缓存数据量不得超过 5 MB。不过，如果您要编写的是针对 Chrome 网上应用店的应用，可使用 unlimitedStorage 取消该限制。 如果清单文件或其中指定的资源无法下载，就无法进行整个缓存更新进程。在这种情况下，浏览器将继续使用原应用缓存。 完整的清单格式： CACHE MANIFEST # daksfljs3kl23j3k43 hash 以便做版本控制 # 默认部分，显式缓存这些文件 CACHE: /favicon.ico index.html stylesheet.css images/logo.png scripts/main.js # 此部分下列出的文件是需要连接到服务器的白名单资源。无论用户是否处于离线状态，对这些资源的所有请求都会绕过缓存。 NETWORK: login.php /myapi http://api.twitter.com # 此部分是可选的，用于指定无法访问资源时的后备网页。其中第一个 URI 代表资源，第二个代表后备网页。两个 URI 必须相关，并且必须与清单文件同源。 # offline.jpg will be served in place of all images in images/large/ # offline.html will be served in place of all other .html files FALLBACK: images/large/ images/offline.jpg *.html /offline.html 应用缓存只在其清单文件发生更改时才会更新。例如，如果您修改了图片资源或更改了 JavaScript 函数，这些更改不会重新缓存。您必须修改清单文件本身才能让浏览器刷新缓存文件。 这些部分可按任意顺序排列，且每个部分均可在同一清单中重复出现; 可使用通配符。 请注意： HTTP 缓存标头以及对通过 SSL 提供的网页设置的缓存限制将被替换为缓存清单。因此，通过 https 提供的网页可实现离线运行。chrome 未来将会禁止非 https 网页使用 ApplicationCache 功能（updated 2016-06-30） 更新缓存应用在离线后将保持缓存状态，除非发生以下某种情况： 用户清除了浏览器对您网站的数据存储。 清单文件经过修改。请注意：更新清单中列出的某个文件并不意味着浏览器会重新缓存该资源。清单文件本身必须进行更改。 应用缓存通过编程方式进行更新。 缓存状态window.applicationCache 对象是对浏览器的应用缓存的编程访问方式。其 status 属性可用于查看缓存的当前状态： var appCache = window.applicationCache; switch (appCache.status) { case appCache.UNCACHED: // UNCACHED == 0 return 'UNCACHED'; break; case appCache.IDLE: // IDLE == 1 return 'IDLE'; break; case appCache.CHECKING: // CHECKING == 2 return 'CHECKING'; break; case appCache.DOWNLOADING: // DOWNLOADING == 3 return 'DOWNLOADING'; break; case appCache.UPDATEREADY: // UPDATEREADY == 4 return 'UPDATEREADY'; break; case appCache.OBSOLETE: // OBSOLETE == 5 return 'OBSOLETE'; break; default: return 'UKNOWN CACHE STATUS'; break; }; 用 js 调用 applicationCache.update() 将尝试更新用户的缓存（前提是已更改清单文件）。最后，当 applicationCache.status 处于 UPDATEREADY 状态时，调用 applicationCache.swapCache() 即可将原缓存换成新缓存。 var appCache = window.applicationCache; appCache.update(); // Attempt to update the user's cache. ... if (appCache.status == window.applicationCache.UPDATEREADY) { appCache.swapCache(); // The fetch was successful, swap in the new cache. } 请注意：以这种方式使用 update() 和 swapCache() 不会向用户提供更新的资源。此流程只是让浏览器检查是否有新的清单、下载指定的更新内容以及重新填充应用缓存。因此，还需要对网页进行两次重新加载才能向用户提供新的内容，其中第一次是获得新的应用缓存，第二次是刷新网页内容。 好消息是，您可以避免重新加载两次的麻烦。要使用户更新到最新版网站，可设置监听器，以监听网页加载时的 updateready 事件： // Check if a new cache is available on page load. window.addEventListener('load', function(e) { window.applicationCache.addEventListener('updateready', function(e) { if (window.applicationCache.status == window.applicationCache.UPDATEREADY) { // Browser downloaded a new app cache. // Swap it in and reload the page to get the new hotness. window.applicationCache.swapCache(); if (confirm('A new version of this site is available. Load it?')) { window.location.reload(); } } else { // Manifest didn't changed. Nothing new to server. } }, false); }, false); applicationCache 事件事件会用于监听缓存的状态。浏览器会对下载进度、应用缓存更新和错误状态等情况触发相应事件。以下代码段为每种缓存事件类型设置了事件监听器： var appCache = window.applicationCache; unction handleCacheEvent(e) { //... } function handleCacheError(e) { alert('Error: Cache failed to update!'); }; // Fired after the first cache of the manifest. appCache.addEventListener('cached', handleCacheEvent, false); // Checking for an update. Always the first event fired in the sequence. appCache.addEventListener('checking', handleCacheEvent, false); // An update was found. The browser is fetching resources. appCache.addEventListener('downloading', handleCacheEvent, false); // The manifest returns 404 or 410, the download failed, // or the manifest changed while the download was in progress. appCache.addEventListener('error', handleCacheError, false); // Fired after the first download of the manifest. appCache.addEventListener('noupdate', handleCacheEvent, false); // Fired if the manifest file returns a 404 or 410. // This results in the application cache being deleted. appCache.addEventListener('obsolete', handleCacheEvent, false); // Fired for each resource listed in the manifest as it is being fetched. appCache.addEventListener('progress', handleCacheEvent, false); // Fired when the manifest resources have been newly redownloaded. appCache.addEventListener('updateready', handleCacheEvent, false); 如果清单文件或其中指定的资源无法下载，整个更新都将失败。在这种情况下，浏览器将继续使用原应用缓存。 原文： 应用缓存初级使用指南 html标准]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>ApplicationCache</tag>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正确检测Javascript数据类型]]></title>
    <url>%2F2016%2F06%2F08%2Fhow-to-get-Javascript-type-of-variables-correctly.html</url>
    <content type="text"><![CDATA[如何正确检测Javascript数据类型 typeof对于任何变量来说，使用typeof 总是以字符串形式返回以下6种类型之一： number string boolean object function undefined 要注意 null 使用 typeof 检测时返回的是 ‘object’ 对于 null 可以使用 function type(o) { return (o === null) ? 'null' : typeof(o) } constructor(构造函数属性值)使用 constructor 属性可以判断绝大部分数据的类型。 var a = 1; a.constructor // number var a = {}; a.constructor // object var a = []; a.constructor // array var a = true; a.constructor // boolean var a = 'true'; a.constructor // string var a = function aaa(){}; a.constructor // function 但是对于 undefined 和 null 特殊值，不能能使用 constructor,会直接抛出异常。可以先转换布尔值，如果为 true，则说明不是 undefined 和null , 再调用 constructor属性 function type(o) { return !o ? o : (o).constructor } Object.prototype.toString使用 toString() 方法检测对象类型是最安全、最准确的。它返回的字符串形式如下 [object class], 其中， object表示对象的通用类型，class表示对象的内部类型。 但是，要获取对象class值的唯一方法是必须调用 Object 对象定义的默认 toString() 方法，因为不同对象都会预定义自己的 toString() 方法，所以不能直接调用对象的 toString() 方法。 var a = new Date() a.toString() // 当前的UTC时间字符串 var a = new Date() Object.prototype.toString.apply(a) 完善的检测方法 // 返回值有： 'undefined', 'null', 'number', 'boolean', 'object', 'function', 'regexp', 'string', 'array', 'date', 'error' function typeOf(o) { var _toString = Object.prototype.toString; var _type = { 'undefined': 'undefined', 'number': 'number', 'boolean': 'boolean', 'string': 'string', '[object Function]': 'function', '[object RegExp]': 'regexp', '[object Array]': 'array', '[object Date]': 'date', '[object Error]': 'error' } return _type[typeof o] || _type[_toString.call(o)] || (o ? 'object' : 'null') }]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>typeof</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 小记]]></title>
    <url>%2F2016%2F05%2F16%2Fgit-mardown.html</url>
    <content type="text"><![CDATA[有一些不太常用的git命令记录下 git amend当一些更改已提交，却发现漏提交了一部分文件，这时就可以用这个命令，可以把漏的部分追加到上一次提交 git add forgotten_file.rb git commit ––amend reset soft刚刚提交，却又发现刚才的代码还有bug，想再次修改后再提交 git reset ––soft HEAD^ 注意与 git reset --hard HEAD^ 不同的是，--soft并不同把上一次提交的代码删除，只是把它变成未提交的状态，而--hard却会完全撤消上一次提交的代码。 git blame当你想查出，一个文件里，每一行代码是谁编辑的，可以使用这个命令 git blame robin.md git checkout tags/v1.0当分支名和标签名相同时，需要这样写 branch_at当你想从某一历史版本中开一个分支，而不是最新的版本中开分支，可以这样写： git branch test_branch eadnadk213dsafdsafkl234j32ll34l2l rebase当远程mater分支已更改， 本地又基于旧版本的master进行的提交，可以重新指定基于远程master，之后再提交，避免冲突时把远程的代码merge 掉： git rebase origin/master master git push origin master git reflogreflog是git用来记录引用变化的一种机制，比如记录分支的变化或者是HEAD引用的变化。可以用来查找操作记录以及恢复数据 git submodule add添加外部项目为子模块 git rebase -i]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pm2一个带有负载均衡功能的Node应用的进程管理器]]></title>
    <url>%2F2016%2F05%2F04%2Fpm2-Node-process-manager.html</url>
    <content type="text"><![CDATA[pm2一个带有负载均衡功能的Node应用的进程管理器PM2是一个提供了内置的负载均衡的Node.js应用程序进程管理器。它可以让你保持应用程序永远在线，无需停机地重启应用，也有助于系统管理员工作。 安装 PM2$ npm install pm2 -g 启动应用$ pm2 start app.js 这样，应用就已经在后台启动，并被监测保持在线。 模块系统PM2 内嵌一个简单强大的模块系统，可以直接像下面这样安装模块 $ pm2 install &lt;module_name> pm2-logrotate 日志管理及分割模块 pm2-webshell 强大的浏览器模拟终端 pm2-auto-pull 持续集成，自动拉取代码 更新PM2# Install latest pm2 version $ npm install pm2 -g # Save process list, exit old PM2 &amp; restore all processes $ pm2 update 主要特性命令概览$ npm install pm2 -g # Install PM2 $ pm2 start app.js # Start, Daemonize and auto restart application $ pm2 start app.js -i 4 # Start 4 instances of application in cluster mode # it will load balance network queries to each app $ pm2 start app.js --name="api" # Start application and name it "api" $ pm2 start app.js --watch # Restart application on file change $ pm2 start script.sh # Start bash script $ pm2 list # List all processes started with PM2 $ pm2 monit # Display memory and cpu usage of each app $ pm2 show [app-name] # Show all informations about application $ pm2 logs # Display logs of all apps $ pm2 logs [app-name] # Display logs for a specific app $ pm2 flush $ pm2 stop all # Stop all apps $ pm2 stop 0 # Stop process with id 0 $ pm2 restart all # Restart all apps $ pm2 reload all # Reload all apps in cluster mode $ pm2 gracefulReload all # Graceful reload all apps in cluster mode $ pm2 delete all # Kill and delete all apps $ pm2 delete 0 # Delete app with id 0 $ pm2 scale api 10 # Scale app with name api to 10 instances $ pm2 reset [app-name] # Reset number of restart for [app-name] $ pm2 startup # Generate a startup script to respawn PM2 on boot $ pm2 save # Save current process list $ pm2 resurrect # Restore previously save processes $ pm2 update # Save processes, kill PM2 and restore processes $ pm2 generate # Generate a sample json configuration file $ pm2 deploy app.json prod setup # Setup "prod" remote server $ pm2 deploy app.json prod # Update "prod" remote server $ pm2 deploy app.json prod revert 2 # Revert "prod" remote server by 2 $ pm2 module:generate [name] # Generate sample module with name [name] $ pm2 install pm2-logrotate # Install module (here a log rotation system) $ pm2 uninstall pm2-logrotate # Uninstall module $ pm2 publish # Increment version, git push and npm publish 开启进程的多种方式$ pm2 start app.js --watch # Restart application on file change $ pm2 start script.sh # Start bash script $ pm2 start app.js -- -a 34 # Start app and pass option -a 34 $ pm2 start app.json # Start all applications declared in app.json $ pm2 start my-python-script.py --interpreter python 进程管理列出所有进程： $ pm2 list 管理进程 $ pm2 stop &lt;app_name|id|'all'|json_conf> $ pm2 restart &lt;app_name|id|'all'|json_conf> $ pm2 delete &lt;app_name|id|'all'|json_conf> 查看进程的详情 $ pm2 describe &lt;id|app_name> CPU / 内存监测$ pm2 monit 日志工具pm2 logs ['all'|'PM2'|app_name|app_id] [--err|--out] [--lines &lt;n>] [--raw] [--timestamp [format]] 例： $ pm2 logs $ pm2 logs WEB-API --err $ pm2 logs all --raw $ pm2 logs --lines 5 $ pm2 logs --timestamp "HH:mm:ss" $ pm2 logs WEB-API --lines 0 --timestamp "HH:mm" --out $ pm2 logs PM2 --timestamp $ pm2 flush // Clear all the logs 开机启动PM2可以自动生成并配置开机启动脚本，让服务器在重启的时候可以保持应用在线 $ pm2 startup # auto-detect platform $ pm2 startup [platform] # render startup-script for a specific platform, the [platform] could be one of: # ubuntu|centos|redhat|gentoo|systemd|darwin|amazon 更多查看>>]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[子进程child_process让Node.js具备命令行的功能]]></title>
    <url>%2F2016%2F04%2F22%2Fchild-process-make-Node-js-have-bash-feature.html</url>
    <content type="text"><![CDATA[在Node中使用子进程的目的，正是希望从Node应用程序中通过命令行的方式访问计算机资源。 共有四种不同的技术来创建一个子进程 child_process.spawnspawn是创建子进程最常见的方法。例： var spawn = require('child_process').spawn, pwd = spawn('pwd'); pwd.stdout.on('data', function(data){ console.log('stdout:' + data); }); pwd.stderr.on('data', function(data){ console.log('stderr' + data); }); pwd.on('close', function(code){ console.log('child process close with code' + code); }); pwd.on('exit', function(code){ console.log('child process exit with code' + code); }); 参数作为数组传入 子进程对 stdout 和 stderr 相关事件可以进行捕获 子进程退出代码为 1，表示发生了错误；没有错误时，退出代码为 0 尽量使用close事件而不是exit事件，在进程结束后访问其数据可能会导致应用程序崩溃 如何使用 stdin 标准输入对象呢： var spawn = require('child_process').spawn, find = spawn('find', ['.', '-ls']), grep = spawn('grep', ['test']); grep.stdout.setEncoding('utf8'); find.stdout.on('data', function(data){ grep.stdin.write(data); }); grep.stdout.on('data', function(data){ console.log(data); }) 上面这段例子模拟了Unix管道（|）功能，可以将一个命令的结果传递给另一个命令作为输入。 child_process.exec 和 child_process.execFile通过 child_process.exec 和 child_process.execFile 来启动 shell 执行命令可以缓存命令执行的结果 child_process.execFile 的第一个参数是命令或执行文件路径， 第二个参数是可选参数列表， 第三个参数是回调函数，该回调函数有三个参数： error, stdout 和 stderr。如果没有发生错误，执行结果会保存到 stdout。 child_process.exec 则没有可选参数列表，只有 execFile 方法的第一个和第三个参数。 var execFile = require('child_process').execFile, child; child = execFile('ls', ['-l'], function(error, stdout, stderr){ if (error == null) { console.log('stdout: ' + stdout); } }); execFile 方法会更安全，因为它的命令行参数作为数组传入。 child_process.forkfork 其实是对 spawn的封装，目的是为了启动子进程并运行 Node.js模块。 例： fork('./child.js') 相当于 spawn('node', ['./child.js']) 此方法会在父进程与子进程之间建立一个真实的通信管道，用于进程之间的通信。但通过fork生成的每个子进程都需要一个全新的 V8 实例，这需要耗费更多时间和内存。 var n = child_process.fork('./child.js'); n.on('message', function(m) { console.log('PARENT got message:', m); }); n.send({ hello: 'world' }); send 方法用于进程间通信， 通过监听message事件来获取消息]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>child_process</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-v15.0升级指南]]></title>
    <url>%2F2016%2F04%2F19%2FReact-v15-0-upgrade-guide.html</url>
    <content type="text"><![CDATA[React-v15.0升级指南 主要变化加入document.createElement 并且废弃 data-reactid经过我们讨论，DOM 有很大的改变。其中最值得关注的一个变化就是，我们不再给每个 DOM设置data-reactid属性。虽然这更难看出一个网页是否使用了 React，但优势是DOM更轻量了。这一改变让我们使用 document.createElement来初始渲染成为可能。在此之前，我们会生成大量的HTML字符串，然后使用 node.innerHTML来插入。当时，我们决定尽快在大部分案例和支持的浏览器中使用document.createElement。浏览器持续地改善，因此兼容所有浏览器不再是正确的。使用 createElement可以让React的其他功能运行得更快。原来的ids用来映射React组件的事件，这意味着，我们不得不对每一个事件做很多工作，即使我们尽可能地缓存这些数据。正如我们遇到过的，缓存和缓存失效很容易出错，我们发现许多问题都无法重现。现在我们在渲染的时候可以直接建立映射，因为我们有了节点的钩子。 data-reactid仍然存在于服务端渲染中。不管怎样，这已经比以前要小很多了，并且这只是一个简单的自增计数器。 不再有额外的 标签另一个关于DOM讨论的重大变化是如何渲染文本块。之前你可能关注到React渲染了很多额外的标签。举个例子，我们在主页渲染Hello {this.props.name}，结果包含了两层标签。现在我们渲染时使用注释节点穿插在普通文本外来划分。这让我们同样拥有更新部分文本的能力，而不用额外的标签。很少人会这些真实的额外标签有依赖，所以你很可以不会受到任何影响。但是如果你在样式文件中对标签有定义，你可能需要作出相应的调整。你仍然可以在你的组件里显式地指定渲染这些标签。 现在使用注释节点渲染 null我们还利用注释节点来渲染null。渲染null是我们在React v0.11版本添加的特性，并且通来渲染 元素来应用。现在通过渲染注释节点，你的样式可能会有一些错乱，尤其是当你使用了:nth-child这样的选择器。React使用标签，一直在考虑如何React命中DOM的实现细节。我们相信这些变化是安全的。另外，我们已经在许多典型的应用中看到这些变化在提升React的性能。 组件现在也可以返回 null我们在React v0.14添加了定义无状态组件的功能。不管怎样，React 0.14仍然允许你定义一个非继承React.Component或者使用 React.createClass()创建的组件。所以我们不能准确地判断你的组件是一个函数还是一个类，并且也不允许你从中返回一个null。这个问题在React 15中已经解决，你可以在你任何组件中返回null，不管是函数还是类。 增加SVG支持所有的SVG标签现在都已完美支持。（极少的标签在React.DOM里不存在，但JSX和React.createElement支持所有标签名）。所有被浏览器支持的SVG属性也全部支持。如果你发现少了什么属性，请给我们提 issue。 本文翻译自 React v15.0]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-router动态路由与webpack分片thunks]]></title>
    <url>%2F2016%2F04%2F18%2Freact-router-and-Webpack-thunks.html</url>
    <content type="text"><![CDATA[react-router动态路由与webpack分片thunks对于大型应用来说，一个首当其冲的问题就是所需加载的 JavaScript 的大小。程序应当只加载当前渲染页所需的 JavaScript。有些开发者将这种方式称之为“代码分拆” — 将所有的代码分拆成多个小包，在用户浏览过程中按需加载。 对于底层细节的修改不应该需要它上面每一层级都进行修改。举个例子，为一个照片浏览页添加一个路径不应该影响到首页加载的 JavaScript 的大小。也不能因为多个团队共用一个大型的路由配置文件而造成合并时的冲突。 路由是个非常适于做代码分拆的地方：它的责任就是配置好每个 view。 如果你使用过单页应用的框架，那你可能应用过路由。路由可以让你的应用看起来好像有很多“页面”。用户可以通过 youdomain.com/about来获取公司相关的介绍信息。 在这里使用双引号，是因为这并不是一个真正意义上的“页面”。 通过各种流行的构建工具的配置，所有的脚本最后都得到连成一片巨大的.js文件。当你访问 youdomain.com/about 这个页面的时候，你会下载应用程序的所有内容。但用户可能根本不想，也不会去浏览这些内容。这是非常糟糕的，也会让你的应用变得越来越大。 对于一个不使用任何框架的普通网页，你首先是下载一个 .html 文件，然后是从缓存中获取脚本和样式文件。用户只下载他需要的内容，仅此而已。 你想让你的React.js应用也按需加载吗？ 前提条件 使用 react-router 做为路由解决方案，因为这是功能最强大的 React路由方案； webpack作为构建工具，因为它有强大的分片能力和齐全的功能 react-router下面是一个常见的路由例子： var HomePage = require('./HomePage.jsx'); var AboutPage = require('./AboutPage.jsx'); var FAQPage = require('./FAQPage.jsx'); &lt;Router history={history}> &lt;Route path="/" component={HomePage} /> &lt;Route path="/about" component={AboutPage} /> &lt;Route path="/faq" component={FAQPage} /> &lt;/Router> 为了方便解释，省略了很多代码 如果一个用户浏览 yourdomain.com/about页面，他将看到AboutPage 组件；如果查看 yourdomain.com/faq页面，将看到 FAQPage组件等等。当你使用路由去配置你的应用，这些组件和相关代码将被打包成一个.js文件。 值得庆幸的是，react-router的 标签有一个叫做getComponent的异步的方法去获取组件。他是一个function接受两个参数，分别是location和callback。当react-router执行回调函数 callback(null, ourComponent)时，路由只渲染ourComponent组件。 getComponent让我们来重写上面的例子来支持异步组件： &lt;Router history={history}> &lt;Route path="/" getComponent={(location, callback) => { // 在这里执行异步操作 callback(null, HomePage); }} /> &lt;Route path="/about" getComponent={(location, callback) => { // 在这里执行异步操作 callback(null, AboutPage); }} /> &lt;Route path="/faq" getComponent={(location, callback) => { // 在这里执行异步操作 callback(null, FAQPage); }} /> &lt;/Router> 这些组件会在需要的时候异步加载。这些组件仍然会在同一个文件中，并且你的应用看起来不会有任何不同。但是没有它，我们的网页将无法运行。 webpackwebpack 有一个特性叫做 chunking（分片），意思就是通过输出多个文件（chunks）来替代一个总的大的文件。你代码里的分割点（split points）决定了哪些模块被分到哪些文件里。 Split Points(分块点)webpack 提供了很多方式去让我们设置分块点。但最有用的一个就是 require.ensure方法。下面是一个例子： function loadModule() { require.ensure([], function(require) { var module = require('module.js'); }, "MyModule"); } module.js 模块将通过webpack 输出在第二个文件里，并且当浏览器执行require.ensure的时候加载。（当loadModule被调用的时候并不会加载） require.ensure方法的第三个参数是指定模块名称。它是一个可选项，如果不填，将会自动生成一个 ID作为文件名。 这离成功还差一步，我们还需要配置webpack.config.js文件来支持分片thunks 配置在webpack 配置文件中的 output选项设置chunkFilename: output: { chunkFilename: '[name].chunk.js' } 你也可以设置[chunkhash]和[ID]变量作为分块的文件名。如果没有指定[name]变量，将会使用 ID 作为分块文件名。 这可以正常运行，但有个问题。通用的依赖通常都在一个单独的文件中。如果在你应用的模块中使用了React，React将包含在每一个分片文件thunks中。 我们可以通过 CommonsChunkPlugin插件来解决这个问题。在你的配置文件中添加 plugins 选项： plugins: [ new webpack.optimize.CommonsChunkPlugin('common.js') ] 我喜欢使用 common.js 作为文件名，因为这样很直观，但它也可以任意指定。 非常好，代码分割完成。让我们配合react-router一起使用。 整合还记得我们上面提到的异步加载组件的路由吗？上面通过 require引用 HomePage组件。让我们配合使用 getComponent 和 require.ensure 来实现按需加载。 &lt;Route path="/" getComponent={(location, callback) => { require.ensure([], function (require) { var HomePage = require('./HomePage.jsx'); callback(null, HomePage); }, 'HomePage'); }} /> 把 require放在 callback里更简洁： &lt;Route path="/" getComponent={(location, callback) => { require.ensure([], function (require) { callback(null, require('./HomePage.jsx')); }, 'HomePage'); }} /> 完整的代码如下： &lt;Router history={history}> &lt;Route path="/" getComponent={(location, callback) => { require.ensure([], function (require) { callback(null, require('./HomePage.jsx')); }); }} /> &lt;Route path="/about" getComponent={(location, callback) => { require.ensure([], function (require) { callback(null, require('./AboutPage.jsx')); }); }} /> &lt;Route path="/faq" getComponent={(location, callback) => { require.ensure([], function (require) { callback(null, require('./FAQPage.jsx')); }); }} /> &lt;/Router> 本文翻译自 http://blog.mxstbr.com/2016/01/react-apps-with-pages/ 参考 http://react-guide.github.io/react-router-cn/docs/guides/advanced/DynamicRouting.html]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>react-router</tag>
        <tag>router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node全局对象：global、process和Buffer]]></title>
    <url>%2F2016%2F04%2F14%2FNode-global-object-global-process-and-Buffer.html</url>
    <content type="text"><![CDATA[Node全局对象：global、process和Bufferglobal对象，也是Node的全局命名空间； process对象，它提供了一些关键功能，例如对三种标准I/O流的封装，以及将同步函数转换为异步回调的功能； Buffer类，它提供了存储和操作原始数据的功能，同样它也是全局可见的 globalglobal与浏览器中的window对象是相似的，它们的关健不同点是： 浏览器中的window对象是一个真正全局的对象。如果在客户端 JavaScript中定义一个全局变量，它将能够被Web页面以及每一个独立的库访问到。 而Node模块中创建一个顶层变量（函数之外的变量），它仅仅在该模块中是全局的，而在其他模块中是不可见的。只有那些被模块显式导出的部分才能被引用该模块的应用程序所使用。 这意味着，由于不小心使用了重复的全局变量名称而引起的数据冲突问题将会大大减少。 process每个Node应用程序都是一个process对象实例，所以，应用程序自然能直接使用某些内建于 process 对象的功能。 process.execPath 方法可以返回当前 Node 应用程序的执行路径 process.version 提供了 Node 版本信息 process.platform 提供服务器平台信息 process.memoryUsage 方法可以查询当前Node 应用程序的内存使用量 process.nextTick 方法 这个方法可以将一个回调函数挂载到Node程序的事件循环机制中，并在下一个事件循环发生时调用该函数。 例： function asynchFunction = function (data, cb) { process.nextTick(function () { cb(val) }) } 虽然使用 setTimout 方法并传入一个0毫秒的延迟可以过到同样的目的 setTimout(function () { cb(val) }, 0) 但是，setTimout并不像 process.nextTick那样高效，process.nextTick的调用速度远远快于setTimout方法 首先你需要将耗时的处理过和打散并分解成多个部分，每个部分分别通过 process.nextTick调用，最终使得应用程序可以对其他请求进行处理，而无需等待耗时计算过程完成。 BufferBuffer 是用于处理二进制数据的一种方式。 流处理往往采用的是二进制数据，而非字符串 Buffer 支持的编码方式包括： ascii 七位 ASCII utf8 多字节编码的 Unicode 字符 usc2 两字节，little endian 方式编码的 Unicode 字符 base64 Base64 编码 hex 每个字节编码为两个十六进制字符]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node与REPL]]></title>
    <url>%2F2016%2F04%2F13%2FREPL-of-node.html</url>
    <content type="text"><![CDATA[这几个月，搜芽前端团队搞了Reactjs+Redux项目，在很多时候，比如部署，都需要使用Node，苦于我的肤浅，于是决定补一下功课。最近都会记录一些 Node相关的笔记。 Node 的优势 应用程序可以很容易地扩展，因为执行一个单线程并不会有非常大的开销 无需诉求于多线程开发，却达到了节约又能高效使用资源的目的。换句话说，你不必创建一个线程安全的应用程序。 全局变量在 Node 中是非常危险的，特别是你忘记 var关键字的时候。 REPLREPL(read-eval-print-loop) 是Node的一个交互式组件。在 REPL环境下输入的任何内容都由底层的 V8 Javascript引擎进行处理。 一些操作技巧 _(下划线) 可以调用上一个表达式 上下键仍然可以快捷输入历史命令, Tab 键自动补全 可以使用重复的 .(点) 来处理多行表达式，如：>var test = function() { ...return val = x * y ...}; undefined 退出 REPL环境的方式有： Ctrl + C两次 Ctrl + D .exit REPL 命令 .break 如果多行输入发生混乱不知道当前位置时，使用 .break会重新开始。不过会丢失之前输入的多行内容。 .clear 重置语境并清空所有表达式。该命令可以使你重头再来。 .exit 退出 REPL .help 显示所有可用的REPL命令。 .save 将当前REPL会话保存至文件 .load 将文件加载到当前会话 定制 REPL首先需要引入 REPL 模块： var repl = require('repl'); 通过在repl对象上调用 start方法创建新的 REPL： repl.start([prompt], [stream], [eval], [useGlobal], [ignoreUndefinded]); 所有参数都可选。 prompt Default is > 默认值为 > stream 默认值为process.stdin eval eval的默认值是 async useGlobal 默认值为 false, 新建一个语境而不是使用全局对象。 ignoreUndefinded 默认值为 false。 不要忽略undefined的返回值。 所以让REPL在表达式无返回值时不输出undefined可以这样实现： repl = require('repl'); // 设置 `ignoreUndefinded` 为 `true` , 启动 `REPL` repl.start('>', null, null, null, true);]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[postCSS 常用插件]]></title>
    <url>%2F2016%2F04%2F10%2FpostCSS-plugins.html</url>
    <content type="text"><![CDATA[postCSS常用插件PostCSS拥有非常多的插件，诸如自动为CSS添加浏览器前缀的插件autoprefixer、当前移动端最常用的px转rem插件px2rem，还有支持尚未成为CSS标准但特定可用的插件cssnext，还有很多很多。就连著名的Bootstrap在下一个版本Bootstrap 5也将使用PostCSS作为样式的基础。 一句话来概括PostCSS：CSS编译器能够做到的事情，它也可以做到，而且能够做得更好 PostCSS性能在PostCSS官方推特上看到，由JavaScript编写的PostCSS比C++编写的libsass还要快3倍. 如果你对上面的性能截图有疑问，可以亲自来这里测试看看。 常用的插件autoprefixer首先是最火的官方插件 autoprefixer 。autoprefixer 是为我们的 css 添加前缀的插件，它的数据来源于 Can I use。目的是让我们写纯粹的 css。例： a { display: flex; } 会编译成： a { display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex } Options通过 autoprefixer(options) 配置： var plugin = autoprefixer({ browsers: ['> 1%', 'IE 7'], cascade: false }); browsers (array): 指定你需要支持的浏览器列表。可以直接指定浏览器版本（如 IE 7）,也可以使用选项（如： last 2 version 或 > 5%）,具体选项可以查看 Browserslist cascade (boolean): should Autoprefixer use Visual Cascade, if CSS is uncompressed. Default: true add (boolean): 是否添加浏览器兼容前缀. 默认值是true. remove (boolean): 是否去除无用的浏览器兼容前缀. 默认值是true. supports (boolean): should Autoprefixer add prefixes for @supports parameters. Default is true. flexbox (boolean|string): should Autoprefixer add prefixes for flexbox properties. With “no-2009” value Autoprefixer will add prefixes only for final and IE versions of specification. Default is true. grid (boolean): should Autoprefixer add IE prefixes for Grid Layout properties. Default is true. stats (object): custom usage statistics for > 10% in my stats browsers query. 调试info() 方法可用于查看调试信息.可以像下面这样查看哪些浏览器被选中以及哪些属性被添加兼容前缀： var info = autoprefixer({ browsers: ['last 1 version'] }).info(); console.log(info); postcss-safe-parserpostcss-safe-parser 可以帮你查找并修补CSS语法错误。 cssnanocssnano 是模块化的CSS压缩器。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>前端构建</tag>
        <tag>loader</tag>
        <tag>postCSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[postCSS-loader配置,让css随心所欲]]></title>
    <url>%2F2016%2F04%2F09%2FpostCSS-loader-configs.html</url>
    <content type="text"><![CDATA[postCSS-loader配置,让css随心所欲组件必不可少的一部分就是 css，这里看下关于 css的一些 loaders。 PostCSSPostCSS 官网是这么介绍自己的： PostCSS is a tool for transforming styles with JS plugins. These plugins can lint your CSS, support variables and mixins, transpile future CSS syntax, inline images, and more. 他是一款通过 JS 插件转换 styles 样式的工具。 在 webpack 里面可以通过 postCSS-loader 来使用 PostCSS。 使用首先是安装 postCSS-loader npm install postcss-loader --save-dev 下面是一个 webpack config 的例子： var precss = require('precss'); // 实现类Sass的功能，变量，嵌套，mixins var autoprefixer = require('autoprefixer'); // 自动添加浏览器前缀 module.exports = { module: { loaders: [ { test: /\.css$/, loader: "style-loader!css-loader!postcss-loader" //在使用 css-loader,style-loader之前处理 } ] }, postcss: function () { // postcss 插件 return [precss, autoprefixer]; } } 上面的例子使用了两个 postcss 插件，应该预先安装： npm install precss --save-dev npm install autoprefixer --save-dev 在文件中引入的css将通过 PostCSS 插件的处理: var css = require('./file.css'); or import './file.css' // => CSS after Autoprefixer and CSSWring 插件组如果你想对不同目录或类型的 css使用不同的 PostCSS 插件配置进行处理，可以使用 ?pack=name 参数 module.exports = { module: { loaders: [ { test: /\.docs\.css$/, loader: "style-loader!css-loader!postcss-loader?pack=cleaner" // 对docs目录下的css使用 cleaner 的配置 }, { test: /\.css$/, loader: "style-loader!css-loader!postcss-loader" // 对其他目录下的css使用 defaults 的配置 } ] }, postcss: function () { return { defaults: [precss, autoprefixer], cleaner: [autoprefixer({ browsers: [] })] }; } } 写在 js 中的样式可以通过 postcss-js 插件处理写在 js 中的样式 { test: /\.style.js$/, loader: "style-loader!css-loader!postcss-loader?parser=postcss-js" } 也可以通过 babel 结合 postcss-js 处理 es6 语法中的样式 { test: /\.style.js$/, loader: "style-loader!css-loader!postcss-loader?parser=postcss-js!babel" } 你可以像下面这样写样式 import colors from '../config/colors'; export default { '.menu': { color: colors.main, height: 25, '&amp;_link': { color: 'white' } } }]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>前端构建</tag>
        <tag>loaders</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[babel-loader配置]]></title>
    <url>%2F2016%2F04%2F08%2Fbabel-loader-configure.html</url>
    <content type="text"><![CDATA[babel-loader配置安装npm install babel-loader babel-core babel-preset-es2015 --save-dev npm 从 npm@3 之后不赞成自动安装peerDependencies，所有必须在package.json里明确指定 babel-core 这样的宿主依赖。 peerDependencies字段，主要用来供插件指定其所需要的主软件的版本。更多可以见这里 如果是从babel 5升级到 babel 6，可以看这份指导 使用在webpack.config.js里配置是比较推荐的方式： module: { loaders: [ { test: /\.jsx?$/, // 匹配'js' or 'jsx' 后缀的文件类型 exclude: /(node_modules|bower_components)/, // 排除某些文件 loader: 'babel', // 使用'babel-loader'也是一样的 query: { // 参数 presets: ['es2015'] } } ] } 选项选项的写法有两种 一种是查询字符串的方式： module: { loaders: [ { test: /\.jsx?$/, exclude: /(node_modules|bower_components)/, loader: 'babel?presets[]=es2015' } ] } 另一种是指定 query属性 module: { loaders: [ { test: /\.jsx?$/, exclude: /(node_modules|bower_components)/, loader: 'babel', query: { presets: ['es2015'] } } ] } babel-loader 还支持以下选项： cacheDirectory: 默认值是 false。如果设置了这个参数，被转换的结果将会被缓存起来。当webpack 再次编译时，将会首先尝试从缓存中读取转换结果，以此避免资源浪费。如果该值为空(loader: ‘babel-loader?cacheDirectory’)，loader会使用系统默认的临时文件目录。 问题及优化性能问题 确保只转换尽可能少的文件，你可能匹配了过多的文件类型，或者匹配了所有的’.js’文件，你需要使用 exclude: /(node_modules|bower_components)/ 排除部分目录 设置 cacheDirectory 参数也可以让你的 loader 性能提升2倍！ babel 给每个需要的文件注入helper扩展您可以改为要求babel作为一个独立运行的模块，以避免重复。 下面的配置通过babel-plugin-transform-runtime插件可以禁用babel向每个文件注入helper 需要先安装插件 npm install babel-plugin-transform-runtime --save loaders: [ // the 'transform-runtime' plugin tells babel to require the runtime // instead of inlining it. { test: /\.jsx?$/, exclude: /(node_modules|bower_components)/, loader: 'babel', query: { presets: ['es2015'], plugins: ['transform-runtime'] } } ]]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>loader</tag>
        <tag>babel-loader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack-config]]></title>
    <url>%2F2016%2F04%2F07%2FWebpack-config.html</url>
    <content type="text"><![CDATA[不得不说，webpack 配置确实烦琐了一些，很多人都使用gulp的插件gulp-webpack来做其他事情。 配置webpackwebpack的构建过程需要一个配置文件，一个典型的配置文件webpack.config.js大概就是这样 var webpack = require('webpack'); module.exports = { // 配置项 }; 基本配置项entrymodule.exports = { entry:'./example1.1', output:{ filename:'bundle1.1.js' } }; 我们也会碰到支持多个入口文件（entry）的情况，每一个入口都需要有自己的名字，具体对应entry的写法而言，有如下几种情况： entry:'./example2.1' // 或者 entry:['./example2.1','./example2.2'] //或者 entry:{ 'example2.1':'example2.1.js', 'example2.2':'example2.2.js' } 第三种是比较推荐的写法，这种写法中，名字和模块文件名一一对应，每个模块都有独立的名字。也就是output.filename中的[name] outputoutput.filenameoutput.filename除了可以指定具体的文件名以外，还可以使用一些占位符，包括： name 模块名称 hash 模块编译后的（整体）Hash值 chunkhash 分片的Hash值 [name] 在上面的entry中，前两种写法，模块是没有名字的，webpack会使用main作为模块名字，因此用数组来指定入口的情况，模块名会重复，而此时webpack会将它们的代码合并打包！而第三种写法，这里的[name]可以理解成模块名字。 [hash]与[chunkhash] 事实上，在webpack的文档中，这个name是指“chunk name”，即分片的名字，这里需要先剧透一下后面要说的“分片”的概念。所谓分片就是指一个入口模块的代码有可能会被分成多个文件，还有一些文件可能是来自模块的公共代码，而不是入口模块。因此这里的[name]并非严格与入口模块一一对应。 了解了这些情况之后，[hash]和[chunkhash]就自然好理解了，一个是指本次打包相关的整体的hash，一个是指分片的hash。 module.exports = { entry:{ 'example3.1':'./example3.1', 'example3.2':'./example3.2' }, output:{ //这里分别用hash和chunkhash，结果不一样 filename:'[name]-[hash].js' //filename:'[name]-[chunkhash].js' } }; output.pathoutput.path来指定输出路径 output.path也可以使用占位符。 如果想保持打包前源文件的目录结构，需要把目录写到模块名上，如： entry:{ 'example4.1':'./src/example4.1', 'hello/example4.2':'./src/hello/example4.2' }, output:{ filename:'[name].js', path:'./dist' } 注意这里的filename一定要包含[name]才行，因为路径信息是带在模块名上的。 CommonChunks插件Common Chunks 插件的作用就是提取代码中的公共模块，然后将公共模块打包到一个独立的文件中去，以便在其它的入口和模块中使用。 var webpack = require('webpack'); module.exports = { entry:{ main1:'./main', main2:'./main.2' }, output:{ filename:'bundle.[name].js' }, plugins: [ new webpack.optimize.CommonsChunkPlugin('common.js', ['main1', 'main2']) ] }; 参数common.js表示公共模块的文件名，后面的数组元素与entry一一对应，表示要提取这些模块中的公共模块。 但是，要记得在HTML中加入公共部分common.js 但模块化不应该有多个入口文件，入口文件不应时时改变，应在内部处理 使用loaderloader是webpack中一个重要的概念，它是指用来将一段代码转换成另一段代码的webpack插件 虽然本质上说，loader也是插件，但因为webpack的体系中还有一个专门的名词就叫插件（plguin），为避免混淆，后面不再将loader与插件混淆说，后文中这将是两个相互独立的概念。 loader的使用有三种方法，分别是： 在require中显式指定 在配置项（webpack.config.js）中指定 在命令行中指定 第二种，在配置项中指定是最灵活的方式，它的指定方式是这样： module: { // loaders是一个数组，每个元素都用来指定loader loaders: [{ test: /\.jade$/, //test值为正则表达式，当文件路径匹配时启用 loader: 'jade', //指定使用什么loader，可以用字符串，也可以用数组 exclude: /node_modules/, //可以使用exclude来排除一部分文件 // exclude: /regexp/ include: 'dist', // 用来指定包含的文件 //可以使用query来指定参数，也可以在loader中用和require一样的用法指定参数，如`jade?p1=1` query: { p1:'1' } }, { test: /\.css$/, loader: 'style!css' //loader可以和require用法一样串联 }, { test: /\.css$/, loaders: ['style', 'css'] //也可以用数组指定loader }] } 串联loader是可以串联使用的，也就是说，一个文件可以先经过A-loader再经过B-loader最后再经过C-loader处理。 require('style!css!./style.css'); 参数loader还可以接受参数，不同的参数可以让loader有不同的行为（前提是loader确实支持不同的行为），具体每个loader支持什么样的参数可以参考loader的文档。 参数的指定方式和url很像，要通过?来指定，例如指定literate参数需要这样写： require('coffee?literate=1!./a.coffee'); 具体的可以对照官方的loader列表一一查看。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>前端构建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[采用非直进式合并（git-merge-no-ff）]]></title>
    <url>%2F2016%2F04%2F02%2Fmake-fast-forwarding-be-off-by-default-in-git.html</url>
    <content type="text"><![CDATA[采用非直进式合并（git-merge-no-ff）使用Git当合并一个分支是一个相当常见的操作。在某些情况下，Git会默认将尝试在快进模式合并一个分支。如果不使用快进合并有什么不同？ 假设我从master创建一个名为speedup分支。在这个分支上工作一段时间（三个提交，那些白色的圆圈）后，当我完成工作时，我把它git push推到我自己的远程分支。同时，主分支master什么都没发生，但仍处于相同的状态之前，我分出。这种情况在下面的图中描述。 一旦该项目的维护者得到通知，我的分支已经准备好合并进master，她可能使用git的常规步骤git fetch操作后执行git merge来合并。因为主分支并没有新的提交（灰色圆圈），Git会用快进执行合并。整个系列的提交将是线性的。历史会像下图（左侧）。 合并的另一个变型是使用 -no-ff 选项（它代表不快进）。在这种情况下，分支历史看上去稍有不同（右侧），有一个附加的提交（虚线圆）强调合并。这个提交告诉我们有关合并分支的备注信息。 Git的默认行为是尽可能使用快进。这可以改变的，非快进模式可以很容易地设定为默认合并模式。 设置非快进模式合并为默认合并方式 git config branch.master.mergeoptions “–no-ff” 总之，非快进合并保持明确分支的概念。它可在保留分支复杂的非线性提交历史。在另一方面，快进合并保持线性历史上的变更，使其更容易使用其他工具（log, blame, bisect）。每个分支的来源将变得很不明显，但如果该项目强制要求提交信息和问题跟踪器之间的严格的交叉引用，这也不是什么大不了的事。 你喜欢哪一种呢，快进式或非快进式？ 翻译自： Fast-Forward Git Merge]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速上手 Flow 静态类型检查器]]></title>
    <url>%2F2016%2F03%2F16%2FFlow-the-type-checker.html</url>
    <content type="text"><![CDATA[快速上手 Flow 静态类型检查器why Flowjavascript是一个弱类型语言，变量类型不需要声明，运算过程中会根据需要自动转换类型，这个是js的优点，够灵活，编码简单，但是同时也是软肋。有时候，有些类型转换的bug无从查起，特别是在复杂的应用中。 Flow为Javascript添加了静态类型检查，以提高开发效率和代码质量。更明确的说，静态类型检查提供的好处像早期错误检查，帮助你发现一些只有在运行时才能发现的错误。 安装由于flow是用OCaml语言写的，npm上只有对应的二进制包。 npm install flow-bin 可者使用 Homebrew 安装 brew install flow 快速上手在项目目录下执行 flow init，会生成一个 .flowconfig 文件 只需要在待检查的js文件头部添加一行注释 /* @flow */ 然后在同一目录下运行flow check即可。 flow serverflow server是为了提高检测效率的后台程序，支持在后台运行，并且只监测有修改的文件。 方法很简单，一条 flow 命令就能完成 Flow 服务器启动，文件检测，被更改文件的检测，即第一次使用 flow 命令会启动 Flow 服务器并且首次检测文件，再次使用 flow 命令会连接 Flow 服务器并且检测文件，之后使用 flow 命令时将会连接 Flow 服务器并且对修改过的文件进行检测。 flow check:检测所有声明了 @flow 的文件 flow check –all:可以让Flow检测所有文件，包括没有声明 @flow 的文件 flow stop:项目开发完成停止服务 flowconfig [ignore]忽略的文件，路径的匹配规则是正则表达式 [include]需要检测的其他目录的文件 [libs]当文件中有第三方库引用或者require全局的module时，需要在一个单独的文件里declare这个对象，这个的值是所有declare路径的集合 [options]包含若干key-value的配置 flow的两种模式/* @flow */ 只要带有这个注释，都会进行类型检测 /* @flow weak */ 只对有加类型声明的变量进行类型检测 类型声明/标注 不声明变量类型的时候，Flow 也会自动检查隐性存在的类型转换。但更为严谨的方式是显式声明变量的类型。 可以在代码里写上类型: /* @flow */ // Changing the return type to number fixes the error function foo(x: string, y: number): number { return x.length * y; } foo('Hello', 42); 也可以这样： /* @flow */ type T = number; var x: T = 0; 下面是一个更详细的例子： class People { name: string; constructor(name:string){ this.name = name } getAge():number{ return 18; } } function getLength(param?:string):number { /*param?:string传参类型什么，?表示此处可不传值；*/ /*\:number为函数返回值类型,如果没有return可不写或写void*/ var s:string = 'string';/*字符*/ var ss:String = new String('string');/*字符对象*/ /* s = ss*///类型不同，flow会报错 var n:number = 12;/*数字*/ var nn:Number = new Number(12);/*数字对象*/ var b:boolean = true;/*bool值，仅能为true/false*/ var bb:Boolean = new Boolean(true);/*bool值对象*/ var o:{prop1:number,prop2:string} = { /*对象熟悉声明*/ prop1: 12, prop2: '21123' } var v:void = undefined;/*undefined*/ var a:any = 'aa';/*任意类型，除undefined*/ var m:mixed = '1';/*任意类型+undefined*/ var mm:mixed = undefined;/*任意类型+undefined*/ var aa:Array = [1,2,3,4];/*数组内值类型声明*/ var P:Class = People;/*自定义类型声明*/ var p:People = new People('pt');/*自定义People类型*/ if (param) { return param.length; } else { return 0; } } 兼容性Flow致力于支持最新的JavaScript标准。目前已经支持各种ES6特性如destructuring, classes, extended objects, optional function parameters，以及核心API扩展（比如Map, Set, Promise, 和 new methods on Object, Array, 和 Math)。其它特性（尤其是模块）正在开发中。Flow支持CommonJS / Node.js 规范的模块。 Flow 也已经支持 React。 代码编译在构建工具中添加flow检查的步骤。webpack和gulp都有对应的flow插件。 我们在项目中用到的插件： eslint-plugin-flow-vars 参考Flow官网最近访问不了，可以看这里：https://github.com/facebook/flow/tree/master/website/docs flow——A static type checker for javascript #32 flow–facebook出品的javascript静态类型检查器]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>Flow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React应用性能优化之IMMUTABLE.JS]]></title>
    <url>%2F2016%2F03%2F14%2FReact-optimize-with-Immutable-js.html</url>
    <content type="text"><![CDATA[React应用性能优化之IMMUTABLE.JS前一篇文章记录了React应用的性能优化点，今天还有个更闪耀的 Immutable.js。 Immutable.jsImmutable.js 本身和 React.js 没有必然的联系。它的意义在于它弥补了Javascript没有不可变数据结构的问题。 Javascript中对象都是参考类型，也就是a={a:1}; b=a; b.a=10;你发现a.a也变成10了。可变的好处是节省内存或是利用可变性做一些事情，但是，在复杂的开发中它的副作用远比好处大的多。于是才有了浅copy和深copy，就是为了解决这个问题。举个常见例子： var defaultConfig = { /* 默认值 */}; var config = $.extend({}, defaultConfig, initConfig); // jQuery用法。initConfig是自定义值 var config = $.extend(true, {}, defaultConfig, initConfig); // 如果对象是多层的，就用到deep-copy了 ES6出现原生的assign方法，但它相当于是浅copy。如果有了不可变的数据结构就省心了，ES5.1中对象有了freeze方法，也是浅copy，a=Object.freeze({a:1}); b=a; b.a=10; a.a还是1。在实际开发中浅copy通常不够。如果用immutableJS: var defaultConfig = Immutable.fromJS({ /* 默认值 */}); var config = defaultConfig.merge(initConfig); // defaultConfig不会改变，返回新值给config var config = defaultConfig.mergeDeep(initConfig); // 深层merge 上述用deep-copy也可以做到，差别在于性能。每次deep-copy都要把整个对象递归的复制一份。而Immutable的实现有些像链表，添加一个新结点把旧结点的父子关系转移到新结点上，性能提升很多。ImmutableJS给的远不止这些，它提供了7种不可变的数据结构：List, Stack, Map, OrderedMap, Set, OrderedSet, Record （详见文档Immutable.js，文档很geek，打开console试吧）。immutableJS ＋ 原生Javascript等于真正的函数式编程。 Immutable 优点1. Immutable 降低了 Mutable 带来的复杂度可变（Mutable）数据耦合了 Time 和 Value 的概念，造成了数据很难被回溯。 比如下面一段代码： function touchAndLog(touchFn) { let data = { key: 'value' }; touchFn(data); console.log(data.key); // 猜猜会打印什么？ } 在不查看 touchFn 的代码的情况下，因为不确定它对 data 做了什么，你是不可能知道会打印什么（这不是废话吗）。但如果 data 是 Immutable 的呢，你可以很肯定的知道打印的是 value。 2. 节省内存Immutable.js 使用了 Structure Sharing 会尽量复用内存，甚至以前使用的对象也可以再次被复用。没有被引用的对象会被垃圾回收。 import { Map} from 'immutable'; let a = Map({ select: 'users', filter: Map({ name: 'Cam' }) }) let b = a.set('select', 'people'); a === b; // false a.get('filter') === b.get('filter'); // true 上面 a 和 b 共享了没有变化的 filter 节点。 3. Undo/Redo，Copy/Paste，甚至时间旅行这些功能做起来小菜一碟因为每次数据都是不一样的，只要把这些数据放到一个数组里储存起来，想回退到哪里就拿出对应数据即可，很容易开发出撤销重做这种功能。 为什么在React.js中使用Immutable.js熟悉React.js的都应该知道，React.js是一个UI = f(states)的框架，为了解决更新的问题，React.js使用了virtual dom，virtual dom通过diff修改dom，来实现高效的dom更新。 听起来很完美吧，但是有一个问题。当state更新时，如果数据没变，你也会去做virtual dom的diff，这就产生了浪费。这种情况其实很常见，如： 熟悉 React 组件生命周期的话都知道：调用 setState 方法总是会触发 render 方法从而进行 vdom re-render 相关逻辑，哪怕实际上你没有更改到 Component.state 。 this.state = {count: 0} this.setState({count: 0});// 组件 state 并未被改变，但仍会触发 render 方法 为了避免这种性能上的浪费，React 提供了一个 shouldComponentUpdate 来控制触发 vdom re-render 逻辑的条件。于是 PureRenderMixin 作为一种优化技巧被使用。但PureRenderMixin只是简单的浅比较，不使用于多层比较。那怎么办？？自己去做复杂比较的话，性能又会非常差。 这时候 immutableJS 就派得上用场了： var map1 = Immutable.fromJS({a:1, b:1, c:{b:{c:{d:{e:7}}}}}); var map2 = Immutable.fromJS({a:1, b:1, c:{b:{c:{d:{e:7}}}}}); Immutable.is(map1, map2); // true 每一次state更新只要有数据改变，那么PureRenderMixin可以立刻判断出数据改变，可以大大提升性能。 实践与 React 搭配使用，Pure Render可以使用 react-immutable-render-mixin 通过es6的修饰器 @decorator 来使用 import React from 'react'; import { immutableRenderDecorator } from 'react-immutable-render-mixin'; @immutableRenderDecorator class Test extends React.Component { render() { return &lt;div>&lt;/div>; } } 或者直接 import immutableRenderMixin from 'react-immutable-render-mixin'; React.createClass({ mixins: [immutableRenderMixin], render: function() { return &lt;div className={this.props.className}>foo&lt;/div>; } }); 与 Redux 搭配使用Redux 是目前流行的 Flux 衍生库。它简化了 Flux 中多个 Store 的概念，只有一个 Store，数据操作通过 Reducer 中实现；同时它提供更简洁和清晰的单向数据流（View -> Action -> Middleware -> Reducer），也更易于开发同构应用。目前已经在我们项目中大规模使用。 由于 Redux 中内置的 combineReducers 和 reducer 中的 initialState 都为原生的 Object 对象，所以不能和 Immutable 原生搭配使用。 幸运的是，Redux 并不排斥使用 Immutable，可以自己重写 combineReducers 或使用 redux-immutablejs 来提供支持。 本文原文链接： facebook immutable.js 意义何在，使用场景？ Immutable 详解及 React 中实践基本没有改动。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>Immutable</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React应用性能优化之shouldComponentUpdate与key]]></title>
    <url>%2F2016%2F03%2F10%2FReact-optimize-with-shouldComponentUpdate-and-key.html</url>
    <content type="text"><![CDATA[React应用性能优化之shouldComponentUpdate与key虽然React 的 vDom diff算法能保证最小程度的 DOM 改变，但当组件树嵌套得非常深时，就不得不需要渲染一个新的虚拟 DOM 来让应用运行得更加高效。 下面看看加速应用程序的两种简单的配置方法： shouldComponentUpdate设置新 props，调用 setState 方法或 forceUpdate 方法时，React 都会调用该组件所有子组件的 render 方法。但是在组件树深度嵌套或 render 方法十分复杂的时侯，页面就会有延迟。 但此时，某些子组件并没有必要更新，或者永远都不需要更新，这时进行的计算过程是没有必要的。 而 shouldComponentUpdate 方法正是用来判断是否需要调用指定组件的 render 方法。 shouldComponentUpdate 方法返回一个布尔值。false 表示不要调用 render 方法；true 表示需要调用 render 方法计算出新的虚拟 DOM。 此方法的默认值是 true。 并且，组件首次渲染时，shouldComponentUpdate 方法不会被调用 shouldComponentUpdate 方法接受两个参数，新的 props 和新的 state： React.creatClass({ shouldComponentUpdate: function (nextProps, nextState) { return nextProps.id !== this.props.id } }) 另外，我们也可以添加 React.addons.PureRenderMixin 插件来处理 shouldComponentUpdate。 这个插件会重写 shouldComponentUpdate 方法，并在该方法内对新老 props 及 state 进行对比， 如果发现它们完全一致则返回 false, 就像上面的例子一样。官方文档里也有介绍： PureRenderMixin import PureRenderMixin from 'react-addons-pure-render-mixin'; class FooComponent extends React.Component { constructor(props) { super(props); this.shouldComponentUpdate = PureRenderMixin.shouldComponentUpdate.bind(this); } render() { return foo; } } key(键)在遍历列表的时候，没有组件添加 key 值会有 warnning 产生。那它是用来干嘛的呢？ 假设有一个 div 组件，它的 key 属性为 ‘foo’，之后又改为 ‘bar’， 那 React 就会跳过 DOM diff， 同时完会弃置 div 所有的子元素，并重新渲染。除了告诉 React 什么时候要抛弃一个节点之外，key 还可以在元素顺序改变时使用。 render: function(){ return items.map(function(item){ return item.name }) } 如果像上面这样，React 在li 列表顺序改变的时候就不会重新渲染，而是采用 insertBefore 操作，这也是最高效的方法。 但是要注意，key 值必须是独一无二的，最好不要是数字，绝对不能是遍历中的index。这样可以保证从一个父组件移动到另一个父组件的情况是不会被处理的。 key 值也是无法读取的。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>shouldComponentUpdate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索命令之locate、whereis、which、find、grep]]></title>
    <url>%2F2016%2F03%2F07%2Fsearch-command-locate-whereis-which-find-grep.html</url>
    <content type="text"><![CDATA[搜索命令之locate、whereis、which、find、grepwhereis搜索命令所在路径及帮助文档所在位置 选项： -b 只查找可执行文件 -m 只查找帮助文件 也可以通过 whereis 命令来判断是否是shell内部命令 which搜索命令所在路么及别名 与whereis的区别在于 which 不仅可以查看命令所在路径，还可以查看到命令的别名 locate搜索文件名最快的方式，根据后台数据库/var/lib/mlocate搜索 updatedb 命令手动更新数据库，数据库更新不是即时的，一般需要一天 /etc/updatedb.conf 配置文件，用于配置搜索限制 find最强大的搜索命令，但同时带来性能问题 find [搜索范围] [搜索条件] -name 按文件名搜索 -iname 不区分大小写搜索 -user 按照所有者搜索 -nouser 查找没有所有者的文件 -mtime 按修改文件的日期搜索，如：+10 查找10天前修改的文件， -10 查找10内修改的文件， 10 查找10天当天修改的文件 -atime 文件访问时间 -ctime 改变文件属性时间 -size 按照文件大小按索，如： find . -size 25k，注意 k 是小写， M是大写 -inum 按照i节点查找文件 -a 逻辑与 and,两个条件都满足，如： find /root -size +20k -a -size -1M 查找大于20k且小于1M的文件 -o 逻辑或 or,两个条件满足一个即可 -exec 命令 {} \; 对搜索结果执行操作，如： find /root -size 25k -exec rm -rf {} \; 查找/root目录下25k大小的文件之后删除 grep在文件中搜索符合条件的字符串 选项： -i 忽略大小写 -v 排除指定字符串 grep 是包含匹配，只要含有匹配的字符串，一整行都会输出；find 是完全匹配，只输出文件名完全一样的文件]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fetch POST 接收不到数据，注意 content-type 的设置]]></title>
    <url>%2F2016%2F03%2F05%2Fresolve-fetch-post-no-response.html</url>
    <content type="text"><![CDATA[Fetch POST 接收不到数据，注意 content-type 的设置最近我们前端组在做一个简易的文档系统，使用redux+mongodb。其中抛弃了Ajax，起用了Fetch。 XMLHttpRequest 是一个设计粗糙的 API，不符合关注分离（Separation of Concerns）的原则，配置和调用方式非常混乱，而且基于事件的异步模型写起来也没有现代的 Promise，generator/yield，async/await 友好。 Fetch 的出现就是为了解决 XHR 的问题，Fetch API 是基于 Promise 设计。 刚开始用的时候发现个问题，POST数据发现后端获取不到，GET方式是没有问题的。如： fetch('/group/update', { method: 'post', body: JSON.stringify(params) }) .then((response) => response.json()) .then((json) => dispatch(fetchUpdateGroupName(json, index))) .catch((err) => (console.log('err:', err))) 以前一直用Jquery Ajax，很少情况需要设置Content-Type，而且看到有些博文介绍Fetch的时候说，Fetch()如果没有设置Content-Type，会自动获取。 后来还是被家优提醒，以下代码才是正确的设置： fetch('/group/update', { method: 'post', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(params) }) .then((response) => response.json()) .then((json) => dispatch(fetchUpdateGroupName(json, index))) .catch((err) => (console.log('err:', err))) 注意： Fetch 支持几种数据类型的传输，其中包含Blob, BLOB (binary large object)，表示二进制大对象。其中有个只读属性，Blob.type(),此时的 Content-Type 应设置为此值。 这里顺便记录下POST常见的Content-Type: application/x-www-form-urlencoded浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。提交的数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。 POST http://www.123.com HTTP/1.1 Content-Type: application/x-www-form-urlencoded;charset=utf-8 title=test&sub%5B%5D=1&sub%5B%5D=2&sub%5B%5D=3 multipart/form-data使用表单上传文件时，必须让 form 的 enctyped 等于这个值, 上传图片时，我们经常会看到下面这样 POST http://www.example.com HTTP/1.1 Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA ------WebKitFormBoundaryrGKCBY7qhFd3TrwA Content-Disposition: form-data; name="text" title ------WebKitFormBoundaryrGKCBY7qhFd3TrwA Content-Disposition: form-data; name="file"; filename="chrome.png" Content-Type: image/png PNG ... content of chrome.png ... ------WebKitFormBoundaryrGKCBY7qhFd3TrwA-- 如果我们使用 new FormData()作为数据主体提交，也需要设置这种类型。 application/json把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。但也有些服务端语言还没有支持这种方式，例如 php 就无法通过 $_POST 对象从上面的请求中获得内容。这时候，需要自己动手处理下：在请求头中 Content-Type 为 application/json 时，从 php://input 里获得原始输入流，再 json_decode 成对象。 参考： 四种常见的 POST 提交数据方式]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>fetch</tag>
        <tag>content-type</tag>
        <tag>POST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何少埋坑-艾神分享会]]></title>
    <url>%2F2016%2F03%2F04%2Fshare-from-mr.ai.html</url>
    <content type="text"><![CDATA[又很久没有记录东西了，真是个不自律的人- -！ 去年十月进入搜芽，感觉搜芽是一个共同成长的公司，有一种亲切感。这算是我第一次进一个前端团队比较大的公司，很多想法在分享与讨论中迸发。 最近产品在预热中，相对有空，我们前端也在尝试一些新技术的应用,用react-redux做一个简易的文档系统。除了家优对技术架构比较熟，我们几个都比较生疏。但是最重要是不要心浮气燥，虽然最近心情不是很好，但我还是尽量静下心来研读文档，在开发中一步一坑地走下去。 研发部也在组织分享会，今天是第一次分享会，艾神定的主题是http协议，主要和大家分享一个http请求从客户端到服务端处理返回的整个过程。 说到艾神，当初见到他的第一印象就是没什么印象，老实、普通，所以当时不是很明白为什么大家叫他艾神。不过后来发现，艾神确实是一个很踏实的人，他是写java的，功力很深，逻辑很严谨。和他一起吃饭的时候，很喜欢和我们‘讲课’。 当然，分享会其他讲http协议不是他的真正目的，他延伸出来的相关案例才是重点。艾神讲协议，是想让我们要注意分清什么是标准，什么是投机。工作中要知道错的为什么错，也要知道对的为什么对，要把程序的运行把控在自己手中，不能存在不确定性。否则埋了坑，一旦出现问题，就要花更多的时间去排查。 我也是见过太多程序员，对一些问题十分马虎，错了就不断推脱，有时候bug补上了却不知道为什么，殊不知可能埋了更大的坑。 艾神是个很靠谱的程序员]]></content>
      <categories>
        <category>workflow</category>
      </categories>
      <tags>
        <tag>review</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 获取本周和本月或任意月的时间段]]></title>
    <url>%2F2015%2F10%2F30%2Fjavascript-get-the-time-period-of-the-week-and-this-month-or-any-month.html</url>
    <content type="text"><![CDATA[javascript 获取本周和本月或任意月的时间段最近有功能从两个时间段变成单个select选择了，但后端不想改接口。只好适配一下，把今天、本周、本月及过去的月份转换一下。 首先，更改一下select菜单，动态取出过去的月份，添加options。 var SearchTimer = ['全部', '今天', '本周', '本月']; (function(){ var Month = new Date().getMonth(); for(; Month > 0; Month--){ SearchTimer.push(Month + '月份'); } })(); 接下来就是要把各个options在选择的时候转换成startTime和endTime. switch(timer){ case '全部': break; case '今天': break; case '本周': break; case '本月': break; default: } 然后是时间的处理，先需要格式化时间，注意补零，格式为yyyy-MM-dd HH:mm:ss。 function formatDate(date) { var myyear = date.getFullYear(); var mymonth = date.getMonth()+1; var myweekday = date.getDate(); var myhours = date.getHours(); var myminutes = date.getMinutes(); var myseconds = date.getSeconds(); if(mymonth &lt; 10){mymonth = "0" + mymonth; } if(myweekday &lt; 10){myweekday = "0" + myweekday; } if(myhours &lt; 10){myhours = "0" + myhours; } if(myminutes &lt; 10){myminutes = "0" + myminutes; } if(myseconds &lt; 10){myseconds = "0" + myseconds; } return (myyear+"-"+mymonth + "-" + myweekday+" "+myhours+":"+myminutes+":"+myseconds); } 今天的时间很好获取，然后是本周时间： var now = new Date(); //当前日期 var nowDayOfWeek = now.getDay(); //今天本周的第几天 var nowDay = now.getDate(); //当前日 var nowMonth = now.getMonth(); //当前月 var nowYear = now.getFullYear(); //当前年 function getWeekStartDate() { //获得本周的开端日期 var weekStartDate = new Date(nowYear, nowMonth, nowDay - nowDayOfWeek); return formatDate(weekStartDate); //调用上面的时间格式化 } function getWeekEndDate() { //获得本周的停止日期 var weekEndDate = new Date(nowYear, nowMonth, nowDay + (6 - nowDayOfWeek)); return formatDate(weekEndDate); } 然后是本月时间，但首先需要知道本月有多少天： function getMonthDays(myMonth){ //获得某月的天数 myMonth = parseInt(myMonth); //这一步很重要，有时候传进来的可能是字符串，后面+1的时候会变成字符串相连 var monthStartDate = new Date(nowYear, myMonth, 1); //当月1号的时间戳 var monthEndDate = new Date(nowYear, myMonth + 1, 1);//下月1号的时间戳 var days = (monthEndDate - monthStartDate)/(1000 * 60 * 60 * 24);//求差即可取得某月天数 return days; } function getMonthStartDate(){ //获得本月的开端日期 var monthStartDate = new Date(nowYear, nowMonth, 1); return formatDate(monthStartDate); } function getMonthEndDate(){ //获得本月的停止日期 var monthEndDate = new Date(nowYear, nowMonth, getMonthDays(nowMonth)); return formatDate(monthEndDate); } 然后是过去任意月份的1号和最后一天： var theMon = timer.replace(/(月份)$/, '')-1; //先匹配出select的月份，如：‘9月份’，但getMonth()是从0天始的，所以需要减1，也正好可以转换成整型 startTime = formatDate(new Date(nowYear, theMon, 1)); endTime = formatDate(new Date(nowYear, theMon, getMonthDays(theMon)));//某月有几天，最后一天就是几天。 所以最后返回时间段： var startTime, endTime; endTime = formatDate(new Date()); switch(timer){ case '全部': startTime = undefined; endTime = undefined; break; case '今天': startTime = formatDate(new Date(nowYear, nowMonth, nowDay)); break; case '本周': startTime = getWeekStartDate(); break; case '本月': startTime = getMonthStartDate(); break; default: var theMon = timer.replace(/(月份)$/, '')-1; startTime = formatDate(new Date(nowYear, theMon, 1)); endTime = formatDate(new Date(nowYear, theMon, getMonthDays(theMon))); break; } return { startTime: startTime, endTime: endTime } 至此就转换完毕。 当然，如果有需要，还可能获取季度。 function getQuarterStartMonth(){ //获得本季度的开端月份 var quarterStartMonth = 0; if(nowMonth&lt;3){quarterStartMonth = 0; }//判断属于第一季度 if(2&lt;nowMonth &amp;&amp; nowMonth&lt;6){quarterStartMonth = 3; } if(5&lt;nowMonth &amp;&amp; nowMonth&lt;9){quarterStartMonth = 6; } if(nowMonth>8){quarterStartMonth = 9; } return quarterStartMonth; } 只要判断属于哪一季度，即可知道开端月份和结束月份。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angularJS自定义指令]]></title>
    <url>%2F2015%2F10%2F17%2Fangular-comorized-directive.html</url>
    <content type="text"><![CDATA[angularJS自定义指令指令可以简单理解成特定DOM元素上执行的函数，它可以拓展元素的功能。 一个定义指令的基本格式如下： angular.module('myApp', []) .directive('myDirective', function(){ return { //指令的配置项 } }); directive() 方法可以接受两个参数： name指令的名字，如： myDirective。在DOM中可以这样使用: ``;或者 ``; 定义指令时的名称用驼峰命名，使用时用中划线方式。 function这个函数可以返回一个对象，如上面；或者直接返回一个函数，它会被接收成 postLink 函数。 指令的返回函数的所有配置项先看看指令的所有参数配置： angular.module('myApp', []) .directive('myDirective', function(){ return { restrict: string,//指令在DOM中的声明形式字符串，默认值是‘A’ proiority: number,//优先级，默认值0 terminal: boolean,//是否停止运行当前元素比本指令优先级低的指令 template: string or function,//模板 或 返回模板的函数 templateUrl: string,//模板文件的链接 replace: boolean or string,//true为替换，默认值false为插入到指令元素内部 scope: boolean or object,//指令作用域 transclude: boolean,//嵌入 controller: string or function(scope, element, attrs, transcluude, otherInjectables){}, require: string, link: function(scope, iElement, iAttrs){}, compile: function(tElement, tAttrs, transclude){ return { pre: function(scope, iElement, iAttrs, controller){}, post: function(scope, iElement, iAttrs, controller){} } return function postLink(){} } } }); 1. restrict可选值： E(元素，用于独立的指令单元，意图表达更明确) A(属性，默认值, 最常用，兼容性最好) C(类名) M(注释，尽量避免使用) 2. priority默认值是0；优先级高的指令总是优先执行。优先级相同的指令，先声明的先执行。 3. terminal设置为true,则停止运行当前元素上比本指令优先级低的指令，但优先级相同的仍然会执行。 4. template值可以是以下类型： a. 模板字符串 b. 一个可以接受两个参数的函数，并返回一个代表模板的字符串 5. templateUrl值可以是以下类型： a. 外部html文件路径的字符串 b. 一个可以接受两个参数的函数，并返回一个外部HTML文件路径的字符串 6. replace默认值false. 值为 true 时，模板会被当作子元素插入到调用此指令的元素内部 7. scope可选值： false: 默认值，直接调用相同的作用域对象； true: 从当前作用域对象继承一个新的作用域对象； {}[object]: 创建一个同当前作用域相隔离的作用域对象。 隔离作用域具有隔离作用域的指令最主要的使用场景是创建可复用的组件，组件可以在未知上下文中使用，并且可以避免污染所处的外部作用域或不经意地污染内部作用域。 绑定策略使用了隔离作用域后，指令的模板就无法访问外部作用域了。但使用无数据的隔离作用域并不常见。AngularJS 有三种方法可以将指令内部的隔离作用域同外部作用域进行数据绑定。 本地作用域属性：@ (or @attr) 使用@符号将本地作用域同DOM属性的值进行绑定。指令内部作用域可以使用外部作用域的变量。 js myApp.controller('myController', ['$scope', function($scope){ $scope.btnText = '按钮'; $scope.validate= '1234'; $scope.submit = function(err){ console.log(err); } }]); myApp.directive('my-btn', function(){ return { restrict: 'EA', scope: { text: '@btnText'//key是在template里使用的变量，val是在使用指令时所绑定的attr。若@符号后不指定名称，则默认绑定为键名'text' }, replace: true, template: '{{text}}'//这里的{{text}}正是scope的text. } }); html //这里的属性‘btn-text’正是指令的‘@btnText’,属性值‘btnText’正是父级作用域的‘$scope.btnText’ 双向绑定： = (or =attr) 可以将本地作用域上的属性同父级作用域上的属性进行双向的数据绑定。 例： js,controller同上一例子,如果理解上面的例子，这里也是很好理解的，只是绑定的不是字符串，而是双向数据绑定。 myApp.directive('myInput', function(){ return { restrict: 'A', scope:{ val: '=value'//key为template里的数据模型，'value'是html里的attr. }, template: '' } }); html //本地作用域的属性val与父级作用域的属性validate进行双向数据绑定 父级作用域绑定： & (or &attr) 可以对父级作用域进行绑定，可以调用父方法。意味着对这个值进行设置时会生成一个指向父级作用域的包装函数。 js myApp.directive('myError', function(){ return { restrict: 'A', scope: { validate: '&check' }, template: ''+ ''//传递参数需要传递一个对象，name是参数名，text是参数值。 } }); html //因为是隔离作用域，他们之间的值是不会互相影响的，只是共用父方法。 要调用一个带有参数的父方法，需要传递一个对象，这个对象的key是参数名称，val是要传递给参数的内容 8. transcludetransclude是一个可选参数，默认值是false, 当值为true时，angularJS会将从DOM元素中获取的内容放到它发现ng-transclude指令的地方，如： first second angular.module('myApp', []) .directive('sidebox', function(){ return { scope: { title: '@' }, transclude: true, template: ''+ '' } }); 只有希望创建一个可以包含任意内容的指令时，才使用transclude: true。，典型的例子是模态框或导航栏。 9. controller值可以是一个字符串或一个函数。 string: 当设置为字符中时，指令会查找注册在应用中的同名控制器。 function: 直接通过匿名构造函数的方式来定义一个内联的控制器。 控制器主要是用来提供可以指令间复用的行为。可以的将当前指令的API暴露给其他的指令使用。如： angular.modue('myApp', []) .directive('inputForm', function(){ return { restrict: 'EA', controller: function($scope){ $scope.input = '手机号'; this.submit = function(){//通过this暴露接口 //do something... } } } }); 任意的服务同样可以被传递给controller。其中有一些特殊的服务： $scope 与指令元素相关联的当前作用域 $element 当前指令对应的元素 $attrs 当前元素的属性组成的对象 $transclude transclude链接函数是实际被执行用来克隆元素和操作DOM的函数 10. controllerAscontrollerAs用来设置控制器别名，以此为名发布控制器，并且作用域可以访问controllerAs。这样可以在视图中引用控制器，甚至无需注入$scope。例： angular.module('myApp', []) .directive('myDirective', function(){ return { restrict: 'A', template: '{{myController.msg}}',//可以在tpl中直接访问controller controllerAs: 'myController', contrller: function(){ this.msg = 'Hello'; } } }); 又例： angular.module('myApp', []) .controller('myController', function(){ this.msg = 'robin'; }); {{main.robin}} 11. require其值可以是字符串或数组，字符串或数组元素代表另个一个指令的名字。require 会将指令控制器注入到当前的指令中，并作为当前指令的链接函数的第四个参数。 结合9.controller的例子，可以这样使用 angular.module('myApp', []) .directive('otherForm', function(){ return { restrict: 'A', require: '^?inputForm', link: function(scope, element, attrs, ctrl){ ctrl.submit(); } } }); 如果是数组： angular.module('myApp', []) .directive('otherForm', function(){ return { restrict: 'A', require: [?^inputForm, inputForm2], link: function(scope, element, attrs, ctrl){ ctrl[0].submit(); ctrl[1].api(); } } }); require前缀： ‘?’ 如果在当前指令中没有找到所面要的控制器，会将null作为link的第四个参数； ‘^’ 指令会在上游的指令链中查找require参数所指定的控制器； ‘?^’ 前两个选项的组合； 没有前缀 指令将在同级作用域查找所需控制器，如果没有找到会抛出一个错误。 12. compilecompile选项可以返回一个对象或函数。 compile函数可以用来在指令和实时数据被放到DOM中之前进行DOM操作，在这里进行添加和删除节点等DOM操作是安全的。 compile与link函数是互斥的。如果同时设置，compile的返回函数会被当作链接函数，link函数会被忽略。 compile: function(tEle, tAttrs, transcludeFn){ //...tEle代表未绑定事件的DOM元素 } 13. linklink函数会经常被使用。负责设置事件监听器、监听数据变化和实时的操作DOM。 如果指令很简单，可以直接从工厂函数返回一个函数来代替。如： angular.module('myApp', []) .directive('myDirective', function(){ return { pre: function(tElement, tAttrs, transclude){}, post: function(scope, iElement, iAttrs, controller){} } }); angular.module('myApp', []) .directive('myDirective', function(){ return { link: function(scope, ele, attrs){ return { pre: function(tElement, tAttrs, transclude){}, post: function(scope, iElement, iAttrs, controller){} } } } });]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>angularJS</tag>
        <tag>directive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 分支]]></title>
    <url>%2F2015%2F10%2F10%2Fgit-branch.html</url>
    <content type="text"><![CDATA[git分支对于我们平常开发新功能，修复bug等有很大的帮助。下面是git分支的常用命令： 分支的新建与切换 $ git checkout -b version2.0 这相当于执行下面这两条命令： $ git branch version2.0 $ git checkout version2.0 分支的合并 $ git checkout master $ git merge version2.0 切换到主分支，把分去version2.0合并到主分支 分支的删除 $ git branch -d verdion2.0 如果分支功能已经合并到主分支，分支就没有用了，可以删除。 合并分支的冲突 合并并不总是顺利的，特别是多人合作的时候，很容易产生冲突。 < HEAD > version2.0 ‘=======’把两个版本冲突的内容分隔开来，我们需要把这些标记都删掉，并留下合并后的代码。 合并GUI工具 如果安装了可视化的合并工具，可以使用$ git mergetool命令来调用。 推荐的GUI合并工具有如：meld, kdiff3 可以这样调用指定的工具：$ git mergetool -t meld 也可以配置默认工具： $ git config --global merge.tool kdiff3]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp 4.0的变化]]></title>
    <url>%2F2015%2F10%2F09%2Fgulp-4.0.html</url>
    <content type="text"><![CDATA[升级日志先来看看新版有什么不同（官方升级日志）： 新的任务系统（基于 bach，替换掉了原先基于 orchestrator 的任务系统） 移除 gulp.reset gulp.task 不再支持三个参数的用法 gulp.task 用字符串注册的任务必须是直接在命令行中调用的任务 gulp.task 可以接受单参数语法，这个参数必须是一个命名函数，函数名会被作为任务名 添加了 gulp.series 和 gulp.parallel 方法用于组合任务 添加了 gulp.tree 方法用于获取任务树，传入 { deep: true } 参数可以得到一个 archy 兼容的节点列表 添加了 gulp.registry 方法以定制注册表。 添加了 gulp.symlink 方法，功能和 gulp.dest 一致，不过是以软链接的方式 gulp.dest 和 gulp.symlink 方法添加了 dirMode 参数允许对目标目录更好地控制 gulp.src 接收的文件匹配字符串会顺序解释，所以你可以写成这样 gulp.src([‘.js’, ‘!b.js’, ‘bad.js’])（排除所有以 b 开头的 JS 文件但是除了 bad.js） gulp.src 方法添加了 since 选项，筛选在特定时间点之后修改过的文件（用于增量编译） 将命令行分离出来成为一个独立模块，以便节约带宽/空间。用 npm install gulp -g 或 npm install gulp-cli -g 都可以安装命令行，只是 gulp-cli 不包含模块代码所以比较小 命令行添加了 –tasks-json 参数，可以导出整个任务树以供他用 命令行添加了 –verify 参数用以检查 package.json 中是否包含黑名单插件（违背准则而被禁入官方插件列表的可怜娃们）。 安装gulp 4.0# 如果安装过全局的 gulp 的话先卸载之 $ npm uninstall gulp -g # 安装全局的 gulp 4.0 $ npm install "gulpjs/gulp#4.0" -g # 到项目目录里删掉本地的 gulp $ npm rm gulp --save-dev # 安装本地的 gulp 4.0 $ npm install "gulpjs/gulp#4.0" --save-dev gulp.task1、移除了gulp.task传递三参数的用法 即这种用法将报错 gulp.task('watch', ['default'], function() { // TODO // watch file }); 在gulp4.0之前，这种用法将会保证default任务先执行完再执行watch任务，gulp的任务流程控制就是这么实现的，流程控制另外增加api实现，详看后面。 2、gulp.task又增加了一种用法，即传递一个具名函数作为参数，将自动注册以该函数名命名的任务 function clean(){} function compile() { // do something... } gulp.task(clean); gulp.task(compile); 等同于 gulp.task('clean', function() { // do something... }); gulp.task('compile', function() { // do something... }); 任务流程控制增加了gulp.series 串行任务和gulp.parallel 并行任务， 比原来的三参数写法要更加清晰。 function clean(){} function copy(){} function compile() { // do something... } gulp.task(clean); gulp.task(copy); gulp.task(compile); gulp.task('clean-build', gulp.series('clean', 'copy', 'compile')); //任务将按顺序执行 gulp.task('build', gulp.parallel('copy', 'compile')); //任务将并发执行 只要在gulpfile.js中没有使用gulp.task传三个参数的用法，gulp 4.0也是兼容老版本的gulpfile.js的。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>前端构建</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端批量压缩图片]]></title>
    <url>%2F2015%2F10%2F08%2Foptimize-images-with-font-end.html</url>
    <content type="text"><![CDATA[前端批量压缩图片前端切图的时候，png 图片都比较大，一直使用的是 Tinypng 来压缩 png 图片，小图标sprite之后，图片数量还是至少在 20 以上，操作甚是麻烦。后来在使用 gulp 的时候，发现了一个批量压缩图片的神器 —— pngquant 。 先来看看一个 gulp 插件 gulp-imagemin Install $ npm install --save-dev gulp-imagemin Usage var gulp = require('gulp'); var imagemin = require('gulp-imagemin'); var pngquant = require('imagemin-pngquant'); gulp.task('default', function () { return gulp.src('src/images/*') .pipe(imagemin({ progressive: true, svgoPlugins: [{removeViewBox: false}], use: [pngquant()] //使用了 pngquant 压缩png图片 })) .pipe(gulp.dest('dist/images')); }); gulp-imagemin 可以压缩几乎所有图片格式 PNG, JPEG, GIF and SVG，其中png压缩是使用了 pngquant ,需要先另外安装： $ npm install --save imagemin-pngquant 但是，图片其实并不需要每次构建都压缩，一般只需要在发布或测试的时候一次性压缩就可以了。 所以也可以不使用 gulp 工具进行图片压缩，直接使用 pngquant。 pngquant 使用起来也是很方便的，下载对应版本，windows下添加文件目录到系统环境变量，进入到相应目录，直接使用命令行 pngquant *.png 即可完成压缩，可以看到目录下生成后缀名为 -fs8.png 或 -or8.png的图片。 查看 Readme.md 配置相应参数 pngquant常用的主要参数--quality min-max 类似JPEG的质量，设置0 ~ 100 的图片压缩质量。 pngquant --quality=65-80 *.png --ext new.png 设置输出压缩图片的文件名。如果不设置，则默认后缀为 -fs8.png 或 -or8.png。如果使用 --ext=.png --force，将会使用原文件名输出并覆盖原文件。 -o out.png or --output out.png 设置图片输出路径。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>前端构建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git ssh-key 及多帐户设置]]></title>
    <url>%2F2015%2F09%2F30%2Fgit-ssh-key-and-multiple-accounts-configs.html</url>
    <content type="text"><![CDATA[git ssh-key 及多帐户设置在使用git的时候，我们在管理远程分支之前需要在本机上创建ssh-key密钥对，并把其中的公钥添加到github中。 首个帐户如果你只会在你的计算机使用一个远程的Git服务器，并且账号是一个，比较简单，生成key的时候也没有太大注意的地方，直接运行如下的第一步然后按回车就可以了 在 gitbash上运行 ssh-keygen -t rsa -C "Github账户邮箱" 接下来会提示输入key的名字 默认名字为id_rsa ,默认不改直接回车就行了 然后会提示输入口令，这里口令与Github中的密码无关，随便输入可以为空，为空直接回车。 如果在第二步中的没有重新命名的话，则忽略此步骤，ssh agent默认只读取id_rsa，为了让SSH识别新的私钥，需将其添加到SSH agent中,如第二步改的名字为robin, 则执行：ssh-add id_rsa如果出现Could not open a connection to your authentication agent的错误，就试着先用以下命令： ssh-agent bash ssh-add robin 添加完之后 登陆Github,点击网页右上侧的 Settings 按钮 - 选择 ssh-keys 点击Add SSH Key ，在title中输入名字，然后将公钥即id_rsa.pub添加到ssh-key处。 执行 ssh -T git@github.com 如果能正常访问即可 $ ssh -T git@github.com Hi robin! You've successfully authenticated, but GitHub does not provide shell access. 第二个帐户 新建user2的SSH Key $ cd ~/.ssh #切换到C:\Users\Administrator\.ssh ssh-keygen -t rsa -C "user2的Github账户邮箱" //新建工作的SSH key Enter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa): user2 //设置名称为user2(后文的user2可以统一替换任何别名) 新密钥添加到SSH agent中 因为默认只读取id_rsa，为了让SSH识别新的私钥，需将其添加到SSH agent中： ssh-add ~/.ssh/user2 //注意路径，如果不在.ssh目录下则不能省略 '~/.ssh/' 同样，如果出现Could not open a connection to your authentication agent的错误，就试着用以下命令： ssh-agent bash ssh-add ~/.ssh/user2 添加user2的公钥 打开新生成的 ~/.ssh/uesr2.pub文件，将里面的内容添加到user2的github帐号下的SSH Key中。 修改config文件 (重要的一步) 将账户以及git服务器与对应的密钥关联。在~/.ssh目录下找到config文件，如果没有就创建： touch config 然后修改如下： 我的config配置如下： # 该文件用于配置私钥对应的服务器 # Default github user1 Host github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa # second user2 # 建一个github别名，新建的帐号使用这个别名做克隆和更新 Host user2 HostName github.com User git IdentityFile ~/.ssh/user2 帐号关联 如果你只是文章中所述配置了Host，那么你多个账号下面的提交用户会是一个人，所以需要通过命令 git config --global --unset user.email 删除全局用户账户设置，当然也可以不删除，如果每个git项目下没有单独设置用户帐户信息的话，会默认使用全局设置 在每一个git项目下面使用命令 git config --local user.name '该项目的github用户名' git config --local user.email '该项目的github邮箱@mail.com' 单独设置用户账户信息，每个不同于全局用户帐户的git 项目都需要设置。 关于 clone 使用 git clone user2:user2/test.git 而不是 git clone git@github.com:user2/test.git 否则无法分辨使用的是哪一个帐户。 关于 remote 如果clone 项目时使用的是 git clone user2:user2/test.git 则remote url的Host 就是user2，可以跳过这一步，否则需要更改一下关联（包括git init新建），查看 remote git remote -v 如果user2的项目`remote.origin.url=git@github.com:user2/test.git `则需要进行修改 git remote rm origin git remote add origin user2:user2/test.git 测试： $ ssh -T git@github.com Hi user1! You've successfully authenticated, but GitHub does not provide shell access. $ ssh -T user2 Hi user2! You've successfully authenticated, but GitHub does not provide shell access.]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
