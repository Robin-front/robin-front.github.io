<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[css3中background-position的四值语法]]></title>
    <url>%2F2017%2F07%2F04%2Fbackground-position-of-css3-about-four-value-syntax%2F</url>
    <content type="text"><![CDATA[刨根问底，每个css属性都要知道它的所有值实在不容易。今天看看 background-position. background-positionCSS中的属性允许您在其容器内移动背景图像（或渐变）。 简介123html &#123; background-position: 100px 5px;&#125; 它有三种不同的取值： 长度值（例如100px 5px） 百分比（例如100% 5%） 关键字（例如top right） 默认值为0 0。这会将您的背景图像放在容器的左上角。 长度值很简单：第一个值是水平位置，第二个值是垂直位置。因此，100px 5px将图像向右移动100像素，向下移动五个像素。您可以设定长度值单位为px，em或任何其他的CSS长度值。 百分比有所不同。戴上你的数学帽子：用x％移动背景图像意味着 将图像中的X％点 与 容器中的X％点 对齐(PS：很多人解释的时候只会说向左向下移动了x%,这就无法解释50%)。例如，50%意味着它会将图像的中间与容器的中间对齐。100%意味着它会将图像的最后一个像素与容器的最后一个像素对齐，依此类推。 关键字只是百分比的捷径。这top right比记住和写作要容易得多0 100%，这就是关键字的意义。以下是所有五个关键字及其等价取值的列表： top：垂直0％ right：水平100％ bottom：垂直100％ left：水平0％ center：如果水平尚未定义，则水平为50％。如果定义了则应用到垂直。 有趣的是，您关键字使用的顺序并不重要：与之top center相同center top。只有当您使用单一关键字时，您才能做到这一点。center 10%是不一样的10% center。 演示此演示演示了background-position具有长度单位，百分比和关键字取值的集合示例。 See the Pen background-position values by CSS-Tricks (@css-tricks) on CodePen. 声明值(Declaring Values)background-position现代浏览器中最多可以放置四个值（有关详细信息，请参阅浏览器支持列表）。 如果您只声明 一个值，则该值是水平偏移量。浏览器将垂直偏移设置为center。 当您声明 两个值 时，第一个值是水平偏移量，第二个值是垂直偏移量。 当您开始使用三个或四个值时，事情会变得更加棘手，但您也可以更好地控制您的背景位置。 三或四值语法在关键字和长度或百分比单位之间进行交替。您可以在background-position的三值或四值中使用任何关键字值， 除 center之外。 当您指定 三个值 时，浏览器将“丢失”第四个值插入为0.以下是三值的示例background-position： 123#threevalues &#123; background-position: right 45px bottom;&#125; 这样就可以将背景图像定位在右侧的45px和容器底部的0px。 这是一个background-position 四值 的例子： 123#fourvalues &#123; background-position: right 45px bottom 20px;&#125; 这将背景图片定位在右侧的45px和容器底部的20px。 注意上面示例中值的顺序：关键字后跟长度单位。三或四个值background-position必须遵循该格式，关键字在长度或百分比单位之前。 演示此演示包括一个值，两个值，三个值和四个值的示例background-position。 See the Pen background-position 1, 2, 3, and 4 value syntax by CSS-Tricks (@css-tricks) on CodePen. 更多参考 background-position 在CSS3规范 background-position 在MDN 偏移背景图像 browser-support基本价值得到支持。四值语法具有此支持： Chrome Safari Firefox Opera IE Android iOS 25+ 7+ 13+ 10.5+ 9+ 4+ 7.1+ 【翻译原文：】https://css-tricks.com/almanac/properties/b/background-position/]]></content>
      <categories>
        <category>css3</category>
      </categories>
      <tags>
        <tag>background</tag>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array数组的indexOf、includes vs for-loop性能比较]]></title>
    <url>%2F2017%2F07%2F03%2Farr-of-indexOf-vs-includes-and-for-loop%2F</url>
    <content type="text"><![CDATA[最近遇到一道算法题，然后有些人会使用 includes、indexOf 去判断是否存在另一个数。这让我不禁思考，这和 for loop有什么区别，能减少时间复杂度吗？我一开始也不是很清楚，但我可以找文档，找标准。我的第一判断是 includes 完全和 for loop没有区别的，只是es6 标准规范提供的语法糖，而 indexOf 还是有一定效率的。带着疑惑，查看 MDN 和 ecma-262 includesincludes 是 ES6 新增语法，返回 布尔值。最容易拿 indexOf 来比较， indexOf 不能判断 NaN, 而且不够语义，返回的是 匹配值的位置 或 -1。 includes 内部实现是这样的： Let O be ? ToObject(this value). Let len be ? ToLength(? Get(O, “length”)). If len is 0, return false. Let n be ? ToInteger(fromIndex). (If fromIndex is undefined, this step produces the value 0.) If n ≥ 0, then Let k be n. Else n &lt; 0, Let k be len + n. If k &lt; 0, let k be 0. Repeat, while k &lt; len Let elementK be the result of ? Get(O, ! ToString(k)). If SameValueZero(searchElement, elementK) is true, return true. Increase k by 1. Return false. 其中的 SameValueZero 内部实现是这样的： If Type(x) is different from Type(y), return false. If Type(x) is Number, then If x is NaN and y is NaN, return true. If x is +0 and y is -0, return true. If x is -0 and y is +0, return true. If x is the same Number value as y, return true. Return false. Return SameValueNonNumber(x, y). 从上面可以看出 includes 内部是使用 while 循环，并不能够降低时间复杂度。它能判断出 NaN 以及 +0等于-0。 所以，返回值的语义化和 NaN的判断就是 includes 的场景。 indexOf好，includes 用来提升效率的幻想破灭了，那 indexOf 呢，规范是这么写的： Let O be ? ToObject(this value). Let len be ? ToLength(? Get(O, “length”)). If len is 0, return -1. Let n be ? ToInteger(fromIndex). (If fromIndex is undefined, this step produces the value 0.) If n ≥ len, return -1. If n ≥ 0, then If n is -0, let k be +0; else let k be n. Else n &lt; 0, Let k be len + n. If k &lt; 0, let k be 0. Repeat, while k &lt; len Let kPresent be ? HasProperty(O, ! ToString(k)). If kPresent is true, then Let elementK be ? Get(O, ! ToString(k)). Let same be the result of performing Strict Equality Comparison searchElement === elementK. If same is true, return k. Increase k by 1. Return -1. Array的 indexOf 也使用了 while 循环，并使用 === 全等比较。（注： 与 String.prototype.indexOf 并不同） indexOf 使用场景是需要知道 匹配值的位置。 结论这是一个性能测试比较 so? 如果单纯只是想比较，简单的才是最快的。 includes与indexOf效率相当，而for Loop最快，因为没有其他的前置判断和浏览器对它的优化。]]></content>
      <categories>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>indexOf</tag>
        <tag>includes</tag>
        <tag>loop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web Animations API 入门教程总结回顾]]></title>
    <url>%2F2017%2F06%2F28%2FWeb-Animations-API-Tutorial-Conclusion%2F</url>
    <content type="text"><![CDATA[这是 Web Animations API 入门教程系列的总结部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与@dancwilson联系。 我们已经涵盖了相当多的知识面，希望能够解决有关Web Animations API是什么（而不是什么）的问题。要总结这个系列，我们将回顾一下我们已经讨论过的内容，并看看尚未实现的内容。 为什么要用API？在介绍中，我们讨论了API是如何将CSS，JS和SVG中的各种方法结合起来进行动画处理，旨在充分利用它们。这意味着，例如，JavaScript可以锁定CSS多年来的硬件加速，并不限于CSS的声明性。API并不意味着替换像GSAP这样的库，而只是为了在浏览器级别提供更多的选项。 Firefox和Chrome都已经开始实施，而Edge已经积压了很多事没有做。随着团队完成规范，polyfill可以让我们开始玩转它。 动画基础要创建一个基本的动画，我们通过提供关键帧和时序属性来跟踪类似于CSS的结构。 123456var player = document.getElementById('toAnimate').animate([ &#123; transform: 'scale(1)', opacity: 1, offset: 0 &#125;, &#123; transform: 'scale(.6)', opacity: .6, offset: 1 &#125; ], &#123; duration: 700, &#125;); 时间轴控制是当前CSS中明显不存在的部分。通过playState属性读取动画的状态，并改变状态，例如play()，pause()，和finish()。我们也可以通过读/写playbackRate属性将播放速度更改或更快。currentTime可读写，我们可以设置当动画与完成回调onfinish。 多个动画和分组Web Animations API允许对元素设置多个动画，创建单独的动画对象。document上默认的timeline可以使用getAnimations()方法让我们访问创建的所有动画。可以通过使用GroupEffects 和 SequenceEffects（在polyfill中提供但不在Level 1规范中）将动画组合在一起或一个接一个地进行播放。 运动路径与未来在这个系列中，沿着一条路径运动让我们看到了它在CSS中的第一个实现，但还有很多其他模块尚未实现。 间距(Spacing)如果在关键帧中没有设置offset，则当前的实现使用默认的间隔，这意味着它们是均匀分布的（例如，三个帧将具有0,1,5和1的偏移量）。该规范还定义了一种基于属性来调整动画的方法，以使其具有恒定的变化率。当讨论Spacing keyframes时，该规范描述了这一点。 Promises该规范已经演变成–包括ready在内的，每次动画取消或进入挂起状态（通常在更改为“运行”或“已暂停”）之前将会被新的Promise替换。除了onfinish, 我们在本系列中讨论的使用回调之外，我们还可使用finished返回的Promise在动画完成后运行其他功能。 让我们继续谈论Web动画API人们开始更多地谈论这个API，我希望这个讨论继续下去。规格，浏览器实现和polyfill已经持续了一段时间，他们准备好仔细检查。 有时CSS会有更多场景，有时候是requestAnimationFrame，有时使用类库会是最好的解决方案。知道什么时候使用什么是好的，这个API提供了不少以前我们以前没有的可用的东西，所以很有趣。 查看本系列的其余部分： 介绍 第1部分：创建基本动画 第2部分：动画和时间线控制 第3部分：多个动画 第4部分：GroupEffects和SequenceEffects 第5部分：运动路径 总结与回顾 【翻译原文】： http://danielcwilson.com/blog/2015/09/animations-conclusion/]]></content>
      <categories>
        <category>Web Animations</category>
      </categories>
      <tags>
        <tag>Web Animations</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web Animations API 入门教程第5部分: 可爱的运动路径]]></title>
    <url>%2F2017%2F06%2F28%2FWeb-Animations-API-Tutorial-Part-5-The-Loveable-Motion-Path%2F</url>
    <content type="text"><![CDATA[这是 Web Animations API 入门教程系列的第5部分。 重要信息：自撰写本文以来，运动路径的规范（和Chromium实现）已经发生了重大变化。以下在概念上仍然有效，但是属性名称和更多内容已经改变。截至2016年10月，请查看CSS运动路径。 最后，沿着路径动画…不再仅仅是SVG的领域。 运动路径：当前方向（Spec）See the Pen Motion Path Infinity by Dan Wilson (@danwilson) on CodePen. 随着API规范的运用，运动路径出现了不同的形式。最初有可能的一个方向是一个形式的特效（如前面所讨论的GroupEffect），但随后借助CSS模块的运动路径的气势一点点上升（拥有它自己的规范）。 因此，沿着路径动画将只是另一组CSS属性，可以动画化，正如opacity和tranform也可以。这样，CSS过渡和关键帧可以使用它,Web Animations API也是…这是伟大的，因为我们想要尽可能多的这些方法之间共享给我们更多的灵活性。Chrome和Opera已经发布了一个初步的实现，所以我们可以在今天开始玩它，尽管还没有在polyfill找到它的任何使用方式。 让我们分解这些属性，我们如何使用它们，现在还有什么事情可以阻碍我们。 运动路径属性我们将讨论motion的三个属性。现在，要查看示例，您将需要运行Chrome 46或Opera 33。 motion-path起始点是motion-path定义元素可以移动的路径，遵循SVG 1.1中的路径工作方式： 123#motioner &#123; motion-path: path("M200 200 S 200.5 200.1 348.7 184.4z");&#125; 这也可以fill-rule在路径调用中作为可选的第一个参数。我建议您阅读Joni Trythall的“优秀口袋指南”，就SVG进行讨论。 根据规范，您还可以使用基本形状，例如circle，polygon，ellipse，和inset。如果您尝试过使用CSS shape，这些应该看起来很熟悉。 根据Blink的初始实现，我只看过这个path()方法可以工作，所以我一直没有正确使用形状或者还没到时候。 motion-offset驱动运动，并将元素放在我们使用的路径上的某个位置motion-offset。这可以是双倍长度值或百分比。因此，从路径的起点到最后，我们设置一个从0到100％的动画。使用我们拥有的Web Animations API 12345var m = document.getElementById('motioner');m.animate([ &#123; motionOffset: 0 &#125;, &#123; motionOffset: '100%' &#125;], 1000); 以及CSS的写法 1234567891011#motioner &#123; animation: path-animation 1s;&#125;@keyframes path-animation &#123; 0% &#123; motion-offset: 0; &#125; 100% &#123; motion-offset: '100%'; &#125;&#125; See the Pen CSS Motion Path Spiral by Dan Wilson (@danwilson) on CodePen. 该CodePen演示显示了从外部到内部沿着螺旋路径移动的几个点。随着每个点接近中心，它变得越来越快，变得越来越透明。 .animate()在每个点被称为两次无限迭代和一个延迟，其中一个调用集中在运动偏移，另一个焦点在缩放和不透明度上。我分解了他们，指出了不同的解决方案，当然，他们也可以结合在一起。 这种方法还使用功能检测，您将会注意到，如果您在Safari，Firefox，Edge或旧版Chrome / Opera中查看，因为您将看到一条消息而不是动画。有几种方法可以做到这一点，比如 12var m = document.getElementById('motioner');if (m.style.motionOffset !== undefined) &#123; ... &#125; 当然，我们不想在真正的网页中完全阻止用户，所以如果支持，我们可以有另一个动画（或者没有动画）切换到Motion Path动画。像往常一样，渐进增强(Progressive Enhancement)是我们的朋友。 motion-rotation最后的属性是motion-rotation，它处理元素沿着路径移动时面向哪个方向。有四种主要方法可以指定这一点。 auto 表示元素将随路径旋转。 reverse 元素也将随着路径旋转，但会增加180度，因此将向后。 auto Xdeg / reverse Xdeg 除了添加X度也会一样 Xdeg 将不再与路径一起旋转，元素将保持固定朝向相同的方向。 See the Pen CSS MotionPath by Dan Wilson (@danwilson) on CodePen. 少了点什么东西？这是第一个版本，当然，浏览器制造商和规范作者仍在讨论这一切。在尝试这一过程中，我注意到的最大的一件事就是缺少适应不同屏幕/容器尺寸的路径。 路径只是按照它们的定义出现。当使用SVG时，我们获得灵活性，因为我们在容器上具有不同的坐标系和属性，如 viewBox。使用CSS中定义的运动路径，路径的大小不能被其他属性另外修改或约束。元素上定义的宽度和高度仅适用于元素，而不是其运动路径。您可以使用媒体查询或JavaScript来定义不同条件的不同路径，但是想通过motion属性灵活地设置它们是不可能的事。 回顾和下一节我们将看到规范的方向，但现在尝试这样做是很有趣的，看看它可能提供什么（和不提供什么）。我正在收集我在CodePen上找到的CSS Motion Path演示文稿，而Eric Willigers（Chrome开发团队的相关实现任务的所有者）拥有一个Google Doc的例子。 我们将在下次再次介绍我们所讨论的内容，并且再看几个目前唯一的规范主题。 查看本系列的其余部分： 介绍 第1部分：创建基本动画 第2部分：动画和时间线控制 第3部分：多个动画 第4部分：GroupEffects和SequenceEffects 第5部分：运动路径 总结与回顾 【翻译原文】： http://danielcwilson.com/blog/2015/09/animations-part-5/]]></content>
      <categories>
        <category>Web Animations</category>
      </categories>
      <tags>
        <tag>Web Animations</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web Animations API 入门教程第4部分: GroupEffects & SequenceEffects]]></title>
    <url>%2F2017%2F06%2F27%2FWeb-Animations-API-Tutorial-Part-4-GroupEffects-and-SequenceEffects%2F</url>
    <content type="text"><![CDATA[这是 Web Animations API 入门教程系列的第4部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与@dancwilson联系。 让我们继续讨论Web动画API中的多个动画，通过讨论今天在polyfill中提供的几个部分来提供分组和排序。 KeyframeEffectsA KeyframeEffect需要三个参数：动画元素(element)，关键帧数组(keyframes)和时间选项(timing options)。这些都是我们以前使用过的参数element.animate()。这个新对象本质上是单个动画的蓝图，当我们讨论分组(group)和队列(sequence)动画的方法时，我们会看到它。它不启动动画，它只是定义动画。 1234567891011var elem = document.getElementById('toAnimate');var timings = &#123; duration: 1000, fill: 'both'&#125;var keyframes = [ &#123; opacity: 1 &#125;. &#123; opacity: 0 &#125;];var effect = new KeyframeEffect(elem, keyframes, timings); GroupEffects虽然在任何浏览器中都没有实现此功能，甚至在Level 2规范中找不到，但是polyfill提供了一种组合动画并将其一起播放的方法。 GroupEffect（是的，它是未来将集成在Level 2规范）组合一个或多个KeyframeEffects同时播放。 See the Pen Group Effects with WAAPI by Dan Wilson (@danwilson) on CodePen. 一个GroupEffect任务需要一个Effects参数，我们可以传递代表我们多个动画的KeyframeEffect数组。一旦定义，我们可以在准备好的时候在默认时间轴上播放动画组。 12345678910111213141516var elem = document.getElementById('toAnimate');var elem2 = document.getElementById('toAnimate2');var timings = &#123; duration: 1000&#125;var keyframes = [ &#123; opacity: 1 &#125;. &#123; opacity: 0 &#125;];var kEffects = [ new KeyframeEffect(elem, keyframes, timings), new KeyframeEffect(elem2, keyframes, timings)];var group = new GroupEffect(kEffects);document.timeline.play(group); SequenceEffects类似于GroupEffect，SequenceEffect允许我们将多个动画（由KeyframeEffects 指定）组合在一起…不是并行播放它们，而是一个接一个地播放它们。您也可以按照polyfill中的定义将GroupEffect和SequenceEffect一起使用（例如具有多个序列的分组）。 See the Pen SequenceEffect with WAAPI by Dan Wilson (@danwilson) on CodePen. 队列提供给你一些我们必须用CSS或者我们在 animations API中看到的东西。我们必须根据早期动画的持续时间或使用 finish 回调来维持延迟。这些方法可能难以维护，或者不会如此精确。 使用先前在GroupEffect代码段中的变量： 12var sequence = new SequenceEffect(kEffects);document.timeline.play(sequence); 创建动画的备用方法我们以前看过element.animate()创建动画的方式。这是创建动画的快捷方式，立即播放，并获取Animation对象的引用。我们专注于这一点，因为Chrome支持了一段时间了，polyfill也是。Firefox是第一个支持替代方式的：·构造函数。它向我们展示了另一种使用方法KeyframeEffect，而且它在Level 1规范中，所以我们应该很快会看到它的更多应用。 首先提醒一下如何element.animate()工作： 1234567891011var elem = document.getElementById('toAnimate');var timings = &#123; duration: 1000, fill: 'both'&#125;var keyframes = [ &#123; opacity: 1 &#125;. &#123; opacity: 0 &#125;];elem.animate(keyframes, timings); 使用与上述相同的变量，以下是使用Animation构造函数的等价写法： 123var kEffect = new KeyframeEffect(elem, keyframes, timings);var player = new Animation(kEffect, elem.ownerDocument.timeline);player.play(); 这里的主要区别在于，动画不会立即开始播放，所以在提前创建动画以便稍后播放时，这将非常有用。 回顾和下一节当Level 2规范通过工作草案时，我们应该看到更多关于这些不同效果的定义。本系列中还有两个计划的章节。下一次我们将再次看看未来，还有什么我们可以期待看到。 查看本系列的其余部分： 介绍 第1部分：创建基本动画 第2部分：动画和时间线控制 第3部分：多个动画 第4部分：GroupEffects和SequenceEffects 第5部分：运动路径 总结与回顾 【翻译原文】：http://danielcwilson.com/blog/2015/09/animations-part-4/]]></content>
      <categories>
        <category>Web Animations</category>
      </categories>
      <tags>
        <tag>Web Animations</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web Animations API 入门教程第3部分: 多个Animations对象]]></title>
    <url>%2F2017%2F06%2F27%2FWeb-Animations-API-Tutorial-Part-3-Multiple-Animations%2F</url>
    <content type="text"><![CDATA[这是 Web Animations API 入门教程系列的第3部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与@dancwilson联系。 在我们讨论动画和时间线控制之后，让我们来讨论多个动画。 每个元素的多个动画See the Pen Multiple animate calls by Dan Wilson (@danwilson) on CodePen. 在这个例子中，每个矩形都有三个动画应用（涉及到transform，opacity和color）。您可以多次调用元素的animate()方法，类似于允许多个动画的CSS。 使用CSS： 123456#toAnimate &#123; animation: pulse 1s, activate 3000ms, have-fun-with-it 2.5s;&#125;@keyframes pulse &#123; /* ... */ &#125;@keyframes activate &#123; /* ... */ &#125;@keyframes have-fun-with-it &#123; /* ... */ &#125; 使用Web Animations API： 1234567var animated = document.getElementById('toAnimate');var pulseKeyframes, //在这里定义 keyframes. activateKeyframes, haveFunKeyframes;var pulse = animated.animate(pulseKeyframes, 1000); // 第二个数值参数作为持续时间的缩写var activate = animated.animate(activateKeyframes, 3000);var haveFunWithIt = animated.animate(haveFunKeyframes, 2500); 使用Web Animations API，这将创建三个Animation对象，每个对象可以通过时间轴(timeline)或播放速率(playback rate)进行暂停，播放，完成，取消的操作。 获取 Animations，全部动画对象所以你可以知道一个动画开始播放了，但是当你想在元素上调用animate()时你却还没有捕获到Animation的引用。那要怎么做？ See the Pen Pause All those Random Dots! by Dan Wilson (@danwilson) on CodePen. 该规范允许getAnimations()在文档上的方法。在最新版本的规范中，它直接在document（document.getAnimations()）上，在Firefox 48+上它是这样实现的。然而，对于Chrome 52 和polyfill（如V2.2.0的），则根据该旧规范将其置于新的timeline对象上。 123// 如果引用了 polyfill ，你可以这样写var animations = document.getAnimations ? document.getAnimations() : document.timeline.getAnimations();// 返回一个数组，包含所有正在进行的（除了已完成的和被取消的）动画 在CodePen示例中，您将看到随机的持续时间，延迟和无限持续时间的变换移动的几个点。“暂停全部”按钮调用getAnimations()并遍历所有, 返回的玩家（每个动画对象）并暂停每一个。 下一节…在下一部分中，我们将看看WAAPI动画可以创建的不同方式（因为它不仅仅是element.animate）。提示：document.timeline会出现更多的体现。 查看本系列的其余部分： 介绍 第1部分：创建基本动画 第2部分：动画和时间线控制 第3部分：多个动画 第4部分：GroupEffects和SequenceEffects 第5部分：运动路径 总结与回顾 【翻译原文】: http://danielcwilson.com/blog/2015/08/animations-part-3/]]></content>
      <categories>
        <category>Web Animations</category>
      </categories>
      <tags>
        <tag>Web Animations</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web Animations API入门教程第2部分：动画和时间线控制]]></title>
    <url>%2F2017%2F06%2F26%2FWeb-Animations-API-Tutorial-Part-2-The-Animation%2F</url>
    <content type="text"><![CDATA[这是 Web Animations API 入门教程系列的第2部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与@dancwilson联系。 现在我们了解如何使用Web Animations API 创建基本动画，让我们来谈谈状态（states），控制(controls)，回调(callback)和时间轴(timelines)。 Animations 播放状态和控制当你调用时element.animate()，返回一个Animation对象（以前称为AnimationPlayerspec），动画开始播放。要查看动画的当前状态，您可以检查readonly属性playState，该属性将返回五个字符串之一。我们也可以通过调用四种方法之一修改动画的当前状态： 1234567var player = element.animate(/* ... */);console.log(player.playState); //"running"player.pause(); //"paused"player.play(); //"running"player.cancel(); //"idle"... 跳到原始状态player.finish(); //"finished"...跳到结束状态 此外running，paused，idle，和finished播放状态有一个pending状态定义当播放或暂停任务正在等待批准即将发生。 这个“步行圆圈”示例显示六个圆缩放。您可以暂停或播放每个圈子，以查看上述播放状态的一部分。 See the Pen Blob That Walks by Dan Wilson (@danwilson) on CodePen. 播放速率在之前的CodePen示例中，还有一个“2x”按钮，您可以按更改动画的播放速度，将其切换到双倍速度。这是通过读/写playbackRate属性。 1234var player = element.animate(/* ... */);console.log(player.playbackRate); //1player.playbackRate = 2; //双倍速度, 也可以使用十进制数字控制它降低速度. 动画完成后的回调使用CSS transitions，当转换结束时，通常会触发一个事件。类似地，Animation允许您指定一个onfinish函数，在动画完成或调用之前讨论过的finish()方法时调用它。请注意，根据规范，无法完成无限次迭代的动画集，也不能完成一个具有playbackRate = 0 的动画集。还有一个oncancel处理程序，以及在Animation完成时使用Promises的写法。 以下示例用于onfinish在动画完成后显示一些统计信息（并且它也很好地切换到下一次关于时间轴的讨论）。 See the Pen Timer Countdown by Dan Wilson (@danwilson) on CodePen. 时间轴每个Animation都公开两个读/写时间相关属性 - currentTime和startTime。现在，我们将重点关注前者。 currentTime返回动画当前的毫秒数。最大值将为延迟时间 +（持续时间迭代次数）（`delay + (duration iterations)`），因此无限次迭代将不具有最大值。 1234567891011var player = element.animate([ &#123;opacity: 1&#125;, &#123;opacity: 0&#125;], &#123; duration: 1000, delay: 500, iterations: 3&#125;);player.onfinish = function() &#123; console.log(player.currentTime); // 3500&#125;; 播放速率将影响时间轴的持续时间。如果您将播放速度设置为10，则您的最大时间保持不变，但您的时间轴会快10倍。这个概念也在之前的“计时器倒计时”示例中显示。 由于currentTime是可 读/写，我们也可以使用它来跳转到时间轴中的某一点。它也可以让我们同步两个动画，如下例所示。 See the Pen Syncing Timelines - WAAPI by Dan Wilson (@danwilson) on CodePen. 还有一个选项： reverse()你也可以使用reverse()反转一个与之非常相似的动画play()（比如它会有相同的playState），除了它将以相反的方式遍历时间轴。当动画完成时，currentTime将为0。 See the Pen waRKOm by Dan Wilson (@danwilson) on CodePen. 下一节…这包含了很多的信息，但仍然只是熟悉一下WAAPI有哪些可用的。下面我们来看一些更高级的用法。 查看本系列的其余部分： 介绍 第1部分：创建基本动画 第2部分：动画和时间线控制 第3部分：多个动画 第4部分：GroupEffects和SequenceEffects 第5部分：运动路径 总结与回顾 【翻译原文】: http://danielcwilson.com/blog/2015/07/animations-part-2/]]></content>
      <categories>
        <category>Web Animations</category>
      </categories>
      <tags>
        <tag>Web Animations</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web Animations API 入门教程第1部分:创建一个基本的动画]]></title>
    <url>%2F2017%2F06%2F26%2FWeb-Animations-API-Tutorial-Part-1-Creating-a-Basic-Animation%2F</url>
    <content type="text"><![CDATA[这是 Web Animations API 入门教程系列的第1部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与@dancwilson联系。 我们之前初步看了下 Web Animations API，但是我们没有得到任何真正的细节，所以现在我们来看看。 WAAPI（Web Animations API, 以下均简称WAAPI）为您提供更多的控制比您可能已经习惯使用的CSS动画，但在我们进入这些演示之前，我们需要设置基本目标：如何通过此API创建基本动画？ 创建关键帧动画如果您熟悉CSS Transitions/ Animations，这将非常熟悉。 12345678910111213var player = document.getElementById('toAnimate').animate([ &#123; transform: 'scale(1)', opacity: 1, offset: 0 &#125;, &#123; transform: 'scale(.5)', opacity: .5, offset: .3 &#125;, &#123; transform: 'scale(.667)', opacity: .667, offset: .7875 &#125;, &#123; transform: 'scale(.6)', opacity: .6, offset: 1 &#125; ], &#123; duration: 700, //毫秒 easing: 'ease-in-out', //'linear', a bezier curve等. delay: 10, //毫秒 iterations: Infinity, //或其他数值 direction: 'alternate', //'normal', 'reverse', 等. fill: 'forwards' //'backwards', 'both', 'none', 'auto' &#125;); 为了对照，这里是一个等效的CSS关键帧动画 123456789101112131415161718192021@keyframes emphasis &#123; 0% &#123; transform: scale(1); opacity: 1; &#125; 30% &#123; transform: scale(.5); opacity: .5; &#125; 78.75% &#123; transform: scale(.667); opacity: .667; &#125; 100% &#123; transform: scale(.6); opacity: .6; &#125;&#125;#toAnimate &#123; animation: emphasis 700ms ease-in-out 10ms infinite alternate forwards;&#125; 我们将分解这一切，解释每一部会。 1var player = document.getElementById('toAnimate').animate() 动画将返回一个 Animation（以前在规范中称为 AnimationPlayer）对象，这将给我们做些有趣的事情，所以你可能想要设置一个变量来捕获这个引用。我们找到我们想要的动画元素（这里简单地使用document.getElementById）并调用该animate函数。此功能是新添加的特性，所以如果您必须要测试它的支持性/存在性，在使用它之前或者引用 polyfill。 该animate函数有两个参数，一个KeyframeEffects和一个AnimationEffectTimingProperties选项的数组。本质上，第一个参数映射到CSS中的内容@keyframes，第二个参数是您在CSS规则中使用的animation-*属性（或animation简写，如我之前的示例）所指定的那样。这里的主要优点是我们可以使用变量或重用以前定义的KeyframeEffects，而使用CSS我们仅限于我们在前面声明的值。 123456var player = document.getElementById('toAnimate').animate([ &#123; transform: 'scale(1)', opacity: 1 &#125;, &#123; transform: 'scale(.5)', opacity: .5 &#125;, &#123; transform: 'scale(.667)', opacity: .667 &#125;, &#123; transform: 'scale(.6)', opacity: .6 &#125; ]); 对于每一个KeyframeEffect，我们将CSS中的百分比偏移量改为offset从0到1 的十进制值。它是可选的，如果没有指定，它们将均匀分布（因此，如果您有三个，则第一个具有偏移为0，第二个偏移量为.5，第三个偏移量为1）。您还可以指定easing与animation-timing-functionCSS中相同的属性。每个的其他属性KeyframeEffect都是动画的属性。每个属性的值应该符合在JavaScript的element.style中的用法，因此opacity将是一个数字，但transform会期望一个字符串。 12345678var player = document.getElementById('toAnimate').animate([], &#123; duration: 700, //milliseconds easing: 'ease-in-out', //'linear', a bezier curve, etc. delay: 10, //milliseconds iterations: Infinity, //or a number direction: 'alternate', //'normal', 'reverse', etc. fill: 'forwards' //'backwards', 'both', 'none', 'auto' &#125;); 时间属性将映射到CSS动画属性，尽管有时会使用不同的名称。较早的代码示例讨论了主要选项。 以下是使用polyfill的示例（但如果您正在Chrome 36+，Opera 23+或Firefox 48+中查看，则应使用实际的浏览器实现）。第一列灰色块使用WAAPI动画，第二列红色块使用CSS关键帧进行动画。 See the Pen CSS Keyframes v. WAAPI by Dan Wilson (@danwilson) on CodePen. 下一节…现在我们知道如何创建在CSS中熟知的等效动画，我们将开始查看Animation 的 animate 函数返回的对象。这是我们看到真正的功能和改进的地方。 查看本系列的其余部分： 介绍 第1部分：创建基本动画 第2部分：动画和时间线控制 第3部分：多个动画 第4部分：GroupEffects和SequenceEffects 第5部分：运动路径 总结与回顾 【翻译原文】： http://danielcwilson.com/blog/2015/07/animations-part-1/]]></content>
      <categories>
        <category>Web Animations</category>
      </categories>
      <tags>
        <tag>Web Animations</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让我们谈谈 Web Animations API]]></title>
    <url>%2F2017%2F06%2F25%2Fanimations-intro%2F</url>
    <content type="text"><![CDATA[这是 Web Animations API 入门教程系列的总结部分。我在2016年6月更新了系列内容，因为Chrome和Firefox都推出了主要更新（以及一些小规格更改）。如果您有想法或问题，或看到我已经误解了该规范，请在Twitter上与@dancwilson联系。 2014年夏天，Google宣布通过Polymer在网页中展示Material设计…使用polyfill技术支持即将推出的标准Web Animations API。 我没有听说过这个API，但是我很感兴趣，特别是因为它谈到了MotionPath(运动路径)效果。这还没有实现（你会在第5部分发现这是什么），但是它的目标是提供一种组合CSS，JS和SVG的动画方式，让我感兴趣。一年以后，Chrome和Firefox开始实施，polyfill的进步是稳定的，现在是认真看待它的时候了。 但是很少有人在谈论WAAPI！我希望开始一系列突出浏览器（和polyfill）功能的帖子，探索为什么我们想要这个API，并找出细微差别。希望我们也能让更多的人讨论和使用这个API。 什么是Web动画API？我们将通过弄清楚它是什么，以及它正在努力完成的事情来开始这个探索。 动画在过去的十年中已经取得了很好的进展，并提供了很好的CSS支持和新增功能来改进JavaScript。但是，每种动画方法仍然对他们所提供的所有优点都有一些缺陷。 CSS具有用于平滑过渡的硬件加速，并且浏览器内置了支持，但规则在CSS中声明，并且需要跳过JavaScript环节以获得动态更改的值。 requestAnimationFrame有很好的支持，让浏览器在动画时进行优化，但如果还有很多其他JavaScript运行，它仍然可以挂起。它也经常需要更多的数学知识来获得定时。 setInterval被很多开发人员用来做动画，但它是不精确的，可以导致动画卡顿。 jQuery.animate() 被其他一些开发人员推荐制作动画，但往往有性能问题。 诸如Velocity和GreenSock（GSAP）这样的类库可以提高JavaScript的性能，并且在许多情况下已经被测试成为最好的。然而，他们仍然需要维护和加载额外的库。 一般来说，我们喜欢浏览器的支持尽可能多，直接被优化过的方式。现在浏览器有document.querySelector，因为我们看到jQuery提供选择DOM元素的值。理想情况下，我们可以在浏览器级别包装尽可能多的动画控件。这些库可以专注于提供更新的功能，并且可以持续迭代。 Web Animations API尝试这样做。它旨在带来CSS性能的强大，增加了JavaScript的好处和灵活性（以及SVG动画，我们将在以后的一篇文章中讨论），并将其留给浏览器使其运行良好。 让我们通过添加新的东西来解决这个问题！在以前的工作中，我们收到一封电子邮件，表示他们知道我们有太多的地方可以查看公司公告 - 电子邮件，办公室的监视器，Yammer，Google Chat和Intranet / wiki。所以要解决他们宣布的问题，他们正在添加一个博客。 我第一次听到有关Web Animations API 和我听到我公司新增博客的想法一样 - 这只会使事情变得更糟。果然，博客没有集中任何东西，它只是添加了一个地方，我们必须查看新闻，然后不了了之了。 这感觉不一样。 审查规范（第一次我在这个程度上真的做到这一点）显示了对此的关注。这并不意味着取代现有的行为（尽管有些浏览器似乎已经不赞成某些行为），而是将各种方式联合起来，并允许他们进行交互。语法类似于CSS，但添加了变量，控制和完成回调的选项。 下一节…因此，Web Animations API是新的，并且开始实现（目前在Chrome和Firefox中），除了拥有一个polyfill。下次我们实际上会开始看看它为开发者提供了什么…有例子！ 查看本系列的其余部分： 介绍 第1部分：创建基本动画 第2部分：动画和时间线控制 第3部分：多个动画 第4部分：GroupEffects和SequenceEffects 第5部分：运动路径 总结与回顾 【翻译原文】：http://danielcwilson.com/blog/2015/07/animations-intro/]]></content>
      <categories>
        <category>Web Animations</category>
      </categories>
      <tags>
        <tag>Web Animations</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css 动画和 Web Animation API(WAAPI)对比]]></title>
    <url>%2F2017%2F06%2F22%2Fcss-animations-vs-web-animations-api%2F</url>
    <content type="text"><![CDATA[有一个JavaScript的动画原生API，称为Web Animation API。我们在这篇文章中称之为WAAPI。MDN有很好的文档，Dan Wilson 有一个伟大的系列文章。 在本文中，我们将比较WAAPI和CSS中完成的动画。 关于浏览器支持的提示尽管现在浏览器的支持很有限，但WAAPI有一个全面而强大的polyfill工具，让它可以在当前的生产环境中使用。 一如既往，您可以检查Can I Use 的浏览器支持数据。然而，这并没有提供非常好的信息来支持WAAPI的所有子功能。这是一个检查器： See the Pen WAAPI Browser Support Test by Dan Wilson (@danwilson) on CodePen. 想要不使用polyfill而体验所有功能，请使用Firefox Nightly。 WAAPI的基础知识如果您曾经使用jQuery.animate()，WAAPI的基本语法应该看起来很熟悉。 12var element = document.querySelector('.animate-me');element.animate(keyframes, 1000); 该animate方法接受两个参数：关键帧和持续时间。与jQuery不同的是，它不仅具有内置在浏览器中的优点，而且性能也更高。 第一个参数，关键帧应该是一个对象数组。每个对象都是我们动画中的一个关键帧。这是一个简单的例子： 1234var keyframes = [ &#123; opacity: 0 &#125;, &#123; opacity: 1 &#125;]; 第二个参数，持续时间，是我们想要动画持续多久。在上面的例子中是1000毫秒。我们来看一个更令人兴奋的例子。 用WAAPI重新创建animista CSS动画这里有一些CSS代码，从非常棒的animista中吸取了一些称为“幻灯片模糊的”入场动画的东西。看起来很可爱。 以下是CSS中的关键帧： 1234567891011120% &#123; transform: translateY(-1000px) scaleY(2.5) scaleX(.2); transform-origin: 50% 0; filter: blur(40px); opacity: 0;&#125;100% &#123; transform: translateY(0) scaleY(1) scaleX(1); transform-origin: 50% 50%; filter: blur(0); opacity: 1;&#125; WAAPI中的代码相同： 123456789101112var keyframes = [ &#123; transform: 'translateY(-1000px) scaleY(2.5) scaleX(.2)', transformOrigin: '50% 0', filter: 'blur(40px)', opacity: 0 &#125;, &#123; transform: 'translateY(0) scaleY(1) scaleX(1)', transformOrigin: '50% 50%', filter: 'blur(0)', opacity: 1 &#125;]; 我们已经看到，将关键帧应用到要运动的任何元素是多么容易的事： 1element.animate(keyframes, 700); 为了简单起见，我只指定了持续时间。但是，我们可以使用这个第二个参数来传递更多的选项。至少我们也应该指定一个缓动函数。以下是可用选项的完整列表，其中包含一些示例值： 1234567891011var options = &#123; iterations: Infinity, iterationStart: 0, delay: 0, endDelay: 0, direction: 'alternate', duration: 700, fill: 'forwards', easing: 'ease-out',&#125;element.animate(keyframes, options); 有了这些选项，我们的动画将从头开始，没有任何延迟，永远循环在向前和向后播放。 See the Pen motion blur waapi circle by CSS GRID (@cssgrid) on CodePen. 令人烦恼的是，对于我们熟悉CSS动画的人来说，一些术语与我们习惯的不同。虽然在积极的一面看，有些事情写起来更快一点！ 这里用easing而不是animation-timing-function 使用iterations而不是animation-iteration-count。如果我们希望动画永远重复，用Infinity而不是infinite。有点混乱，Infinity不是引用。Infinity是一个JavaScript关键字，而其他值是字符串。 我们使用毫秒而不是秒，对于之前编写过许多JavaScript的人来说，这应该是熟悉的。（您可以在CSS动画中使用毫秒数，但很少有人使用。） 我们来仔细看看一个选项：iterationStart。 当我第一次碰到iterationStart, 我被难住了。你为什么要指定迭代的开始，而不仅仅是减少迭代次数？当您使用十进制数时，此选项非常有用。例如，您可以将其设置为 .5，动画将开始一半。要做一整个动画需要两半，所以如果你的迭代次数设置为1，并且你的iterationStart设置为 .5，动画将从一半到动画结束播放，然后从动画开头开始，结束于中间！ 值得注意的是，您也可以将迭代次数设置为小于1。例如： 1234var option = &#123; iterations: .5, iterationStart: .5&#125; 这将从中间到最后播放动画。 endDelay：endDelay如果要将多个动画串在一起，但是希望在一个动画的结尾和任何后续动画的开始之间存在差距。这是一个有用的视频，Patrick Brosset 的解释。 缓动缓动是任何动画中最重要的元素之一。WAAPI为我们提供了两种不同的方式设置缓动函数 - 在我们的关键帧阵列或我们的选项对象内。 在CSS中，如果你应用了，animation-timing-function: ease-in-out你可能会假设你的动画的开始会ease in，动画的结束将会ease out。实际上，这些缓动函数应用在关键帧之间，而不是整个动画。这可以对动画的感觉进行细粒度的控制。WAAPI还提供这种能力。 12345var keyframes = [ &#123; opacity: 0, easing: 'ease-in' &#125;, &#123; opacity: 0.5, easing: 'ease-out' &#125;, &#123; opacity: 1 &#125;] 值得注意的是，在CSS和WAAPI中，您不应该传入最后一帧的缓动值，因为这将不起作用。这是很多人犯的错误。 有时候，在整个动画中添加缓动效果更为直观。这在CSS是不可能的，但现在可以实现与WAAPI。 1234var options = &#123; duration: 1000, easing: 'ease-in-out',&#125; 你可以看到这两种缓动在CodePen上的区别： See the Pen Same animation, different easing by CSS GRID (@cssgrid) on CodePen. ease vs linear值得注意的是CSS动画和WAAPI之间的另一个区别：CSS ease的默认值是ease,WAAPI的默认值linear。 Ease实际上是一个版本，ease-in-out是一个非常好的选择，如果你感到懒惰。同时，linear 是沉闷的和无生机的 - 一致的速度看起来机械和不自然。它被选为默认值，可能因为它是最中立的选项。然而，在WAAPI中使用时，使用缓动比在CSS更重要，以免您的动画看起来很乏味和机械地。 性能WAAPI提供与CSS动画相同的性能改进，尽管这并不意味着平滑的动画是不可避免的。 我希望这个API的性能优化意味着我们可以避免使用will-change和完全hack translateZ - 最终可能。但是，至少在目前的浏览器实现中，这些属性在处理闪烁问题（jank issue）方面仍然是有帮助和必要的。 但是，至少如果您的动画有延迟，则无需担心使用will-change。网络动画规范的主要作者对“Animation for Work Slack community”提出了一些有趣的建议，希望他不介意我在这里重复： 如果您有一个积极的延迟，您不需要will-change因为浏览器将在延迟开始时进行分层，当动画启动时，它将准备就绪。 WAAPI对战CSS动画？WAAPI为我们提供了一个在JavaScript中实现css中的语法。然而，他们不应该被视为对手。如果我们决定坚持使用CSS进行animations和transitions，那么我们可以与WAAPI进行动画交互。 Animation 对象该.animate()方法不仅仅是动画我们的元素，它也返回一些东西。 如果我们看看控制台中的返回值，我们将看到它的一个动画对象。这为我们提供了各种各样的功能，其中一些是非常不言自明的myAnimation.pause()。通过更改animation-play-state属性，我们可以通过CSS动画实现类似的结果，但WAAPI语法比稍微简单element.style.animationPlayState = &quot;paused&quot;。我们也有权力轻松地扭转我们的动画myAnimation.reverse()，再次，animation-direction与使用我们的脚本更改CSS属性相比，稍微有点改进。 然而，到目前为止，@keyframe用JavaScript进行操作并不是世界上最简单的事情。即使像重新启动动画一样简单，就像Chris Coyier 先前写过的那样，这个技巧也有一些技巧。使用WAAPI，我们可以简单地使用myAnimation.play()，它从一开始就重播动画，如果它已经完成，或者如果我们暂停播放，则从中间迭代继续播放动画。 我们甚至可以轻松地改变动画的速度。 12myAnimation.playbackRate = 2; // speed it upmyAnimation.playbackRate = .4; // use a number less than one to slow it down getAnimations（）此方法将返回任何动画对象的数组，以便我们使用WAAPI定义的任何动画以及 任何CSS transitions或animations。 1element.getAnimations() // returns any animations or transitions applied to our element using CSS or WAAPI 如果您感觉使用CSS来定义和应用您的动画比较顺手，getAnimations()可以使用API​​与@keyframes 结合使用。您可以继续使用CSS进行大部分动画工作，并在需要API时获得API的优势。让我们看看这是多么简单。 即使一个DOM元素只有一个动画应用到它，getAnimations()也将始终返回一个数组。我们来抓住那个单一的动画对象来处理。 12var h2 = document.querySelector("h2");var myCSSAnimation = h2.getAnimations()[0]; 现在我们可以在我们的CSS动画中使用web animation API :) 12myCSSAnimation.playbackRate = 4;myCSSAnimation.reverse(); Promise和事件我们已经有多种通过CSS触发的事件，我们可以在我们的JavaScript代码利用的有：animationstart，animationend，animationiteration和transitionend。我经常需要收听animations或transitions的结束，以便从DOM中删除应用于它的元素。 在WAAPI 中使用animationend或transitionend为此目的相当于再次使用动画对象： 123myAnimation.onfinish = function() &#123; element.remove();&#125; WAAPI为我们提供了事件和Promise的选择。我们的动画的.finished属性对象将在动画结束时返回一个resolve 的 Promise。以下是上面的例子，就像使用Promise一样： 12myAnimation.finished.then(() =&gt; element.remove()) 我们来看看Mozilla开发人员网络中的一个稍微有点省略的例子。Promise.all接收一个Promise数组，一旦所有这些Promise得到解决，才会运行我们的回调函数。我们已经看到，element.getAnimations()返回一个动画对象数组。我们可以将数组中的所有动画对象映射到每个动画对象.finished上，为我们提供所需的Promise数组。 在这个例子中，只有在页面上的所有动画完成后，我们的函数才能运行。 1234Promise.all(document.getAnimations().map(animation =&gt; animation.finished)).then(function() &#123; // do something cool &#125;); 未来本文中提到的功能只是开始。目前的规范和实践看起来是一件伟大的事情的开始。 「翻譯原文」：https://css-tricks.com/css-animations-vs-web-animations-api/?utm_source=frontendfocus]]></content>
      <categories>
        <category>css3</category>
        <category>animation</category>
        <category>Web Animation</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>animation</tag>
        <tag>Web Animation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack3官方正式发布,亮点:作用域提升，“魔法注释”，以及更多新特性！]]></title>
    <url>%2F2017%2F06%2F21%2Fwebpack3%E5%AE%98%E6%96%B9%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83-%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%90%E5%8D%87%EF%BC%8C%E2%80%9C%E9%AD%94%E6%B3%95%E6%B3%A8%E9%87%8A%E2%80%9D%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%9B%B4%E5%A4%9A%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%81%2F</url>
    <content type="text"><![CDATA[作用域提升，“魔法注释”，以及更多新特性！原文 在我们发布了 webpack v2 之后，我们曾向社区做了一些承诺。 我们承诺，我们将提供用户投票的功能。 此外，我们承诺我们的发布周期会 更快，更稳定。 这次没有 beta 版本，完全向下兼容。我们承诺让你们、让 webpack 成长的社区更轻松的使用。webpack 团队自豪地宣布，今天我们已经发布了 webpack 3.0.0！ 现在就可以下载或升级！ 1npm install webpack@3.0.0 --save-dev 或者使用 1yarn add webpack@3.0.0 --dev 从 webpack 2 迁移到 3，只需要执行升级命令，在使用上没有任何差别。我们将这次升级标记为版本的重大升级，是因为内部的突破性变化可能会影响某些插件的使用。 到目前为止，98%的升级的用户都没有遇到任何不兼容！ 有哪些新特性?像上文提到的一样，我们发布了一些由用户投票选出的功能，感谢 Github，赞助商和我们的支持者，有了他们我们才能做出每一个改进。😍 🔬作用域提升（Scope Hoisting）🔬作用域提升是 webpack 3 的重点功能。之前 webpack 在打包时，您的 bundle 中的每个模块都将被包装在单独的函数闭包中。这些闭包会使您的 JavaScript 在浏览器中执行速度更慢。相比之下，像 Closure Compiler 和 RollupJS 这样的工具可以将所有模块包装在一个大的闭包内，从而使您的代码在浏览器中具有更快的执行速度。 70K =&gt; 37K (gzip!) savings on our main bundle using #Webpack 3 RC.2 + ModuleConcatenationPlugin 😲 🔥 Awesome work @TheLarkInn @wSokra et al! pic.twitter.com/zVfQoivT9d&mdash; Jeremy Gayed 🤓 (@tizmagik) June 17, 2017 而现在，使用 webpack 3，您现在可以 在配置中添加下面的插件以启用作用域提升： 12345module.exports = &#123; plugins: [ new webpack.optimize.ModuleConcatenationPlugin() ]&#125;; 作用域提升是基于 ECMAScript Module 语法实现的一个特征。通过这个，webpack 可以根据你正在使用什么样的模块和一些其他条件来回退到正常的捆绑。 为了了解什么触发了这些回退，我们添加了一个 --display-optimization-bailoutcli 标志，它将告诉你是什么导致的回退。 Total evaluation script time went from 2.52s to 2.06s, first meaningful paint from 3.43s to 2.70s and all initial event fired 20% earlier&mdash; Jeremias Menichelli (@jeremenichelli) June 18, 2017 同时，由于作用域提升会移除模块外的函数包装，你可能会看到一些小的体积改进。然而，更显着的改进是JavaScript在浏览器中加载的速度。 如果您在比较使用之前和之后时发现加载速度取得了非常棒的改进，请随时回复一些数据，我们将很荣幸分享！ 🔮 魔法注释 ”Magic Comments” 🔮当我们在webpack 2中引入使用动态导入语法（import()）时，用户表示，他们不能像使用 require.ensure 一样创建命名 chunk。我们现在介绍由社区创建的“魔法注释”，它可以传递 chunk 名称，还有更多功能，例如可以添加更多的内联注释到 import() 语句中。 1import(/* webpackChunkName: "my-chunk-name" */ 'module'); 通过使用注释，我们能够在使用动态导入语法的同时，对代码块进行命名。 尽管这是我们在 v2.4 和 v2.6 中发布的技术特性，但在 v3 中，我们修复了这些功能的一些错误，使其变得更稳定。 同时，现在允许动态导入语法具有与 require.ensure 相同的灵活性。 TIL webpack /chunkName/ comments aren&#39;t just for nicer filenames—also great for organizing your chunks. Even interops w/ commonsChunk! pic.twitter.com/wjdT9y6oTE&mdash; Adam Rackis (@AdamRackis) June 7, 2017 要了解更多信息，请参阅我们最新文档的代码分割部分，文档高亮了这些新功能！ 😍 接下来是什么？😍我们有很多功能和增强功能想要推出！但我们需要了解用户需求的优先级。所以访问我们的投票页面，并提出你想看到的功能！ 这些是我们希望带给您的一些功能： 更好地构建缓存 更快的初始构建和增量构建 更好的TypeScript体验 改进长期缓存 WASM模块支持 改善用户体验 🙇 致谢 🙇感谢我们所有的用户，贡献者，文档作者，博客，赞助商，支持者和维护者。是他们都帮助我们确保 webpack 在未来几年成功。 为此，我们感谢所有人。webpack 发展到现在与你的支持密不可分，我们迫不及待地想要与你分享未来 webpack 的新进展！]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flow和TypeScript之间的区别和优劣]]></title>
    <url>%2F2017%2F06%2F14%2FFlow%E5%92%8CTypeScript%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BC%98%E5%8A%A3%2F</url>
    <content type="text"><![CDATA[采用Flow＆TypeScript, 两者上手流程之间的比较。 让我们想象一下我们想要采用一种类型检查器的场景… 本文译自： adopting flow and typescript 最近我们已经注意到了我们的应用程序中的很多NaN的出现。我们搜索源代码并找到以下代码： 12345// math.jsfunction square(n) &#123; return n * n;&#125;square("oops"); 我们对自己叹了口气，也许决定添加一个类型检查器。我们退后一步，查看我们的选项： Flow 或 TypeScript。 这两个工具都有相当简单的方法给逐个文件应用： Flow: // @flow 向文件顶部添加注释 TypeScript：将扩展名更改为.js扩展.ts 名 但是让我们比较一下这里面发生了什么。 采用TypeScript要采用TypeScript，我们首先重命名math.js为 math.ts： 12345// math.tsfunction square(n) &#123; return n * n;&#125;square("oops"); 现在我们将运行typescript： 1(no errors) 没有错误，是因为TypeScript要求我们给函数键入注释，然后才会根据注释检查类型。如下所示： 1234function square(n: number): number &#123; return n * n;&#125;square("oops"); 如果没有这些类型，TypeScript将根据您的配置执行下面两件事情之一： 隐含地将每个未知类型转换为any。这种任何类型将让您退出所有类型检查。 或者如果您使用了--noImplicitAny选项，它会为任何未知类型抛出错误，指明需要添加类型注释。 这意味着TypeScript 覆盖的代码量与您所写的类型相关。写入类型时，类型coverage将线性上升。 类型覆盖（type coverage）在我们进一步讲解之前，我应该解释一下什么是类型覆盖。 未有类型覆盖的代码用红色显示 如果你看到你的代码中的值和表达式，并问类型检查器“你知道这是什么类型吗”。 如果类型检查器知道它类型，则覆盖该值或表达式。如果类型检查器不知道类型，那么它没有被覆盖。 您希望您的程序尽可能多地提供类型覆盖，因为这样可以在更多地方抛出错误时提前告诉您。 没有类型覆盖，类型检查器什么都不是。 采用Flow12345// @flowfunction square(n) &#123; return n * n;&#125;square("oops"); 然后我们将运行Flow并查看结果： 123456789function square(n) &#123; return n * n; ^ ^ Error (x2)&#125;square("oops");Error (x2)string. The operand of an arithmetic operation must be a number. 紧接着就抛出了类型错误，告诉我们代码出了问题。 Flow 只需要我们键入文件和外部模块的导出。可以推测出其他一切。 这使得类型覆盖率快得多。只需几种类型，您可以快速获取具有非常高类型覆盖率的文件。 根据我的经验，我可以在短短几分钟内将文件覆盖约70-90％。 这是一个非常科学的差异图： 这不是我一家之言，你可以自己尝试一下，看看几种类型的区别。 要查看Flow中文件的类型覆盖，可以运行： 1flow coverage path/to/file.js --color 您还可以使用 流量报告 来帮助您。 注意：我没有注意到TypeScript 有任何的类型报告工具（如果您知道一个，请给我发送一个链接）。但是，您可以测试代码是否覆盖，以确定当您出现错误时是否会报告错误。 这个的工作原理是什么这两种工具具有不同行为的原因归结于其架构之间的区别。 TypeScript体系结构：AST导向TypeScript将遍历您的程序并构建已知类型的表。当它发现值和表达式时，它会立即为其分配类型。当TypeScript发现一个未知的类型时，它必须立即作出决定，这意味着将其分配给any或抛出错误。 Flow 架构：图形导向Flow 将建立一个你所有的值和表达式及其彼此之间的关系的图表。然后，它将开始为每个值和表达式分配类型。如果它找到一个未知的类型，它将使它成为一个“开放”类型，稍后再回来判断。 一旦Flow具有您的程序的完整蓝图，它将开始连接所有点，从一个值连接到另一个值地跟踪类型。打开类型接受流入它们的所有值的类型 - 生成的类型称为 “推断类型”。 你可以看这个是怎么回事。来看看我们在之前的类型错误： 123456789function square(n) &#123; return n * n; ^ ^ Error (x2)&#125;square("oops");Error (x2)string. The operand of an arithmetic operation must be a number. 注意错误是指向n * n而不是 square(&quot;oops&quot;)。因为我们没有写入一个类型为n的 “oops”字符串流入它，并且Flow开始检查n，就好像它是一个字符串。 添加类型注释我们可以看到错误点移动了： 12345678function square(n: number) &#123; return n * n;&#125;square("oops"); ^ ErrorError: string.This type is incompatible with the expected param type of number. 这提出了一个重要的一点：Flow可以在任何地方自动推断类型并不意味着你不应该添加类型注释你的代码。 结论TypeScript和Flow都有非常好的上手过程。一个个文件地尝试是一个很好的经历。 但是，如果使用Flow，你就会有更高以及更快的覆盖类型，你就可以安心睡觉。 使用Flow，您可以添加类型以使错误更友好，而不仅只是发现它们。]]></content>
      <categories>
        <category>Flow</category>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>Flow</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用RXJS组合、过滤和映射数据流的值]]></title>
    <url>%2F2017%2F06%2F05%2F%E4%BD%BF%E7%94%A8RXJS%E7%BB%84%E5%90%88%E3%80%81%E8%BF%87%E6%BB%A4%E5%92%8C%E6%98%A0%E5%B0%84%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E5%80%BC%2F</url>
    <content type="text"><![CDATA[查询可观测序列在事件桥接 一文中，我们将现有的DOM和Node.js事件转换成可观察的序列以订阅它们。在本主题中，我们将把可观察序列的父级class视为IObservable对象，其中Rx组件提供通用LINQ操作符来操作这些对象。大多数操作符获取可观察的序列并对其执行一些逻辑并输出另一个可观测序列。另外，从代码示例可以看出，甚至可以在源序列上使用多个运算符，最终将结果序列调整到您的确切需求。 本文翻译在： RXJS中文文档 使用不同的运算符我们已经在以前的主题中使用create和range运算符来创建和返回简单的序列。我们还使用fromEvent和fromEventPattern运算符将现有事件转换成可观察的序列。在本主题中，我们将使用其他Observable类型的运算符，以便可以过滤，分组和转换数据。这些运算符将可观察到的序列作为输入，并生成输出另一个可观察序列。 组合不同序列在本节中，我们会研究将各种可观察序列组合成单个可观察序列的操作符。请注意，当我们组合序列时，数据不会被转换。在以下示例中，我们使用Concat运算符将两个序列组合成一个序列并订阅它。为了说明的目的，我们将使用非常简单的range(x, y)运算符创建一个从x开始的整数序列，然后产生y个序列数字。 123456789101112var source1 = Rx.Observable.range(1, 3);var source2 = Rx.Observable.range(1, 3);source1.concat(source2) .subscribe(console.log.bind(console));// =&gt; 1// =&gt; 2// =&gt; 3// =&gt; 1// =&gt; 2// =&gt; 3 注意，结果序列是1,2,3,1,2,3。这是因为当您使用concat运算符时，第二个序列（source2）将在第一个序列（source1）完成推送其所有值之后才会激活。只有在source1完成之后，source2才会将值推送到最后的序列。然后，订阅者将从得到的序列中获取所有值。 与merge 操作符进行比较。如果运行以下示例代码，您将获得1,1,2,2,3,3。这是因为两个序列同时处于活动状态，并且值在数据源中发生时被推出。结果序列仅在最后一个数据源完成推送值时完成。 123456789101112var source1 = Rx.Observable.range(1, 3);var source2 = Rx.Observable.range(1, 3);source1.merge(source2) .subscribe(console.log.bind(console));// =&gt; 1// =&gt; 1// =&gt; 2// =&gt; 2// =&gt; 3// =&gt; 3 catch 操作符可以进行另一个比较。在这种情况下，如果source1完成没有任何错误，那么source2将不会启动。因此，如果运行以下示例代码，则获得1,2,3因为source2（产生4,5,6））被忽略。 123456789var source1 = Rx.Observable.range(1, 3);var source2 = Rx.Observable.range(4, 3);source1.catch(source2) .subscribe(console.log.bind(console));// =&gt; 1// =&gt; 2// =&gt; 3 最后，我们来看看onErrorResumeNext。即使由于错误导致source1无法完成，该操作符也将移动到source2。在以下示例中，即使source1表示通过使用throw运算符终止异常的序列，用户将接收source2发布的值（1,2,3）。因此，如果您预期到任何一个源序列产生任何错误，那么使用它onErrorResumeNext来保证用户仍然会收到一些值是更安全的。 123456789var source1 = Rx.Observable.throw(new Error('An error has occurred.'));var source2 = Rx.Observable.range(1, 3);source1.onErrorResumeNext(source2) .subscribe(console.log.bind(console));// =&gt; 1// =&gt; 2// =&gt; 3 映射select或 map 操作符将可观察到的一个序列的每个元素转换成另一种形式。 在下面的示例中，我们将一系列字符串映射到一系列表示长度的整数中。 123456789101112var array = ['Reactive', 'Extensions', 'RxJS'];var seqString = Rx.Observable.from(array);var seqNum = seqString.map(x =&gt; x.length);seqNum .subscribe(console.log.bind(console));// =&gt; 8// =&gt; 10// =&gt; 4 在以下示例中，我们在“桥接现有事件”主题中看到的事件转换示例的扩展，我们使用select或map运算符将事件参数投影到x和y点。这样，我们将鼠标移动事件序列转换为可以进一步解析和操作的数据类型，如下一个“过滤”部分所示。 123456var move = Rx.Observable.fromEvent(document, 'mousemove');var points = move.map(e =&gt; (&#123;x: e.clientX, y: e.clientY &#125;));points.subscribe( pos =&gt; console.log('Mouse at point ' + pos.x + ', ' + pos.y)); 最后，我们来看看selectMany or flatMap运算符。selectMany或flatMap操作符具有许多重载，其中一个就是需要选择器函数作为参数。这个选择器函数是由数据源推出的每个值去调用的。对于每一个值，选择器将其映射成一个迷你的可观察序列。最后，selectMany或者flatMap操作符将所有这些迷你序列扁平化成单个结果序列，然后将其推送到用户。 在数据源和由选择器函数产生的所有迷你可观察序列都已经完成之后，源序列返回selectMany或flatMap发布的onCompleted。当发生源数据流中的错误时触发onError，当一个异常被选择函数抛出，或者当在任何迷你观察序列的发生了错误。 在下面的例子中，我们首先创建一个数据源序列，每5秒产生一个整数，并决定使用生成的前两个值（使用take运算符）。然后，我们使用selectMany或者flatMap对另一个序列{100,101,102}这些整数进行映射。通过这样做，产生两个迷你观察序列{100,101,102}和{100,101,102}。它们最终平坦化成{100,101,102,100,101,102}的单个整数流，并被推送到观察者。 12345678910111213141516var source1 = Rx.Observable.interval(5000).take(2);var proj = Rx.Observable.range(100, 3);var resultSeq = source1.flatMap(proj);var subscription = resultSeq.subscribe( x =&gt; console.log('onNext: %s', x), e =&gt; console.log('onError: %s', e.message), () =&gt; console.log('onCompleted'));// =&gt; onNext: 100// =&gt; onNext: 101// =&gt; onNext: 102// =&gt; onNext: 100// =&gt; onNext: 101// =&gt; onNext: 102// =&gt; onCompleted 过滤在下面的例子中，我们使用generate 运算符创建一个简单的可观察数字序列。该generate操作符有几个版本，包括有相对和绝对时间调度。在我们的示例中，它需要初始状态（在我们的示例中为0），一个条件函数终止（少于10次），迭代器（+1），结果选择器（当前值的平方函数））和打印只使用小于5的那些使用filter或where运算符。 1234567891011121314151617var seq = Rx.Observable.generate( 0, i =&gt; i &lt; 10, i =&gt; i + 1, i =&gt; i * i);var source = seq.filter(n =&gt; n &lt; 5);var subscription = source.subscribe( x =&gt; console.log('onNext: %s', x), e =&gt; console.log('onError: %s', e.message), () =&gt; console.log('onCompleted'));// =&gt; onNext: 0// =&gt; onNext: 1// =&gt; onNext: 4// =&gt; onCompleted 以下示例是本主题前面已经看到的映射示例的扩展。在该示例中，我们使用select或map运算符将事件参数投影到具有x和y的点。在下面的例子中，我们使用filter或where和select或map操作符只挑选那些鼠标移动，我们感兴趣的是，在这种情况下，我们鼠标移动过滤，以找出在第一平分线（其中x和y坐标是相等的）。 1234567var move = Rx.Observable.fromEvent(document, 'mousemove');var points = move.map(e =&gt; (&#123; x: e.clientX, y: e.clientY &#125;));var overfirstbisector = points.filter(pos =&gt; pos.x === pos.y);var movesub = overfirstbisector.subscribe(pos =&gt; console.log('mouse at ' + pos.x + ', ' pos.y)); 基于时间的操作您可以使用缓冲区运算符执行基于时间的操作。 缓冲可观察序列意味着可观测序列的值基于指定的时间段或计数阈值被放入缓冲区。这在您预期有大量数据被序列推出的情况下特别有用，并且订阅者没有资源来处理这些值。通过基于时间或计数缓冲结果，并且只有在超过条件时才返回值序列（或者源序列完成时），用户可以按照自己的速度处理OnNext调用。 在下面的例子中，我们首先创建一个以每秒为时间单位的简单的整数序列。然后我们使用bufferWithCount运算符，并指定每个缓冲区将保存序列中的5个项目。在onNext当缓冲区已满被调用。然后我们使用缓冲区的总和Array.reduce。缓冲区自动刷新，另一个循环开始。打印输出将为10,35,60 …，其中10 = 0 + 1 + 2 + 3 + 4,35 = 5 + 6 + 7 + 8 + 9等。 123456789101112var seq = Rx.Observable.interval(1000);var bufSeq = seq.bufferWithCount(5);bufSeq .map(arr =&gt; arr.reduce((acc, x) =&gt; acc + x, 0)) .subscribe(console.log.bind(console));// =&gt; 10// =&gt; 35// =&gt; 60... 我们还可以创建一个指定时间跨度（以毫秒为单位）的缓冲区。在以下示例中，缓冲区将保存累积3秒钟的项目。打印输出将为3,12,21 …其中3 = 0 + 1 + 2,12 = 3 + 4 + 5，依此类推。 1234567var seq = Rx.Observable.interval(1000);var bufSeq = seq.bufferWithTime(3000);bufSeq .map(arr =&gt; arr.reduce((acc, x) =&gt; acc + x, 0)) .subscribe(console.log.bind(console)); 请注意，如果您使用任何一个buffer*或window*运算符，则必须确保序列不为空，然后再过滤。 按类别操作按类别划分的操作符主题列出了按类别实施的Observable的所有主要操作符; 具体来说：创建，转换，合并，功能，数学，时间，异常，杂项，选择和原值。]]></content>
      <categories>
        <category>RXJS</category>
      </categories>
      <tags>
        <tag>RXJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何调试Node.js|使用谷歌chrome浏览器调试Node.js]]></title>
    <url>%2F2017%2F06%2F02%2F%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95Node-js%E4%BD%BF%E7%94%A8%E8%B0%B7%E6%AD%8Cchrome%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95Node-js%2F</url>
    <content type="text"><![CDATA[如何调试 Node.js, 还在使用 console.log 来调试 Node.js 吗，可以像调试前端页面一样调试 Node.js! 译文：Debugging Node.js with Google Chrome 调试是从软件应用程序中识别和删除错误的任务，而不仅仅是打印代码中的值。本文介绍如何使用最新的Google Chrome DevTools高效地调试Node.js程序。 为什么console.log不是最好的选择？使用console.log来调试你的代码，通常你会无限重复地做 “停止你的应用程序，添加一个console.log，并再次启动你的应用程序” 这样的操作。除了减缓您的应用程序的开发外，它还使您的书写变得脏乱并创建不必要的代码。最后，尝试注销变量以及其他可能的日志记录操作的噪点时，可能会在尝试找到正在调试的值时使调试变得困难。 调试工具调试工具为用户提供的是几个重要的功能console.log无法提供。特别是，它们允许您在代码中的特定点暂停执行应用程序，并在程序仍在运行时检查和修改变量的值。 设置Chrome for Node.js调试使用Chrome 57+，Node.js调试功能是默认启用的，不需要像以前的版本那样从“实验功能”面板手动启用它。 如果您还没有完成，请将Google Chrome更新到最新版本，并确保使用Node.js 6.4+。 要开始调试，请使用 - inspect标志运行Node.js应用程序。 1$ node --inspect &lt;your_file&gt; .js 接下来，忽略从终端中显示的“chrome-devtools://”开头的URL ，而是在Google Chrome中打开“ about:inspect ”。 最后点击“ Open dedicated DevTools for Node” 开始调试应用程序的代码。 此外，关于调试Node.js App的官方文档还提供了所有其他检查器工具和客户端选项的详细列表。 Chrome DevTools的应用要结束本文，我想说明一下Chrome DevTools在以下Express应用程序中的应用。 123456789101112131415161718'use strict'const express = require('express')const app = express()const PORT = process.env.PORT || 3000function capitalize (str) &#123; const firstLetter = str.charAt(0) // we can check what's inside here return `$&#123;firstLetter.toUpperCase()&#125;$&#123;str.slice(1)&#125;`&#125;app.get('/:name?', (req, res) =&gt; &#123; const name = req.params.name ? capitalize(req.params.name) : 'World' res.send(`Hello $&#123;name&#125;!`)&#125;)app.listen(PORT, () =&gt; console.log(`App listening on *:$&#123;PORT&#125;`)) 让我们从运行- inspect标志，并打开专用DevTools for Node如前所述。 此时，您将可以访问您可能已经熟悉的所有功能：断点(breakpoints)，压缩代码的源映射(source map for transpiled code)，堆快照检查(heap snapshot inspection)，分配分析(allocation profiling)，JavaScript值热插拔(JavaScript values hot-swapping)等。 具体来说，如下图所示，您可以插入断点来停止执行程序，检查和“热交换”变量的值。 使用Chrome作为调试工具的另外一件好事是您可以使用相同的界面🚀调试前端和后端JavaScript代码。]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>debug</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RXJS我该选用哪个操作符之-创建篇]]></title>
    <url>%2F2017%2F06%2F01%2FRXJS%E6%88%91%E8%AF%A5%E9%80%89%E7%94%A8%E5%93%AA%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8B-%E5%88%9B%E5%BB%BA%E7%AF%87%2F</url>
    <content type="text"><![CDATA[RXJS该怎么上手？这么多操作符该用哪个？RXJS比较强大，操作符众多，想熟悉需要比较长时间的运用，所以大部分新手都比较疑惑应该使用哪些操作符去实现自己的数据流的操作。 更多详情请翻阅 RXJS中文翻译文档 我该选用哪个操作符? - 创建操作符使用此页面查找Observable符合您需求的类型创建操作： 静态方法 我想创建一个新的序列 使用自定义逻辑 Observable.create 像一个for循环 Observable.generate 并随时间发射值 Observable.generateWithRelativeTime Observable.generateWithAbsoluteTime 它返回一个值 Observable.return/just 多次 Observable.repeat 这会抛出错误 Observable.throw 完成了 Observable.empty 从来没有做任何事情 Observable.never 从事件 Observable.fromEvent 它使用自定义函数来添加和删除事件处理程序 Observable.fromEventPattern 来自一个ES6 Promise Observable.fromPromise 它可迭代 覆盖到数组中的值 Observable.fromArray 对象键/值对 Observable.pairs 异步元素 Observable.for 数值范围内的值 Observable.range 来自一个可迭代的数组或类似数组的对象的值 Observable.from 来自参数 Observable.of 根据定时器发出值 Observable.interval 具有可选的初始延迟 Observable.timer 不传参调用函数 在特定的调度程序 Observable.start 异步 Observable.startAsync 取决于订阅时 基于布尔条件 Observable.if f从一组预先设定的序列 Observable.case 使用自定义逻辑 Observable.defer 它取决于资源 Observable.using 我想包装一个函数 并产生一个序列的结果 Observable.toAsync 它接受回调 Observable.fromCallback 它接受Node.js回调 Observable.fromNodeCallback 我想结合多个序列 并且仅从产生值的序列中接收值 Observable.amb 所有人都已经完成通知 Observable.forkJoin 并输出所有这些值 Observable.merge 为了 不改变时重复使用最新值 Observable.combineLatest 每个值只使用一次 Observable.zip 通过订阅每个序列为了 当前一个序列完成时 Observable.concat 当另一个序列抛出错误时 Observable.catch 不管先前的序列是完成还是抛出错误 Observable.onErrorResumeNext 通过响应不同的值组合（连接微积分） Observable.when]]></content>
      <categories>
        <category>RXJS</category>
      </categories>
      <tags>
        <tag>RXJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RXJS我该选用哪个操作符之-实例操作符篇]]></title>
    <url>%2F2017%2F06%2F01%2FRXJS%E6%88%91%E8%AF%A5%E9%80%89%E7%94%A8%E5%93%AA%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8B-%E5%AE%9E%E4%BE%8B%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%AF%87%2F</url>
    <content type="text"><![CDATA[RXJS比较强大，操作符众多，想熟悉需要比较长时间的运用，所以大部分新手都比较疑惑应该使用哪些操作符去实现自己的数据流的操作。 更多详情请翻阅 RXJS中文翻译文档 我该选用哪个操作符? - 实例操作符使用此页面通过类型查找Observable 适合您需要的实例运算符： 实例操作符 使用现有的序列 我想改变每个值 map/select 我想从每个值拉一个属性 pluck 我想在不影响值的情况下被通知值 do/tap doOnNext/tapOnNext doOnError/tapOnError doOnCompleted/tapOnCompleted 我想包含值 基于自定义逻辑 filter/where 从序列开头 take 基于自定义逻辑 takeWhile 从序列的末尾 takeLast 直到另一个序列发射一个值或完成 takeUntil 我想忽略值 全部 ignoreElements 从序列的开头 skip 基于自定义逻辑 skipWhile 从序列的末尾 skipLast 直到另一个序列发出一个值 skipUntil 与以前的值相同 distinctUntilChanged 这（触发）太频繁 throttle 我想计算 总和 这些值的 sum 平均值 average 使用自定义逻辑 并且只输出最终值 aggregate reduce 并在计算出值时输出（每一步的）值 scan 我想用元数据包装它的消息 描述每个消息 materialize 包括从最后一个价值以来的时间 timeInterval 包括时间戳 timestamp 经过一段时间的不活动 我想抛出一个错误 timeout 我想切换到另一个序列 timeout 我想确保只有一个值 并且如果存在多于或少于一个值则抛出错误 single 并且如果没有值，则使用默认值 singleOrDefault 我只想取第一个值 并且如果没有值，则抛出错误 first 并且如果没有值，则使用默认值 firstOrDefault 在一段时间内 sample 我只想取最后的值 如果没有值，则报错 last 并且如果没有值，则使用默认值 lastOrDefault 我想知道它包含多少值 count 我想知道它是否包含一个指定的值 contains 我想知道条件是否满足 只需要任一值满足 any/some 需要所有值都满足 all/every 我想把消息延迟一段特定的时间 delay 基于自定义逻辑 delayWithSelector 我想给值分组 直到序列完成 toArray toMap toSet 使用自定义逻辑 作为数组 buffer 作为序列 window 根据特定大小分批 作为数组 bufferWithCount 作为序列 windowWithCount 基于时间 作为数组 bufferWithTime 作为序列 windowWithTime 基于时间或计数，以先发生者为准 作为数组 bufferWithTimeOrCount 作为序列 windowWithTimeOrCount 基于一个指定的key 直到序列完成 groupBy 并控制每组的生命周期 groupByUntil 我想为每个值开始一个新的序列 并且并行地从所有序列中发出值 flatMap/selectMany 并按顺序从每个序列中输出值 concatMap/selectConcat 并在新值到达时取消先前的序列 flatMapLatest/selectSwitch 并递归地为每个新值启动一个新的序列 expand 并根据onNext，onError和onCompleted并行地从所有序列发出值 flatMapObserver/selectManyObserver 并根据onNext，onError和onCompleted顺序地从所有序列发出值 concatMapObserver/selectConcatObserver 我想把它与另一个结合起来 两者都完成时发出通知 forkJoin 我想执行复杂的操作，而不会打破流畅的调用 let 我想在多个订阅者之间共享订阅 使用特定的subject实现 multicast publish share 并向未来订阅者提供最后的值 publishLast shareLast 并向未来订阅者重播默认值或最新值 publishValue shareValue 并向未来的订阅者重播n个值 replay shareReplay 发生错误时 我想重新订阅 retry 我想开始一个新序列 catch 取决于错误 catch 当完成时 我想重新订阅 repeat 我想开始一个新序列 concat 当完成或抛出错误时 我想开始一个新序列 onErrorResumeNext 当完成，抛出错误或退订时 我想执行一个函数 finally 我想改变路由的调度程序 调用subscribe（订阅） subscribeOn 消息 observeOn 使用两个序列 我想决定从哪个接收值 取决于哪个序列先发出值 amb 我想确定它们的值是否相等 sequenceEqual 我想合并它们的值 只有当第一个序列发射时，使用每个序列的最新值 withLatestFrom 为了 不改变时重复使用最新值 combineLatest 每个值只使用一次 zip 重复分享我选择的“生命周期” 并通知每个组合 join 并给每个“左”的序列的值给“右”的序列 groupJoin 我想包含两者的值 merge]]></content>
      <categories>
        <category>RXJS</category>
      </categories>
      <tags>
        <tag>RXJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Marko和react,preact,vue相比快在哪里]]></title>
    <url>%2F2017%2F06%2F01%2FMarko%E5%92%8Creact-preact-vue%E7%9B%B8%E6%AF%94%E5%BF%AB%E5%9C%A8%E5%93%AA%E9%87%8C%2F</url>
    <content type="text"><![CDATA[译文：why-is-marko-fast 在eBay，我们正在使用[Marko](http://markojs.com/)每天处理超过十亿的请求，这就要求我们精简我们的开源UI库Marko。我们大大优化了Marko ，以实现快速渲染，高级性能技术，并实现了最小的页面重量（〜10kb gzipped）。性能只是一个方面，因为我们还必须扩展Marko以支持数百个团队的开发，从而允许开发人员有效地创建可维护和强大的Web应用程序。 我们已经创建了我们自己的benchMarks进行比较，也已经将Marko添加到其他基准测试中，但是基准测试并不总是值得信赖的。尽管我们尽可能公平地对待我们的基准，但最重要的是在现实世界的应用中的表现，而不是专注于微观基准。这就是V8团队转而采用新的方法来衡量和理解现实JavaScript性能的一个原因。 同样，我们已经观察过我们的开发人员实际开发中如何编写他们的Marko组件，并且发现了可以进一步优化的模式。而不是关注本文中的基准测试，我想关注我们应用于Marko的优化细节。 多个编译输出Marko是一个在服务器和浏览器中运行的同构UI库。正如Michael Rawlings在“ 服务器端渲染染 ”中提到的，当在服务器上呈现时，Marko直接呈现可以作为HTTP响应发送的文档（HTML）的字符串表示形式。 在浏览器中呈现时，必须解析HTML字符串才能更新DOM。因此，Marko通过程序将视图编译为直接呈现到虚拟文档（VDOM）树，这可以针对浏览器有效地更新真实的DOM。 给出以下模板： 1&lt;div&gt;Hello $&#123;input.name&#125;!&lt;/div&gt; 编译为服务器编译输出针对服务器上的HTML输出进行了优化： 123456789var marko_template = require("marko/html").t(__filename), marko_helpers = require("marko/runtime/html/helpers"), marko_escapeXml = marko_helpers.x;function render(input, out) &#123; out.w("&lt;div&gt;Hello " + marko_escapeXml(input.name) + "!&lt;/div&gt;");&#125; 编译为浏览器编译输出针对浏览器中的虚拟DOM渲染进行了优化： 12345678var marko_template = require("marko/vdom").t(__filename);function render(input, out) &#123; out.e("DIV", null, 3) .t("Hello ") .t(input.name) .t("!");&#125; 模块化运行时Marko运行时并不作为单个JavaScript文件分发。相反，Marko编译器会生成一个JavaScript模块，该模块仅导入实际需要的运行时部分。这允许我们向Marko添加新功能，而不会使现有应用程序膨胀。例如，给出以下模板： 12$ var color = 'red';&lt;div style=&#123;backgroundColor: color&#125;&gt;&lt;/div&gt; 在上面的示例中，需要额外的运行时代码来根据所提供style的JavaScript对象呈现属性。导入styleAttr助手的编译代码如下所示： 12345678910var marko_styleAttr = require("marko/runtime/vdom/helper-styleAttr");function render(input, out) &#123; var color = 'red'; out.e("DIV", &#123; style: marko_styleAttr(&#123; backgroundColor: color &#125;) &#125;, 0, 4);&#125; 高性能的服务器端渲染与基于专门进行虚拟DOM渲染的JSX的解决方案相比，Marko在服务器端渲染方面具有巨大的优势。当渲染到服务器上的虚拟DOM树时，它是一个两步的过程来呈现HTML： 首先在内存中生成一个完整的虚拟DOM树 第二遍将虚拟DOM树序列化为可以通过线路发送的HTML字符串（这需要遍历整个树结构） 相比之下，Marko直接一次性渲染一整个HTML流。没有中间树数据结构。 静态子树的编译时优化给出以下模板： 1&lt;div&gt;This is a &lt;strong&gt;static&lt;/strong&gt; node&lt;/div&gt; Marko将会认识到，模板片段每次都会产生相同的输出，因此会像以下编译输出一样创建一个虚拟DOM节点： 123456789var marko_node0 = marko_createElement("DIV", null, 3, ...) .t("This is a ") .e("STRONG", null, 1) .t("static") .t(" node");function render(input, out) &#123; out.n(marko_node0);&#125; 渲染静态子树几乎是零成本。此外，Marko将跳过对比/修补静态子树。 同样，在服务器上，Marko会将模板的静态部分合并成一个字符串： 123function render(input, out) &#123; out.w("&lt;div&gt;This is a &lt;strong&gt;static&lt;/strong&gt; node&lt;/div&gt;");&#125; 静态属性的编译时优化Marko还将优化动态元素的静态属性。 给出以下模板： 1&lt;div.hello&gt;Hello $&#123;input.name&#125;!&lt;/div&gt; Marko将产生以下编译输出： 12345678910var marko_attrs0 = &#123; "class": "hello" &#125;;function render(input, out) &#123; out.e("DIV", marko_attrs0, 3) .t("Hello ") .t(input.name) .t("!");&#125; 请注意，属性对象只创建一次，它用于每个渲染。另外，静态属性不会发生 diffing/patching。 智能编译器使用Marko，我们倾向于在编译时尽可能多地执行。这使我们的编译器更加复杂，但它在运行时给我们带来了很大的收获。我们有〜90％的代码覆盖率和超过2000个测试，以确保编译器正常工作。此外，在许多情况下，Marko编译器为给定的模板提供运行时提示，以便运行时可以针对特定模式进行优化。例如，识别的Marko如果HTML元素仅具有class/id/style定义和做版本比较时/修补运行时优化了这些虚拟DOM节点（Marko编译器生成的代码，标记简单的虚拟DOM节点用于针对 diffing/patching 逻辑）。 事件委托如果你正在建立一个UI组件，您将很可能需要编写代码来处理不同的DOM事件（click，submit，等）。开发人员常常编写使用el.addEventListener(...)或使用诸如jQuery的库来添加DOM事件监听器的代码。当您使用Marko构建UI组件时，您仍然可以执行此操作，但是在初始化大量组件时，在附加侦听器时会出现开销。相反，Marko建议使用声明式事件绑定，如下所示： 123&lt;button type="button" on-click("handleClick")&gt; Click Me&lt;/button&gt; 当使用声明性事件绑定时，事实上没有附加任何DOM事件侦听器。相反，Marko会为每个DOM事件（在启动时完成）为页面的根DOM元素附加一个监听器。当Marko在根节点处收到事件时，它将把事件委托给该事件的相应组件。这是通过查看event.target属性来查看事件发生的位置，然后向上遍历树来查找需要通知的组件。因此，当根目录捕获DOM事件时，会做更多的工作，但这种方法使用的内存少得多，并减少了初始化时需要完成的。将事件委派给组件的额外开销并不明显，因此这是一个非常有益的优化。]]></content>
      <categories>
        <category>Marko</category>
      </categories>
      <tags>
        <tag>Marko</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm@5发布有哪些改进]]></title>
    <url>%2F2017%2F06%2F01%2Fnpm-5%E5%8F%91%E5%B8%83%E6%9C%89%E5%93%AA%E4%BA%9B%E6%94%B9%E8%BF%9B%2F</url>
    <content type="text"><![CDATA[从今天开始，如果您输入“npm install npm@latest -g”，那么您将被更新为npm版本5。另外，在所有Node.js 8的新安装中都捆绑了npm@5 ，它已经替代了Node.js 7在Node Project的当前版本中。 在过去一年半的时间里，我们一直在努力解决大量的痛点，其中有些是创建npm以来就已经存在的。今天的发布是对npm速度，一致性和用户体验的最大改进。 发布说明中有什么新内容和更改内容的明确列表，但这里有一些亮点： 速度很快重新编排了包元数据，软件包下载和软件包缓存，这大大加快了工作。一般来说，期望性能提升20-100％; 我们还看到一些安装和版本冲突的运行速度提高了5倍。 由于npm最初的设计，开发人员已经改变了他们如何使用npm。npm生态系统不仅呈指数级增长，而且从2014年起，平均npm软件包中的依赖关系数量增加了250％。现在，更多的开发人员现在可以在本地安装Babel，Webpack和Tap等有用工具，而不是全局。这是一个最佳实践，但这意味着“npm install”可以做更多的工作。 鉴于我们社区的规模，任何速度上升都会为数百万用户带来巨大的节省，更不用说我们的所有组织和npm企业客户。使npm @ 5变快成为一个很显然的目标。 目标一致默认锁文件Shrinkwrap很早就已经是npm的一部分，但npm@5使lockfiles成为默认，所以所有的npm安装现在都是可重现的。在安装给定版本的软件包时，每次安装它您获得的文件将是相同的。 我们发现无数常见且耗时的问题可能与不同开发人员环境利用不同软件包版本时发生的“漂移”相关。使用默认锁文件，这不再是问题。你不会浪费时间，试图找出一个错误，只是为了了解它来自运行不同版本的图书馆的人。 SHA-512哈希npm@5增加了对Node.js支持的任何tarball Hash功能的支持，并以SHA-512 hash发布。通过检查所有下载的软件包，您可以防止数据损坏和恶意攻击，并且您可以相信您从npm下载的代码是一致和安全的。 自愈缓存我们的新缓存很容易损坏，但也更具弹性。多个npm进程不会破坏共享缓存，npm@5将检查插入和提取的数据，以防止安装损坏的数据。如果缓存项失败完整性检查，npm@5将自动删除它并重新获取。 更易使用根据您的反馈，我们通过npm @ 5中的优化改进了用户体验。其中很大一部分是输出更多的有用的提示信息。最好的例子是，npm不再显示package上的整个树; 相反，您将看到有关安装内容的摘要报告。由于平均每个package中的依赖关系较大，因此我们进行了此更改。逐个文件读出结果是超过一定数量就会显得非常笨重。 比较有一个项目使用 benchmark 比较了 yarn, pnpm, npm 的效率, 传送门 下面是比较结果： Installer Average over 5 runs yarn –offline 5.88 pnpm –offline 6.72 pnpm (cached) 6.86 npm 5.x (shrinkpacked, compressed) 8.35 npm 5.x (shrinkpacked) 8.94 npm 5.x (cached) 11.36 npm 4.x (cached) 13.47 yarn 13.71 npm 5.x 14.93 pnpm 17.57 npm 4.x (shrinkpacked, compressed) 18.73 npm 4.x (shrinkpacked) 18.78 npm 4.x 29.73]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSX是什么鬼(WTF is JSX)]]></title>
    <url>%2F2017%2F05%2F30%2FJSX%E6%98%AF%E4%BB%80%E4%B9%88%E9%AC%BC%2F</url>
    <content type="text"><![CDATA[JSX实际上很简单：只需要花1分钟阅读这个，你会明白有关这个有趣的替代模板的一切。 替换标题：“融入JSX” Pragma您可以声明每个文件或每个函数来告诉您的transpiler（例如：Babel）每个节点在运行时应调用的函数的名称（请参阅“Transpilation”）。 在下面的例子中，我们说的是“ h()为每个节点注入一个函数”： 1/** @jsx h */ Transpilation如果你还没有使用解析器，你应该是尝试一下。使用ES6 / ES2015 编写，调试，测试和运行JavaScript时更为高效。Babel是最受欢迎和推荐的透析器，所以我会假设你正在使用它。 除了将ES6 / ES7 +语法转换为 ES5 以外，Babel还包括对JSX 开箱即用的转换支持。您不需要添加或更改任何内容以使用此功能。 通过查看一个非常简单的例子来了解它的工作原理是最简单的： 转换前 :( 你写的代码） 12/** @jsx h */let foo = &lt;div id="foo"&gt;Hello!&lt;/div&gt;; 转换后 :(你运行的代码） 1var foo = h('div', &#123;id:"foo"&#125;, 'Hello!'); 你可能看第二个代码片段的时候，认为使用函数构建UI不会那么糟糕 这就是为什么我坐上了 JSX 的车：如果它从地球上消失了，用手写的输出依然会很舒服。 JSX只是一种已经相当不错的语法的糖。 人们甚至把它用于整个项目：hyperscript 我们来构建一个JSX渲染器首先，我们需要定义转换代码后调用的 h() 函数。 你调用任何你想要的，我使用h()，因为这种类型的“构建器”功能的原始想法被称为hyperscript (“hypertext“ + “javascript”).。 1234function h(nodeName, attributes, ...args) &#123; let children = args.length ? [].concat(...args) : null; return &#123; nodeName, attributes, children &#125;;&#125; 好的，这看起来很简单（ps: 只处理了 children） 不熟悉ES6 / ES2015？ 这…在参数列表是一个rest param。它将“其余”的参数收集到数组中。 该concat(…args)位是一个扩展运算符：它需要该数组并将其扩展为参数concat()。这里使用的concat()是将子节点推入数组。 现在我们有这些嵌套的JSON对象我们的h()函数吐出来，所以我们最终得到一个这样的“树”： 1234567&#123; nodeName: "div", attributes: &#123; "id": "foo" &#125;, children: ["Hello!"]&#125; 所以我们只需要一个接受该格式并抛出实际DOM节点的函数：(即沉染vdom) 12345678910111213141516function render(vnode) &#123; // 字符串只转换成 文本节点： if (vnode.split) return document.createTextNode(vnode); // 使用 VDOM 的 nodeName 创建一个DOM 标签 let n = document.createElement(vnode.nodeName); // 拷贝所有属性到新节点上 let a = vnode.attributes || &#123;&#125;; Object.keys(a).forEach( k =&gt; n.setAttribute(k, a[k]) ); // 渲染并添加子节点 (vnode.children || []).forEach( c =&gt; n.appendChild(render(c)) ); return n;&#125; ：） 不难理解这是如何工作的。 如果有帮助，您可以将“虚拟DOM”视为一个非常简单的配置，用于构建给定的DOM结构。 虚拟DOM的好处是它非常轻巧。小对象引用其他小对象，一个由易于优化的应用程序逻辑构成的结构。 这也意味着它不受任何渲染逻辑或缓慢的DOM方法的束缚。 使用JSX我们知道JSX被转换成h()函数调用。 那些函数调用创建一个简单的“虚拟”DOM树。 我们可以使用该render()函数来制作一个匹配的“真实”DOM树。 这就是这样的： 12345678// JSX -&gt; VDOM:let vdom = &lt;div id="foo"&gt;Hello!&lt;/div&gt;;// VDOM -&gt; DOM:let dom = render(vdom);// add the tree to &lt;body&gt;:document.body.appendChild(dom); Partials，迭代与逻辑：没有新的语法 我们拥有所有的JavaScript语法，而不是模板语言引入的有限概念。（PS:这是JSX胜过模板语言的地方） “Partials”是由无逻辑/有限逻辑模板引擎引入的概念，用于在不同的上下文中重复使用视图块。 迭代似乎是每个新的模板语言都重新发明的东西（我和任何人一样有罪）。使用JSX，没有新的语法来学习：迭代您在JavaScript程序中的其他任何地方。您选择最适合给定任务迭代式的：[].forEach()，[].map()，for和while循环等 逻辑，像迭代，是模板语言喜欢重新发明的东西。一方面，无逻辑模板在将逻辑嵌入到视图方法非常弱：有限的结构，如\{\{ \#if value}}将逻辑推入控制器层，鼓励膨胀。这规避了构建语言来描述更复杂的逻辑，避免可预见性和安全隐患。 在另一方面，使用代码生成（一种从粗略到不可原谅的技术）的引擎通常具有执行逻辑或甚至迭代任意JavaScript表达式的能力。这是一个很好的理由，不惜一切代价避免这种情况：您的代码被从原始位置（也许是一个模块，闭包或标记内）中剥离出来，并对“别的地方”评估。这对我来说是不可预测的或足够安全的。 JSX允许所有 JavaScript的语言功能，而不依赖于在构建步骤中生成奇怪的代码，没有eval()和扩展。 1234567891011121314// 将数组中的字符串以列表的形式展示let items = ['foo', 'bar', 'baz'];// 创建列表lifunction item(text) &#123; return &lt;li&gt;&#123;text&#125;&lt;/li&gt;;&#125;// 一个使用迭代和复用的视图let list = render( &lt;ul&gt; &#123; items.map(item) &#125; &lt;/ul&gt;); render()返回一个DOM节点（在上述情况下是返回列表），所以我们只需要把它放到DOM中： 1document.body.appendChild(list); 把它放在一起以下是小型虚拟DOM渲染器和使用它的视图的完整源码。 具有一些样式的CodePen可在下面获得。 同样，我也写了一个例子：在任何地方使用JSX渲染DOM 1234567891011121314151617181920212223242526const ITEMS = 'hello there people'.split(' ');// turn an Array into list items:let list = items =&gt; items.map( p =&gt; &lt;li&gt; &#123;p&#125; &lt;/li&gt; );// view with a call out ("partial") to generate a list from an Array:let vdom = ( &lt;div id="foo"&gt; &lt;p&gt;Look, a simple JSX DOM renderer!&lt;/p&gt; &lt;ul&gt;&#123; list(ITEMS) &#125;&lt;/ul&gt; &lt;/div&gt;);// render() converts our "virtual DOM" (see below) to a real DOM tree:let dom = render(vdom);// append the new nodes somewhere:document.body.appendChild(dom);// Remember that "virtual DOM"? It's just JSON - each "VNode" is an object with 3 properties.let json = JSON.stringify(vdom, null, ' ');// The whole process (JSX -&gt; VDOM -&gt; DOM) in one step:document.body.appendChild( render( &lt;pre id="vdom"&gt;&#123; json &#125;&lt;/pre&gt; )); Codepen演示]]></content>
      <categories>
        <category>JSX</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>JSX</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJS事件桥接]]></title>
    <url>%2F2017%2F05%2F05%2FRxJS%E4%BA%8B%E4%BB%B6%E6%A1%A5%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[事件桥接RxJS 提供工厂方法来桥接 DOM 或 Node.js 中已存在的异步数据源，所以，你可以使用丰富的创作、过滤和资源管理功能对RxJS提供的任何类型的数据流进行操作。这篇文章探讨 fromEvent 和 fromEventPattern操作符，它允许导入一个 DOM 或者普通事件到 RxJS 的数据流。每次引发事件时，一个 OnNext 消息将传递到数据流。然后，可以像其他任何数据流一样操作事件数据流。 RxJS 不打算取代现有的异步编程模型如 Promises 或 callbacks。但是，当你尝试组合事件， RxJS的工厂方法会提供简便的方法给你，你完全感受不到当前使用了何种编程模式。这真的很方便维护（比如取消订阅）和筛选（比如选择合适的数据）数据源。在本节和下节中，你可以尝试 RxJS 的这些特性如何协助你完成异步编程。 自然，RxJS 支持一批库和他们的勾子函数去使用他们的事件系统，比如 jQuery, Zepto.js, AngularJS, Ember.js 和 Backbone.js。这种行为，不管怎样只能重写本地绑定。默认情况下， RxJS 也支持 Node.js EventEmitter 的事件勾子。 将一个 DOM 事件转换成 RxJS 数据流接下来这个例子为鼠标移动事件创建了一个 DOM 事件操作，并且在页面上打印出鼠标的坐标。 123var result = document.getElementById('result');document.addEventListener('mousemove', e =&gt; result.innerHTML = e.clientX + ', ' + e.clientY, false); 导入一个事件到 RxJS, 你可以使用 fromEvent 操作符，并且传入被桥接的事件参数。然后它会将事件转换成数据流。 下面这个例子，我们将 DOM 的 mousemove 事件流转换成事件流（可观察对象）。每次鼠标移动事件被触发时，订阅都会接收到一个 onNext 事件。然后我们可以检查这种通知的事件参数并获得鼠标的坐标。 12345var result = document.getElementById('result');var source = Rx.Observable.fromEvent(document, 'mousemove');var subscription = source.subscribe(e =&gt; result.innerHTML = e.clientX + ', ' + e.clientY); 在这个例子中要注意，（鼠标）移动变成一个数据流以便我们进一步操作。 Querying Observable Sequences 这篇文章将会展示如何将该序列投射到点类型集合中并筛选其内容，以便应用程序只接收满足一定条件的值。 事件处理程序的销毁由 subscribe 方法返回的 Disposable 对象处理。调用 dispose 将会释放由该序列所使用的所有资源，包括底层事件处理程序。这本质上是取消订阅事件。 fromEvent 方法还支持向多个项目添加事件处理程序，比如一整个 DOM 节点列表。下面这个例子将会给列表中的每个元素添加 ‘click’ 事件。 123456var result = document.getElementById('result');var sources = document.querySelectorAll('div');var source = Rx.Observable.fromEvent(sources, 'click');var subscription = source.subscribe(e =&gt; result.innerHTML = e.clientX + ', ' + e.clientY); 另外，fromEvent 也支持类库，像 jQuery, Zepto.js, AngularJS, Ember.js and Backbone.js： 123456var $result = $('#result');var $sources = $('div');var source = Rx.Observable.fromEvent($sources, 'click');var subscription = source.subscribe(e =&gt; $result.html(e.clientX + ', ' + e.clientY)); 如果表现不如预期，你可以通过设置 Rx.config.useNativeEvents 为 true 去重写它，这会无视任何类库。 123456789// 只使用原生事件，尽管引用了 jQueryRx.config.useNativeEvents = true;// 只使用原生事件var result = document.getElementById('result');var source = Rx.Observable.fromEvent(document, 'mousemove');var subscription = source.subscribe(e =&gt; result.innerHTML = e.clientX + ', ' + e.clientY); 另外，您可以轻松地给事件系统的事件添加许多快捷方式，比如 mousemove， 甚至是 Pointer and Touch 事件。 1234567891011121314151617Rx.dom = &#123;&#125;;var events = "blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu";if (root.PointerEvent) &#123; events += " pointerdown pointerup pointermove pointerover pointerout pointerenter pointerleave";&#125;if (root.TouchEvent) &#123; events += " touchstart touchend touchmove touchcancel";&#125;events.split(' ').forEach(e =&gt; &#123; Rx.dom[e] = (element, selector) =&gt; Rx.Observable.fromEvent(element, e, selector)&#125;); 现在我们可以重写单个鼠标拖拽事件： 1234567891011var draggable = document.getElementById('draggable');var mousedrag = Rx.dom.mousedown(draggable).flatMap(md =&gt; &#123; md.preventDefault(); var start = getLocation(md); return Rx.dom.mousemove(document) .map(mm =&gt; getDelta(start, mm)) .takeUntil(Rx.dom.mouseup(draggable));&#125;); 注意这在 RxJS-DOM 项目中已经可用，但你自己实现也只需要很少量的代码。 将 Node.js 事件转换成 RxJS 数据流Node.js 也支持类似 EventEmitter: 1234567891011var Rx = require('rx'), EventEmitter = require('events').EventEmitter;var eventEmitter = new EventEmitter();var source = Rx.Observable.fromEvent(eventEmitter, 'data')var subscription = source.subscribe(data =&gt; console.log('data: ' + data));eventEmitter.emit('data', 'foo');// =&gt; data: foo 使用 FromEventPattern 桥接自定义事件下面有一个使用类库实现事件订阅和退订的实例。fromEventPattern 方法就是为了这个目的而创建的，用来桥接这些自定义事件。 举个例子，你可以想使用 jQuery on 方法去桥接。我们可以将下列代码转换为基于表格行单击的 alert。 1$( "#dataTable tbody" ).on('click', 'tr', e =&gt; alert($( e.target ).text())); 使用 fromEventPattern 方法转换后的代码看起来像下面这样。每个函数在处理函数中传递，允许您调用 on 和 off 方法来正确处理事件的处理。 1234567var $tbody = $('#dataTable tbody');var source = Rx.Observable.fromEventPattern( function addHandler (h) &#123; $tbody.on('click', 'tr', h); &#125;, function delHandler (h) &#123; $tbody.off('click', 'tr', h); &#125;);var subscription = source.subscribe(e =&gt; alert($( e.target ).text())); 除了这种常用的支持外，我们也支持 addHandler 返回一个对象，它可以通过 removeHandler 去完全退订。在这个例子中，我们将使用 Dojo Toolkit 和 on 模块。 123456789101112131415161718192021require(['dojo/on', 'dojo/dom', 'rx', 'rx.async', 'rx.binding'], (on, dom, rx) =&gt; &#123; var input = dom.byId('input'); var source = Rx.Observable.fromEventPattern( function addHandler (h) &#123; return on(input, 'click', h); &#125;, function delHandler (_, signal) &#123; signal.remove(); &#125; ); var subscription = source.subscribe( x =&gt; console.log('Next: Clicked!'), err =&gt; console.log('Error: ' + err), () =&gt; console.log('Completed')); on.emit(input, 'click'); // =&gt; Next: Clicked!&#125;); 相关内容概念 Querying Observable Sequences 本文翻译在: RxJS中文文档]]></content>
      <categories>
        <category>RxJS</category>
      </categories>
      <tags>
        <tag>RxJS</tag>
        <tag>bridging</tag>
        <tag>event</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用RxJS创建和订阅单一数据流]]></title>
    <url>%2F2017%2F05%2F04%2F%E5%88%9B%E5%BB%BA%E5%92%8C%E8%AE%A2%E9%98%85%E5%8D%95%E4%B8%80%E6%95%B0%E6%8D%AE%E6%B5%81%2F</url>
    <content type="text"><![CDATA[来自 创建和订阅单一可观察序列你不需要去实现 Observable 类去创建一个可观察序列。 同样的，你也不需要去实现 Observer 去订阅数据流。通过安装 Rx 库，你可以利用 Observable类型，它提供了许多操作符来根据零个，一个或多个元素去创建一个数据流。另外， RxJS 还提供 subscribe 方法允许你使用 onNext, onError 和 onCompleted 函数。 从零创建一个数据流在使用操作符之前，让我们看一看怎样使用 Rx.Observable.create 方法从零创建 Observable 。 首先， 我们需要确认引用了 rx.js 核心文件。 1&lt;script src="rx.js"&gt;&lt;/script&gt; 如果我们使用 Node.js， 我们可以这样引入: 1var Rx = require('rx'); 在这个例子中， 我们将只产生一个单一值42，然后标记为完成。 如果不需要清除，返回值是完全可选的。 12345678910111213141516171819var source = Rx.Observable.create(observer =&gt; &#123; // 产生一个单一值然后完成。 observer.onNext(42); observer.onCompleted(); // 任何清除的逻辑写在这里 return () =&gt; console.log('disposed')&#125;);var subscription = source.subscribe( x =&gt; console.log('onNext: %s', x), e =&gt; console.log('onError: %s', e), () =&gt; console.log('onCompleted'));// =&gt; onNext: 42// =&gt; onCompletedsubscription.dispose();// =&gt; disposed 对于大多数操作， 这完全是多余的，但这展示了非常基础的大部分 RxJS 操作符是如何工作的。 创建及订阅单一数据流接下来的例子使用 Observable 类的 range 操作符来创建一个包含一些数字的单一数据流。观察者使用 Observable 类的 Subscribe 订阅这个数据流集合， 并且处理回调 onNext, onError and onCompleted。在我们的例子中，创建了一个从 x 开始的整数序列，然后接下来产生 y 个。 只要订阅了数据流，数据就会发送给观察者。onNext函数会打印出这个值。 123456789101112131415// 创建一个从 1 开始，包含 5 个整数的数据流var source = Rx.Observable.range(1, 5);// 打印每个值var subscription = source.subscribe( x =&gt; console.log('onNext: %s', x), e =&gt; console.log('onError: %s', e), () =&gt; console.log('onCompleted'));// =&gt; onNext: 1// =&gt; onNext: 2// =&gt; onNext: 3// =&gt; onNext: 4// =&gt; onNext: 5// =&gt; onCompleted 当一个观察者订阅了一个数据流， subscribe 方法背后使用的异步操作取决于操作符。因些， subscribe 的调用是异步的，因为调用者在完成序列观察之前不会被阻塞。这篇文章 Using Schedulers 提供了更多信息。 注意 subscribe 方法返回一个 Disposable，所以你可以很容易地退订和销毁它。当你在可观察对象上调用 dispose 方法时，观察者将会停止监听数据流。正常来说，你不需要精确地调用 dispose 除非你需要提前退订，或者当数据流的生命周期比观察者的还长。 Rx 的订阅被设计成 触发-丢弃 的场景，并不需要终结者。注意到，可观察对象的操作符的默认表现是 只要有可能（比如，onCompleted 或 onError 消息被发送时），订阅就会被销毁。举个例子，下面的代码将会订阅 a 和 b 两个数据流。如果 a 抛出一个错误， x 会立即退订 b 。 1var x = Rx.Observable.zip(a, b, (a1, b1) =&gt; a1 + b1).subscribe(); 还可以调整代码示例以使用观察者的 Create 运算符，创建并从指定的 OnNext, OnError, 和 OnCompleted 回调返回一个观察者。然后你可以传递 observer 给 observable 的 subscribe 方法。下面的例子展示了这种写法。 123456789101112131415161718// 创建包含 5个整数的数据流，从 1 开始var source = Rx.Observable.range(1, 5);// 创建观察者var observer = Rx.Observer.create( x =&gt; console.log('onNext: %s', x), e =&gt; console.log('onError: %s', e), () =&gt; console.log('onCompleted'));// 打印每个结果var subscription = source.subscribe(observer);// =&gt; onNext: 1// =&gt; onNext: 2// =&gt; onNext: 3// =&gt; onNext: 4// =&gt; onNext: 5// =&gt; onCompleted 另外，从零创建一个数据流，你也可以将已存在的 数据， 事件，回调以及 promise 转换成数据流。下一节的主题将会教你怎么做。 注意，这一节只展示了可以从零创建数据流的很少一部分操作符。学习更多其他的 LINQ 操作符， 可以查看 Querying Observable Sequences. 使用定时器接下来的例子使用 timer 操作符去创建一个数据流。 这个数据流将在5秒后输出第一个值，接着每1秒输出后面的值。为了说明， 我们配合 timestamp 操作符去查询，使每一个被推出来的值将在发布时追加时间戳。这样，当我们订阅这个数据源时，我们可以接收到值和时间戳。 首先，我们需要确认我们是否在浏览器引入了相关的文件。注意 RxJS NPM 包已经默认包含了所有操作符。 12&lt;script src="rx.js"&gt;&lt;/script&gt;&lt;script src="rx.time.js"&gt;&lt;/script&gt; 下面是我们的例子： 123456789101112131415console.log('Current time: ' + Date.now());var source = Rx.Observable.timer( 5000, /* 5 秒 */ 1000 /* 1 秒 */) .timestamp();var subscription = source.subscribe( x =&gt; console.log(x.value + ': ' + x.timestamp));/* 输出可能像这样子 */// Current time: 1382560697820// 0: 1382560702820// 1: 1382560703820// 2: 1382560704820 通过使用 timestamp 操作符，我们可以证实，第一个值确实是开始5秒后输出，然后每1秒输出一个值。 将数组和可迭代对象转换为数据流使用 Rx.Observable.from 操作符，你可以将一个数组转换为数据流。 1234567891011121314151617var array = [1,2,3,4,5];// 将数组转换为数据流var source = Rx.Observable.from(array);// 输出每个值var subscription = source.subscribe( x =&gt; console.log('onNext: %s', x), e =&gt; console.log('onError: %s', e), () =&gt; console.log('onCompleted'));// =&gt; onNext: 1// =&gt; onNext: 2// =&gt; onNext: 3// =&gt; onNext: 4// =&gt; onNext: 5// =&gt; onCompleted 你也可以转换类数组结构，比如包含 length 属性和数字索引的对象。这种情况下，我们只简单有一个包含长度为5的对象。 1234567891011121314151617var arrayLike = &#123; length: 5 &#125;;// 转换数组为数据流var source = Rx.Observable.from(arrayLike, (v, k) =&gt; k);// 输出每个值var subscription = source.subscribe( x =&gt; console.log('onNext: %s', x), e =&gt; console.log('onError: %s', e), () =&gt; console.log('onCompleted'));// =&gt; onNext: 1// =&gt; onNext: 2// =&gt; onNext: 3// =&gt; onNext: 4// =&gt; onNext: 5// =&gt; onCompleted 另外，我们也可以使用 ES6 可迭代对象，如 Map 和 Set 使用 from 转换成数据流。下面这个例子，我们将获取一个 Set 对象，并且将它转换成数据流。 1234567891011121314151617var set = new Set([1,2,3,4,5]);// 转换 Set 为数据流var source = Rx.Observable.from(set);// 转出每个值var subscription = source.subscribe( x =&gt; console.log('onNext: %s', x), e =&gt; console.log('onError: %s', e), () =&gt; console.log('onCompleted'));// =&gt; onNext: 1// =&gt; onNext: 2// =&gt; onNext: 3// =&gt; onNext: 4// =&gt; onNext: 5// =&gt; onCompleted 我们也可以将它应用在 Map 对象上面。 1234567891011121314var map = new Map([['key1', 1], ['key2', 2]]);// 将 Map 转换成数据流var source = Rx.Observable.from(map);// 打印每个值var subscription = source.subscribe( x =&gt; console.log('onNext: %s', x), e =&gt; console.log('onError: %s', e), () =&gt; console.log('onCompleted'));// =&gt; onNext: key1, 1// =&gt; onNext: key2, 2// =&gt; onCompleted from 方法也支持 ES6 generators，可以你的浏览器已经支持，或将要支持。这允许我们实现一些像 斐波那契序列 等，并将它们转换成数据流。 1234567891011121314151617181920212223242526function* fibonacci () &#123; var fn1 = 1; var fn2 = 1; while (1)&#123; var current = fn2; fn2 = fn1; fn1 = fn1 + current; yield current; &#125;&#125;// 将 generator 转换成数据流var source = Rx.Observable.from(fibonacci()).take(5);// 打印每个值var subscription = source.subscribe( x =&gt; console.log('onNext: %s', x), e =&gt; console.log('onError: %s', e), () =&gt; console.log('onCompleted'));// =&gt; onNext: 1// =&gt; onNext: 1// =&gt; onNext: 2// =&gt; onNext: 3// =&gt; onNext: 5// =&gt; onCompleted 冷（惰性） vs. 热（非惰性） 数据流冷数据流的开始运行取决于订阅，比如，数据流只有当 subscribe 调用的时候才开始输出值。用户之间也没有共享值。这些是与热数据流的不同之处，热数据像流鼠标移动事件或股票代码这样的订阅时就已经不断输出值。当观察者订阅热数据流时，它将会获取流的实时值。热数据流是与所有订阅者共享的，每个订阅者按顺序推送下一个值。举个例子，就算没有人订阅一个特定的股票，股票市场也将继续根据市场动向更新其价值。当有注册者对这支股票感兴趣时，它会自动获得股票的最新值。 下面的示例演示了一个冷数据流。这个例子中，我们使用了 Interval 操作符去创建一个单一数据流并在特定的时间间隔输出值，这个例子中是间隔1秒。 两个观察者订阅这个数据流并打印输出值。你会注意到数据流会为每个订阅者重置，第二个订阅者也是从第1个值开始的。 首先，我们需要确保在浏览器中引入了相关文件。注意 RxJS NPM 包已经默认包含了所有操作符。 1&lt;script src="rx.lite.js"&gt;&lt;/script&gt; 然后是例子： 12345678910111213141516171819202122232425var source = Rx.Observable.interval(1000);var subscription1 = source.subscribe( x =&gt; console.log('Observer 1: onNext: ' + x), e =&gt; console.log('Observer 1: onError: ' + e.message), () =&gt; console.log('Observer 1: onCompleted'));var subscription2 = source.subscribe( x =&gt; console.log('Observer 2: onNext: ' + x), e =&gt; console.log('Observer 2: onError: ' + e.message), () =&gt; console.log('Observer 2: onCompleted'));setTimeout(() =&gt; &#123; subscription1.dispose(); subscription2.dispose();&#125;, 5000);// =&gt; Observer 1: onNext: 0// =&gt; Observer 2: onNext: 0// =&gt; Observer 1: onNext: 1// =&gt; Observer 2: onNext: 1// =&gt; Observer 1: onNext: 2// =&gt; Observer 2: onNext: 2// =&gt; Observer 1: onNext: 3// =&gt; Observer 2: onNext: 3 接下来的例子中，我们使用 publish 操作符将前面的冷数据源转换成热数据源，返回一个 ConnectableObservable 实例，我们称为 hot。publish 操作符通过向多个订阅服务器广播单个订阅来提供共享订阅的机制。hot变量作为代理订阅 source，因为它从 source 接收值，推到自己的用户. 我们使用 ConnectableObservable.prototype.connect 建立订阅的备份源，并开始接收值。因为 ConnectableObservable 继承自 Observable， 我们可以在它运行之前使用 subscribe 去订阅这个热数据流。 在这个例子中要注意，当 subscription1订阅它的时候热数据流还没有开始。因些，没有值输出给订阅者。只有调用 Connect 之后，输出值才会推送给 subscription1。3秒的延迟之后，subscription2 订阅了热数据流，并且立即开始接收当前输出值（当前值是3），一直到最后。输出结果看起来像这样： 123456789101112// =&gt; Current time: 1382562433256// =&gt; Current Time after 1st subscription: 1382562433260// =&gt; Current Time after connect: 1382562436261// =&gt; Observer 1: onNext: 0// =&gt; Observer 1: onNext: 1// =&gt; Current Time after 2nd subscription: 1382562439262// =&gt; Observer 1: onNext: 2// =&gt; Observer 2: onNext: 2// =&gt; Observer 1: onNext: 3// =&gt; Observer 2: onNext: 3// =&gt; Observer 1: onNext: 4// =&gt; Observer 2: onNext: 4 首先，我们需要确认我们引入了相关文件。注意 RxJS NPM包已经默认包含了所有操作符。 1&lt;script src="rx.lite.js"&gt;&lt;/script&gt; 接下来是例子！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849console.log('Current time: ' + Date.now());// 创建一个数据流var source = Rx.Observable.interval(1000);// 将数据流转换成热数据流var hot = source.publish();// 第一个订阅时没有值输出var subscription1 = hot.subscribe( x =&gt; console.log('Observer 1: onNext: %s', x), e =&gt; console.log('Observer 1: onError: %s', e), () =&gt; console.log('Observer 1: onCompleted'));console.log('Current Time after 1st subscription: ' + Date.now());// 空闲 3 秒setTimeout(() =&gt; &#123; // 热数据源连接并开始输出值给订阅者 hot.connect(); console.log('Current Time after connect: ' + Date.now()); // 又空闲 3 秒 setTimeout(() =&gt; &#123; console.log('Current Time after 2nd subscription: ' + Date.now()); var subscription2 = hot.subscribe( x =&gt; console.log('Observer 2: onNext: %s', x), e =&gt; console.log('Observer 2: onError: %s', e), () =&gt; console.log('Observer 2: onCompleted')); &#125;, 3000);&#125;, 3000);// =&gt; Current Time after connect: 1431197578426// =&gt; Observer 1: onNext: 0// =&gt; Observer 1: onNext: 1// =&gt; Observer 1: onNext: 2// =&gt; Current Time after 2nd subscription: 1431197581434// =&gt; Observer 1: onNext: 3// =&gt; Observer 2: onNext: 3// =&gt; Observer 1: onNext: 4// =&gt; Observer 2: onNext: 4// =&gt; Observer 1: onNext: 5// =&gt; Observer 2: onNext: 5// =&gt; ... 类推 这有助于思考冷热数据源的关系，就像一个人看（subscribe）电影和表演。 冷数据流：电影。 热数据流：现场演出 重播热数据流：录播现场演出 你管你何时观看电影，你看电影和别人看都是独立的，尽管所有观看者看的都是相同的内容。另一方面，一个表演是与多个观看都一起分享的。如果你迟到了，你将会错过一部分。不管怎样，如果记录下来了（在 RxJS中可以使用 BehaviorSubject 或 ReplaySubject），你也可像看电影一样看现场演出。.publish().refCount() 现场表演是艺术家在没有人观看的情况下退出比赛，当观众中至少有一人出现时，他会重新开始演奏。]]></content>
      <categories>
        <category>RxJS</category>
      </categories>
      <tags>
        <tag>RxJS</tag>
        <tag>Observable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coverage针对js和css的代码覆盖检测-Chrome_devtools的新功能]]></title>
    <url>%2F2017%2F04%2F06%2FCoverage%E9%92%88%E5%AF%B9js%E5%92%8Ccss%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E6%A3%80%E6%B5%8B-Chrome-devtools%E7%9A%84%E6%96%B0%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[也许你之前用过一些像 css usage、css used 这样的浏览器插件去检测代码覆盖率。但现在，Chrome的实验版本Canary终于实现了代码覆盖率检测，这意味着它将很快普及到正式版本。这是一个令人兴奋的功能，在使用JavaScript和CSS时非常有用，所以我会做一个快速的演示，并探索它如何使用。 它做了些什么事情代码覆盖可以在您运行您的Web应用程序的时候，遍历每个JS / CSS文件，看看哪些代码行运行，哪些代码没有运行。 在这里，我做了一个简单的静态网页，Chrome生成了页面上存在的CSS和JS文件的问题汇总。右侧的栏显示每个文件的相对大小，红色表示未使用的代码，绿色显示运行的代码。 记录代码覆盖范围与devtools时间轴类似，您点击开始记录，然后在您的站点进行正常的交互。完成后，Chrome会进行一些计算并生成读数。在这里，我很好奇网站上有多少未使用的CSS，所以我导航到各个子页面，以确保我触及到每个css。果然，这里有很多改进的空间，因为我的网站上的css的97％没有使用！ Chrome还可让您深入研究单个文件的代码范围。在这里，左边的红色/绿色条显示哪一行执行了，哪一行没有。请注意，当检查最小化的文件时，可以按文件左下角的按钮来“prettify”代码。 这有什么用在一个复杂的或长期的项目上工作时，很容易积累冗余代码。如果你使用 webpack 或另一个JS构建系统，可以防止大多数无用的JS代码。但是对于CSS来说，这样做可能会有点棘手。有了这个覆盖工具，在Chrome是一个伟大的方式来快速了解多少冗余的代码在运行，哪些文件需要优化。 如何才能使用它下载Chrome的实验版本Canary或等待此功能更新到正式版本。 【译文参考】：https://blog.logrocket.com/using-the-chrome-devtools-new-code-coverage-feature-ca96c3dddcaf]]></content>
      <categories>
        <category>Chrome_devtools</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>coverage</tag>
        <tag>Chrome_devtools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习RxJS需要知道的奇淫技巧]]></title>
    <url>%2F2017%2F04%2F05%2F%E5%AD%A6%E4%B9%A0RxJS%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[使用 Rx 的奇淫技巧尝试画珠宝图为你想创建的流画一个珠宝图。 通过画珠宝图，你将会很清楚你应该使用哪些操作符。 珠宝图就是每个珠宝表示当前的一个事件或状态。珠宝图需要包含输入和输出流。 通过画珠宝图，我们可以看到，我们在异步调用事件回调之前，需要延迟检测用户的输入。在这个例图里展示的是throttle操作符的延迟。从一个流创建另一个流，我们会使用 flatMap 或 selectMany 操作符。然后就有了下面的代码： 1var dictionarySuggest = userInput.throttle(250).flatMap(input =&gt; serverCall(input)); 何时忽略这条指南如果你感觉你已经可以很熟练地编写出你想要的流，你可以省去画珠宝图这一步。不管怎样，就算是 Rx 团队的成员在写代码的时候也仍然会先画一画珠宝图。 调用 subscribe 时传递多个参数为了方便， Rx 提供一个subscribe方法来加载观察者的回调函数。 观察者只需要实现这三个方法（onNext, onError &amp; onCompleted）。 subscribe方法的扩展允许开发人员使用这些方法的默认选项。 比如： 当调用subscribe方法时只有一个onNext参数，onError将捕获来自事件流的异常。onCompleted在这里什么也不会做。 大部分情况下，处理异常是很重要的（不管是对于恢复还是中断应用程序）。 知道事件流是否完成也经常是很重要的。举个例子，告诉用户他的操作是否完成了。 所以，最好提供完整的三个参数给 subscribe 操作符。 RxJS还提供了三种方便的方法，其仅订阅所期望的序列的一部分。其他的处理程序会默认为原来的行为。有三个这样的功能： subscribeOnNext: 只对应 onNext 消息 subscribeOnError: 只对应 onError 消息 subscribeOnCompleted: 只对应 onCompleted 消息. 何时忽略这条指南 当流确定不会有完成状态，比如 keyup事件。 当流确定不会抛出异常，比如一个事件，一个完全确定的流。 当默认行为是符合预期的时候。 考虑通过特定的调度程序并发引入操作符相比使用observeon操作符来改变可观察序列产生消息的执行上下文，更好的做法是在正确的地方开始创建并发。 通过正确的调度器将会减少 ObserveOn操作符的使用。 例1Rx.Observable.range(0, 90000, Rx.Scheduler.requestAnimationFrame).subscribe(draw); 在这个例子中，来自range操作符的回调将会通过window.requestAnimationFrame传递。在这个例子中， range操作符的回调将被调用。默认情况下，当递归调用立即执行时，range过载将会代替 onNext在Rx.Scheduler.currentThread上的调用。 通过提供Rx.Scheduler.requestAnimationFrame调度程序， 所有来自observable的消息都将会在 window.requestAnimationFrame回调中产生。 何时忽略这条指南当结合来自不同执行上下文的几个事件时，使用指南4.4将所有消息尽可能晚地放在特定的执行上下文。 尽可能少且尽可能迟地调用observeOn 操作符通过使用 observeOn 操作符， 一个预定的功能是通过原始的消息流来获取信息。这可能会改变时序信息以及对系统施加额外的压力。在查询中延迟使用这个操作符可以改善这两个问题。 Sample12345var result = xs.throttle(1000) .flatMap(x =&gt; ys.takeUntil(zs).sample(250).map(y =&gt; x + y)) .merge(ws) .filter(x =&gt; x &lt; 10) .observeOn(Rx.Scheduler.requestAnimationFrame); 这个例子合并了多个 运行在不同上下文的 observable 。这个查询筛选掉了大部分信息。将observeOn操作符放在查询中的前面会对筛选出来的消息做额外的工作。最后才调用 observeOn 将会最大限度地提高性能。 何时忽略这条指南如果你使用的 observable 并没有指定不同的上下文环境。这种情况下可以不必使用 observeOn 操作符。 关注内存限制RxJS 有很多操作符和类可以在内存中创建 observable, 比如：replay 操作符。当这些内存存储着 observable 时，这些缓存的大小将取决于 observable 的操作。如果缓存过大，将会造成内存溢出。有许多缓冲操作符提供策略来限制缓冲区，不管是从时间方面还是大小。提供这个限制将解决内存压力问题。 例子1var result = xs.replay(null, 10000, 1000 * 60 /* 1 hr */).refCount(); 这个例子中，replay 操作符创建了一个 buffer. 我们有限制这个 buffer 最多包含 10,000 条信息以及最多保留这些信息1小时。 何时忽略这条指南当 observable 创建了大量的信息只填充了一小块 buffer， 或者当 buffer本身有大小限制。 使用 do/tap 操作符的副作用很明显有很多 Rx 操作符使用函数作为参数，这可以在这些参数中传递任何有效的用户代码。这些代码可以改变全局状态（比如改变全局变量，读写硬盘等等）。 Rx 是通过每个操作符组合起来运行的（除了共享操作符，例如“publish”）。这将使副作用发生在每个订阅。 如果这种表现是期望的行为，最好弄清楚在 do/tap 操作符中有副作用的这部分代码。这些方法会过载，只能调用指定的方法，比如 doOnNext/tapOnNext，doOnError/tapOnError,doOnCompleted/tapOnCompleted 例1var result = xs.filter(x =&gt; x.failed).tap(x =&gt; log(x)); 这个例子中，过滤失败的消息。将它们分发到订阅observable的代码之前记录该消息。此记录有一个副作用（比如：将消息放置在计算机的事件日志中）并明确地通过调用do/tap操作符。 假设消息可以传达，直到退订完成由于RxJS 使用推模式，消息可以通过不同的上下文环境发送。 当退订的时候，消息可能还在路上。当退订还没有完成的时候，这些消息仍然可以被传达。当控制权被返回时，消息将不能再传达。退订过程可以是在一个不同的上下文环境中进行。 何时忽略这条指南一旦 onCompleted 或 onError 方法被调用，RxJS语法可以保证订阅已结束。 使用 publish 操作符分享副作用因为许多 observable是冷门的(see cold vs. hot on Channel 9), 每个订阅都有单独的副作用。 某些情况下，这些副作用只发生一次。publish 操作符通过向多个用户广播单个订阅来提供共享订阅的机制。 有几个过载publish运算符。最方便的过载是那些提供了一个函数封装 observable 共享的副作用的参数。 例1234567891011var xs = Rx.Observable.create(observer =&gt; &#123; console.log('Side effect'); observer.onNext('hi!'); observer.onCompleted();&#125;);xs.publish(sharedXs =&gt; &#123; sharedXs.subscribe(console.log); sharedXs.subscribe(console.log); return sharedXs;&#125;).subscribe(); 这个例子中，xs 是一个有副作用的（写入console） observable。正常情况下，每个单独的订阅都会触发这些副作用。 publish 操作符使用xs单独给所有订阅者 sharedXs 变量去订阅。 何时忽略这条指南只有当 publish 操作符需要共享副作用时才使用这条指南。在大多数情况下，您可以创建单独的订阅，没有任何问题：不管是订阅没有副作用的或是副作用可以执行多次没有任何问题的。 参考 同步翻译至RxJS中文文档]]></content>
      <categories>
        <category>RxJS</category>
      </categories>
      <tags>
        <tag>RxJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么选择 RxJS?]]></title>
    <url>%2F2017%2F04%2F04%2Fwhy-rxjs%2F</url>
    <content type="text"><![CDATA[Why RxJS?你可能会问，为什么选择 RxJS? 为什么不是 Promises? Promises 可以很好地解决异步操作，像使用 XMLHttpRequest 去查询服务器, 它预期会返回值并且最终完成请求。 The Reactive Extensions 统一了 JavaScript 中的 Promises, callbacks 以及事件数据，比如 DOM输入, Web Workers, Web Sockets. 一旦我们统一了这些概念，就可以进行各种各样的组合. 为了让您了解丰富的组合，我们可以创建一个自动完成功能，它从文本输入中接收用户输入，然后查询服务，确保不会对每个键盘输入的进行泛滥地调用，而是以一种更自然的方式调用。 首先，我们将引用JavaScript文件，包括jQuery，尽管RxJS没有依赖于jQuery … 12&lt;script src="http://code.jquery.com/jquery.js"&gt;&lt;/script&gt;&lt;script src="rx.lite.js"&gt;&lt;/script&gt; 接下来，我们将从输入框获取用户输入，使用Rx.Observable.fromEvent 方法监听 keyup 事件. 如果 jQuery, Zepto, AngularJS and Ember.js 可用，将会使用它们来绑定事件, 否则将使用原生事件绑定. 这跟您的框架思考事件的一致方式，因此没有任何惊喜。 12345678910111213var $input = $('#input'), $results = $('#results');/* 只从 keyup 事件获得输入值 */var keyups = Rx.Observable.fromEvent($input, 'keyup') .map(e =&gt; e.target.value) .filter(text =&gt; text.length &gt; 2);/* 函数节流输出设置为 500ms */var throttled = keyups.throttle(500 /* ms */);/* 现在判断值是否有改变，只获取不同的值 */var distinct = throttled.distinctUntilChanged(); 现在，让我们来查询维基百科！在RxJS中，我们可以立即通过Rx.Observable.fromPromise方法绑定到任何Promises A+的实现上，或者直接返回它，并将其封装。 1234567891011function searchWikipedia (term) &#123; return $.ajax(&#123; url: 'http://en.wikipedia.org/w/api.php', dataType: 'jsonp', data: &#123; action: 'opensearch', format: 'json', search: term &#125; &#125;).promise();&#125; 一旦创建，现在我们可以将不同的节流输入绑定在一起，然后查询服务。在这种情况下，我们将调用flatMapLatest获取该值，并确保我们不会有任何混乱的调用。 1var suggestions = distinct.flatMapLatest(searchWikipedia); 最后，我们将在可观察对象上调用subscribe方法开始拉数据。 12345678910111213suggestions.subscribe(data =&gt; &#123; var res = data[1]; /* Do something 像数据绑定 */ $results.empty(); $.each(res, (_, value) =&gt; $('&lt;li&gt;' + value + '&lt;/li&gt;').appendTo($results));&#125;, error =&gt; &#123; /* handle any errors */ $results.empty(); $('&lt;li&gt;Error: ' + error + '&lt;/li&gt;').appendTo($results);&#125;); 翻译参考 同步发布RxJS中文文档]]></content>
      <categories>
        <category>RxJS</category>
      </categories>
      <tags>
        <tag>RxJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lerp的应用-利用简单线性插值来平滑动画效果]]></title>
    <url>%2F2017%2F03%2F20%2FLerp%E7%9A%84%E5%BA%94%E7%94%A8-%E5%88%A9%E7%94%A8%E7%AE%80%E5%8D%95%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC%E6%9D%A5%E5%B9%B3%E6%BB%91%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[上一篇的 RxJS的动画简介 里提到一个动画平滑的小技巧, 这里展示几个例子，它真的很简单却很有用。 Lerp是两点之间的线性插值的别称。这是一个实现起来相当简单的效果，但可以真正改善你的动画的外观，如果你将一个对象从点A移动到点B. 它是如何工作的？如果您有一个对象的当前位置和目标的位置，您可以线性内插这些点之间的距离的百分比，并在每个动画帧上更新该位置。 12345function lerp(position, targetPosition) &#123;// 计算当前位置与目标位置差值的 20% position.x += (targetPosition.x - position.x)*0.2; position.y += (targetPosition.y - position.y)*0.2;&#125; 通过这样做，对象移动的量随着位置和目标之间的距离减小而变小。这意味着对象将越来越接近它的目标，速度将减慢，这创造一个很好的缓和效果。 一些例子这里有一个球跟随用户的鼠标或触摸运动的例子。如果我们使球移动到鼠标移动的地方，球的移动可以非常快但看起来有点脱节。如果我们快速移动鼠标，我们也可以看到单独的“球影”。 这里是同样的演示，除了这次我们使用lerp。不是将球立即向右移动到鼠标位置，我们每次将它移动10％的距离。 注意球的运动很平滑，整体更令人愉快的效果。 这里是使用lerp的另一个例子。这次我们有一个滚动指示器，当您向下滚动“页面”时更新。 所以，lerp“把戏”是一个伟大的工具，我们的网络动画套路，以对抗线性或锯齿状的运动。]]></content>
      <categories>
        <category>animate</category>
      </categories>
      <tags>
        <tag>animate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJS的动画简介]]></title>
    <url>%2F2017%2F03%2F19%2FRxJS%E7%9A%84%E5%8A%A8%E7%94%BB%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[本文译自 An Animated Intro to RxJS 你可能听说过RxJS，ReactiveX，或反应式编程，或者甚至只听过函数式编程。这些术语在谈论最新和最前沿的前端技术时变得越来越突出。如果你像我一样，当你第一次尝试学习它时，你感到很困惑。 根据ReactiveX.io： ReactiveX是一个库，用于通过使用可观察序列来组成异步和基于事件的程序。 这句话包含了很多要消化的内容。在本文中，我们将采用一种不同的方法来学习RxJS（ReactiveX的JavaScript实现）和Observables，通过创建反应式动画。 理解Observable数组是元素的集合，例如[1, 2, 3, 4, 5]。你可以立即得到所有的元素，你可以做的事情像map，filter和映射他们。这允许你以任何你想要的方式转换元素的集合。 现在假设阵列中的每个元素随时间发生; 也就是说，你不是立即得到所有的元素，而是一次一个。你可能得到第一个元素在第1秒，下一个在第3秒，依此类推。以下是如何表示： 这可以被描述为值的流，或事件序列，或更确切地，称为observable。 observable是随时间的值的集合。 就像使用数组一样，您可以对这些值进行映射，过滤等操作，以创建和组合新的observable。最后，你可以订阅这些observable，并在steam的值之后执行你想要做的事。这是RxJS的源。 RxJS起步开始使用RxJS的最简单的方法是使用CDN，虽然有很多方法可以安装，这取决于项目的需要。 12&lt;!-- the latest, minified version of RxJS --&gt;&lt;script src="https://unpkg.com/@reactivex/rxjs@latest/dist/global/Rx.min.js"&gt;&lt;/script&gt; 一旦你的项目中有RxJS，你可以从任何东西中创建一个observable ： 123456789101112131415161718const aboutAnything = 42;// 从变量创建// The observable emits that value, then completes.const meaningOfLife$ = Rx.Observable.just(aboutAnything);// 从数组或可遍历的结构中创建// The observable emits each item from the array, then completes.const myNumber$ = Rx.Observable.from([1, 2, 3, 4, 5]);// From a promise.// The observable emits the result eventually, then completes (or errors).const myData$ = Rx.Observable.fromPromise(fetch('http://example.com/users'));// 从事件中创建// The observable continuously emits events from the event listener.const mouseMove$ = Rx.Observable .fromEvent(document.documentElement, 'mousemove'); 注意：变量末尾的美元符号$是一个约定，表示该变量是一个可观察者。Observable可以用来对任何可以表示为随时间变化的值的流进行建模，例如事件，Promises，计时器，间隔和动画。 因为，这些可观察的东西不做任何事情，至少直到你实际观察他们。一个简单的订阅将做到这一点，使用创建.subscribe()： 12345678myNumber$.subscribe(number =&gt; console.log(number));// Result:// &gt; 1// &gt; 2// &gt; 3// &gt; 4// &gt; 5 让我们实践看看： 12345678910const docElm = document.documentElement;const cardElm = document.querySelector('#card');const titleElm = document.querySelector('#title');const mouseMove$ = Rx.Observable .fromEvent(docElm, 'mousemove');mouseMove$.subscribe(event =&gt; &#123; titleElm.innerHTML = `$&#123;event.clientX&#125;, $&#123;event.clientY&#125;`&#125;); 从mouseMove$观察到的，每次mousemove事件发生时，订阅改变titleElm的.innerHTML的鼠标的位置。该.map操作（据工作原理类似Array.prototype.map方法）可帮助简化事情： 1234// Produces e.g., &#123;x: 42, y: 100&#125; instead of the entire eventconst mouseMove$ = Rx.Observable .fromEvent(docElm, 'mousemove') .map(event =&gt; (&#123; x: event.clientX, y: event.clientY &#125;)); 使用一些数学和内联样式，您可以使卡片朝向鼠标旋转。pos.y / clientHeight和pos.x / clientWidth计算为0和1之间的值，所以乘以由50减去一半（25）产生的值从-25到25，这正是我们需要为我们的旋转值： 123456789101112131415161718const docElm = document.documentElement;const cardElm = document.querySelector('#card');const titleElm = document.querySelector('#title');const &#123; clientWidth, clientHeight &#125; = docElm;const mouseMove$ = Rx.Observable .fromEvent(docElm, 'mousemove') .map(event =&gt; (&#123; x: event.clientX, y: event.clientY &#125;))mouseMove$.subscribe(pos =&gt; &#123; const rotX = (pos.y / clientHeight * -50) - 25; const rotY = (pos.x / clientWidth * 50) - 25; cardElm.style = ` transform: rotateX($&#123;rotX&#125;deg) rotateY($&#123;rotY&#125;deg); `;&#125;); 使用 .merge 合并现在让我们假设你想让这个适应触摸设备，不管是鼠标事件或是触摸动作。没有任何混乱的回调，你可以通过RxJS使用很多方法来结合Observable。在这个例子中，可以使用.merge实现。就像交通多条车道合并成一个单一的车道，这将返回一个包含所有数据的Observable通过合并多个Observable. 123456789101112const touchMove$ = Rx.Observable .fromEvent(docElm, 'touchmove') .map(event =&gt; (&#123; x: event.touches[0].clientX, y: event.touches[0].clientY &#125;));const move$ = Rx.Observable.merge(mouseMove$, touchMove$);move$.subscribe(pos =&gt; &#123; // ...&#125;); 继续，尝试在触摸屏设备上平移左右： 还有很多其他有用的Observable合并方法，如.switch()，.combineLatest()和.withLatestFrom()，我们继续关注下一个点。 添加平滑的运动旋转卡动作有点太死板。只要鼠标（或手指）停止，旋转即刻停止。为了解决这个问题，线性内插（线性插值）都可以使用。一般技术中描述这个伟大的教程由雷切尔·史密斯。本质上，而不是从A点跳到B，线性插值会在每一个动画运行一小部分。这将产生一个平滑的过渡，甚至当鼠标/触摸移动已停止。 让我们创建一个函数实现这个功能：计算给定初始值和终值下一个值，采用线性插值： 123456789function lerp(start, end) &#123; const dx = end.x - start.x; const dy = end.y - start.y; return &#123; x: start.x + dx * 0.1, y: start.y + dy * 0.1, &#125;;&#125; 非常简约。我们有一个纯函数每次返回一个新的，线性内插的位置值，通过移动当前的（开始）接近每个动画帧上的下一个（完）位置10％的位置。 调度和.interval问题是，我们如何在RxJS中表示动画帧？原来，RxJS有一个叫做Schedulers的东西，它控制什么时候从一个observable发出数据，当订阅都开始接收值。 使用Rx.Observable.interval()，您可以创建一个observable，它在固定的时间间隔发出值，例如每隔一秒（Rx.Observable.interval(1000)）。如果创建一个非常微小的时间间隔，例如Rx.Observable.interval(0)，并希望它只在每个动画帧上发出值，那么在动画帧内Rx.Scheduler.animationFrame每隔16到17ms就会发出一个值，如下所示： 1const animationFrame$ = Rx.Observable.interval(0, Rx.Scheduler.animationFrame); 结合.withLatestFrom要创建平滑线性插值，您只需要关心每个动画帧的最新鼠标或触摸位置。要做到这一点，有一个操作符叫.withLatestFrom()： 12const smoothMove$ = animationFrame$ .withLatestFrom(move$, (frame, move) =&gt; move); 现在，smoothMove$是一个新的observable，move$ 只有当animationFrame$发出一个值时，才会发出最新的值。这是必须的 - 你并不想要的动画帧外发出的值（除非你真的喜欢jank）。第二个参数是描述当组合来自每个可观察的最新值时要做什么的函数。在这种情况下，唯一重要的值是move值，这是所有返回的值。 与过渡.scan现在你有一个observable从move$每个动画帧发出最新的值，是时候添加线性插值了。.scan()运算符“积累”从可观察到的当前值和下一个值，提供给需要这些值的函数。 这对于我们的线性插值用例是完美的。记住，我们的lerp(start, end)函数有两个参数：start（current）值和end（next）值。 1234const smoothMove$ = animationFrame$ .withLatestFrom(move$, (frame, move) =&gt; move) .scan((current, next) =&gt; lerp(current, next)); // or simplified: .scan(lerp) 现在，您可以订阅smoothMove$代替move$在操作中查看线性插值： 结论RxJS 不是一个动画库，当然，但对于处理随时间变化的值，它的可组合以及声明性的方式是ReactiveX演示动画的核心概念。反应式编程是考虑编程的另类方式，具有许多优点： 它是声明性的，可组合的和不可变的，避免回调地狱，并使你的代码更简洁，可重用和模块化。 它在处理所有类型的异步数据时非常有用，无论是获取数据，通过WebSockets进行通信，监听来自多个源的外部事件，甚至是动画。 “关注的分离” - 您使用Observable和运算符声明性地表示您期望的数据，然后在一个单独的上下文环境中处理.subscribe()，而不会在您的原代码上产生副作用。 有这么多语言的实现了它 - Java，PHP，Python，Ruby，C＃，Swift和其他你可能没有听说过的。 它不是一个框架，它与许多流行的框架（如React，Angular和Vue）可以非常好地融合在一起。 你可以得到行家指点，如果你想要，但ReactiveX从被提出到现在实施了近十年前（2009年），由创意所产生的Conal Elliott和保罗·胡达克 2年前（1997年），在描述功能性反应的动画（惊喜惊喜）。不用说，它经过了足够的测试。 本文探讨了一些有用的部分和RxJS的概念-创建与订阅.fromEvent()和.interval()，对订阅操作.map()和.scan()，多个订阅相结合.merge()和.withLatestFrom()，并与引入调度Rx.Scheduler.animationFrame。有很多其他有用的资源学习RxJS： ReactiveX：RxJS - 官方文档 RxMarbles - 用于可视化观察 Reactive编程的介绍 如果你想进一步深入RxJS动画（和使用更多的CSS变量），请查看我的幻灯片从CSS Dev Conf 2016和我2016年的演讲从JSConf冰岛关于反应式动画与CSS变量。这里有一些使用RxJS创建的动画可能对触发灵感有帮助： 3D数字时钟 心脏app概念 透视使用RxJS拖动]]></content>
      <categories>
        <category>RxJS</category>
      </categories>
      <tags>
        <tag>RxJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过动图简单通俗地了解Flexbox的工作原理]]></title>
    <url>%2F2017%2F03%2F13%2F%E9%80%9A%E8%BF%87%E5%8A%A8%E5%9B%BE%E7%AE%80%E5%8D%95%E9%80%9A%E4%BF%97%E5%9C%B0%E4%BA%86%E8%A7%A3Flexbox%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[本文译自 Scott Domes Flex属性是一个复合属性，而大部分教程中都只设置一个值，但其实它包含了 flex-basis、flex-grow、flex-shrink. 让我们深入了解Flexbox - 以及如何利用它来构建适应性强和漂亮的布局. 属性一： Flex-Basis在上一篇文章中，我们主要把它用于外部容器中。这一次，我们试着把它用在容器内的子元素中。 这是一个很不起眼的属性，但也很直接。 Flex-basis 控制着一个元素的默认大小，在其他 flex 属性应用之前。 在下面的 GIF 看来，它的作用和 width 的作用一样： 是什么让 flex-basis 表现得和 width 一样？事实上，它对应着 flex 的坐标轴。 flex-basis 影响无素在主轴上的大小 让我们看看保持 flex-basis 的值不变，但是改变主轴方向会有什么变化： 注意到，我从手动设置高度变成手动设置宽度。 Flex-basis 影响宽度还是高度取决于 flex-direction 的值。 属性二：Flex Grow现在，我们来点更复杂的。 首先，让我们设置给所有方块设置相同的宽度，120px: 现在，当它加上属性 flex-grow（默认值为0）.这意味着，不允许方块自动充满容器。 没理解？现在给每个方块的 flex-grow 属性设置为 1： 所有方块共同充满了容器的整个宽度，并且是平均分。 flex-grow 属性覆盖了 width 属性。 让人困惑的是 flex-grow 的值到底是什么意思？ flex-grow: 1 意味着什么？ 好吧，下图是给每个方块设置 flex-grow 值为 999 的表现： 这真是。。完全一样。 那是因为 flex-grow 不是一个绝对的值，而是一个相对的值。 重要的不是一个方块 flex-grow 值的本身，而是这个值和其他方块的值的关系。 如果给每个方块设置 flex-grow: 1， 然后调整第3个方块的 flex-grow 属性，可以看到如下变化： 想要真正明白这里发生了什么，让我们快速略过一个简单的数学计算。 每个正方形都以flex-grow为1开始。如果我们将每个正方形的flex-grow相加，则总和为6。因此，容器被分成6个单独的部分。每个正方形增长到可用空间的1/6以填满容器。 当设置第3个方块的flex-grow 为 2， 现在容器被分成7份，因为 flex-grow 属性的值的总和为 1+1+2+1+1+1. 方块3获得 2/7 的宽度，剩下的获得 1/7。 当设置第3个方块为 flex-grow: 3， 容器被分成8份（1+1+3+1+1+1）, 方块3占 3/8, 剩下的占 1/8. 以此类推。 flex-grow是占所有值总和的比例。如果给所有方块设置flex-grow: 4, 方块3设置 flex-grow: 12, 效果和给它们分别设置 1 和 3 是一样的。 最后一点，flex-grow 和 flex-basis 都和主轴对应。我们的方块只会增长宽度，除非设置 flex-direction 为 column. 属性三： Flex Shrinkflex-shrink 和 flex-grow正好相反，决定每个方块可以收缩多少。 它只有在元素必须收缩以适应其容器时才起作用 - 即当容器太小时。 它的主要用途是指定哪些元素要缩小，哪些元素不用缩小。默认情况下，每个方块的 flex-shrink 值为1 - 这意味着它会随着容器的收缩而收缩。 让我们看看它的表现。在下面的GIFS中，正方形的flex-grow为1，因此它们填充了容器，并且flex-shrink为1，因此它们被允许收缩. 现在让我们将方块3的flex-shrink设置为0.它禁止收缩，所以它会增长以适应容器，但它拒绝收缩到其设置的120px宽度以下。 flex-shrink的默认值是1 - 这意味着你的元素会收缩，除非设置为0去禁止它。 同样，flex-shrink 是按比例的。如果一个盒子的flex-shrink为6，其余的flex-shrink为2，一个盒子将以3倍的速度缩减，当空间被压缩。 注意这里说的是：具有3x弹性收缩的方块将比其他方块缩短3倍。这并不意味着它将收缩1/3的宽度。 稍后，我们会深入了解这到底会收缩或增长多少，在此之前，先来看一下最后一个属性，并把所有混在一起。 属性四： Flexflex 是 grow, shrink 以及 basis 的缩写，复合属性。 它的默认值是 0(grow) 1（shrink）auto(basis). 最后一个例子，让我们简化到两个 boxs 这是它们的属性： 123456.square#one &#123; flex: 2 1 300px;&#125;.square#two &#123; flex: 1 2 300px;&#125; 两者都有相同的 flex-basis属性。这意味着如果它们都有足够的空间（容器是600px加上边距和填充空间），它们都将是300px宽度。 但随着容器的增长，Square 1（具有更高的flex-grow）将增长两倍。随着盒子的收缩，Square 2（具有更高的flex-shrink）将缩短两倍。 它是如何增长和收缩的这里有可能会混淆：当Square 1增长时，它不会增长到Square 2的两倍。同样，当Square 2缩小时，它不会缩小到Square 1的一半大小 - 即使比率的收缩率为2比1。 这不是他们的大小 2比1或1比2.这是他们的收缩和增长的速度的比例。 一点数学计算容器的起始大小为640像素。在容器的每一边占用20px的填充后，这留下了足够的空间，两个方块恢复到它们的flex-basis的300px. 当容器设置为430px时，我们丢失了210px的空间。正方形1，flex-shrink:1，失去70px。方形2，flex-shrink: 2，失去140px。 当容器缩小到340px时，我们现在已经失去了300像素的空间。方块1损失100像素，方块2损失200像素. 损失的空间根据它们各自的收缩率（2:1）的比率来分割。 flex-grow同样。当容器增长到940px，我们获得了300px的空间，Square 1获得了额外的200px，Square 2获得了额外的100px。 在上面的GIF中，您可以看到宽度如何根据比率进行调整，增量（Δ）显示与基于flex-basis的差异。]]></content>
      <categories>
        <category>Flexbox</category>
      </categories>
      <tags>
        <tag>Flexbox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js遍历Object对象可枚举属性、不可枚举属性、原型链属性和自身属性]]></title>
    <url>%2F2017%2F01%2F13%2Fjs%E9%81%8D%E5%8E%86Object%E5%8F%AF%E6%9E%9A%E4%B8%BE%E5%B1%9E%E6%80%A7%E3%80%81%E4%B8%8D%E5%8F%AF%E6%9E%9A%E4%B8%BE%E5%B1%9E%E6%80%A7%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%B1%9E%E6%80%A7%E5%92%8C%E8%87%AA%E8%BA%AB%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[利用hasOwnProperty、getOwnPropertyNames、Object.keys、for…in遍历对象的可枚举属性、不可枚举属性、原型链上的属性和自身属性。 首先来看看各种方法的用法及兼容性。 hasOwnPropertyObject.prototype.hasOwnProperty(name) 方法用来判断某个对象是否含有指定的自身属性，它本身是对象原型链上的默认方法。 hasOwnProperty 方法是 ES3 就标准化了，所以不用担心兼容性问题。 但由于 hasOwnProperty 是原型链上的方法，所以有可能被对象的自身方法所屏蔽。如： 123456789101112var foo = &#123; hasOwnProperty: function() &#123; return false; &#125;, bar: 'Here be dragons'&#125;;foo.hasOwnProperty('bar'); // 始终返回 false// 如果担心这种情况，可以直接使用原型链上真正的 hasOwnProperty 方法(&#123;&#125;).hasOwnProperty.call(foo, 'bar'); // trueObject.prototype.hasOwnProperty.call(foo, 'bar'); // true getOwnPropertyNamesObject.getOwnPropertyNames(obj)方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组, 该方法不会获取到原型链上的属性。如： 12345678910111213141516171819// 父类构造函数function ParentClass() &#123;&#125;ParentClass.prototype.inheritedMethod = function() &#123;&#125;;// 继承var ChildClass = Object.create(ParentClass.prototype, &#123; // 不可枚举属性 getFoo: &#123; value: function() &#123; return this.foo; &#125;, enumerable: false &#125;&#125;);// 自身可枚举属性ChildClass.foo = 1;// 再定义一个原型链属性ChildClass.prototype.prototypeMethod = function() &#123;&#125;;console.log(Object.getOwnPropertyNames(my_obj).sort()); // ["foo", "getFoo"] 兼容性到 IE9, es 5标准。 Object.keys()返回该对象的所有可枚举自身属性的属性名。 123//具有随机键排序的数组类对象var an_obj = &#123; 100: 'a', 2: 'b', 7: 'c' &#125;;console.log(Object.keys(an_obj)); // console: ['2', '7', '100'] 这些属性的顺序与手动遍历（如for..in）该对象属性时的一致。 注意：Object.keys 和 getOwnPropertyNames ，在ES5，如果此方法的参数不是一个对象（原始的），那么它会造成 TypeError。在ES6，非对象的参数将被强制转换为一个对象。 12345678Object.keys("foo");Object.getOwnPropertyNames("foo");// TypeError: "foo" is not an object (ES5 code)Object.keys("foo");// ["0", "1", "2"] (ES6 code)Object.getOwnPropertyNames("foo");// ["0", "1", "2", "length"] (ES6 code) 兼容性到 IE9, es 5标准。 for..in手动遍历，可以遍历到自身和原型链上所有可枚举的属性。 只获取自身可枚举属性 直接用 Object.keys() IE9 以下可以通过hasOwnProperty实现： 1234567if (!Object.keys) Object.keys = function(o) &#123; if (o !== Object(o)) throw new TypeError('Object.keys called on a non-object'); var k=[],p; for (p in o) if (Object.prototype.hasOwnProperty.call(o,p)) k.push(p); return k;&#125; 只获取自身不可枚举属性 通过 Object.keys() 排除可枚举属性 12345678910111213141516var target = myObject;var enum_and_nonenum = Object.getOwnPropertyNames(target);// 排除可枚举属性var enum_only = Object.keys(target);var nonenum_only = enum_and_nonenum.filter(function(key) &#123; var indexInEnum = enum_only.indexOf(key); if (indexInEnum == -1) &#123; // not found in enum_only keys mean the key is non-enumerable, // so return true so we keep this in the filter return true; &#125; else &#123; return false; &#125;&#125;);console.log(nonenum_only); 通过propertyIsEnumerable判断，该方法返回Boolean值，不可枚举返回false。 123456789var target = myObject;var enum_and_nonenum = Object.getOwnPropertyNames(target);var enum_only = Object.keys(target);var nonenum_only = enum_and_nonenum.filter(function(key) &#123; // 筛选不可枚举属性 return !target.propertyIsEnumerable(key)&#125;);console.log(nonenum_only); 只获取原型链上的可枚举属性 直接用 for..in 1234var o = Object.getPrototypeOf(targetObj); // 跳过遍历自身属性，直接从原型上开始var k=[],p;for (p in o) if (Object.prototype.hasOwnProperty.call(o,p)) k.push(p);return k; 注意，这样遍历出来的属性也不一定能访问， 因为自身属性可能会屏蔽掉原型上的属性。 只获取原型链上的不可枚举属性比较麻烦，如果使用 getOwnPropertyNames，只能单独获取一层原型链，必须一级一级遍历往上找，而且这也不一定有场景，因为原型链上的方法重名是会被屏蔽的。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>getOwnPropertyNames</tag>
        <tag>hasOwnProperty</tag>
        <tag>Object.keys</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[比较instanceof与isPrototypeOf]]></title>
    <url>%2F2017%2F01%2F12%2F%E6%AF%94%E8%BE%83instanceof%E4%B8%8EisPrototypeof%2F</url>
    <content type="text"><![CDATA[在javascript中，instanceof 和 isPrototypeOf 都可以判断一个原型是否在另一个实例的原型链中，那他们有什么区别呢，为什么说 isPrototypeOf 可以替代 instanceof 。 instanceof 用法123456789101112function Super() &#123; // init code&#125;function Sub() &#123; Super.call(this); // other init code&#125;Sub.prototype = new Super();var sub = new Sub(); 对于上面的代码，用 instanceof 可以像这样确定他们的关系： 1sub instanceof Super; // true isPrototypeOf 用法复用上面的代码，用 isPrototypeOf 可以这样写： 1Super.prototype.isPrototypeOf(sub); // true 区别乍一看，都可以用，但某种情况下是有区别的，例如： 1234567891011var super = &#123; // some super properties&#125;var sub = Object.create(super);sub.someProp = 5;var sub = Object.create(sub);console.log(super.isPrototypeOf(sub)); // trueconsole.log(sub instanceof super); // TypeError 这时候 super 并不是构造函数，无法使用 instanceof, 只能使用 isPrototypeOf. 结论结论就是 isPrototypeOf 能使用的场景更广，完全可以替代 instanceof， 只是写起来没那么简洁。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>instanceof</tag>
        <tag>isPrototypeOf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript通过Vibration API实现手机振动反馈提高用户体验]]></title>
    <url>%2F2017%2F01%2F10%2Fjavascript%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E6%8C%AF%E5%8A%A8%E5%8F%8D%E9%A6%88%E6%8F%90%E9%AB%98%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[目前大多数的移动设备均具备硬件能力支持振动，让软件代码通过使设备摇晃来向用户提供物理反馈。Vibration API 为 Web应用程序提供访问此硬件的能力。如果设备不支持，则不会产生任何效果。 振动描述振动被抽象成【开-关】脉冲的模式，且可以具有变化的长度。参数可以是单个整数，表示持续振动的毫秒数 (ms)；或可由多个整数组成的数组，达到振动和暂停循环的效果。只要单一 window.navigator.vibrate() 函式即可控制振动。 单次振动你可指定单一数值，或用只有一个数值成员的数组，让设备振动 1 次： 12window.navigator.vibrate(200);window.navigator.vibrate([200]); 以上两个例子都可以使设备振动 200 ms. 多次振动一个数组的值描述了装置振动与不振动的交替时间段。数组中的每个值都转换为整数，然后交替解释为设备应该振动的毫秒数和不振动的毫秒数。例如: 1window.navigator.vibrate([200, 100, 200]); 这会使设备振动200 ms，然后暂停100 ms，然后再次振动设备200 ms。 您可以根据需要设定多个振动/暂停对，数组的值可以是偶数或奇数个； 值得注意的是，由于振动在每个振动周期结束时自动停止，因此您不必提供最后一个值去暂停，换句话说，数组长度只需要设置奇数个。 停止振动当调用 window.navigator.vibrate() 的参数为「0」、空白数组，或数组全为「0」时，即可取消目前进行中的振动。 持续振动一些基于setInterval和clearInterval操作将允许您创建持续的振动： 123456789101112131415161718192021var vibrateInterval;// Starts vibration at passed in levelfunction startVibrate(duration) &#123; navigator.vibrate(duration);&#125;// Stops vibrationfunction stopVibrate() &#123; // Clear interval and stop persistent vibrating if(vibrateInterval) clearInterval(vibrateInterval); navigator.vibrate(0);&#125;// Start persistent vibration at given duration and interval// Assumes a number value is givenfunction startPeristentVibrate(duration, interval) &#123; vibrateInterval = setInterval(function() &#123; startVibrate(duration); &#125;, interval);&#125; 当然上面的代码片段没有考虑到振动参数为数组情况; 基于阵列的持久性振动将需要计算数组项的和，并基于该数量创建周期（可能具有额外的延迟）。 生成振动节奏可以通过vibe.js tool这个工具来生成你需要的振动频率，然后复制它到你的代码里。 lib我写了一个小lib，方便使用vibrate.js demo: DEMO 译自： MDN Vibration API]]></content>
      <categories>
        <category>Vibration</category>
        <category>html5</category>
      </categories>
      <tags>
        <tag>Vibration</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由lodash引出数组Array的slice方法性能探究]]></title>
    <url>%2F2016%2F11%2F25%2F%E7%94%B1lodash%E5%BC%95%E5%87%BA%E6%95%B0%E7%BB%84Array%E7%9A%84slice%E6%96%B9%E6%B3%95%E6%80%A7%E8%83%BD%E6%8E%A2%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[lodash 源码中，发现数组截取操作并没有直接使用array的slice方法，而是写了个 baseSlice 方法，更重要的是 baseSlice 方法里，也并没有使用 slice 方法，而是使用循环索引的方式去实现。这让我陷入思考，难道原生Array的slice方法还不如循环快？ lodash 源码如下： 1234567891011121314151617181920function baseSlice(array, start, end) &#123; var index = -1, length = array.length; if (start &lt; 0) &#123; start = -start &gt; length ? 0 : (length + start); &#125; end = end &gt; length ? length : end; if (end &lt; 0) &#123; end += length; &#125; length = start &gt; end ? 0 : ((end - start) &gt;&gt;&gt; 0); start &gt;&gt;&gt;= 0; var result = Array(length); while (++index &lt; length) &#123; result[index] = array[index + start]; &#125; return result;&#125; 于是就开始写代码比较： 操作长度为100的数组，执行10000次： 1234567891011121314151617181920212223242526272829303132333435var baseArray = [];var i = -1;while (++ i &lt; 100) &#123; // 定义一个10000长度的数组以供使用 baseArray[i] = i;&#125;console.time('slice with no args');for (var i = 0; i &lt; 10000; i++)&#123; baseArray.slice();&#125;console.timeEnd('slice with no args');console.time('slice with args');for (var i = 0; i &lt; 10000; i++)&#123; baseArray.slice(20, 40);&#125;console.timeEnd('slice with args');console.time('index');for (var i = 0; i &lt; 10000; i++)&#123; var result = Array(100); var index = -1; var length = baseArray.length; while (++index &lt; length) &#123; result[index] = baseArray[index]; &#125;&#125;console.timeEnd('index');console.time('index with no init array');for (var i = 0; i &lt; 10000; i++)&#123; var result = []; var index = -1; var length = baseArray.length; while (++index &lt; 20) &#123; result[index] = baseArray[index]; &#125;&#125;console.timeEnd('index with no init array'); 对比结果： 123456789101112131415// chrome 版本 54.0.2840.98 (64-bit)slice with no args: 93.3msslice with args: 175msindex: 365msindex with no init array: 546ms// safari 版本 9.0.2 (11601.3.9)slice with no args: 122.152msslice with args: 117.181msindex: 60076.301msindex with no init array: 62055.406ms//firefox 50.0slice with no args: 462.07msslice with args: 442.25msindex: 194206.08msindex with no init array: 184714.59ms 由于mac ox无法测试IE, 可以看出，chrome总体要比safafi、firefox快很多； slice方法上，safari和chrome差不多， chrome下slice有参数比无参数慢； 新建数组Array()和 []性能差不多； 这么看来，那用原生 slice 明显会更好，为什么 lodash 要用循环索引呢？难道是因为一般应用数组都不会这么大，那改成长度为100的数组进行操作； 123456789101112131415// chromeslice with no args: 6msslice with args: 4.12msindex: 5.82msindex with no init array: 7.96ms// safarislice with no args: 9.158msslice with args: 8.432msindex: 640.311msindex with no init array: 643.174ms//firefoxslice with no args: 17.56msslice with args: 17.53msindex: 2174.15msindex with no init array: 2198.15ms 发现结论并没有改变。 然后就向lodash提了question, 回复是： The perf wins of Array#slice vs. baseSlice depends on the size of the array. That is a minor point though as the perf of that method is not likely to be an issue. The reason we use baseSlice is because we treat arrays as dense while Array#slice will respect sparse arrays. 大概意思是，他觉得性能没有太大的差别，Array#slice和baseSlice性能强弱取决于数组的大小。这里采用baseSlice是因为他们要视所有为密集数据，而Array#slice会处理稀疏数组。 然后就有下面的测试： 使用 Array#slice和baseSlice 分别截取数组其中一段，循环1000000次： 12345678910111213141516171819var baseArray = [];var i = -1;while (++ i &lt; 100000) &#123; // 定义一个10000长度的数组以供使用,这里数组长度并不影响性能，性能影响主要在于截取的长度。 baseArray[i] = i;&#125;console.time('slice with args');for (var i = 0; i &lt; 1000000; i++)&#123; baseArray.slice(0, 20);&#125;console.timeEnd('slice with args');console.time('index');for (var i = 0; i &lt; 1000000; i++)&#123; var result = Array(20); var index = -1; while (++index &lt; 20) &#123; result[index] = baseArray[index]; &#125;&#125;console.timeEnd('index'); 不同截取长度在chrome下的效果： 123456789// 截取长度 20slice with args: 110msindex: 78.9ms// 截取长度 30slice with args: 114msindex: 112ms// 截取长度 30slice with args: 132msindex: 146ms 由此看出，截取长度为30左右时，Array#slice和loop方式性能基本一样，而 Array#slice 基本不受截取长度的影响。 所以结论是，当长度为30以下时，lodash的方法是比较高效的，当然，这影响微乎其微。像_.chunk方法，一般场景分组都不会太长。 疑惑是，对我的回复的后半句我没怎么看懂，密集数据和稀疏数据对这有什么影响呢？]]></content>
      <categories>
        <category>lodash</category>
        <category>array</category>
        <category>slice</category>
      </categories>
      <tags>
        <tag>lodash</tag>
        <tag>array</tag>
        <tag>slice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Debounce-and-Throttle-的可視化解釋]]></title>
    <url>%2F2016%2F11%2F17%2FDebounce-and-Throttle-%E7%9A%84%E5%8F%AF%E8%A6%96%E5%8C%96%E8%A7%A3%E9%87%8B%2F</url>
    <content type="text"><![CDATA[Debounce 和 Throttle是两个概念，我们可以在JavaScript中使用，以提高我们对执行功能的控制，在事件处理的时候特别有用。 比喻这两种技术都回答同样的问题“一个功能可以随着时间被推移多久？” Debounce：把它看成是“多个分组事件之一”。试想一下，你回家，再进入电梯，门正在关闭……，突然你的邻居出现在大厅，并试图跳上电梯。要有礼貌！并打开大门，他说：你等等，让我一起上。相同的情况下，可以与第三人再次发生，等等…这可能会延缓出发几分钟。 Throttle：把它看成是一个阀，它规定了执行的流程。我们可以判断函数可以在一定时间内被调用的最大次数。因此，再用电梯比喻..你有足够的礼貌，持续10秒等人，但一旦时间到了，你一定要走！ 无 Debounce 或 Throttle 事件处理程序就像一次只能一个人用的电梯：没有那么高效。 我希望这个坏比喻对你有所帮助，但有时言语并不会对掌握这些概念有多大的帮助，所以我创建了一个演示去理解 Debounce 和 Throttle 概念，并把它们应用到mousemove事件。 123456789function elevator_departure(name)&#123; alert(name + " was the last one. Nobody else? Let's go then");&#125;;var debounced_elevator_departure = $.debounce(200, false, elevator_departure);debounced_elevator_departure('John');debounced_elevator_departure('Mike');debounced_elevator_departure('Peter');// You will see *only* one message, "Peter was the last one. Nobody else? Let's go then"; 我发现这3个人在JavaScript中都通过debounce和throttle执行了。我真的建议你先读一下 Ben Alman&#39;s 的文章，以便更好地理解 debounce 和 throttle. underscore 和 lodash 有不同的实现方式，但参数都是一样的（除了 throttle没有 trailing）. Underscore.js by Jeremy Ashkenas * Lodash.js by John-David Dalton * jQuery Plugin by Ben Alman. 演示这里是视觉演示: 这是截图： 注意： 这个的源代码演示在GitHub上托管。 如果你看到动画在浏览器中并不流畅，请在一个单独的页面打开演示，或者尝试在Chrome中。 我通过在鼠标区域 tapping来去在Android环境下演示它 每个单元代表约30毫秒，但JS是单线程的，所以浏览器是不是准确。这个演示并不是想成为一个最佳实践，只是为了更好地去理解概念。 当你做了setTimeout，时间间隔可能不同，在每个浏览器在4ms和15ms的之间（尼古拉斯Zakas的文章），甚至是setTimeout(fn,0)至少需要4毫秒。在另一方面，时间为1毫秒为最小单位的。 在mousemove第一行中的事件也有做节流（80毫秒）。这对理解演示有所帮助。 要获得 trailing选项$.throttle，你需要传递false。 不要忘了，这一切都是builder，他们返回一个函数，所以你只需要执行一次。 应用场景debounce 案例用它减少执行频繁的事件。例子： 当将要处理的textarea的快速打字：你不想执行处理函数，直到用户停止输入再来处理文本。 当数据保存到通过AJAX服务器：你不想每秒调用非常缓慢的邮件服务器 throttle 案例和debounce 一样，但如果想每隔一段时间必须执行事件，可以使用它： 假设用户不停地快速输入30秒，可能你会想每5秒执行一次函数； 一些对性能有影响的事件但又必须处理：scroll, mouseweel, mousemove。一个简单的鼠标滚轮运动可以在一秒钟内触发几十个事件。 本文翻译自 Debounce and Throttle: a visual explanation ========= update on 11-21 ========= exampledebounce123456789101112131415161718192021var validation = _.debounce(function () &#123; ... // 校验输入，逻辑可能还会有点复杂&#125;, 250)jQuery('input').keyup(validation) // 输入完成或停顿250ms后才去执行校验，如果不停输入10s，则10s内都不会触发/** * debounce第三个参数为可选参数， * leading为true时，则在事件开始时首先执行一次， 默认值为 false； * trailing为true时，则在结束时触发, 默认值为 true； * maxWait设置每隔多长时间必须触发； */function foo () &#123; ... &#125;jQuery('input').on('keyup', _.debounce(foo, 300, &#123; 'leading': true, // 注意： 执行的前提是定时器为undefined 'trailing': false, 'maxWait': 1000&#125;));// debounce还可以被取消jQuery('button').on('click', function() &#123; validation.cancel();&#125;); throttle123456789101112function mousemove () &#123; ...&#125;jQuery('#div').on('mousemove', _.throttle(mousemove, 100)) // 每100ms必须触发一次// mousemove会在定时器开始时触发, 但5分钟内不会有第二次jQuery('#div').on('mousemove', _.throttle(mousemove, 300000, &#123; 'leading': true, // 定时器前沿触发，默认值为true 'trailing': false // 定时器后沿触发，默认值为true&#125;));// throttle 同样可以被取消jQuery(window).on('popstate', throttled.cancel);]]></content>
      <categories>
        <category>函数节流</category>
      </categories>
      <tags>
        <tag>debounce</tag>
        <tag>throttle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 npm shrinkwrap 来管理项目依赖]]></title>
    <url>%2F2016%2F10%2F20%2F%E4%BD%BF%E7%94%A8-npm-shrinkwrap-%E6%9D%A5%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%2F</url>
    <content type="text"><![CDATA[管理依赖是一个复杂软件开发过程中必定会遇到的问题。 在Node.js项目开发的时候，我们也经常需要安装和升级对应的依赖。虽然 npm 以及语意化的版本号 (semantic versioning, semver) 让开发过程中依赖的获取和升级变得非常容易， 但不严格的版本号限制，也带来了版本号的不确定性。主要的问题可能有三个： npm 建议使用 semver 的应用程序版本，但这也完全依赖第三方包遵守这一规则。如果你依赖于的包不遵循 semver ，或者依赖的包的新版本有重大更改（而你使用了 ^ 的宽泛版本安装），这潜在可能是会导致问题的。 另一个问题的出现是由于 npm 安装依赖的机制。npm 的安装包是有层次结构的，手动控制要安装的软件包的版本号可以实现，但是你只能在 package.json 使用精确的版本号控制你的直接依赖包，但那些多层以上的依赖就没办法控制了；一个第三方包不严谨的版本依赖生命可能破坏你的依赖管理。 在开发阶段执行得到的版本，和后续部署时得到的可能是不一致的，更不可控的是，你依赖的第三方包也有这样的情况会导致潜在的上线风险。 如果要控制上线的风险，我们就必需要解决这个问题，这时候，就需要使用 npm shrinkwrap 这个命令来解决问题。 npm shrinkwrapnpm shrinkwrap 可以按照当前项目 node_modules 目录内的安装包情况生成稳定的版本号描述。 比方说，有一个包 A 1234567&#123; "name": "A", "version": "0.1.0", "dependencies": &#123; "B": "&lt;0.1.0" &#125;&#125; 还有一个包 B 1234567&#123; "name": "B", "version": "0.0.1", "dependencies": &#123; "C": "&lt;0.1.0" &#125;&#125; 以及包 C 1234&#123; "name": "C", "version": "0.0.1"&#125; 你的项目只依赖于 A，于是 npm install 会得到这样的目录结构 123A@0.1.0 `-- B@0.0.1 `-- C@0.0.1 这时候，B@0.0.2 发布了，这时候在一个新的环境下执行 npm install 将得到 123A@0.1.0 `-- B@0.0.2 `-- C@0.0.1 这时候两次安装得到的版本号就不一致了。而通过 shrinkwrap 命令，我们可以保证在所有环境下安装得到稳定的结果。 在项目引入新包的时候，或者 A 的开发者执行一下 npm shrinkwrap，可以在项目根目录得到一个 npm-shrinkwrap.json 文件。 这个文件内容如下 1234567891011121314&#123; "name": "A", "version": "0.1.0", "dependencies": &#123; "B": &#123; "version": "0.0.1", "dependencies": &#123; "C": &#123; "version": "0.0.1" &#125; &#125; &#125; &#125;&#125; shrinkwrap 命令根据目前安装在node_modules的文件情况锁定依赖版本。在项目中执行 npm install 的时候，npm 会检查在根目录下有没有 npm-shrinkwrap.json 文件，如果 shrinkwrap 文件存在的话，npm 会使用它（而不是 package.json）来确定安装的各个包的版本号信息。 这样一来，在安装时候确定的所有版本信息会稳定的固化在 shrinkwrap 里。无论是A，B 和 C中的版本如何变化，或者它们的 package.json 文件如何修改，你始终能保证，在你项目中执行 npm install 的到的版本号时稳定的。 在开发中使用 shrinkwrap在开发过程中，引入一个新包的流程如下 npm install PACKAGE_NAME@VERSION --save 获取特定版本的包 测试功能 测试功能正常后，执行 npm shrinkwrap 把依赖写入 shrinkwrap 文件 在代码仓库中提交 shrinkwrap / package.json描述 升级一个包的流程应该是这样 npm outdated 获取项目所有依赖的更新信息 npm install PACKAGE_NAME@VERSION --save 获取特定版本的包 测试功能 测试功能正常后，执行 npm shrinkwrap把依赖写入 shrinkwrap 文件 在代码仓库中提交 shrinkwrap / package.json描述 删除一个包的流程如下 npm uninstall PACKAGE_NAME --save 删除这个包 测试功能 测试功能正常后，执行 npm shrinkwrap 把更新的依赖写入 shrinkwrap 文件 在代码仓库中提交 shrinkwrap / package.json 描述 比一般的安装多了一步手工生成 shrinkwrap 文件。在实际工作中，有时候我们会忘记这一步，导致上线时候没有获取到依赖包的特定版本。 本文转自使用 npm shrinkwrap 来管理项目依赖]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>shrinkwrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Git-Hooks进行自动部署,让提交发布自动化]]></title>
    <url>%2F2016%2F08%2F11%2F%E7%94%A8Git-Hooks%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2-%E8%AE%A9%E6%8F%90%E4%BA%A4%E5%8F%91%E5%B8%83%E8%87%AA%E5%8A%A8%E5%8C%96%2F</url>
    <content type="text"><![CDATA[之前了解的自动化部署都是jekins这样集成化的成熟的工具。最近因为有朋友提交代码时，不想登陆服务器拉取代码，才了解到 git hooks。看来还是git使用不到位。之前一直都是本地开发并提交代码，测试时，人工登陆测试服务器去拉取最新代码。 网上资料还是比较多的，最后在本机测试是成功了的。 主要选要明白几个关键点： git init –bare post-receive 文件 SSH 认证 这几个都比较容易找到资料。 git init –bare和 git init 不一样的是，git init --bare并不存储实际代码，仓库文件夹不会看到任何项目代码，反而生成了一些 .git之外的文件夹，其中 hooks文件夹就是存放git命令操作后需要执行的脚本。 需要新建两个文件夹，一个执行git init --bare作为远端仓库，一个执行git init作为服务器项目目录。 本地开发目录和服务器项目目录的remote都要指向 服务器的远端仓库。 post-receive 文件post-receive 文件是git push 之后，执行的脚本文件，自动部署的脚本代码就写在这里。 如： 123456789101112#!/bin/shunset GIT_DIRecho "远程开始更新"NowPath=`pwd`echo $NowPathDeployPath="../deploy"cd $DeployPathgit pull origin masterecho "远程更新完毕"cd $NowPathexit 0 这里有一点比较容易出问题的就是路径，最好还是使用绝对路径。 脚本里还可以加入任何想执行的脚本，比如打包编译。 不过要注意使用 chmod +x post-receive 改变一下权限，服务器端的配置就基本完成了。 SSH认证这个在 mac os x 和 linux都没有问题，我用别人的windows配置的时候经常都会出现认证失败，就算认证成功了，也无法执行脚本，对这个还是不太熟悉。我猜可能是 cmd 的问题，ssh 登陆后还遇到过乱码。 这些都配置好之后，本地开发只需要提交代码，服务器就可以预览最新代码了。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack-sourcemap选项应该选哪个]]></title>
    <url>%2F2016%2F08%2F08%2Fwebpack-sourcemap%E9%80%89%E9%A1%B9%E5%BA%94%E8%AF%A5%E9%80%89%E5%93%AA%E4%B8%AA%2F</url>
    <content type="text"><![CDATA[使用 webpack 也有一段时间了，但是每次看到别的项目配置，还是会去浏览一遍。这次刚好看到一个 devtool: &#39;#eval-source-map&#39;，就有些好奇，之前都是默认使用 #source-map 并没有过多去注意它。google一下，发现这个 devtool 选项还不少，那我们到底选哪个呢，它们有哪些区别。 先来看看官方文档的相关描述： 有构建速度，重新构建速度，打包速度，来源 这几项的展示。 然后可以看看这一篇文章，对这几个选项描述得比较详细： https://chemzqm.me/webpack-sourcemap 摘出主要部分： eval 文档上解释的很明白，每个模块都封装到 eval 包裹起来，并在后面添加 //# sourceURL source-map 这是最原始的 source-map 实现方式，其实现是打包代码同时创建一个新的 sourcemap 文件， 并在打包文件的末尾添加 //# sourceURL 注释行告诉 JS 引擎文件在哪儿 hidden-source-map 文档上也说了，就是 soucremap 但没注释，没注释怎么找文件呢？貌似只能靠后缀，譬如 xxx/bundle.js 文件，某些引擎会尝试去找 xxx/bundle.js.map inline-source-map 为每一个文件添加 sourcemap 的 DataUrl，注意这里的文件是打包前的每一个文件而不是最后打包出来的，同时这个 DataUrl 是包含一个文件完整 souremap 信息的 Base64 格式化后的字符串，而不是一个 url。 eval-source-map 这个就是把 eval 的 sourceURL 换成了完整 souremap 信息的 DataUrl cheap-source-map 不包含列信息，不包含 loader 的 sourcemap，（譬如 babel 的 sourcemap） cheap-module-source-map 不包含列信息，同时 loader 的 sourcemap 也被简化为只包含对应行的。最终的 sourcemap 只有一份，它是 webpack 对 loader 生成的 sourcemap 进行简化，然后再次生成的。 webpack 不仅支持这 7 种，而且它们还是可以任意组合的，就如文档所说，你可以设置 souremap 选项为 cheap-module-inline-source-map。 结合官方的列表比较和引用的这篇文章的介绍，就比较容易选择合适的选项了。建议开发时使用 #cheap-module-eval-source-map，测试环境或线上有需要的话使用 #cheap-module-source-map]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用ApplicationCache离线缓存做一个h5离线应用]]></title>
    <url>%2F2016%2F06%2F30%2F%E4%BD%BF%E7%94%A8ApplicationCache%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98%E5%81%9A%E4%B8%80%E4%B8%AAh5%E7%A6%BB%E7%BA%BF%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[原生app可以离线操作，在以前是相对web app的优势，web必须联网才能刷新使用。虽然所有浏览器都有缓存机制，但它们并不一定总能起到预期的作用。HTML5 使用 ApplicationCache 接口解决了由离线带来的部分难题。即使用户在离线状态下按了刷新按钮，您的应用也会正常加载和运行。 使用缓存接口可为您的应用带来以下三个优势： 离线浏览 - 用户可在离线时浏览您的完整网站 速度 - 缓存资源为本地资源，因此加载速度较快。 服务器负载更少 - 浏览器只会从发生了更改的服务器下载资源。 引用清单文件manifest属性要启用某个应用的应用缓存，请在文档的 html 标记中添加 manifest 属性： 1234&lt;!DOCTYPE html&gt;&lt;html manifest="app.manifest"&gt; ...&lt;/html&gt; 您应在要缓存的网络应用的每个页面上都添加 manifest 属性。如果网页不包含 manifest 属性，浏览器就不会缓存该网页（除非清单文件中明确列出了该属性）。这就意味着用户浏览的每个包含 manifest 的网页都会隐式添加到应用缓存。因此，您无需在清单中列出每个网页。 manifest 属性可指向绝对网址或相对路径，但绝对网址必须与相应的网络应用同源。 清单文件格式与 MIME 类型设置清单文件可使用任何文件扩展名，但必须以正确的 text/cache-manifest MIME 类型提供。 下面是几件网络服务的配置例子： Apache: 新建或者编辑现有的 .htaccess 文件，在里面加上一行 1AddType text/cache-manifest .manifest Nginx: 修改 mime.types 文件，在里面增加 manifest 文件的映射 1text/cache-manifest manifest Tomcat： 修改 web.xml 文件，在里面增加 1234&lt;mime-mapping&gt; &lt;extension&gt;manifest&lt;/extension&gt; &lt;mime-type&gt;text/cache-manifest&lt;/mime-type&gt; &lt;/mime-mapping&gt; 清单文件结构基本的清单格式： 12345CACHE MANIFESTindex.htmlstylesheet.cssimages/logo.pngscripts/main.js 您需要注意以下几点： CACHE MANIFEST 字符串应在第一行，且必不可少。 网站的缓存数据量不得超过 5 MB。不过，如果您要编写的是针对 Chrome 网上应用店的应用，可使用 unlimitedStorage 取消该限制。 如果清单文件或其中指定的资源无法下载，就无法进行整个缓存更新进程。在这种情况下，浏览器将继续使用原应用缓存。 完整的清单格式： 1234567891011121314151617181920212223CACHE MANIFEST# daksfljs3kl23j3k43 hash 以便做版本控制# 默认部分，显式缓存这些文件CACHE:/favicon.icoindex.htmlstylesheet.cssimages/logo.pngscripts/main.js# 此部分下列出的文件是需要连接到服务器的白名单资源。无论用户是否处于离线状态，对这些资源的所有请求都会绕过缓存。NETWORK:login.php/myapihttp://api.twitter.com# 此部分是可选的，用于指定无法访问资源时的后备网页。其中第一个 URI 代表资源，第二个代表后备网页。两个 URI 必须相关，并且必须与清单文件同源。# offline.jpg will be served in place of all images in images/large/# offline.html will be served in place of all other .html filesFALLBACK:images/large/ images/offline.jpg*.html /offline.html 应用缓存只在其清单文件发生更改时才会更新。例如，如果您修改了图片资源或更改了 JavaScript 函数，这些更改不会重新缓存。您必须修改清单文件本身才能让浏览器刷新缓存文件。 这些部分可按任意顺序排列，且每个部分均可在同一清单中重复出现; 可使用通配符。 请注意： HTTP 缓存标头以及对通过 SSL 提供的网页设置的缓存限制将被替换为缓存清单。因此，通过 https 提供的网页可实现离线运行。chrome 未来将会禁止非 https 网页使用 ApplicationCache 功能（updated 2016-06-30） 更新缓存应用在离线后将保持缓存状态，除非发生以下某种情况： 用户清除了浏览器对您网站的数据存储。 清单文件经过修改。请注意：更新清单中列出的某个文件并不意味着浏览器会重新缓存该资源。清单文件本身必须进行更改。 应用缓存通过编程方式进行更新。 缓存状态window.applicationCache 对象是对浏览器的应用缓存的编程访问方式。其 status 属性可用于查看缓存的当前状态： 12345678910111213141516171819202122232425var appCache = window.applicationCache;switch (appCache.status) &#123; case appCache.UNCACHED: // UNCACHED == 0 return 'UNCACHED'; break; case appCache.IDLE: // IDLE == 1 return 'IDLE'; break; case appCache.CHECKING: // CHECKING == 2 return 'CHECKING'; break; case appCache.DOWNLOADING: // DOWNLOADING == 3 return 'DOWNLOADING'; break; case appCache.UPDATEREADY: // UPDATEREADY == 4 return 'UPDATEREADY'; break; case appCache.OBSOLETE: // OBSOLETE == 5 return 'OBSOLETE'; break; default: return 'UKNOWN CACHE STATUS'; break;&#125;; 用 js 调用 applicationCache.update() 将尝试更新用户的缓存（前提是已更改清单文件）。最后，当 applicationCache.status 处于 UPDATEREADY 状态时，调用 applicationCache.swapCache() 即可将原缓存换成新缓存。 123456789var appCache = window.applicationCache;appCache.update(); // Attempt to update the user's cache....if (appCache.status == window.applicationCache.UPDATEREADY) &#123; appCache.swapCache(); // The fetch was successful, swap in the new cache.&#125; 请注意：以这种方式使用 update() 和 swapCache() 不会向用户提供更新的资源。此流程只是让浏览器检查是否有新的清单、下载指定的更新内容以及重新填充应用缓存。因此，还需要对网页进行两次重新加载才能向用户提供新的内容，其中第一次是获得新的应用缓存，第二次是刷新网页内容。 好消息是，您可以避免重新加载两次的麻烦。要使用户更新到最新版网站，可设置监听器，以监听网页加载时的 updateready 事件： 1234567891011121314151617// Check if a new cache is available on page load.window.addEventListener('load', function(e) &#123; window.applicationCache.addEventListener('updateready', function(e) &#123; if (window.applicationCache.status == window.applicationCache.UPDATEREADY) &#123; // Browser downloaded a new app cache. // Swap it in and reload the page to get the new hotness. window.applicationCache.swapCache(); if (confirm('A new version of this site is available. Load it?')) &#123; window.location.reload(); &#125; &#125; else &#123; // Manifest didn't changed. Nothing new to server. &#125; &#125;, false);&#125;, false); applicationCache 事件事件会用于监听缓存的状态。浏览器会对下载进度、应用缓存更新和错误状态等情况触发相应事件。以下代码段为每种缓存事件类型设置了事件监听器： 12345678910111213141516171819202122232425262728293031323334var appCache = window.applicationCache;unction handleCacheEvent(e) &#123; //...&#125;function handleCacheError(e) &#123; alert('Error: Cache failed to update!');&#125;;// Fired after the first cache of the manifest.appCache.addEventListener('cached', handleCacheEvent, false);// Checking for an update. Always the first event fired in the sequence.appCache.addEventListener('checking', handleCacheEvent, false);// An update was found. The browser is fetching resources.appCache.addEventListener('downloading', handleCacheEvent, false);// The manifest returns 404 or 410, the download failed,// or the manifest changed while the download was in progress.appCache.addEventListener('error', handleCacheError, false);// Fired after the first download of the manifest.appCache.addEventListener('noupdate', handleCacheEvent, false);// Fired if the manifest file returns a 404 or 410.// This results in the application cache being deleted.appCache.addEventListener('obsolete', handleCacheEvent, false);// Fired for each resource listed in the manifest as it is being fetched.appCache.addEventListener('progress', handleCacheEvent, false);// Fired when the manifest resources have been newly redownloaded.appCache.addEventListener('updateready', handleCacheEvent, false); 如果清单文件或其中指定的资源无法下载，整个更新都将失败。在这种情况下，浏览器将继续使用原应用缓存。 原文： 应用缓存初级使用指南 html标准]]></content>
      <categories>
        <category>ApplicationCache</category>
        <category>html5</category>
      </categories>
      <tags>
        <tag>ApplicationCache</tag>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正确检测Javascript数据类型]]></title>
    <url>%2F2016%2F06%2F08%2F%E6%AD%A3%E7%A1%AE%E6%A3%80%E6%B5%8BJavascript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[typeof对于任何变量来说，使用typeof 总是以字符串形式返回以下6种类型之一： number string boolean object function undefined 要注意 null 使用 typeof 检测时返回的是 ‘object’ 对于 null 可以使用 123function type(o) &#123; return (o === null) ? 'null' : typeof(o)&#125; constructor(构造函数属性值)使用 constructor 属性可以判断绝大部分数据的类型。 123456var a = 1; a.constructor // numbervar a = &#123;&#125;; a.constructor // objectvar a = []; a.constructor // arrayvar a = true; a.constructor // booleanvar a = 'true'; a.constructor // stringvar a = function aaa()&#123;&#125;; a.constructor // function 但是对于 undefined 和 null 特殊值，不能能使用 constructor,会直接抛出异常。可以先转换布尔值，如果为 true，则说明不是 undefined 和null , 再调用 constructor属性 123function type(o) &#123; return !o ? o : (o).constructor&#125; Object.prototype.toString使用 toString() 方法检测对象类型是最安全、最准确的。它返回的字符串形式如下 [object class], 其中， object表示对象的通用类型，class表示对象的内部类型。 但是，要获取对象class值的唯一方法是必须调用 Object 对象定义的默认 toString() 方法，因为不同对象都会预定义自己的 toString() 方法，所以不能直接调用对象的 toString() 方法。 var a = new Date() a.toString() // 当前的UTC时间字符串 12var a = new Date()Object.prototype.toString.apply(a) 完善的检测方法 12345678910111213141516// 返回值有： 'undefined', 'null', 'number', 'boolean', 'object', 'function', 'regexp', 'string', 'array', 'date', 'error'function typeOf(o) &#123; var _toString = Object.prototype.toString; var _type = &#123; 'undefined': 'undefined', 'number': 'number', 'boolean': 'boolean', 'string': 'string', '[object Function]': 'function', '[object RegExp]': 'regexp', '[object Array]': 'array', '[object Date]': 'date', '[object Error]': 'error' &#125; return _type[typeof o] || _type[_toString.call(o)] || (o ? 'object' : 'null')&#125;]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git小记]]></title>
    <url>%2F2016%2F05%2F16%2Fgit%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[有一些不太常用的git命令记录下 git amend当一些更改已提交，却发现漏提交了一部分文件，这时就可以用这个命令，可以把漏的部分追加到上一次提交 12git add forgotten_file.rbgit commit ––amend reset soft刚刚提交，却又发现刚才的代码还有bug，想再次修改后再提交 1git reset ––soft HEAD^ 注意与 git reset --hard HEAD^ 不同的是，--soft并不同把上一次提交的代码删除，只是把它变成未提交的状态，而--hard却会完全撤消上一次提交的代码。 git blame当你想查出，一个文件里，每一行代码是谁编辑的，可以使用这个命令 1git blame robin.md git checkout tags/v1.0当分支名和标签名相同时，需要这样写 branch_at当你想从某一历史版本中开一个分支，而不是最新的版本中开分支，可以这样写： 1git branch test_branch eadnadk213dsafdsafkl234j32ll34l2l rebase当远程mater分支已更改， 本地又基于旧版本的master进行的提交，可以重新指定基于远程master，之后再提交，避免冲突时把远程的代码merge 掉： 12git rebase origin/master mastergit push origin master git reflogreflog是git用来记录引用变化的一种机制，比如记录分支的变化或者是HEAD引用的变化。可以用来查找操作记录以及恢复数据 git submodule add添加外部项目为子模块 git rebase -i]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pm2一个带有负载均衡功能的Node应用的进程管理器]]></title>
    <url>%2F2016%2F05%2F04%2Fpm2%E4%B8%80%E4%B8%AA%E5%B8%A6%E6%9C%89%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8A%9F%E8%83%BD%E7%9A%84Node%E5%BA%94%E7%94%A8%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[PM2是一个提供了内置的负载均衡的Node.js应用程序进程管理器。它可以让你保持应用程序永远在线，无需停机地重启应用，也有助于系统管理员工作。 安装 PM21$ npm install pm2 -g 启动应用1$ pm2 start app.js 这样，应用就已经在后台启动，并被监测保持在线。 模块系统PM2 内嵌一个简单强大的模块系统，可以直接像下面这样安装模块 1$ pm2 install &lt;module_name&gt; pm2-logrotate 日志管理及分割模块 pm2-webshell 强大的浏览器模拟终端 pm2-auto-pull 持续集成，自动拉取代码 更新PM21234# Install latest pm2 version$ npm install pm2 -g# Save process list, exit old PM2 &amp; restore all processes$ pm2 update 主要特性命令概览12345678910111213141516171819202122232425262728293031323334353637383940$ npm install pm2 -g # Install PM2$ pm2 start app.js # Start, Daemonize and auto restart application$ pm2 start app.js -i 4 # Start 4 instances of application in cluster mode # it will load balance network queries to each app$ pm2 start app.js --name="api" # Start application and name it "api"$ pm2 start app.js --watch # Restart application on file change$ pm2 start script.sh # Start bash script$ pm2 list # List all processes started with PM2$ pm2 monit # Display memory and cpu usage of each app$ pm2 show [app-name] # Show all informations about application$ pm2 logs # Display logs of all apps$ pm2 logs [app-name] # Display logs for a specific app$ pm2 flush$ pm2 stop all # Stop all apps$ pm2 stop 0 # Stop process with id 0$ pm2 restart all # Restart all apps$ pm2 reload all # Reload all apps in cluster mode$ pm2 gracefulReload all # Graceful reload all apps in cluster mode$ pm2 delete all # Kill and delete all apps$ pm2 delete 0 # Delete app with id 0$ pm2 scale api 10 # Scale app with name api to 10 instances$ pm2 reset [app-name] # Reset number of restart for [app-name]$ pm2 startup # Generate a startup script to respawn PM2 on boot$ pm2 save # Save current process list$ pm2 resurrect # Restore previously save processes$ pm2 update # Save processes, kill PM2 and restore processes$ pm2 generate # Generate a sample json configuration file$ pm2 deploy app.json prod setup # Setup "prod" remote server$ pm2 deploy app.json prod # Update "prod" remote server$ pm2 deploy app.json prod revert 2 # Revert "prod" remote server by 2$ pm2 module:generate [name] # Generate sample module with name [name]$ pm2 install pm2-logrotate # Install module (here a log rotation system)$ pm2 uninstall pm2-logrotate # Uninstall module$ pm2 publish # Increment version, git push and npm publish 开启进程的多种方式12345$ pm2 start app.js --watch # Restart application on file change$ pm2 start script.sh # Start bash script$ pm2 start app.js -- -a 34 # Start app and pass option -a 34$ pm2 start app.json # Start all applications declared in app.json$ pm2 start my-python-script.py --interpreter python 进程管理列出所有进程： 1$ pm2 list 管理进程 123$ pm2 stop &lt;app_name|id|'all'|json_conf&gt;$ pm2 restart &lt;app_name|id|'all'|json_conf&gt;$ pm2 delete &lt;app_name|id|'all'|json_conf&gt; 查看进程的详情 1$ pm2 describe &lt;id|app_name&gt; CPU / 内存监测1$ pm2 monit 日志工具1pm2 logs ['all'|'PM2'|app_name|app_id] [--err|--out] [--lines &lt;n&gt;] [--raw] [--timestamp [format]] 例： 123456789$ pm2 logs$ pm2 logs WEB-API --err$ pm2 logs all --raw$ pm2 logs --lines 5$ pm2 logs --timestamp "HH:mm:ss"$ pm2 logs WEB-API --lines 0 --timestamp "HH:mm" --out$ pm2 logs PM2 --timestamp$ pm2 flush // Clear all the logs 开机启动PM2可以自动生成并配置开机启动脚本，让服务器在重启的时候可以保持应用在线 12345$ pm2 startup# auto-detect platform$ pm2 startup [platform]# render startup-script for a specific platform, the [platform] could be one of:# ubuntu|centos|redhat|gentoo|systemd|darwin|amazon 更多查看&gt;&gt;]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js的cluster模块发挥CPU的多核优势]]></title>
    <url>%2F2016%2F04%2F24%2FNode-js%E7%9A%84cluster%E6%A8%A1%E5%9D%97%E5%8F%91%E6%8C%A5CPU%E7%9A%84%E5%A4%9A%E6%A0%B8%E4%BC%98%E5%8A%BF%2F</url>
    <content type="text"><![CDATA[一个Node.js应用程序只能使用在一个线程中。为了充分发挥多核CPU的优势，Node.js中提供了一个 cluster模块，允许在多个子进程中运行不同的Node.js应用程序。cluster模块是对 child_process.fork()的一个封装。]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[子进程child_process让Node.js具备命令行的功能]]></title>
    <url>%2F2016%2F04%2F22%2F%E5%AD%90%E8%BF%9B%E7%A8%8Bchild-process%E8%AE%A9Node-js%E5%85%B7%E5%A4%87%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[在Node中使用子进程的目的，正是希望从Node应用程序中通过命令行的方式访问计算机资源。 共有四种不同的技术来创建一个子进程 child_process.spawnspawn是创建子进程最常见的方法。例： 123456789101112131415161718var spawn = require('child_process').spawn, pwd = spawn('pwd');pwd.stdout.on('data', function(data)&#123; console.log('stdout:' + data);&#125;);pwd.stderr.on('data', function(data)&#123; console.log('stderr' + data);&#125;);pwd.on('close', function(code)&#123; console.log('child process close with code' + code);&#125;);pwd.on('exit', function(code)&#123; console.log('child process exit with code' + code);&#125;); 参数作为数组传入 子进程对 stdout 和 stderr 相关事件可以进行捕获 子进程退出代码为 1，表示发生了错误；没有错误时，退出代码为 0 尽量使用close事件而不是exit事件，在进程结束后访问其数据可能会导致应用程序崩溃 如何使用 stdin 标准输入对象呢： 12345678910111213var spawn = require('child_process').spawn, find = spawn('find', ['.', '-ls']), grep = spawn('grep', ['test']);grep.stdout.setEncoding('utf8');find.stdout.on('data', function(data)&#123; grep.stdin.write(data);&#125;);grep.stdout.on('data', function(data)&#123; console.log(data);&#125;) 上面这段例子模拟了Unix管道（|）功能，可以将一个命令的结果传递给另一个命令作为输入。 child_process.exec 和 child_process.execFile通过 child_process.exec 和 child_process.execFile 来启动 shell 执行命令可以缓存命令执行的结果 child_process.execFile 的第一个参数是命令或执行文件路径， 第二个参数是可选参数列表， 第三个参数是回调函数，该回调函数有三个参数： error, stdout 和 stderr。如果没有发生错误，执行结果会保存到 stdout。 child_process.exec 则没有可选参数列表，只有 execFile 方法的第一个和第三个参数。 12345678var execFile = require('child_process').execFile, child;child = execFile('ls', ['-l'], function(error, stdout, stderr)&#123; if (error == null) &#123; console.log('stdout: ' + stdout); &#125;&#125;); execFile 方法会更安全，因为它的命令行参数作为数组传入。 child_process.forkfork 其实是对 spawn的封装，目的是为了启动子进程并运行 Node.js模块。 例： fork(&#39;./child.js&#39;) 相当于 spawn(&#39;node&#39;, [&#39;./child.js&#39;]) 此方法会在父进程与子进程之间建立一个真实的通信管道，用于进程之间的通信。但通过fork生成的每个子进程都需要一个全新的 V8 实例，这需要耗费更多时间和内存。 12345var n = child_process.fork('./child.js');n.on('message', function(m) &#123; console.log('PARENT got message:', m);&#125;);n.send(&#123; hello: 'world' &#125;); send 方法用于进程间通信， 通过监听message事件来获取消息]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-v15.0升级指南]]></title>
    <url>%2F2016%2F04%2F19%2FReact-v15-0%E5%8D%87%E7%BA%A7%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[React-v15.0升级指南 主要变化加入document.createElement 并且废弃 data-reactid经过我们讨论，DOM 有很大的改变。其中最值得关注的一个变化就是，我们不再给每个 DOM设置data-reactid属性。虽然这更难看出一个网页是否使用了 React，但优势是DOM更轻量了。这一改变让我们使用 document.createElement来初始渲染成为可能。在此之前，我们会生成大量的HTML字符串，然后使用 node.innerHTML来插入。当时，我们决定尽快在大部分案例和支持的浏览器中使用document.createElement。浏览器持续地改善，因此兼容所有浏览器不再是正确的。使用 createElement可以让React的其他功能运行得更快。原来的ids用来映射React组件的事件，这意味着，我们不得不对每一个事件做很多工作，即使我们尽可能地缓存这些数据。正如我们遇到过的，缓存和缓存失效很容易出错，我们发现许多问题都无法重现。现在我们在渲染的时候可以直接建立映射，因为我们有了节点的钩子。 data-reactid仍然存在于服务端渲染中。不管怎样，这已经比以前要小很多了，并且这只是一个简单的自增计数器。 不再有额外的 &lt;span&gt;标签另一个关于DOM讨论的重大变化是如何渲染文本块。之前你可能关注到React渲染了很多额外的&lt;span&gt;标签。举个例子，我们在主页渲染&lt;div&gt;Hello {this.props.name}&lt;/div&gt;，结果包含了两层&lt;span&gt;标签。现在我们渲染时使用注释节点穿插在普通文本外来划分。这让我们同样拥有更新部分文本的能力，而不用额外的标签。很少人会这些真实的额外标签有依赖，所以你很可以不会受到任何影响。但是如果你在样式文件中对&lt;span&gt;标签有定义，你可能需要作出相应的调整。你仍然可以在你的组件里显式地指定渲染这些标签。 现在使用注释节点渲染 null我们还利用注释节点来渲染null。渲染null是我们在React v0.11版本添加的特性，并且通来渲染 &lt;noscript&gt;元素来应用。现在通过渲染注释节点，你的样式可能会有一些错乱，尤其是当你使用了:nth-child这样的选择器。React使用&lt;noscript&gt;标签，一直在考虑如何React命中DOM的实现细节。我们相信这些变化是安全的。另外，我们已经在许多典型的应用中看到这些变化在提升React的性能。 组件现在也可以返回 null我们在React v0.14添加了定义无状态组件的功能。不管怎样，React 0.14仍然允许你定义一个非继承React.Component或者使用 React.createClass()创建的组件。所以我们不能准确地判断你的组件是一个函数还是一个类，并且也不允许你从中返回一个null。这个问题在React 15中已经解决，你可以在你任何组件中返回null，不管是函数还是类。 增加SVG支持所有的SVG标签现在都已完美支持。（极少的标签在React.DOM里不存在，但JSX和React.createElement支持所有标签名）。所有被浏览器支持的SVG属性也全部支持。如果你发现少了什么属性，请给我们提 issue。 本文翻译自 React v15.0]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-router动态路由与Webpack分片thunks]]></title>
    <url>%2F2016%2F04%2F18%2Freact-router%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E4%B8%8EWebpack%E5%88%86%E7%89%87thunks%2F</url>
    <content type="text"><![CDATA[对于大型应用来说，一个首当其冲的问题就是所需加载的 JavaScript 的大小。程序应当只加载当前渲染页所需的 JavaScript。有些开发者将这种方式称之为“代码分拆” — 将所有的代码分拆成多个小包，在用户浏览过程中按需加载。 对于底层细节的修改不应该需要它上面每一层级都进行修改。举个例子，为一个照片浏览页添加一个路径不应该影响到首页加载的 JavaScript 的大小。也不能因为多个团队共用一个大型的路由配置文件而造成合并时的冲突。 路由是个非常适于做代码分拆的地方：它的责任就是配置好每个 view。 如果你使用过单页应用的框架，那你可能应用过路由。路由可以让你的应用看起来好像有很多“页面”。用户可以通过 youdomain.com/about来获取公司相关的介绍信息。 在这里使用双引号，是因为这并不是一个真正意义上的“页面”。 通过各种流行的构建工具的配置，所有的脚本最后都得到连成一片巨大的.js文件。当你访问 youdomain.com/about 这个页面的时候，你会下载应用程序的所有内容。但用户可能根本不想，也不会去浏览这些内容。这是非常糟糕的，也会让你的应用变得越来越大。 对于一个不使用任何框架的普通网页，你首先是下载一个 .html 文件，然后是从缓存中获取脚本和样式文件。用户只下载他需要的内容，仅此而已。 你想让你的React.js应用也按需加载吗？ 前提条件 使用 react-router 做为路由解决方案，因为这是功能最强大的 React路由方案； Webpack作为构建工具，因为它有强大的分片能力和齐全的功能 react-router下面是一个常见的路由例子： 123456789var HomePage = require('./HomePage.jsx');var AboutPage = require('./AboutPage.jsx');var FAQPage = require('./FAQPage.jsx');&lt;Router history=&#123;history&#125;&gt; &lt;Route path="/" component=&#123;HomePage&#125; /&gt; &lt;Route path="/about" component=&#123;AboutPage&#125; /&gt; &lt;Route path="/faq" component=&#123;FAQPage&#125; /&gt;&lt;/Router&gt; 为了方便解释，省略了很多代码 如果一个用户浏览 yourdomain.com/about页面，他将看到AboutPage 组件；如果查看 yourdomain.com/faq页面，将看到 FAQPage组件等等。当你使用路由去配置你的应用，这些组件和相关代码将被打包成一个.js文件。 值得庆幸的是，react-router的 &lt;Route&gt;标签有一个叫做getComponent的异步的方法去获取组件。他是一个function接受两个参数，分别是location和callback。当react-router执行回调函数 callback(null, ourComponent)时，路由只渲染ourComponent组件。 getComponent让我们来重写上面的例子来支持异步组件： 1234567891011121314151617181920212223&lt;Router history=&#123;history&#125;&gt; &lt;Route path="/" getComponent=&#123;(location, callback) =&gt; &#123; // 在这里执行异步操作 callback(null, HomePage); &#125;&#125; /&gt; &lt;Route path="/about" getComponent=&#123;(location, callback) =&gt; &#123; // 在这里执行异步操作 callback(null, AboutPage); &#125;&#125; /&gt; &lt;Route path="/faq" getComponent=&#123;(location, callback) =&gt; &#123; // 在这里执行异步操作 callback(null, FAQPage); &#125;&#125; /&gt;&lt;/Router&gt; 这些组件会在需要的时候异步加载。这些组件仍然会在同一个文件中，并且你的应用看起来不会有任何不同。但是没有它，我们的网页将无法运行。 WebpackWebpack 有一个特性叫做 chunking（分片），意思就是通过输出多个文件（chunks）来替代一个总的大的文件。你代码里的分割点（split points）决定了哪些模块被分到哪些文件里。 Split Points(分块点)Webpack 提供了很多方式去让我们设置分块点。但最有用的一个就是 require.ensure方法。下面是一个例子： 12345function loadModule() &#123; require.ensure([], function(require) &#123; var module = require('module.js'); &#125;, "MyModule");&#125; module.js 模块将通过Webpack 输出在第二个文件里，并且当浏览器执行require.ensure的时候加载。（当loadModule被调用的时候并不会加载） require.ensure方法的第三个参数是指定模块名称。它是一个可选项，如果不填，将会自动生成一个 ID作为文件名。 这离成功还差一步，我们还需要配置Webpack.config.js文件来支持分片thunks 配置在Webpack 配置文件中的 output选项设置chunkFilename: 123output: &#123; chunkFilename: '[name].chunk.js'&#125; 你也可以设置[chunkhash]和[ID]变量作为分块的文件名。如果没有指定[name]变量，将会使用 ID 作为分块文件名。 这可以正常运行，但有个问题。通用的依赖通常都在一个单独的文件中。如果在你应用的模块中使用了React，React将包含在每一个分片文件thunks中。 我们可以通过 CommonsChunkPlugin插件来解决这个问题。在你的配置文件中添加 plugins 选项： 123plugins: [ new webpack.optimize.CommonsChunkPlugin('common.js')] 我喜欢使用 common.js 作为文件名，因为这样很直观，但它也可以任意指定。 非常好，代码分割完成。让我们配合react-router一起使用。 整合还记得我们上面提到的异步加载组件的路由吗？上面通过 require引用 HomePage组件。让我们配合使用 getComponent 和 require.ensure 来实现按需加载。 123456789&lt;Route path="/" getComponent=&#123;(location, callback) =&gt; &#123; require.ensure([], function (require) &#123; var HomePage = require('./HomePage.jsx'); callback(null, HomePage); &#125;, 'HomePage'); &#125;&#125;/&gt; 把 require放在 callback里更简洁： 12345678&lt;Route path="/" getComponent=&#123;(location, callback) =&gt; &#123; require.ensure([], function (require) &#123; callback(null, require('./HomePage.jsx')); &#125;, 'HomePage'); &#125;&#125;/&gt; 完整的代码如下： 1234567891011121314151617181920212223242526&lt;Router history=&#123;history&#125;&gt; &lt;Route path="/" getComponent=&#123;(location, callback) =&gt; &#123; require.ensure([], function (require) &#123; callback(null, require('./HomePage.jsx')); &#125;); &#125;&#125; /&gt; &lt;Route path="/about" getComponent=&#123;(location, callback) =&gt; &#123; require.ensure([], function (require) &#123; callback(null, require('./AboutPage.jsx')); &#125;); &#125;&#125; /&gt; &lt;Route path="/faq" getComponent=&#123;(location, callback) =&gt; &#123; require.ensure([], function (require) &#123; callback(null, require('./FAQPage.jsx')); &#125;); &#125;&#125; /&gt;&lt;/Router&gt; 本文翻译自 http://blog.mxstbr.com/2016/01/react-apps-with-pages/ 参考 http://react-guide.github.io/react-router-cn/docs/guides/advanced/DynamicRouting.html]]></content>
      <categories>
        <category>react</category>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>Webpack</tag>
        <tag>react-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node全局对象：global、process和Buffer]]></title>
    <url>%2F2016%2F04%2F14%2FNode%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%EF%BC%9Aglobal%E3%80%81process%E5%92%8CBuffer%2F</url>
    <content type="text"><![CDATA[global对象，也是Node的全局命名空间； process对象，它提供了一些关键功能，例如对三种标准I/O流的封装，以及将同步函数转换为异步回调的功能； Buffer类，它提供了存储和操作原始数据的功能，同样它也是全局可见的 globalglobal与浏览器中的window对象是相似的，它们的关健不同点是： 浏览器中的window对象是一个真正全局的对象。如果在客户端 JavaScript中定义一个全局变量，它将能够被Web页面以及每一个独立的库访问到。 而Node模块中创建一个顶层变量（函数之外的变量），它仅仅在该模块中是全局的，而在其他模块中是不可见的。只有那些被模块显式导出的部分才能被引用该模块的应用程序所使用。 这意味着，由于不小心使用了重复的全局变量名称而引起的数据冲突问题将会大大减少。 process每个Node应用程序都是一个process对象实例，所以，应用程序自然能直接使用某些内建于 process 对象的功能。 process.execPath 方法可以返回当前 Node 应用程序的执行路径 process.version 提供了 Node 版本信息 process.platform 提供服务器平台信息 process.memoryUsage 方法可以查询当前Node 应用程序的内存使用量 process.nextTick 方法 这个方法可以将一个回调函数挂载到Node程序的事件循环机制中，并在下一个事件循环发生时调用该函数。 例： 12345function asynchFunction = function (data, cb) &#123; process.nextTick(function () &#123; cb(val) &#125;)&#125; 虽然使用 setTimout 方法并传入一个0毫秒的延迟可以过到同样的目的 123setTimout(function () &#123; cb(val)&#125;, 0) 但是，setTimout并不像 process.nextTick那样高效，process.nextTick的调用速度远远快于setTimout方法 首先你需要将耗时的处理过和打散并分解成多个部分，每个部分分别通过 process.nextTick调用，最终使得应用程序可以对其他请求进行处理，而无需等待耗时计算过程完成。 BufferBuffer 是用于处理二进制数据的一种方式。 流处理往往采用的是二进制数据，而非字符串 Buffer 支持的编码方式包括： ascii 七位 ASCII utf8 多字节编码的 Unicode 字符 usc2 两字节，little endian 方式编码的 Unicode 字符 base64 Base64 编码 hex 每个字节编码为两个十六进制字符]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node与REPL]]></title>
    <url>%2F2016%2F04%2F13%2F%E8%AE%B0node%E4%B8%8EREPL%2F</url>
    <content type="text"><![CDATA[前言这几个月，搜芽前端团队搞了Reactjs+Redux项目，在很多时候，比如部署，都需要使用Node，苦于我的肤浅，于是决定补一下功课。最近都会记录一些 Node相关的笔记。 Node 的优势 应用程序可以很容易地扩展，因为执行一个单线程并不会有非常大的开销 无需诉求于多线程开发，却达到了节约又能高效使用资源的目的。换句话说，你不必创建一个线程安全的应用程序。 全局变量在 Node 中是非常危险的，特别是你忘记 var关键字的时候。 REPLREPL(read-eval-print-loop) 是Node的一个交互式组件。在 REPL环境下输入的任何内容都由底层的 V8 Javascript引擎进行处理。 一些操作技巧 _(下划线) 可以调用上一个表达式 上下键仍然可以快捷输入历史命令, Tab 键自动补全 可以使用重复的 .(点) 来处理多行表达式，如： 1234&gt;var test = function() &#123;...return val = x * y ...&#125;;undefined 退出 REPL环境的方式有： Ctrl + C两次 Ctrl + D .exit REPL 命令 .break 如果多行输入发生混乱不知道当前位置时，使用 .break会重新开始。不过会丢失之前输入的多行内容。 .clear 重置语境并清空所有表达式。该命令可以使你重头再来。 .exit 退出 REPL .help 显示所有可用的REPL命令。 .save 将当前REPL会话保存至文件 .load 将文件加载到当前会话 定制 REPL首先需要引入 REPL 模块： 1var repl = require('repl'); 通过在repl对象上调用 start方法创建新的 REPL： 1repl.start([prompt], [stream], [eval], [useGlobal], [ignoreUndefinded]); 所有参数都可选。 prompt Default is &gt; 默认值为 &gt; stream 默认值为process.stdin eval eval的默认值是 async useGlobal 默认值为 false, 新建一个语境而不是使用全局对象。 ignoreUndefinded 默认值为 false。 不要忽略undefined的返回值。 所以让REPL在表达式无返回值时不输出undefined可以这样实现： 123repl = require('repl');// 设置 `ignoreUndefinded` 为 `true` , 启动 `REPL`repl.start('&gt;', null, null, null, true);]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[postCSS常用插件]]></title>
    <url>%2F2016%2F04%2F10%2FpostCSS%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[PostCSS拥有非常多的插件，诸如自动为CSS添加浏览器前缀的插件autoprefixer、当前移动端最常用的px转rem插件px2rem，还有支持尚未成为CSS标准但特定可用的插件cssnext，还有很多很多。就连著名的Bootstrap在下一个版本Bootstrap 5也将使用PostCSS作为样式的基础。 一句话来概括PostCSS：CSS编译器能够做到的事情，它也可以做到，而且能够做得更好 PostCSS性能在PostCSS官方推特上看到，由JavaScript编写的PostCSS比C++编写的libsass还要快3倍. 如果你对上面的性能截图有疑问，可以亲自来这里测试看看。 常用的插件autoprefixer首先是最火的官方插件 autoprefixer 。autoprefixer 是为我们的 css 添加前缀的插件，它的数据来源于 Can I use。目的是让我们写纯粹的 css。例： 123a &#123; display: flex;&#125; 会编译成： 123456a &#123; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex&#125; Options通过 autoprefixer(options) 配置： 1var plugin = autoprefixer(&#123; browsers: ['&gt; 1%', 'IE 7'], cascade: false &#125;); browsers (array): 指定你需要支持的浏览器列表。可以直接指定浏览器版本（如 IE 7）,也可以使用选项（如： last 2 version 或 &gt; 5%）,具体选项可以查看 Browserslist cascade (boolean): should Autoprefixer use Visual Cascade, if CSS is uncompressed. Default: true add (boolean): 是否添加浏览器兼容前缀. 默认值是true. remove (boolean): 是否去除无用的浏览器兼容前缀. 默认值是true. supports (boolean): should Autoprefixer add prefixes for @supports parameters. Default is true. flexbox (boolean|string): should Autoprefixer add prefixes for flexbox properties. With “no-2009” value Autoprefixer will add prefixes only for final and IE versions of specification. Default is true. grid (boolean): should Autoprefixer add IE prefixes for Grid Layout properties. Default is true. stats (object): custom usage statistics for &gt; 10% in my stats browsers query. 调试info() 方法可用于查看调试信息.可以像下面这样查看哪些浏览器被选中以及哪些属性被添加兼容前缀： 12var info = autoprefixer(&#123; browsers: ['last 1 version'] &#125;).info();console.log(info); postcss-safe-parserpostcss-safe-parser 可以帮你查找并修补CSS语法错误。 cssnanocssnano 是模块化的CSS压缩器。]]></content>
  </entry>
  <entry>
    <title><![CDATA[postCSS-loader配置,让css随心所欲]]></title>
    <url>%2F2016%2F04%2F09%2FpostCSS-loader%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[组件必不可少的一部分就是 css，这里看下关于 css的一些 loaders。 PostCSSPostCSS 官网是这么介绍自己的： PostCSS is a tool for transforming styles with JS plugins. These plugins can lint your CSS, support variables and mixins, transpile future CSS syntax, inline images, and more. 他是一款通过 JS 插件转换 styles 样式的工具。 在 Webpack 里面可以通过 postCSS-loader 来使用 PostCSS。 使用首先是安装 postCSS-loader 1npm install postcss-loader --save-dev 下面是一个 Webpack config 的例子： 12345678910111213141516var precss = require('precss'); // 实现类Sass的功能，变量，嵌套，mixinsvar autoprefixer = require('autoprefixer'); // 自动添加浏览器前缀module.exports = &#123; module: &#123; loaders: [ &#123; test: /\.css$/, loader: "style-loader!css-loader!postcss-loader" //在使用 css-loader,style-loader之前处理 &#125; ] &#125;, postcss: function () &#123; // postcss 插件 return [precss, autoprefixer]; &#125;&#125; 上面的例子使用了两个 postcss 插件，应该预先安装： 123&gt; npm install precss --save-dev&gt; npm install autoprefixer --save-dev&gt; 在文件中引入的css将通过 PostCSS 插件的处理: 1234var css = require('./file.css');orimport './file.css'// =&gt; CSS after Autoprefixer and CSSWring 插件组如果你想对不同目录或类型的 css使用不同的 PostCSS 插件配置进行处理，可以使用 ?pack=name 参数 1234567891011121314151617181920module.exports = &#123; module: &#123; loaders: [ &#123; test: /\.docs\.css$/, loader: "style-loader!css-loader!postcss-loader?pack=cleaner" // 对docs目录下的css使用 cleaner 的配置 &#125;, &#123; test: /\.css$/, loader: "style-loader!css-loader!postcss-loader" // 对其他目录下的css使用 defaults 的配置 &#125; ] &#125;, postcss: function () &#123; return &#123; defaults: [precss, autoprefixer], cleaner: [autoprefixer(&#123; browsers: [] &#125;)] &#125;; &#125;&#125; 写在 js 中的样式可以通过 postcss-js 插件处理写在 js 中的样式 1234&#123; test: /\.style.js$/, loader: "style-loader!css-loader!postcss-loader?parser=postcss-js"&#125; 也可以通过 babel 结合 postcss-js 处理 es6 语法中的样式 1234&#123; test: /\.style.js$/, loader: "style-loader!css-loader!postcss-loader?parser=postcss-js!babel"&#125; 你可以像下面这样写样式 1234567891011import colors from '../config/colors';export default &#123; '.menu': &#123; color: colors.main, height: 25, '&amp;_link': &#123; color: 'white' &#125; &#125;&#125;]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>loaders</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[babel-loader配置]]></title>
    <url>%2F2016%2F04%2F08%2Fbabel-loader%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[安装1npm install babel-loader babel-core babel-preset-es2015 --save-dev npm 从 npm@3 之后不赞成自动安装peerDependencies，所有必须在package.json里明确指定 babel-core 这样的宿主依赖。 peerDependencies字段，主要用来供插件指定其所需要的主软件的版本。更多可以见这里 如果是从babel 5升级到 babel 6，可以看这份指导 使用在webpack.config.js里配置是比较推荐的方式： 123456789101112module: &#123; loaders: [ &#123; test: /\.jsx?$/, // 匹配'js' or 'jsx' 后缀的文件类型 exclude: /(node_modules|bower_components)/, // 排除某些文件 loader: 'babel', // 使用'babel-loader'也是一样的 query: &#123; // 参数 presets: ['es2015'] &#125; &#125; ]&#125; 选项选项的写法有两种 一种是查询字符串的方式： 123456789module: &#123; loaders: [ &#123; test: /\.jsx?$/, exclude: /(node_modules|bower_components)/, loader: 'babel?presets[]=es2015' &#125; ]&#125; 另一种是指定 query属性 123456789101112module: &#123; loaders: [ &#123; test: /\.jsx?$/, exclude: /(node_modules|bower_components)/, loader: 'babel', query: &#123; presets: ['es2015'] &#125; &#125; ]&#125; babel-loader 还支持以下选项： cacheDirectory: 默认值是 false。如果设置了这个参数，被转换的结果将会被缓存起来。当Webpack 再次编译时，将会首先尝试从缓存中读取转换结果，以此避免资源浪费。如果该值为空(loader: ‘babel-loader?cacheDirectory’)，loader会使用系统默认的临时文件目录。 问题及优化性能问题 确保只转换尽可能少的文件，你可能匹配了过多的文件类型，或者匹配了所有的’.js’文件，你需要使用 exclude: /(node_modules|bower_components)/ 排除部分目录 设置 cacheDirectory 参数也可以让你的 loader 性能提升2倍！ babel 给每个需要的文件注入helper扩展您可以改为要求babel作为一个独立运行的模块，以避免重复。 下面的配置通过babel-plugin-transform-runtime插件可以禁用babel向每个文件注入helper 需要先安装插件 npm install babel-plugin-transform-runtime --save 12345678910111213loaders: [ // the 'transform-runtime' plugin tells babel to require the runtime // instead of inlining it. &#123; test: /\.jsx?$/, exclude: /(node_modules|bower_components)/, loader: 'babel', query: &#123; presets: ['es2015'], plugins: ['transform-runtime'] &#125; &#125;]]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>loader</tag>
        <tag>babel-loader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack-config]]></title>
    <url>%2F2016%2F04%2F07%2FWebpack-config%2F</url>
    <content type="text"><![CDATA[不得不说，Webpack 配置确实烦琐了一些，很多人都使用gulp的插件gulp-webpack来做其他事情。 配置WebpackWebpack的构建过程需要一个配置文件，一个典型的配置文件webpack.config.js大概就是这样 12345var webpack = require('webpack');module.exports = &#123; // 配置项&#125;; 基本配置项entry123456module.exports = &#123; entry:'./example1.1', output:&#123; filename:'bundle1.1.js' &#125;&#125;; 我们也会碰到支持多个入口文件（entry）的情况，每一个入口都需要有自己的名字，具体对应entry的写法而言，有如下几种情况： 12345678entry:'./example2.1'// 或者entry:['./example2.1','./example2.2']//或者entry:&#123; 'example2.1':'example2.1.js', 'example2.2':'example2.2.js'&#125; 第三种是比较推荐的写法，这种写法中，名字和模块文件名一一对应，每个模块都有独立的名字。也就是output.filename中的[name] outputoutput.filenameoutput.filename除了可以指定具体的文件名以外，还可以使用一些占位符，包括： name 模块名称 hash 模块编译后的（整体）Hash值 chunkhash 分片的Hash值 [name] 在上面的entry中，前两种写法，模块是没有名字的，webpack会使用main作为模块名字，因此用数组来指定入口的情况，模块名会重复，而此时webpack会将它们的代码合并打包！而第三种写法，这里的[name]可以理解成模块名字。 [hash]与[chunkhash] 事实上，在webpack的文档中，这个name是指“chunk name”，即分片的名字，这里需要先剧透一下后面要说的“分片”的概念。所谓分片就是指一个入口模块的代码有可能会被分成多个文件，还有一些文件可能是来自模块的公共代码，而不是入口模块。因此这里的[name]并非严格与入口模块一一对应。 了解了这些情况之后，[hash]和[chunkhash]就自然好理解了，一个是指本次打包相关的整体的hash，一个是指分片的hash。 1234567891011module.exports = &#123; entry:&#123; 'example3.1':'./example3.1', 'example3.2':'./example3.2' &#125;, output:&#123; //这里分别用hash和chunkhash，结果不一样 filename:'[name]-[hash].js' //filename:'[name]-[chunkhash].js' &#125;&#125;; output.pathoutput.path来指定输出路径 output.path也可以使用占位符。 如果想保持打包前源文件的目录结构，需要把目录写到模块名上，如： 12345678entry:&#123; 'example4.1':'./src/example4.1', 'hello/example4.2':'./src/hello/example4.2'&#125;,output:&#123; filename:'[name].js', path:'./dist'&#125; 注意这里的filename一定要包含[name]才行，因为路径信息是带在模块名上的。 CommonChunks插件Common Chunks 插件的作用就是提取代码中的公共模块，然后将公共模块打包到一个独立的文件中去，以便在其它的入口和模块中使用。 1234567891011121314var webpack = require('webpack');module.exports = &#123; entry:&#123; main1:'./main', main2:'./main.2' &#125;, output:&#123; filename:'bundle.[name].js' &#125;, plugins: [ new webpack.optimize.CommonsChunkPlugin('common.js', ['main1', 'main2']) ]&#125;; 参数common.js表示公共模块的文件名，后面的数组元素与entry一一对应，表示要提取这些模块中的公共模块。 但是，要记得在HTML中加入公共部分common.js 12&lt;script src="./common.js"&gt;&lt;/script&gt;&lt;script src="./bundle.main1.js"&gt;&lt;/script&gt; 但模块化不应该有多个入口文件，入口文件不应时时改变，应在内部处理 使用loaderloader是webpack中一个重要的概念，它是指用来将一段代码转换成另一段代码的webpack插件 虽然本质上说，loader也是插件，但因为webpack的体系中还有一个专门的名词就叫插件（plguin），为避免混淆，后面不再将loader与插件混淆说，后文中这将是两个相互独立的概念。 loader的使用有三种方法，分别是： 在require中显式指定 在配置项（webpack.config.js）中指定 在命令行中指定 第二种，在配置项中指定是最灵活的方式，它的指定方式是这样： 12345678910111213141516171819202122module: &#123; // loaders是一个数组，每个元素都用来指定loader loaders: [&#123; test: /\.jade$/, //test值为正则表达式，当文件路径匹配时启用 loader: 'jade', //指定使用什么loader，可以用字符串，也可以用数组 exclude: /node_modules/, //可以使用exclude来排除一部分文件 // exclude: /regexp/ include: 'dist', // 用来指定包含的文件 //可以使用query来指定参数，也可以在loader中用和require一样的用法指定参数，如`jade?p1=1` query: &#123; p1:'1' &#125; &#125;, &#123; test: /\.css$/, loader: 'style!css' //loader可以和require用法一样串联 &#125;, &#123; test: /\.css$/, loaders: ['style', 'css'] //也可以用数组指定loader &#125;]&#125; 串联loader是可以串联使用的，也就是说，一个文件可以先经过A-loader再经过B-loader最后再经过C-loader处理。 1require('style!css!./style.css'); 参数loader还可以接受参数，不同的参数可以让loader有不同的行为（前提是loader确实支持不同的行为），具体每个loader支持什么样的参数可以参考loader的文档。 参数的指定方式和url很像，要通过?来指定，例如指定literate参数需要这样写： 1require('coffee?literate=1!./a.coffee'); 具体的可以对照官方的loader列表一一查看。]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[采用非直进式合并（git-merge-no-ff）]]></title>
    <url>%2F2016%2F04%2F02%2F%E9%87%87%E7%94%A8%E9%9D%9E%E7%9B%B4%E8%BF%9B%E5%BC%8F%E5%90%88%E5%B9%B6%EF%BC%88git-merge-no-ff%EF%BC%89%2F</url>
    <content type="text"><![CDATA[使用Git当合并一个分支是一个相当常见的操作。在某些情况下，Git会默认将尝试在快进模式合并一个分支。如果不使用快进合并有什么不同？ 假设我从master创建一个名为speedup分支。在这个分支上工作一段时间（三个提交，那些白色的圆圈）后，当我完成工作时，我把它git push推到我自己的远程分支。同时，主分支master什么都没发生，但仍处于相同的状态之前，我分出。这种情况在下面的图中描述。 一旦该项目的维护者得到通知，我的分支已经准备好合并进master，她可能使用git的常规步骤git fetch操作后执行git merge来合并。因为主分支并没有新的提交（灰色圆圈），Git会用快进执行合并。整个系列的提交将是线性的。历史会像下图（左侧）。 合并的另一个变型是使用 -no-ff 选项（它代表不快进）。在这种情况下，分支历史看上去稍有不同（右侧），有一个附加的提交（虚线圆）强调合并。这个提交告诉我们有关合并分支的备注信息。 Git的默认行为是尽可能使用快进。这可以改变的，非快进模式可以很容易地设定为默认合并模式。 设置非快进模式合并为默认合并方式 git config branch.master.mergeoptions “–no-ff” 总之，非快进合并保持明确分支的概念。它可在保留分支复杂的非线性提交历史。在另一方面，快进合并保持线性历史上的变更，使其更容易使用其他工具（log, blame, bisect）。每个分支的来源将变得很不明显，但如果该项目强制要求提交信息和问题跟踪器之间的严格的交叉引用，这也不是什么大不了的事。 你喜欢哪一种呢，快进式或非快进式？ 翻译自： Fast-Forward Git Merge]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速上手Flow-静态类型检查器]]></title>
    <url>%2F2016%2F03%2F16%2F%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BFlow-%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%99%A8%2F</url>
    <content type="text"><![CDATA[why Flowjavascript是一个弱类型语言，变量类型不需要声明，运算过程中会根据需要自动转换类型，这个是js的优点，够灵活，编码简单，但是同时也是软肋。有时候，有些类型转换的bug无从查起，特别是在复杂的应用中。 Flow为Javascript添加了静态类型检查，以提高开发效率和代码质量。更明确的说，静态类型检查提供的好处像早期错误检查，帮助你发现一些只有在运行时才能发现的错误。 安装由于flow是用OCaml语言写的，npm上只有对应的二进制包。 1npm install flow-bin 可者使用 Homebrew 安装 1brew install flow 快速上手在项目目录下执行 flow init，会生成一个 .flowconfig 文件 只需要在待检查的js文件头部添加一行注释 1/* @flow */ 然后在同一目录下运行flow check即可。 flow serverflow server是为了提高检测效率的后台程序，支持在后台运行，并且只监测有修改的文件。 方法很简单，一条 flow 命令就能完成 Flow 服务器启动，文件检测，被更改文件的检测，即第一次使用 flow 命令会启动 Flow 服务器并且首次检测文件，再次使用 flow 命令会连接 Flow 服务器并且检测文件，之后使用 flow 命令时将会连接 Flow 服务器并且对修改过的文件进行检测。 flow check:检测所有声明了 @flow 的文件 flow check –all:可以让Flow检测所有文件，包括没有声明 @flow 的文件 flow stop:项目开发完成停止服务 flowconfig [ignore]忽略的文件，路径的匹配规则是正则表达式 [include]需要检测的其他目录的文件 [libs]当文件中有第三方库引用或者require全局的module时，需要在一个单独的文件里declare这个对象，这个的值是所有declare路径的集合 [options]包含若干key-value的配置 flow的两种模式12/* @flow */ 只要带有这个注释，都会进行类型检测/* @flow weak */ 只对有加类型声明的变量进行类型检测 类型声明/标注 不声明变量类型的时候，Flow 也会自动检查隐性存在的类型转换。但更为严谨的方式是显式声明变量的类型。 可以在代码里写上类型: 12345678/* @flow */// Changing the return type to number fixes the errorfunction foo(x: string, y: number): number &#123; return x.length * y;&#125;foo('Hello', 42); 也可以这样： 123/* @flow */type T = number;var x: T = 0; 下面是一个更详细的例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class People &#123; name: string; constructor(name:string)&#123; this.name = name &#125; getAge():number&#123; return 18; &#125;&#125;function getLength(param?:string):number &#123; /*param?:string传参类型什么，?表示此处可不传值；*/ /*\:number为函数返回值类型,如果没有return可不写或写void*/ var s:string = 'string';/*字符*/ var ss:String = new String('string');/*字符对象*/ /* s = ss*///类型不同，flow会报错 var n:number = 12;/*数字*/ var nn:Number = new Number(12);/*数字对象*/ var b:boolean = true;/*bool值，仅能为true/false*/ var bb:Boolean = new Boolean(true);/*bool值对象*/ var o:&#123;prop1:number,prop2:string&#125; = &#123; /*对象熟悉声明*/ prop1: 12, prop2: '21123' &#125; var v:void = undefined;/*undefined*/ var a:any = 'aa';/*任意类型，除undefined*/ var m:mixed = '1';/*任意类型+undefined*/ var mm:mixed = undefined;/*任意类型+undefined*/ var aa:Array&lt;number&gt; = [1,2,3,4];/*数组内值类型声明*/ var P:Class&lt;People&gt; = People;/*自定义类型声明*/ var p:People = new People('pt');/*自定义People类型*/ if (param) &#123; return param.length; &#125; else &#123; return 0; &#125;&#125; 兼容性Flow致力于支持最新的JavaScript标准。目前已经支持各种ES6特性如destructuring, classes, extended objects, optional function parameters，以及核心API扩展（比如Map, Set, Promise, 和 new methods on Object, Array, 和 Math)。其它特性（尤其是模块）正在开发中。Flow支持CommonJS / Node.js 规范的模块。 Flow 也已经支持 React。 代码编译在构建工具中添加flow检查的步骤。webpack和gulp都有对应的flow插件。 我们在项目中用到的插件： eslint-plugin-flow-vars 参考Flow官网最近访问不了，可以看这里：https://github.com/facebook/flow/tree/master/website/docs flow——A static type checker for javascript #32 flow–facebook出品的javascript静态类型检查器]]></content>
      <categories>
        <category>Flow</category>
      </categories>
      <tags>
        <tag>Flow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React应用性能优化之IMMUTABLE.JS]]></title>
    <url>%2F2016%2F03%2F14%2FReact%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8BIMMUTABLE-JS%2F</url>
    <content type="text"><![CDATA[前一篇文章记录了React应用的性能优化点，今天还有个更闪耀的 Immutable.js。 Immutable.jsImmutable.js 本身和 React.js 没有必然的联系。它的意义在于它弥补了Javascript没有不可变数据结构的问题。 Javascript中对象都是参考类型，也就是a={a:1}; b=a; b.a=10;你发现a.a也变成10了。可变的好处是节省内存或是利用可变性做一些事情，但是，在复杂的开发中它的副作用远比好处大的多。于是才有了浅copy和深copy，就是为了解决这个问题。举个常见例子： 123var defaultConfig = &#123; /* 默认值 */&#125;;var config = $.extend(&#123;&#125;, defaultConfig, initConfig); // jQuery用法。initConfig是自定义值var config = $.extend(true, &#123;&#125;, defaultConfig, initConfig); // 如果对象是多层的，就用到deep-copy了 ES6出现原生的assign方法，但它相当于是浅copy。如果有了不可变的数据结构就省心了，ES5.1中对象有了freeze方法，也是浅copy，a=Object.freeze({a:1}); b=a; b.a=10; a.a还是1。在实际开发中浅copy通常不够。如果用immutableJS: 123var defaultConfig = Immutable.fromJS(&#123; /* 默认值 */&#125;);var config = defaultConfig.merge(initConfig); // defaultConfig不会改变，返回新值给configvar config = defaultConfig.mergeDeep(initConfig); // 深层merge 上述用deep-copy也可以做到，差别在于性能。每次deep-copy都要把整个对象递归的复制一份。而Immutable的实现有些像链表，添加一个新结点把旧结点的父子关系转移到新结点上，性能提升很多。ImmutableJS给的远不止这些，它提供了7种不可变的数据结构：List, Stack, Map, OrderedMap, Set, OrderedSet, Record （详见文档Immutable.js，文档很geek，打开console试吧）。immutableJS ＋ 原生Javascript等于真正的函数式编程。 Immutable 优点1. Immutable 降低了 Mutable 带来的复杂度可变（Mutable）数据耦合了 Time 和 Value 的概念，造成了数据很难被回溯。 比如下面一段代码： 12345function touchAndLog(touchFn) &#123; let data = &#123; key: 'value' &#125;; touchFn(data); console.log(data.key); // 猜猜会打印什么？&#125; 在不查看 touchFn 的代码的情况下，因为不确定它对 data 做了什么，你是不可能知道会打印什么（这不是废话吗）。但如果 data 是 Immutable 的呢，你可以很肯定的知道打印的是 value。 2. 节省内存Immutable.js 使用了 Structure Sharing 会尽量复用内存，甚至以前使用的对象也可以再次被复用。没有被引用的对象会被垃圾回收。 123456789import &#123; Map&#125; from 'immutable';let a = Map(&#123; select: 'users', filter: Map(&#123; name: 'Cam' &#125;)&#125;)let b = a.set('select', 'people');a === b; // falsea.get('filter') === b.get('filter'); // true 上面 a 和 b 共享了没有变化的 filter 节点。 3. Undo/Redo，Copy/Paste，甚至时间旅行这些功能做起来小菜一碟因为每次数据都是不一样的，只要把这些数据放到一个数组里储存起来，想回退到哪里就拿出对应数据即可，很容易开发出撤销重做这种功能。 为什么在React.js中使用Immutable.js熟悉React.js的都应该知道，React.js是一个UI = f(states)的框架，为了解决更新的问题，React.js使用了virtual dom，virtual dom通过diff修改dom，来实现高效的dom更新。 听起来很完美吧，但是有一个问题。当state更新时，如果数据没变，你也会去做virtual dom的diff，这就产生了浪费。这种情况其实很常见，如： 熟悉 React 组件生命周期的话都知道：调用 setState 方法总是会触发 render 方法从而进行 vdom re-render 相关逻辑，哪怕实际上你没有更改到 Component.state 。 12this.state = &#123;count: 0&#125;this.setState(&#123;count: 0&#125;);// 组件 state 并未被改变，但仍会触发 render 方法 为了避免这种性能上的浪费，React 提供了一个 shouldComponentUpdate 来控制触发 vdom re-render 逻辑的条件。于是 PureRenderMixin 作为一种优化技巧被使用。但PureRenderMixin只是简单的浅比较，不使用于多层比较。那怎么办？？自己去做复杂比较的话，性能又会非常差。 这时候 immutableJS 就派得上用场了： 123var map1 = Immutable.fromJS(&#123;a:1, b:1, c:&#123;b:&#123;c:&#123;d:&#123;e:7&#125;&#125;&#125;&#125;&#125;);var map2 = Immutable.fromJS(&#123;a:1, b:1, c:&#123;b:&#123;c:&#123;d:&#123;e:7&#125;&#125;&#125;&#125;&#125;);Immutable.is(map1, map2); // true 每一次state更新只要有数据改变，那么PureRenderMixin可以立刻判断出数据改变，可以大大提升性能。 实践与 React 搭配使用，Pure Render可以使用 react-immutable-render-mixin 通过es6的修饰器 @decorator 来使用 123456789import React from 'react';import &#123; immutableRenderDecorator &#125; from 'react-immutable-render-mixin';@immutableRenderDecoratorclass Test extends React.Component &#123; render() &#123; return &lt;div&gt;&lt;/div&gt;; &#125;&#125; 或者直接 123456789import immutableRenderMixin from 'react-immutable-render-mixin';React.createClass(&#123; mixins: [immutableRenderMixin], render: function() &#123; return &lt;div className=&#123;this.props.className&#125;&gt;foo&lt;/div&gt;; &#125;&#125;); 与 Redux 搭配使用Redux 是目前流行的 Flux 衍生库。它简化了 Flux 中多个 Store 的概念，只有一个 Store，数据操作通过 Reducer 中实现；同时它提供更简洁和清晰的单向数据流（View -&gt; Action -&gt; Middleware -&gt; Reducer），也更易于开发同构应用。目前已经在我们项目中大规模使用。 由于 Redux 中内置的 combineReducers 和 reducer 中的 initialState 都为原生的 Object 对象，所以不能和 Immutable 原生搭配使用。 幸运的是，Redux 并不排斥使用 Immutable，可以自己重写 combineReducers 或使用 redux-immutablejs 来提供支持。 本文原文链接： facebook immutable.js 意义何在，使用场景？ Immutable 详解及 React 中实践基本没有改动。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Immutable.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React应用性能优化之shouldComponentUpdate与key]]></title>
    <url>%2F2016%2F03%2F10%2FReact%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8BshouldComponentUpdate%E4%B8%8Ekey%2F</url>
    <content type="text"><![CDATA[虽然React 的 vDom diff算法能保证最小程度的 DOM 改变，但当组件树嵌套得非常深时，就不得不需要渲染一个新的虚拟 DOM 来让应用运行得更加高效。 下面看看加速应用程序的两种简单的配置方法： shouldComponentUpdate设置新 props，调用 setState 方法或 forceUpdate 方法时，React 都会调用该组件所有子组件的 render 方法。但是在组件树深度嵌套或 render 方法十分复杂的时侯，页面就会有延迟。 但此时，某些子组件并没有必要更新，或者永远都不需要更新，这时进行的计算过程是没有必要的。 而 shouldComponentUpdate 方法正是用来判断是否需要调用指定组件的 render 方法。 shouldComponentUpdate 方法返回一个布尔值。false 表示不要调用 render 方法；true 表示需要调用 render 方法计算出新的虚拟 DOM。 此方法的默认值是 true。 并且，组件首次渲染时，shouldComponentUpdate 方法不会被调用 shouldComponentUpdate 方法接受两个参数，新的 props 和新的 state： 12345React.creatClass(&#123; shouldComponentUpdate: function (nextProps, nextState) &#123; return nextProps.id !== this.props.id &#125; &#125;) 另外，我们也可以添加 React.addons.PureRenderMixin 插件来处理 shouldComponentUpdate。 这个插件会重写 shouldComponentUpdate 方法，并在该方法内对新老 props 及 state 进行对比， 如果发现它们完全一致则返回 false, 就像上面的例子一样。官方文档里也有介绍： PureRenderMixin 1234567891011import PureRenderMixin from 'react-addons-pure-render-mixin';class FooComponent extends React.Component &#123; constructor(props) &#123; super(props); this.shouldComponentUpdate = PureRenderMixin.shouldComponentUpdate.bind(this); &#125; render() &#123; return &lt;div className=&#123;this.props.className&#125;&gt;foo&lt;/div&gt;; &#125;&#125; key(键)在遍历列表的时候，没有组件添加 key 值会有 warnning 产生。那它是用来干嘛的呢？ 假设有一个 div 组件，它的 key 属性为 ‘foo’，之后又改为 ‘bar’， 那 React 就会跳过 DOM diff， 同时完会弃置 div 所有的子元素，并重新渲染。除了告诉 React 什么时候要抛弃一个节点之外，key 还可以在元素顺序改变时使用。 12345render: function()&#123; return items.map(function(item)&#123; return &lt;li key='item.id'&gt;item.name&lt;/li&gt; &#125;)&#125; 如果像上面这样，React 在li 列表顺序改变的时候就不会重新渲染，而是采用 insertBefore 操作，这也是最高效的方法。 但是要注意，key 值必须是独一无二的，最好不要是数字，绝对不能是遍历中的index。这样可以保证从一个父组件移动到另一个父组件的情况是不会被处理的。 key 值也是无法读取的。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索命令之locate、whereis、which、find、grep]]></title>
    <url>%2F2016%2F03%2F07%2F%E6%90%9C%E7%B4%A2%E5%91%BD%E4%BB%A4%E4%B9%8Blocate%E3%80%81whereis%E3%80%81which%E3%80%81find%E3%80%81grep%2F</url>
    <content type="text"><![CDATA[whereis搜索命令所在路径及帮助文档所在位置 选项： -b 只查找可执行文件 -m 只查找帮助文件 也可以通过 whereis 命令来判断是否是shell内部命令 which搜索命令所在路么及别名 与whereis的区别在于 which 不仅可以查看命令所在路径，还可以查看到命令的别名 locate搜索文件名最快的方式，根据后台数据库/var/lib/mlocate搜索 updatedb 命令手动更新数据库，数据库更新不是即时的，一般需要一天 /etc/updatedb.conf 配置文件，用于配置搜索限制 find最强大的搜索命令，但同时带来性能问题 find [搜索范围] [搜索条件] -name 按文件名搜索 -iname 不区分大小写搜索 -user 按照所有者搜索 -nouser 查找没有所有者的文件 -mtime 按修改文件的日期搜索，如：+10 查找10天前修改的文件， -10 查找10内修改的文件， 10 查找10天当天修改的文件 -atime 文件访问时间 -ctime 改变文件属性时间 -size 按照文件大小按索，如： find . -size 25k，注意 k 是小写， M是大写 -inum 按照i节点查找文件 -a 逻辑与 and,两个条件都满足，如： find /root -size +20k -a -size -1M 查找大于20k且小于1M的文件 -o 逻辑或 or,两个条件满足一个即可 -exec 命令 {} \; 对搜索结果执行操作，如： find /root -size 25k -exec rm -rf {} \; 查找/root目录下25k大小的文件之后删除 grep在文件中搜索符合条件的字符串 选项： -i 忽略大小写 -v 排除指定字符串 grep 是包含匹配，只要含有匹配的字符串，一整行都会输出；find 是完全匹配，只输出文件名完全一样的文件]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fetch POST接收不到数据，注意content-type的设置]]></title>
    <url>%2F2016%2F03%2F05%2FFetch%20POST%E6%8E%A5%E6%94%B6%E4%B8%8D%E5%88%B0%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%B3%A8%E6%84%8Fcontent-type%E7%9A%84%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[最近我们前端组在做一个简易的文档系统，使用redux+mongodb。其中抛弃了Ajax，起用了Fetch。 XMLHttpRequest 是一个设计粗糙的 API，不符合关注分离（Separation of Concerns）的原则，配置和调用方式非常混乱，而且基于事件的异步模型写起来也没有现代的 Promise，generator/yield，async/await 友好。 Fetch 的出现就是为了解决 XHR 的问题，Fetch API 是基于 Promise 设计。 刚开始用的时候发现个问题，POST数据发现后端获取不到，GET方式是没有问题的。如： 1234567fetch('/group/update', &#123; method: 'post', body: JSON.stringify(params)&#125;) .then((response) =&gt; response.json()) .then((json) =&gt; dispatch(fetchUpdateGroupName(json, index))) .catch((err) =&gt; (console.log('err:', err))) 以前一直用Jquery Ajax，很少情况需要设置Content-Type，而且看到有些博文介绍Fetch的时候说，Fetch()如果没有设置Content-Type，会自动获取。 后来还是被家优提醒，以下代码才是正确的设置： 12345678910fetch('/group/update', &#123; method: 'post', headers: &#123; 'Content-Type': 'application/json' &#125;, body: JSON.stringify(params)&#125;) .then((response) =&gt; response.json()) .then((json) =&gt; dispatch(fetchUpdateGroupName(json, index))) .catch((err) =&gt; (console.log('err:', err))) 注意： Fetch 支持几种数据类型的传输，其中包含Blob, BLOB (binary large object)，表示二进制大对象。其中有个只读属性，Blob.type(),此时的 Content-Type 应设置为此值。 这里顺便记录下POST常见的Content-Type: application/x-www-form-urlencoded浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。提交的数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。 POST http://www.123.com HTTP/1.1 Content-Type: application/x-www-form-urlencoded;charset=utf-8 title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3 multipart/form-data使用表单上传文件时，必须让 form 的 enctyped 等于这个值, 上传图片时，我们经常会看到下面这样 POST http://www.example.com HTTP/1.1 Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA ------WebKitFormBoundaryrGKCBY7qhFd3TrwA Content-Disposition: form-data; name=&quot;text&quot; title ------WebKitFormBoundaryrGKCBY7qhFd3TrwA Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot; Content-Type: image/png PNG ... content of chrome.png ... ------WebKitFormBoundaryrGKCBY7qhFd3TrwA-- 如果我们使用 new FormData()作为数据主体提交，也需要设置这种类型。 application/json把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。但也有些服务端语言还没有支持这种方式，例如 php 就无法通过 $_POST 对象从上面的请求中获得内容。这时候，需要自己动手处理下：在请求头中 Content-Type 为 application/json 时，从 php://input 里获得原始输入流，再 json_decode 成对象。 参考： 四种常见的 POST 提交数据方式]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>fetch</tag>
        <tag>content-type</tag>
        <tag>POST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何少埋坑-艾神分享会]]></title>
    <url>%2F2016%2F03%2F04%2F%E8%89%BE%E7%A5%9E%E5%88%86%E4%BA%AB%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[又很久没有记录东西了，真是个不自律的人- -！ 去年十月进入搜芽，感觉搜芽是一个共同成长的公司，有一种亲切感。这算是我第一次进一个前端团队比较大的公司，很多想法在分享与讨论中迸发。 最近产品在预热中，相对有空，我们前端也在尝试一些新技术的应用,用react-redux做一个简易的文档系统。除了家优对技术架构比较熟，我们几个都比较生疏。但是最重要是不要心浮气燥，虽然最近心情不是很好，但我还是尽量静下心来研读文档，在开发中一步一坑地走下去。 研发部也在组织分享会，今天是第一次分享会，艾神定的主题是http协议，主要和大家分享一个http请求从客户端到服务端处理返回的整个过程。 说到艾神，当初见到他的第一印象就是没什么印象，老实、普通，所以当时不是很明白为什么大家叫他艾神。不过后来发现，艾神确实是一个很踏实的人，他是写java的，功力很深，逻辑很严谨。和他一起吃饭的时候，很喜欢和我们‘讲课’。 当然，分享会其他讲http协议不是他的真正目的，他延伸出来的相关案例才是重点。艾神讲协议，是想让我们要注意分清什么是标准，什么是投机。工作中要知道错的为什么错，也要知道对的为什么对，要把程序的运行把控在自己手中，不能存在不确定性。否则埋了坑，一旦出现问题，就要花更多的时间去排查。 我也是见过太多程序员，对一些问题十分马虎，错了就不断推脱，有时候bug补上了却不知道为什么，殊不知可能埋了更大的坑。 艾神是个很靠谱的程序员]]></content>
  </entry>
  <entry>
    <title><![CDATA[javascript获取本周和本月或任意月的时间段]]></title>
    <url>%2F2015%2F10%2F30%2Fjavascript%E5%8F%96%E6%9C%AC%E5%91%A8%E5%92%8C%E6%9C%AC%E6%9C%88%E6%88%96%E4%BB%BB%E6%84%8F%E6%9C%88%E7%9A%84%E6%97%B6%E9%97%B4%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[最近有功能从两个时间段变成单个select选择了，但后端不想改接口。只好适配一下，把今天、本周、本月及过去的月份转换一下。 首先，更改一下select菜单，动态取出过去的月份，添加options。 var SearchTimer = [&apos;全部&apos;, &apos;今天&apos;, &apos;本周&apos;, &apos;本月&apos;]; (function(){ var Month = new Date().getMonth(); for(; Month &gt; 0; Month--){ SearchTimer.push(Month + &apos;月份&apos;); } })(); 接下来就是要把各个options在选择的时候转换成startTime和endTime. switch(timer){ case &apos;全部&apos;: break; case &apos;今天&apos;: break; case &apos;本周&apos;: break; case &apos;本月&apos;: break; default: } 然后是时间的处理，先需要格式化时间，注意补零，格式为yyyy-MM-dd HH:mm:ss。 function formatDate(date) { var myyear = date.getFullYear(); var mymonth = date.getMonth()+1; var myweekday = date.getDate(); var myhours = date.getHours(); var myminutes = date.getMinutes(); var myseconds = date.getSeconds(); if(mymonth &lt; 10){mymonth = &quot;0&quot; + mymonth; } if(myweekday &lt; 10){myweekday = &quot;0&quot; + myweekday; } if(myhours &lt; 10){myhours = &quot;0&quot; + myhours; } if(myminutes &lt; 10){myminutes = &quot;0&quot; + myminutes; } if(myseconds &lt; 10){myseconds = &quot;0&quot; + myseconds; } return (myyear+&quot;-&quot;+mymonth + &quot;-&quot; + myweekday+&quot; &quot;+myhours+&quot;:&quot;+myminutes+&quot;:&quot;+myseconds); } 今天的时间很好获取，然后是本周时间： var now = new Date(); //当前日期 var nowDayOfWeek = now.getDay(); //今天本周的第几天 var nowDay = now.getDate(); //当前日 var nowMonth = now.getMonth(); //当前月 var nowYear = now.getFullYear(); //当前年 function getWeekStartDate() { //获得本周的开端日期 var weekStartDate = new Date(nowYear, nowMonth, nowDay - nowDayOfWeek); return formatDate(weekStartDate); //调用上面的时间格式化 } function getWeekEndDate() { //获得本周的停止日期 var weekEndDate = new Date(nowYear, nowMonth, nowDay + (6 - nowDayOfWeek)); return formatDate(weekEndDate); } 然后是本月时间，但首先需要知道本月有多少天： function getMonthDays(myMonth){ //获得某月的天数 myMonth = parseInt(myMonth); //这一步很重要，有时候传进来的可能是字符串，后面+1的时候会变成字符串相连 var monthStartDate = new Date(nowYear, myMonth, 1); //当月1号的时间戳 var monthEndDate = new Date(nowYear, myMonth + 1, 1);//下月1号的时间戳 var days = (monthEndDate - monthStartDate)/(1000 * 60 * 60 * 24);//求差即可取得某月天数 return days; } function getMonthStartDate(){ //获得本月的开端日期 var monthStartDate = new Date(nowYear, nowMonth, 1); return formatDate(monthStartDate); } function getMonthEndDate(){ //获得本月的停止日期 var monthEndDate = new Date(nowYear, nowMonth, getMonthDays(nowMonth)); return formatDate(monthEndDate); } 然后是过去任意月份的1号和最后一天： var theMon = timer.replace(/(月份)$/, &apos;&apos;)-1; //先匹配出select的月份，如：‘9月份’，但getMonth()是从0天始的，所以需要减1，也正好可以转换成整型 startTime = formatDate(new Date(nowYear, theMon, 1)); endTime = formatDate(new Date(nowYear, theMon, getMonthDays(theMon)));//某月有几天，最后一天就是几天。 所以最后返回时间段： var startTime, endTime; endTime = formatDate(new Date()); switch(timer){ case &apos;全部&apos;: startTime = undefined; endTime = undefined; break; case &apos;今天&apos;: startTime = formatDate(new Date(nowYear, nowMonth, nowDay)); break; case &apos;本周&apos;: startTime = getWeekStartDate(); break; case &apos;本月&apos;: startTime = getMonthStartDate(); break; default: var theMon = timer.replace(/(月份)$/, &apos;&apos;)-1; startTime = formatDate(new Date(nowYear, theMon, 1)); endTime = formatDate(new Date(nowYear, theMon, getMonthDays(theMon))); break; } return { startTime: startTime, endTime: endTime } 至此就转换完毕。 当然，如果有需要，还可能获取季度。 function getQuarterStartMonth(){ //获得本季度的开端月份 var quarterStartMonth = 0; if(nowMonth&lt;3){quarterStartMonth = 0; }//判断属于第一季度 if(2&lt;nowMonth &amp;&amp; nowMonth&lt;6){quarterStartMonth = 3; } if(5&lt;nowMonth &amp;&amp; nowMonth&lt;9){quarterStartMonth = 6; } if(nowMonth&gt;8){quarterStartMonth = 9; } return quarterStartMonth; } 只要判断属于哪一季度，即可知道开端月份和结束月份。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angularJS自定义指令]]></title>
    <url>%2F2015%2F10%2F17%2Fangular%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[指令可以简单理解成特定DOM元素上执行的函数，它可以拓展元素的功能。 一个定义指令的基本格式如下： angular.module(&apos;myApp&apos;, []) .direcitve(&apos;myDirective&apos;, function(){ return { //指令的配置项 } }); directive() 方法可以接受两个参数： name指令的名字，如： myDirective。在DOM中可以这样使用: `&lt;my-directive&gt;&lt;/my-directive&gt;`;或者 `&lt;div my-directive&gt;&lt;/div&gt;`; 定义指令时的名称用驼峰命名，使用时用中划线方式。 function这个函数可以返回一个对象，如上面；或者直接返回一个函数，它会被接收成 postLink 函数。 指令的返回函数的所有配置项先看看指令的所有参数配置： angular.module(&apos;myApp&apos;, []) .directive(&apos;myDirective&apos;, function(){ return { restrict: string,//指令在DOM中的声明形式字符串，默认值是‘A’ proiority: number,//优先级，默认值0 terminal: boolean,//是否停止运行当前元素比本指令优先级低的指令 template: string or function,//模板 或 返回模板的函数 templateUrl: string,//模板文件的链接 replace: boolean or string,//true为替换，默认值false为插入到指令元素内部 scope: boolean or object,//指令作用域 transclude: boolean,//嵌入 controller: string or function(scope, element, attrs, transcluude, otherInjectables){}, require: string, link: function(scope, iElement, iAttrs){}, compile: function(tElement, tAttrs, transclude){ return { pre: function(scope, iElement, iAttrs, controller){}, post: function(scope, iElement, iAttrs, controller){} } return function postLink(){} } } }); 1. restrict可选值： E(元素，用于独立的指令单元，意图表达更明确) &lt;my-directive&gt;&lt;/my-directive&gt; A(属性，默认值, 最常用，兼容性最好) &lt;div my-directive=&apos;expression&apos;&gt;&lt;/div&gt; C(类名) &lt;div class=&quot;my-directive: expression&quot;&gt;&lt;/div&gt; M(注释，尽量避免使用) &lt;-- directive: my-directive expression --&gt; 2. priority默认值是0；优先级高的指令总是优先执行。优先级相同的指令，先声明的先执行。 3. terminal设置为true,则停止运行当前元素上比本指令优先级低的指令，但优先级相同的仍然会执行。 4. template值可以是以下类型： a. 模板字符串 b. 一个可以接受两个参数的函数，并返回一个代表模板的字符串 5. templateUrl值可以是以下类型： a. 外部html文件路径的字符串 b. 一个可以接受两个参数的函数，并返回一个外部HTML文件路径的字符串 6. replace默认值false. 值为 true 时，模板会被当作子元素插入到调用此指令的元素内部 7. scope可选值： false: 默认值，直接调用相同的作用域对象； true: 从当前作用域对象继承一个新的作用域对象； {}[object]: 创建一个同当前作用域相隔离的作用域对象。 隔离作用域具有隔离作用域的指令最主要的使用场景是创建可复用的组件，组件可以在未知上下文中使用，并且可以避免污染所处的外部作用域或不经意地污染内部作用域。 绑定策略使用了隔离作用域后，指令的模板就无法访问外部作用域了。但使用无数据的隔离作用域并不常见。AngularJS 有三种方法可以将指令内部的隔离作用域同外部作用域进行数据绑定。 本地作用域属性：@ (or @attr) 使用@符号将本地作用域同DOM属性的值进行绑定。指令内部作用域可以使用外部作用域的变量。 js myApp.controller(&apos;myController&apos;, [&apos;$scope&apos;, function($scope){ $scope.btnText = &apos;按钮&apos;; $scope.validate= &apos;1234&apos;; $scope.submit = function(err){ console.log(err); } }]); myApp.directive(&apos;my-btn&apos;, function(){ return { restrict: &apos;EA&apos;, scope: { text: &apos;@btnText&apos;//key是在template里使用的变量，val是在使用指令时所绑定的attr。若@符号后不指定名称，则默认绑定为键名&apos;text&apos; }, replace: true, template: &apos;&lt;button&gt;{{text}}&lt;/button&gt;&apos;//这里的{{text}}正是scope的text. } }); html &lt;form action=&quot;/&quot;&gt; &lt;input type=&quot;text&quot;&gt; &lt;my-btn btn-text=&quot;btnText&quot;&gt;&lt;/my-btn&gt;//这里的属性‘btn-text’正是指令的‘@btnText’,属性值‘btnText’正是父级作用域的‘$scope.btnText’ &lt;/form&gt; 双向绑定： = (or =attr) 可以将本地作用域上的属性同父级作用域上的属性进行双向的数据绑定。 例： js,controller同上一例子,如果理解上面的例子，这里也是很好理解的，只是绑定的不是字符串，而是双向数据绑定。 myApp.directive(&apos;myInput&apos;, function(){ return { restrict: &apos;A&apos;, scope:{ val: &apos;=value&apos;//key为template里的数据模型，&apos;value&apos;是html里的attr. }, template: &apos;&lt;input type=&quot;text&quot; ng-model=&quot;val&quot;&gt;&apos; } }); html &lt;form action=&quot;/&quot;&gt; &lt;div my-input value=&quot;validate&quot;&gt;&lt;/div&gt;//本地作用域的属性val与父级作用域的属性validate进行双向数据绑定 &lt;/form&gt; 父级作用域绑定： &amp; (or &amp;attr) 可以对父级作用域进行绑定，可以调用父方法。意味着对这个值进行设置时会生成一个指向父级作用域的包装函数。 js myApp.directive(&apos;myError&apos;, function(){ return { restrict: &apos;A&apos;, scope: { validate: &apos;&amp;check&apos; }, template: &apos;&lt;input type=&quot;text&quot; ng-model=&quot;text&quot;&gt;&apos;+ &apos;&lt;button ng-click=&apos;validate({name: text})&apos;&gt;&lt;/button&gt;&apos;//传递参数需要传递一个对象，name是参数名，text是参数值。 } }); html &lt;div&gt; &lt;div my-error check=&quot;submit(name)&quot;&gt;&lt;/div&gt; &lt;div my-error check=&quot;submit(name)&quot;&gt;&lt;/div&gt;//因为是隔离作用域，他们之间的值是不会互相影响的，只是共用父方法。 &lt;/div&gt; 要调用一个带有参数的父方法，需要传递一个对象，这个对象的key是参数名称，val是要传递给参数的内容 8. transcludetransclude是一个可选参数，默认值是false, 当值为true时，angularJS会将从DOM元素中获取的内容放到它发现ng-transclude指令的地方，如： &lt;ul sidebox&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt; &lt;/ul&gt; angular.module(&apos;myApp&apos;, []) .directive(&apos;sidebox&apos;, function(){ return { scope: { title: &apos;@&apos; }, transclude: true, template: &apos;&lt;div class=&quot;sidebox&quot;&gt;&lt;/div&gt;&apos;+ &apos;&lt;div class=&quot;content&quot; ng-tranclude&gt;&lt;/div&gt;&apos; } }); 只有希望创建一个可以包含任意内容的指令时，才使用transclude: true。，典型的例子是模态框或导航栏。 9. controller值可以是一个字符串或一个函数。 string: 当设置为字符中时，指令会查找注册在应用中的同名控制器。 function: 直接通过匿名构造函数的方式来定义一个内联的控制器。 控制器主要是用来提供可以指令间复用的行为。可以的将当前指令的API暴露给其他的指令使用。如： angular.modue(&apos;myApp&apos;, []) .directive(&apos;inputForm&apos;, function(){ return { restrict: &apos;EA&apos;, controller: function($scope){ $scope.input = &apos;手机号&apos;; this.submit = function(){//通过this暴露接口 //do something... } } } }); 任意的服务同样可以被传递给controller。其中有一些特殊的服务： $scope 与指令元素相关联的当前作用域 $element 当前指令对应的元素 $attrs 当前元素的属性组成的对象 $transclude transclude链接函数是实际被执行用来克隆元素和操作DOM的函数 10. controllerAscontrollerAs用来设置控制器别名，以此为名发布控制器，并且作用域可以访问controllerAs。这样可以在视图中引用控制器，甚至无需注入$scope。例： angular.module(&apos;myApp&apos;, []) .directive(&apos;myDirective&apos;, function(){ return { restrict: &apos;A&apos;, template: &apos;&lt;h4&gt;{{myController.msg}}&lt;/h4&gt;&apos;,//可以在tpl中直接访问controller controllerAs: &apos;myController&apos;, contrller: function(){ this.msg = &apos;Hello&apos;; } } }); &lt;div my-directive&gt;&lt;/div&gt; 又例： angular.module(&apos;myApp&apos;, []) .controller(&apos;myController&apos;, function(){ this.msg = &apos;robin&apos;; }); &lt;div ng-controller=&quot;myController as main&quot;&gt;{{main.robin}}&lt;/div&gt; 11. require其值可以是字符串或数组，字符串或数组元素代表另个一个指令的名字。require 会将指令控制器注入到当前的指令中，并作为当前指令的链接函数的第四个参数。 结合9.controller的例子，可以这样使用 angular.module(&apos;myApp&apos;, []) .directive(&apos;otherForm&apos;, function(){ return { restrict: &apos;A&apos;, require: &apos;^?inputForm&apos;, link: function(scope, element, attrs, ctrl){ ctrl.submit(); } } }); 如果是数组： angular.module(&apos;myApp&apos;, []) .directive(&apos;otherForm&apos;, function(){ return { restrict: &apos;A&apos;, require: [?^inputForm, inputForm2], link: function(scope, element, attrs, ctrl){ ctrl[0].submit(); ctrl[1].api(); } } }); require前缀： ‘?’ 如果在当前指令中没有找到所面要的控制器，会将null作为link的第四个参数； ‘^’ 指令会在上游的指令链中查找require参数所指定的控制器； ‘?^’ 前两个选项的组合； 没有前缀 指令将在同级作用域查找所需控制器，如果没有找到会抛出一个错误。 12. compilecompile选项可以返回一个对象或函数。 compile函数可以用来在指令和实时数据被放到DOM中之前进行DOM操作，在这里进行添加和删除节点等DOM操作是安全的。 compile与link函数是互斥的。如果同时设置，compile的返回函数会被当作链接函数，link函数会被忽略。 compile: function(tEle, tAttrs, transcludeFn){ //...tEle代表未绑定事件的DOM元素 } 13. linklink函数会经常被使用。负责设置事件监听器、监听数据变化和实时的操作DOM。 如果指令很简单，可以直接从工厂函数返回一个函数来代替。如： angular.module(&apos;myApp&apos;, []) .directive(&apos;myDirective&apos;, function(){ return { pre: function(tElement, tAttrs, transclude){}, post: function(scope, iElement, iAttrs, controller){} } }); angular.module(&apos;myApp&apos;, []) .directive(&apos;myDirective&apos;, function(){ return { link: function(scope, ele, attrs){ return { pre: function(tElement, tAttrs, transclude){}, post: function(scope, iElement, iAttrs, controller){} } } } });]]></content>
      <categories>
        <category>angularJS</category>
      </categories>
      <tags>
        <tag>angularJS</tag>
        <tag>指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git分支]]></title>
    <url>%2F2015%2F10%2F10%2Fgit%E5%88%86%E6%94%AF%2F</url>
    <content type="text"><![CDATA[git分支对于我们平常开发新功能，修复bug等有很大的帮助。下面是git分支的常用命令： 分支的新建与切换 $ git checkout -b version2.0 这相当于执行下面这两条命令： $ git branch version2.0 $ git checkout version2.0 分支的合并 $ git checkout master $ git merge version2.0 切换到主分支，把分去version2.0合并到主分支 分支的删除 $ git branch -d verdion2.0 如果分支功能已经合并到主分支，分支就没有用了，可以删除。 合并分支的冲突 合并并不总是顺利的，特别是多人合作的时候，很容易产生冲突。 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD &lt;div id=&quot;footer&quot;&gt;copyright&lt;/div&gt; ======= &lt;div id=&quot;footer&quot;&gt; please contact us &lt;/div&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; version2.0 ‘=======’把两个版本冲突的内容分隔开来，我们需要把这些标记都删掉，并留下合并后的代码。 合并GUI工具 如果安装了可视化的合并工具，可以使用$ git mergetool命令来调用。 推荐的GUI合并工具有如：meld, kdiff3 可以这样调用指定的工具：$ git mergetool -t meld 也可以配置默认工具： $ git config --global merge.tool kdiff3]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp 4.0的变化]]></title>
    <url>%2F2015%2F10%2F09%2Fgulp-4.0%2F</url>
    <content type="text"><![CDATA[升级日志先来看看新版有什么不同（官方升级日志）： 新的任务系统（基于 bach，替换掉了原先基于 orchestrator 的任务系统） 移除 gulp.reset gulp.task 不再支持三个参数的用法 gulp.task 用字符串注册的任务必须是直接在命令行中调用的任务 gulp.task 可以接受单参数语法，这个参数必须是一个命名函数，函数名会被作为任务名 添加了 gulp.series 和 gulp.parallel 方法用于组合任务 添加了 gulp.tree 方法用于获取任务树，传入 { deep: true } 参数可以得到一个 archy 兼容的节点列表 添加了 gulp.registry 方法以定制注册表。 添加了 gulp.symlink 方法，功能和 gulp.dest 一致，不过是以软链接的方式 gulp.dest 和 gulp.symlink 方法添加了 dirMode 参数允许对目标目录更好地控制 gulp.src 接收的文件匹配字符串会顺序解释，所以你可以写成这样 gulp.src([‘.js’, ‘!b.js’, ‘bad.js’])（排除所有以 b 开头的 JS 文件但是除了 bad.js） gulp.src 方法添加了 since 选项，筛选在特定时间点之后修改过的文件（用于增量编译） 将命令行分离出来成为一个独立模块，以便节约带宽/空间。用 npm install gulp -g 或 npm install gulp-cli -g 都可以安装命令行，只是 gulp-cli 不包含模块代码所以比较小 命令行添加了 –tasks-json 参数，可以导出整个任务树以供他用 命令行添加了 –verify 参数用以检查 package.json 中是否包含黑名单插件（违背准则而被禁入官方插件列表的可怜娃们）。 安装gulp 4.0# 如果安装过全局的 gulp 的话先卸载之 $ npm uninstall gulp -g # 安装全局的 gulp 4.0 $ npm install &quot;gulpjs/gulp#4.0&quot; -g # 到项目目录里删掉本地的 gulp $ npm rm gulp --save-dev # 安装本地的 gulp 4.0 $ npm install &quot;gulpjs/gulp#4.0&quot; --save-dev gulp.task1、移除了gulp.task传递三参数的用法 即这种用法将报错 gulp.task(&apos;watch&apos;, [&apos;default&apos;], function() { // TODO // watch file }); 在gulp4.0之前，这种用法将会保证default任务先执行完再执行watch任务，gulp的任务流程控制就是这么实现的，流程控制另外增加api实现，详看后面。 2、gulp.task又增加了一种用法，即传递一个具名函数作为参数，将自动注册以该函数名命名的任务 function clean(){} function compile() { // do something... } gulp.task(clean); gulp.task(compile); 等同于 gulp.task(&apos;clean&apos;, function() { // do something... }); gulp.task(&apos;compile&apos;, function() { // do something... }); 任务流程控制增加了gulp.series 串行任务和gulp.parallel 并行任务， 比原来的三参数写法要更加清晰。 function clean(){} function copy(){} function compile() { // do something... } gulp.task(clean); gulp.task(copy); gulp.task(compile); gulp.task(&apos;clean-build&apos;, gulp.series(&apos;clean&apos;, &apos;copy&apos;, &apos;compile&apos;)); //任务将按顺序执行 gulp.task(&apos;build&apos;, gulp.parallel(&apos;copy&apos;, &apos;compile&apos;)); //任务将并发执行 只要在gulpfile.js中没有使用gulp.task传三个参数的用法，gulp 4.0也是兼容老版本的gulpfile.js的。]]></content>
      <categories>
        <category>前端构建</category>
      </categories>
      <tags>
        <tag>前端构建</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端批量压缩图片]]></title>
    <url>%2F2015%2F10%2F08%2F%E5%89%8D%E7%AB%AF%E6%89%B9%E9%87%8F%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[前端切图的时候，png 图片都比较大，一直使用的是 Tinypng 来压缩 png 图片，小图标sprite之后，图片数量还是至少在 20 以上，操作甚是麻烦。后来在使用 gulp 的时候，发现了一个批量压缩图片的神器 —— pngquant 。 先来看看一个 gulp 插件 gulp-imagemin Install $ npm install --save-dev gulp-imagemin Usagevar gulp = require(&apos;gulp&apos;); var imagemin = require(&apos;gulp-imagemin&apos;); var pngquant = require(&apos;imagemin-pngquant&apos;); gulp.task(&apos;default&apos;, function () { return gulp.src(&apos;src/images/*&apos;) .pipe(imagemin({ progressive: true, svgoPlugins: [{removeViewBox: false}], use: [pngquant()] //使用了 pngquant 压缩png图片 })) .pipe(gulp.dest(&apos;dist/images&apos;)); }); gulp-imagemin 可以压缩几乎所有图片格式 PNG, JPEG, GIF and SVG，其中png压缩是使用了 pngquant ,需要先另外安装： $ npm install --save imagemin-pngquant 但是，图片其实并不需要每次构建都压缩，一般只需要在发布或测试的时候一次性压缩就可以了。 所以也可以不使用 gulp 工具进行图片压缩，直接使用 pngquant。 pngquant 使用起来也是很方便的，下载对应版本，windows下添加文件目录到系统环境变量，进入到相应目录，直接使用命令行 pngquant *.png 即可完成压缩，可以看到目录下生成后缀名为 -fs8.png 或 -or8.png的图片。 查看 Readme.md 配置相应参数 pngquant常用的主要参数--quality min-max 类似JPEG的质量，设置0 ~ 100 的图片压缩质量。 pngquant --quality=65-80 *.png --ext new.png 设置输出压缩图片的文件名。如果不设置，则默认后缀为 -fs8.png 或 -or8.png。如果使用 --ext=.png --force，将会使用原文件名输出并覆盖原文件。 -o out.png or --output out.png 设置图片输出路径。]]></content>
      <categories>
        <category>前端构建</category>
      </categories>
      <tags>
        <tag>前端构建</tag>
        <tag>图片压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git ssh-key及多帐户设置]]></title>
    <url>%2F2015%2F09%2F30%2Fgit%20ssh-key%E5%8F%8A%E5%A4%9A%E5%B8%90%E6%88%B7%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[在使用git的时候，我们在管理远程分支之前需要在本机上创建ssh-key密钥对，并把其中的公钥添加到github中。 首个帐户如果你只会在你的计算机使用一个远程的Git服务器，并且账号是一个，比较简单，生成key的时候也没有太大注意的地方，直接运行如下的第一步然后按回车就可以了 在 gitbash上运行 ssh-keygen -t rsa -C &quot;Github账户邮箱&quot; 接下来会提示输入key的名字 默认名字为id_rsa ,默认不改直接回车就行了 然后会提示输入口令，这里口令与Github中的密码无关，随便输入可以为空，为空直接回车。 如果在第二步中的没有重新命名的话，则忽略此步骤，ssh agent默认只读取id_rsa，为了让SSH识别新的私钥，需将其添加到SSH agent中,如第二步改的名字为robin, 则执行：ssh-add id_rsa如果出现Could not open a connection to your authentication agent的错误，就试着先用以下命令： ssh-agent bash ssh-add robin 添加完之后 登陆Github,点击网页右上侧的 Settings 按钮 - 选择 ssh-keys 点击Add SSH Key ，在title中输入名字，然后将公钥即id_rsa.pub添加到ssh-key处。 执行 ssh -T git@github.com 如果能正常访问即可 $ ssh -T git@github.com Hi robin! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 第二个帐户 新建user2的SSH Key$ cd ~/.ssh #切换到C:\Users\Administrator\.ssh ssh-keygen -t rsa -C &quot;user2的Github账户邮箱&quot; //新建工作的SSH key Enter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa): user2 //设置名称为user2(后文的user2可以统一替换任何别名) 新密钥添加到SSH agent中 因为默认只读取id_rsa，为了让SSH识别新的私钥，需将其添加到SSH agent中： ssh-add ~/.ssh/user2 //注意路径，如果不在.ssh目录下则不能省略 &apos;~/.ssh/&apos; 同样，如果出现Could not open a connection to your authentication agent的错误，就试着用以下命令： ssh-agent bash ssh-add ~/.ssh/user2 添加user2的公钥 打开新生成的 ~/.ssh/uesr2.pub文件，将里面的内容添加到user2的github帐号下的SSH Key中。 修改config文件 (重要的一步) 将账户以及git服务器与对应的密钥关联。在~/.ssh目录下找到config文件，如果没有就创建： touch config 然后修改如下： 我的config配置如下： # 该文件用于配置私钥对应的服务器 # Default github user1 Host github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa # second user2 # 建一个github别名，新建的帐号使用这个别名做克隆和更新 Host user2 HostName github.com User git IdentityFile ~/.ssh/user2 帐号关联 如果你只是文章中所述配置了Host，那么你多个账号下面的提交用户会是一个人，所以需要通过命令 git config --global --unset user.email 删除全局用户账户设置，当然也可以不删除，如果每个git项目下没有单独设置用户帐户信息的话，会默认使用全局设置 在每一个git项目下面使用命令 git config --local user.name &apos;该项目的github用户名&apos; git config --local user.email &apos;该项目的github邮箱@mail.com&apos; 单独设置用户账户信息，每个不同于全局用户帐户的git 项目都需要设置。 关于 clone 使用 git clone user2:user2/test.git 而不是 git clone git@github.com:user2/test.git 否则无法分辨使用的是哪一个帐户。 关于 remote 如果clone 项目时使用的是 git clone user2:user2/test.git 则remote url的Host 就是user2，可以跳过这一步，否则需要更改一下关联（包括git init新建），查看 remote git remote -v 如果user2的项目remote.origin.url=git@github.com:user2/test.git则需要进行修改 git remote rm origin git remote add origin user2:user2/test.git 测试：$ ssh -T git@github.com Hi user1! You&apos;ve successfully authenticated, but GitHub does not provide shell access. $ ssh -T user2 Hi user2! You&apos;ve successfully authenticated, but GitHub does not provide shell access.]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[维护一个方便自己开发的Less库]]></title>
    <url>%2F2015%2F09%2F19%2F%E7%BB%B4%E6%8A%A4%E4%B8%80%E4%B8%AA%E6%96%B9%E4%BE%BF%E8%87%AA%E5%B7%B1%E5%BC%80%E5%8F%91%E7%9A%84Less%E5%BA%93%2F</url>
    <content type="text"><![CDATA[less用less开发的时候，经常会用到一些重复使用的mixins，建个库记录维护起来，方便以后自己开发的时候快速引用。 传送门：less-lib 主要分reset类和模块复用类]]></content>
      <categories>
        <category>less</category>
      </categories>
      <tags>
        <tag>less</tag>
      </tags>
  </entry>
</search>